<Type Name="JsonMetadataServices" FullName="System.Text.Json.Serialization.Metadata.JsonMetadataServices">
  <TypeSignature Language="C#" Value="public static class JsonMetadataServices" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit JsonMetadataServices extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Text.Json.Serialization.Metadata.JsonMetadataServices" />
  <TypeSignature Language="VB.NET" Value="Public Class JsonMetadataServices" />
  <TypeSignature Language="F#" Value="type JsonMetadataServices = class" />
  <TypeSignature Language="C++ CLI" Value="public ref class JsonMetadataServices abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Json</AssemblyName>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="net-7.0">
      <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides helpers to create and initialize metadata for JSON-serializable types.</summary>
    <remarks>This API is intended for use by the output of the System.Text.Json source generator. It should not be called directly.</remarks>
  </Docs>
  <Members>
    <Member MemberName="BooleanConverter">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.JsonConverter&lt;bool&gt; BooleanConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Json.Serialization.JsonConverter`1&lt;bool&gt; BooleanConverter" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Serialization.Metadata.JsonMetadataServices.BooleanConverter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BooleanConverter As JsonConverter(Of Boolean)" />
      <MemberSignature Language="F#" Value="member this.BooleanConverter : System.Text.Json.Serialization.JsonConverter&lt;bool&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.BooleanConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Json::Serialization::JsonConverter&lt;bool&gt; ^ BooleanConverter { System::Text::Json::Serialization::JsonConverter&lt;bool&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that converts <see cref="T:System.Boolean" /> values.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ByteArrayConverter">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.JsonConverter&lt;byte[]&gt; ByteArrayConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Json.Serialization.JsonConverter`1&lt;unsigned int8[]&gt; ByteArrayConverter" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Serialization.Metadata.JsonMetadataServices.ByteArrayConverter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ByteArrayConverter As JsonConverter(Of Byte())" />
      <MemberSignature Language="F#" Value="member this.ByteArrayConverter : System.Text.Json.Serialization.JsonConverter&lt;byte[]&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.ByteArrayConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Json::Serialization::JsonConverter&lt;cli::array &lt;System::Byte&gt; ^&gt; ^ ByteArrayConverter { System::Text::Json::Serialization::JsonConverter&lt;cli::array &lt;System::Byte&gt; ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter&lt;System.Byte[]&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that converts byte array values.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ByteConverter">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.JsonConverter&lt;byte&gt; ByteConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Json.Serialization.JsonConverter`1&lt;unsigned int8&gt; ByteConverter" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Serialization.Metadata.JsonMetadataServices.ByteConverter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ByteConverter As JsonConverter(Of Byte)" />
      <MemberSignature Language="F#" Value="member this.ByteConverter : System.Text.Json.Serialization.JsonConverter&lt;byte&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.ByteConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Json::Serialization::JsonConverter&lt;System::Byte&gt; ^ ByteConverter { System::Text::Json::Serialization::JsonConverter&lt;System::Byte&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that converts <see cref="T:System.Byte" /> values.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CharConverter">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.JsonConverter&lt;char&gt; CharConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Json.Serialization.JsonConverter`1&lt;char&gt; CharConverter" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Serialization.Metadata.JsonMetadataServices.CharConverter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CharConverter As JsonConverter(Of Char)" />
      <MemberSignature Language="F#" Value="member this.CharConverter : System.Text.Json.Serialization.JsonConverter&lt;char&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.CharConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Json::Serialization::JsonConverter&lt;char&gt; ^ CharConverter { System::Text::Json::Serialization::JsonConverter&lt;char&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that converts <see cref="T:System.Char" /> values.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateArrayInfo&lt;TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TElement[]&gt; CreateArrayInfo&lt;TElement&gt; (System.Text.Json.JsonSerializerOptions options, System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TElement[]&gt; collectionInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TElement[]&gt; CreateArrayInfo&lt;TElement&gt;(class System.Text.Json.JsonSerializerOptions options, class System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues`1&lt;!!TElement[]&gt; collectionInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateArrayInfo``1(System.Text.Json.JsonSerializerOptions,System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues{``0[]})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateArrayInfo(Of TElement) (options As JsonSerializerOptions, collectionInfo As JsonCollectionInfoValues(Of TElement())) As JsonTypeInfo(Of TElement())" />
      <MemberSignature Language="F#" Value="static member CreateArrayInfo : System.Text.Json.JsonSerializerOptions * System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;'Element[]&gt; -&gt; System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Element[]&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateArrayInfo (options, collectionInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TElement&gt;&#xA; static System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;cli::array &lt;TElement&gt; ^&gt; ^ CreateArrayInfo(System::Text::Json::JsonSerializerOptions ^ options, System::Text::Json::Serialization::Metadata::JsonCollectionInfoValues&lt;cli::array &lt;TElement&gt; ^&gt; ^ collectionInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TElement[]&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
        <Parameter Name="collectionInfo" Type="System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TElement[]&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TElement">The generic definition of the element type.</typeparam>
        <param name="options">The <see cref="T:System.Text.Json.JsonSerializerOptions" /> to use.</param>
        <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
        <summary>Creates serialization metadata for an array.</summary>
        <returns>Serialization metadata for the given type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateConcurrentQueueInfo&lt;TCollection,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt; CreateConcurrentQueueInfo&lt;TCollection,TElement&gt; (System.Text.Json.JsonSerializerOptions options, System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt; collectionInfo) where TCollection : System.Collections.Concurrent.ConcurrentQueue&lt;TElement&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TCollection&gt; CreateConcurrentQueueInfo&lt;(class System.Collections.Concurrent.ConcurrentQueue`1&lt;!!TElement&gt;) TCollection, TElement&gt;(class System.Text.Json.JsonSerializerOptions options, class System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues`1&lt;!!TCollection&gt; collectionInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateConcurrentQueueInfo``2(System.Text.Json.JsonSerializerOptions,System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateConcurrentQueueInfo(Of TCollection As ConcurrentQueue(Of TElement), TElement As ConcurrentQueue(Of TElement)) (options As JsonSerializerOptions, collectionInfo As JsonCollectionInfoValues(Of TCollection)) As JsonTypeInfo(Of TCollection)" />
      <MemberSignature Language="F#" Value="static member CreateConcurrentQueueInfo : System.Text.Json.JsonSerializerOptions * System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;'Collection (requires 'Collection :&gt; System.Collections.Concurrent.ConcurrentQueue&lt;'Element&gt;)&gt; -&gt; System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Collection (requires 'Collection :&gt; System.Collections.Concurrent.ConcurrentQueue&lt;'Element&gt;)&gt; (requires 'Collection :&gt; System.Collections.Concurrent.ConcurrentQueue&lt;'Element&gt;)" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateConcurrentQueueInfo (options, collectionInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TCollection, typename TElement&gt;&#xA; where TCollection : System::Collections::Concurrent::ConcurrentQueue&lt;TElement&gt; static System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TCollection&gt; ^ CreateConcurrentQueueInfo(System::Text::Json::JsonSerializerOptions ^ options, System::Text::Json::Serialization::Metadata::JsonCollectionInfoValues&lt;TCollection&gt; ^ collectionInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TCollection">
          <Constraints>
            <BaseTypeName>System.Collections.Concurrent.ConcurrentQueue&lt;TElement&gt;</BaseTypeName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
        <Parameter Name="collectionInfo" Type="System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TCollection">The generic definition of the type.</typeparam>
        <typeparam name="TElement">The generic definition of the element type.</typeparam>
        <param name="options">To be added.</param>
        <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
        <summary>Creates metadata for types assignable to <see cref="T:System.Collections.Concurrent.ConcurrentQueue`1" />.</summary>
        <returns>Serialization metadata for the given type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateConcurrentStackInfo&lt;TCollection,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt; CreateConcurrentStackInfo&lt;TCollection,TElement&gt; (System.Text.Json.JsonSerializerOptions options, System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt; collectionInfo) where TCollection : System.Collections.Concurrent.ConcurrentStack&lt;TElement&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TCollection&gt; CreateConcurrentStackInfo&lt;(class System.Collections.Concurrent.ConcurrentStack`1&lt;!!TElement&gt;) TCollection, TElement&gt;(class System.Text.Json.JsonSerializerOptions options, class System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues`1&lt;!!TCollection&gt; collectionInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateConcurrentStackInfo``2(System.Text.Json.JsonSerializerOptions,System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateConcurrentStackInfo(Of TCollection As ConcurrentStack(Of TElement), TElement As ConcurrentStack(Of TElement)) (options As JsonSerializerOptions, collectionInfo As JsonCollectionInfoValues(Of TCollection)) As JsonTypeInfo(Of TCollection)" />
      <MemberSignature Language="F#" Value="static member CreateConcurrentStackInfo : System.Text.Json.JsonSerializerOptions * System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;'Collection (requires 'Collection :&gt; System.Collections.Concurrent.ConcurrentStack&lt;'Element&gt;)&gt; -&gt; System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Collection (requires 'Collection :&gt; System.Collections.Concurrent.ConcurrentStack&lt;'Element&gt;)&gt; (requires 'Collection :&gt; System.Collections.Concurrent.ConcurrentStack&lt;'Element&gt;)" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateConcurrentStackInfo (options, collectionInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TCollection, typename TElement&gt;&#xA; where TCollection : System::Collections::Concurrent::ConcurrentStack&lt;TElement&gt; static System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TCollection&gt; ^ CreateConcurrentStackInfo(System::Text::Json::JsonSerializerOptions ^ options, System::Text::Json::Serialization::Metadata::JsonCollectionInfoValues&lt;TCollection&gt; ^ collectionInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TCollection">
          <Constraints>
            <BaseTypeName>System.Collections.Concurrent.ConcurrentStack&lt;TElement&gt;</BaseTypeName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
        <Parameter Name="collectionInfo" Type="System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TCollection">The generic definition of the type.</typeparam>
        <typeparam name="TElement">The generic definition of the element type.</typeparam>
        <param name="options">To be added.</param>
        <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
        <summary>Creates metadata for types assignable to <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.</summary>
        <returns>Serialization metadata for the given type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDictionaryInfo&lt;TCollection,TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt; CreateDictionaryInfo&lt;TCollection,TKey,TValue&gt; (System.Text.Json.JsonSerializerOptions options, System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt; collectionInfo) where TCollection : System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TCollection&gt; CreateDictionaryInfo&lt;(class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TValue&gt;) TCollection, TKey, TValue&gt;(class System.Text.Json.JsonSerializerOptions options, class System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues`1&lt;!!TCollection&gt; collectionInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateDictionaryInfo``3(System.Text.Json.JsonSerializerOptions,System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDictionaryInfo(Of TCollection As Dictionary(Of TKey, TValue), TKey As Dictionary(Of TKey, TValue), TValue As Dictionary(Of TKey, TValue)) (options As JsonSerializerOptions, collectionInfo As JsonCollectionInfoValues(Of TCollection)) As JsonTypeInfo(Of TCollection)" />
      <MemberSignature Language="F#" Value="static member CreateDictionaryInfo : System.Text.Json.JsonSerializerOptions * System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;'Collection (requires 'Collection :&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;)&gt; -&gt; System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Collection (requires 'Collection :&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;)&gt; (requires 'Collection :&gt; System.Collections.Generic.Dictionary&lt;'Key, 'Value&gt;)" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateDictionaryInfo (options, collectionInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TCollection, typename TKey, typename TValue&gt;&#xA; where TCollection : System::Collections::Generic::Dictionary&lt;TKey, TValue&gt; static System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TCollection&gt; ^ CreateDictionaryInfo(System::Text::Json::JsonSerializerOptions ^ options, System::Text::Json::Serialization::Metadata::JsonCollectionInfoValues&lt;TCollection&gt; ^ collectionInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TCollection">
          <Constraints>
            <BaseTypeName>System.Collections.Generic.Dictionary&lt;TKey,TValue&gt;</BaseTypeName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
        <Parameter Name="collectionInfo" Type="System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TCollection">The generic definition of the type.</typeparam>
        <typeparam name="TKey">The generic definition of the key type.</typeparam>
        <typeparam name="TValue">The generic definition of the value type.</typeparam>
        <param name="options">To be added.</param>
        <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
        <summary>Creates metadata for types assignable to <see cref="T:System.Collections.Generic.Dictionary`2" />.</summary>
        <returns>Serialization metadata for the given type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateICollectionInfo&lt;TCollection,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt; CreateICollectionInfo&lt;TCollection,TElement&gt; (System.Text.Json.JsonSerializerOptions options, System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt; collectionInfo) where TCollection : System.Collections.Generic.ICollection&lt;TElement&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TCollection&gt; CreateICollectionInfo&lt;(class System.Collections.Generic.ICollection`1&lt;!!TElement&gt;) TCollection, TElement&gt;(class System.Text.Json.JsonSerializerOptions options, class System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues`1&lt;!!TCollection&gt; collectionInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateICollectionInfo``2(System.Text.Json.JsonSerializerOptions,System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateICollectionInfo(Of TCollection As ICollection(Of TElement), TElement As ICollection(Of TElement)) (options As JsonSerializerOptions, collectionInfo As JsonCollectionInfoValues(Of TCollection)) As JsonTypeInfo(Of TCollection)" />
      <MemberSignature Language="F#" Value="static member CreateICollectionInfo : System.Text.Json.JsonSerializerOptions * System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;'Collection (requires 'Collection :&gt; System.Collections.Generic.ICollection&lt;'Element&gt;)&gt; -&gt; System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Collection (requires 'Collection :&gt; System.Collections.Generic.ICollection&lt;'Element&gt;)&gt; (requires 'Collection :&gt; System.Collections.Generic.ICollection&lt;'Element&gt;)" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateICollectionInfo (options, collectionInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TCollection, typename TElement&gt;&#xA; where TCollection : System::Collections::Generic::ICollection&lt;TElement&gt; static System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TCollection&gt; ^ CreateICollectionInfo(System::Text::Json::JsonSerializerOptions ^ options, System::Text::Json::Serialization::Metadata::JsonCollectionInfoValues&lt;TCollection&gt; ^ collectionInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TCollection">
          <Constraints>
            <InterfaceName>System.Collections.Generic.ICollection&lt;TElement&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
        <Parameter Name="collectionInfo" Type="System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TCollection">The generic definition of the type.</typeparam>
        <typeparam name="TElement">The generic definition of the element type.</typeparam>
        <param name="options">To be added.</param>
        <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
        <summary>Creates metadata for types assignable to <see cref="T:System.Collections.Generic.ICollection`1" />.</summary>
        <returns>Serialization metadata for the given type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateIDictionaryInfo&lt;TCollection&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt; CreateIDictionaryInfo&lt;TCollection&gt; (System.Text.Json.JsonSerializerOptions options, System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt; collectionInfo) where TCollection : System.Collections.IDictionary;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TCollection&gt; CreateIDictionaryInfo&lt;(class System.Collections.IDictionary) TCollection&gt;(class System.Text.Json.JsonSerializerOptions options, class System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues`1&lt;!!TCollection&gt; collectionInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateIDictionaryInfo``1(System.Text.Json.JsonSerializerOptions,System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateIDictionaryInfo(Of TCollection As IDictionary) (options As JsonSerializerOptions, collectionInfo As JsonCollectionInfoValues(Of TCollection)) As JsonTypeInfo(Of TCollection)" />
      <MemberSignature Language="F#" Value="static member CreateIDictionaryInfo : System.Text.Json.JsonSerializerOptions * System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;'Collection (requires 'Collection :&gt; System.Collections.IDictionary)&gt; -&gt; System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Collection (requires 'Collection :&gt; System.Collections.IDictionary)&gt; (requires 'Collection :&gt; System.Collections.IDictionary)" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateIDictionaryInfo (options, collectionInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TCollection&gt;&#xA; where TCollection : System::Collections::IDictionary static System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TCollection&gt; ^ CreateIDictionaryInfo(System::Text::Json::JsonSerializerOptions ^ options, System::Text::Json::Serialization::Metadata::JsonCollectionInfoValues&lt;TCollection&gt; ^ collectionInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TCollection">
          <Constraints>
            <InterfaceName>System.Collections.IDictionary</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
        <Parameter Name="collectionInfo" Type="System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TCollection">The generic definition of the type.</typeparam>
        <param name="options">To be added.</param>
        <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
        <summary>Creates metadata for types assignable to <see cref="T:System.Collections.IDictionary" />.</summary>
        <returns>Serialization metadata for the given type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateIDictionaryInfo&lt;TCollection,TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt; CreateIDictionaryInfo&lt;TCollection,TKey,TValue&gt; (System.Text.Json.JsonSerializerOptions options, System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt; collectionInfo) where TCollection : System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TCollection&gt; CreateIDictionaryInfo&lt;(class System.Collections.Generic.IDictionary`2&lt;!!TKey, !!TValue&gt;) TCollection, TKey, TValue&gt;(class System.Text.Json.JsonSerializerOptions options, class System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues`1&lt;!!TCollection&gt; collectionInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateIDictionaryInfo``3(System.Text.Json.JsonSerializerOptions,System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateIDictionaryInfo(Of TCollection As IDictionary(Of TKey, TValue), TKey As IDictionary(Of TKey, TValue), TValue As IDictionary(Of TKey, TValue)) (options As JsonSerializerOptions, collectionInfo As JsonCollectionInfoValues(Of TCollection)) As JsonTypeInfo(Of TCollection)" />
      <MemberSignature Language="F#" Value="static member CreateIDictionaryInfo : System.Text.Json.JsonSerializerOptions * System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;'Collection (requires 'Collection :&gt; System.Collections.Generic.IDictionary&lt;'Key, 'Value&gt;)&gt; -&gt; System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Collection (requires 'Collection :&gt; System.Collections.Generic.IDictionary&lt;'Key, 'Value&gt;)&gt; (requires 'Collection :&gt; System.Collections.Generic.IDictionary&lt;'Key, 'Value&gt;)" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateIDictionaryInfo (options, collectionInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TCollection, typename TKey, typename TValue&gt;&#xA; where TCollection : System::Collections::Generic::IDictionary&lt;TKey, TValue&gt; static System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TCollection&gt; ^ CreateIDictionaryInfo(System::Text::Json::JsonSerializerOptions ^ options, System::Text::Json::Serialization::Metadata::JsonCollectionInfoValues&lt;TCollection&gt; ^ collectionInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TCollection">
          <Constraints>
            <InterfaceName>System.Collections.Generic.IDictionary&lt;TKey,TValue&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
        <Parameter Name="collectionInfo" Type="System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TCollection">The generic definition of the type.</typeparam>
        <typeparam name="TKey">The generic definition of the key type.</typeparam>
        <typeparam name="TValue">The generic definition of the value type.</typeparam>
        <param name="options">To be added.</param>
        <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
        <summary>Creates metadata for types assignable to <see cref="T:System.Collections.Generic.IDictionary`2" />.</summary>
        <returns>Serialization metadata for the given type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateIEnumerableInfo&lt;TCollection&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt; CreateIEnumerableInfo&lt;TCollection&gt; (System.Text.Json.JsonSerializerOptions options, System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt; collectionInfo) where TCollection : System.Collections.IEnumerable;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TCollection&gt; CreateIEnumerableInfo&lt;(class System.Collections.IEnumerable) TCollection&gt;(class System.Text.Json.JsonSerializerOptions options, class System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues`1&lt;!!TCollection&gt; collectionInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateIEnumerableInfo``1(System.Text.Json.JsonSerializerOptions,System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateIEnumerableInfo(Of TCollection As IEnumerable) (options As JsonSerializerOptions, collectionInfo As JsonCollectionInfoValues(Of TCollection)) As JsonTypeInfo(Of TCollection)" />
      <MemberSignature Language="F#" Value="static member CreateIEnumerableInfo : System.Text.Json.JsonSerializerOptions * System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;'Collection (requires 'Collection :&gt; System.Collections.IEnumerable)&gt; -&gt; System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Collection (requires 'Collection :&gt; System.Collections.IEnumerable)&gt; (requires 'Collection :&gt; System.Collections.IEnumerable)" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateIEnumerableInfo (options, collectionInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TCollection&gt;&#xA; where TCollection : System::Collections::IEnumerable static System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TCollection&gt; ^ CreateIEnumerableInfo(System::Text::Json::JsonSerializerOptions ^ options, System::Text::Json::Serialization::Metadata::JsonCollectionInfoValues&lt;TCollection&gt; ^ collectionInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TCollection">
          <Constraints>
            <InterfaceName>System.Collections.IEnumerable</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
        <Parameter Name="collectionInfo" Type="System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TCollection">The generic definition of the type.</typeparam>
        <param name="options">To be added.</param>
        <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
        <summary>Creates metadata for types assignable to <see cref="T:System.Collections.IEnumerable" />.</summary>
        <returns>Serialization metadata for the given type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateIEnumerableInfo&lt;TCollection,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt; CreateIEnumerableInfo&lt;TCollection,TElement&gt; (System.Text.Json.JsonSerializerOptions options, System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt; collectionInfo) where TCollection : System.Collections.Generic.IEnumerable&lt;TElement&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TCollection&gt; CreateIEnumerableInfo&lt;(class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;) TCollection, TElement&gt;(class System.Text.Json.JsonSerializerOptions options, class System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues`1&lt;!!TCollection&gt; collectionInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateIEnumerableInfo``2(System.Text.Json.JsonSerializerOptions,System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateIEnumerableInfo(Of TCollection As IEnumerable(Of TElement), TElement As IEnumerable(Of TElement)) (options As JsonSerializerOptions, collectionInfo As JsonCollectionInfoValues(Of TCollection)) As JsonTypeInfo(Of TCollection)" />
      <MemberSignature Language="F#" Value="static member CreateIEnumerableInfo : System.Text.Json.JsonSerializerOptions * System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;#seq&lt;'Element&gt;&gt; -&gt; System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;#seq&lt;'Element&gt;&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateIEnumerableInfo (options, collectionInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TCollection, typename TElement&gt;&#xA; where TCollection : System::Collections::Generic::IEnumerable&lt;TElement&gt; static System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TCollection&gt; ^ CreateIEnumerableInfo(System::Text::Json::JsonSerializerOptions ^ options, System::Text::Json::Serialization::Metadata::JsonCollectionInfoValues&lt;TCollection&gt; ^ collectionInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TCollection">
          <Constraints>
            <InterfaceName>System.Collections.Generic.IEnumerable&lt;TElement&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
        <Parameter Name="collectionInfo" Type="System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TCollection">The generic definition of the type.</typeparam>
        <typeparam name="TElement">The generic definition of the element type.</typeparam>
        <param name="options">To be added.</param>
        <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
        <summary>Creates metadata for types assignable to <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
        <returns>Serialization metadata for the given type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateIListInfo&lt;TCollection&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt; CreateIListInfo&lt;TCollection&gt; (System.Text.Json.JsonSerializerOptions options, System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt; collectionInfo) where TCollection : System.Collections.IList;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TCollection&gt; CreateIListInfo&lt;(class System.Collections.IList) TCollection&gt;(class System.Text.Json.JsonSerializerOptions options, class System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues`1&lt;!!TCollection&gt; collectionInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateIListInfo``1(System.Text.Json.JsonSerializerOptions,System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateIListInfo(Of TCollection As IList) (options As JsonSerializerOptions, collectionInfo As JsonCollectionInfoValues(Of TCollection)) As JsonTypeInfo(Of TCollection)" />
      <MemberSignature Language="F#" Value="static member CreateIListInfo : System.Text.Json.JsonSerializerOptions * System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;'Collection (requires 'Collection :&gt; System.Collections.IList)&gt; -&gt; System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Collection (requires 'Collection :&gt; System.Collections.IList)&gt; (requires 'Collection :&gt; System.Collections.IList)" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateIListInfo (options, collectionInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TCollection&gt;&#xA; where TCollection : System::Collections::IList static System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TCollection&gt; ^ CreateIListInfo(System::Text::Json::JsonSerializerOptions ^ options, System::Text::Json::Serialization::Metadata::JsonCollectionInfoValues&lt;TCollection&gt; ^ collectionInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TCollection">
          <Constraints>
            <InterfaceName>System.Collections.IList</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
        <Parameter Name="collectionInfo" Type="System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TCollection">The generic definition of the type.</typeparam>
        <param name="options">To be added.</param>
        <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
        <summary>Creates metadata for types assignable to <see cref="T:System.Collections.IList" />.</summary>
        <returns>Serialization metadata for the given type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateIListInfo&lt;TCollection,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt; CreateIListInfo&lt;TCollection,TElement&gt; (System.Text.Json.JsonSerializerOptions options, System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt; collectionInfo) where TCollection : System.Collections.Generic.IList&lt;TElement&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TCollection&gt; CreateIListInfo&lt;(class System.Collections.Generic.IList`1&lt;!!TElement&gt;) TCollection, TElement&gt;(class System.Text.Json.JsonSerializerOptions options, class System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues`1&lt;!!TCollection&gt; collectionInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateIListInfo``2(System.Text.Json.JsonSerializerOptions,System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateIListInfo(Of TCollection As IList(Of TElement), TElement As IList(Of TElement)) (options As JsonSerializerOptions, collectionInfo As JsonCollectionInfoValues(Of TCollection)) As JsonTypeInfo(Of TCollection)" />
      <MemberSignature Language="F#" Value="static member CreateIListInfo : System.Text.Json.JsonSerializerOptions * System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;'Collection (requires 'Collection :&gt; System.Collections.Generic.IList&lt;'Element&gt;)&gt; -&gt; System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Collection (requires 'Collection :&gt; System.Collections.Generic.IList&lt;'Element&gt;)&gt; (requires 'Collection :&gt; System.Collections.Generic.IList&lt;'Element&gt;)" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateIListInfo (options, collectionInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TCollection, typename TElement&gt;&#xA; where TCollection : System::Collections::Generic::IList&lt;TElement&gt; static System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TCollection&gt; ^ CreateIListInfo(System::Text::Json::JsonSerializerOptions ^ options, System::Text::Json::Serialization::Metadata::JsonCollectionInfoValues&lt;TCollection&gt; ^ collectionInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TCollection">
          <Constraints>
            <InterfaceName>System.Collections.Generic.IList&lt;TElement&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
        <Parameter Name="collectionInfo" Type="System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TCollection">The generic definition of the type.</typeparam>
        <typeparam name="TElement">The generic definition of the element type.</typeparam>
        <param name="options">To be added.</param>
        <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
        <summary>Creates metadata for types assignable to <see cref="T:System.Collections.Generic.IList`1" />.</summary>
        <returns>Serialization metadata for the given type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateImmutableDictionaryInfo&lt;TCollection,TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt; CreateImmutableDictionaryInfo&lt;TCollection,TKey,TValue&gt; (System.Text.Json.JsonSerializerOptions options, System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt; collectionInfo, Func&lt;System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;,TCollection&gt; createRangeFunc) where TCollection : System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TCollection&gt; CreateImmutableDictionaryInfo&lt;(class System.Collections.Generic.IReadOnlyDictionary`2&lt;!!TKey, !!TValue&gt;) TCollection, TKey, TValue&gt;(class System.Text.Json.JsonSerializerOptions options, class System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues`1&lt;!!TCollection&gt; collectionInfo, class System.Func`2&lt;class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!!TKey, !!TValue&gt;&gt;, !!TCollection&gt; createRangeFunc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateImmutableDictionaryInfo``3(System.Text.Json.JsonSerializerOptions,System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues{``0},System.Func{System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``1,``2}},``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateImmutableDictionaryInfo(Of TCollection As IReadOnlyDictionary(Of TKey, TValue), TKey As IReadOnlyDictionary(Of TKey, TValue), TValue As IReadOnlyDictionary(Of TKey, TValue)) (options As JsonSerializerOptions, collectionInfo As JsonCollectionInfoValues(Of TCollection), createRangeFunc As Func(Of IEnumerable(Of KeyValuePair(Of TKey, TValue)), TCollection)) As JsonTypeInfo(Of TCollection)" />
      <MemberSignature Language="F#" Value="static member CreateImmutableDictionaryInfo : System.Text.Json.JsonSerializerOptions * System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;'Collection (requires 'Collection :&gt; System.Collections.Generic.IReadOnlyDictionary&lt;'Key, 'Value&gt;)&gt; * Func&lt;seq&lt;System.Collections.Generic.KeyValuePair&lt;'Key, 'Value&gt;&gt;, 'Collection (requires 'Collection :&gt; System.Collections.Generic.IReadOnlyDictionary&lt;'Key, 'Value&gt;)&gt; -&gt; System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Collection (requires 'Collection :&gt; System.Collections.Generic.IReadOnlyDictionary&lt;'Key, 'Value&gt;)&gt; (requires 'Collection :&gt; System.Collections.Generic.IReadOnlyDictionary&lt;'Key, 'Value&gt;)" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateImmutableDictionaryInfo (options, collectionInfo, createRangeFunc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TCollection, typename TKey, typename TValue&gt;&#xA; where TCollection : System::Collections::Generic::IReadOnlyDictionary&lt;TKey, TValue&gt; static System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TCollection&gt; ^ CreateImmutableDictionaryInfo(System::Text::Json::JsonSerializerOptions ^ options, System::Text::Json::Serialization::Metadata::JsonCollectionInfoValues&lt;TCollection&gt; ^ collectionInfo, Func&lt;System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;TKey, TValue&gt;&gt; ^, TCollection&gt; ^ createRangeFunc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TCollection">
          <Constraints>
            <InterfaceName>System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
        <Parameter Name="collectionInfo" Type="System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt;" />
        <Parameter Name="createRangeFunc" Type="System.Func&lt;System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;,TCollection&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TCollection">The generic definition of the type.</typeparam>
        <typeparam name="TKey">The generic definition of the key type.</typeparam>
        <typeparam name="TValue">The generic definition of the value type.</typeparam>
        <param name="options">To be added.</param>
        <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
        <param name="createRangeFunc">A method to create an immutable dictionary instance.</param>
        <summary>Creates metadata for <see cref="T:System.Collections.Immutable.ImmutableDictionary`2" /> and types assignable to <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2" />.</summary>
        <returns>Serialization metadata for the given type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateImmutableEnumerableInfo&lt;TCollection,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt; CreateImmutableEnumerableInfo&lt;TCollection,TElement&gt; (System.Text.Json.JsonSerializerOptions options, System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt; collectionInfo, Func&lt;System.Collections.Generic.IEnumerable&lt;TElement&gt;,TCollection&gt; createRangeFunc) where TCollection : System.Collections.Generic.IEnumerable&lt;TElement&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TCollection&gt; CreateImmutableEnumerableInfo&lt;(class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;) TCollection, TElement&gt;(class System.Text.Json.JsonSerializerOptions options, class System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues`1&lt;!!TCollection&gt; collectionInfo, class System.Func`2&lt;class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TCollection&gt; createRangeFunc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateImmutableEnumerableInfo``2(System.Text.Json.JsonSerializerOptions,System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues{``0},System.Func{System.Collections.Generic.IEnumerable{``1},``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateImmutableEnumerableInfo(Of TCollection As IEnumerable(Of TElement), TElement As IEnumerable(Of TElement)) (options As JsonSerializerOptions, collectionInfo As JsonCollectionInfoValues(Of TCollection), createRangeFunc As Func(Of IEnumerable(Of TElement), TCollection)) As JsonTypeInfo(Of TCollection)" />
      <MemberSignature Language="F#" Value="static member CreateImmutableEnumerableInfo : System.Text.Json.JsonSerializerOptions * System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;#seq&lt;'Element&gt;&gt; * Func&lt;seq&lt;'Element&gt;, #seq&lt;'Element&gt;&gt; -&gt; System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;#seq&lt;'Element&gt;&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateImmutableEnumerableInfo (options, collectionInfo, createRangeFunc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TCollection, typename TElement&gt;&#xA; where TCollection : System::Collections::Generic::IEnumerable&lt;TElement&gt; static System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TCollection&gt; ^ CreateImmutableEnumerableInfo(System::Text::Json::JsonSerializerOptions ^ options, System::Text::Json::Serialization::Metadata::JsonCollectionInfoValues&lt;TCollection&gt; ^ collectionInfo, Func&lt;System::Collections::Generic::IEnumerable&lt;TElement&gt; ^, TCollection&gt; ^ createRangeFunc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TCollection">
          <Constraints>
            <InterfaceName>System.Collections.Generic.IEnumerable&lt;TElement&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
        <Parameter Name="collectionInfo" Type="System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt;" />
        <Parameter Name="createRangeFunc" Type="System.Func&lt;System.Collections.Generic.IEnumerable&lt;TElement&gt;,TCollection&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TCollection">The generic definition of the type.</typeparam>
        <typeparam name="TElement">The generic definition of the element type.</typeparam>
        <param name="options">To be added.</param>
        <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
        <param name="createRangeFunc">A method to create an immutable dictionary instance.</param>
        <summary>Creates metadata for non-dictionary immutable collection types.</summary>
        <returns>Serialization metadata for the given type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateIReadOnlyDictionaryInfo&lt;TCollection,TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt; CreateIReadOnlyDictionaryInfo&lt;TCollection,TKey,TValue&gt; (System.Text.Json.JsonSerializerOptions options, System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt; collectionInfo) where TCollection : System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TCollection&gt; CreateIReadOnlyDictionaryInfo&lt;(class System.Collections.Generic.IReadOnlyDictionary`2&lt;!!TKey, !!TValue&gt;) TCollection, TKey, TValue&gt;(class System.Text.Json.JsonSerializerOptions options, class System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues`1&lt;!!TCollection&gt; collectionInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateIReadOnlyDictionaryInfo``3(System.Text.Json.JsonSerializerOptions,System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateIReadOnlyDictionaryInfo(Of TCollection As IReadOnlyDictionary(Of TKey, TValue), TKey As IReadOnlyDictionary(Of TKey, TValue), TValue As IReadOnlyDictionary(Of TKey, TValue)) (options As JsonSerializerOptions, collectionInfo As JsonCollectionInfoValues(Of TCollection)) As JsonTypeInfo(Of TCollection)" />
      <MemberSignature Language="F#" Value="static member CreateIReadOnlyDictionaryInfo : System.Text.Json.JsonSerializerOptions * System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;'Collection (requires 'Collection :&gt; System.Collections.Generic.IReadOnlyDictionary&lt;'Key, 'Value&gt;)&gt; -&gt; System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Collection (requires 'Collection :&gt; System.Collections.Generic.IReadOnlyDictionary&lt;'Key, 'Value&gt;)&gt; (requires 'Collection :&gt; System.Collections.Generic.IReadOnlyDictionary&lt;'Key, 'Value&gt;)" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateIReadOnlyDictionaryInfo (options, collectionInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TCollection, typename TKey, typename TValue&gt;&#xA; where TCollection : System::Collections::Generic::IReadOnlyDictionary&lt;TKey, TValue&gt; static System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TCollection&gt; ^ CreateIReadOnlyDictionaryInfo(System::Text::Json::JsonSerializerOptions ^ options, System::Text::Json::Serialization::Metadata::JsonCollectionInfoValues&lt;TCollection&gt; ^ collectionInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TCollection">
          <Constraints>
            <InterfaceName>System.Collections.Generic.IReadOnlyDictionary&lt;TKey,TValue&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
        <Parameter Name="collectionInfo" Type="System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TCollection">The generic definition of the type.</typeparam>
        <typeparam name="TKey">The generic definition of the key type.</typeparam>
        <typeparam name="TValue">The generic definition of the value type.</typeparam>
        <param name="options">To be added.</param>
        <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
        <summary>Creates metadata for types assignable to <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2" />.</summary>
        <returns>Serialization metadata for the given type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateISetInfo&lt;TCollection,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt; CreateISetInfo&lt;TCollection,TElement&gt; (System.Text.Json.JsonSerializerOptions options, System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt; collectionInfo) where TCollection : System.Collections.Generic.ISet&lt;TElement&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TCollection&gt; CreateISetInfo&lt;(class System.Collections.Generic.ISet`1&lt;!!TElement&gt;) TCollection, TElement&gt;(class System.Text.Json.JsonSerializerOptions options, class System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues`1&lt;!!TCollection&gt; collectionInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateISetInfo``2(System.Text.Json.JsonSerializerOptions,System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateISetInfo(Of TCollection As ISet(Of TElement), TElement As ISet(Of TElement)) (options As JsonSerializerOptions, collectionInfo As JsonCollectionInfoValues(Of TCollection)) As JsonTypeInfo(Of TCollection)" />
      <MemberSignature Language="F#" Value="static member CreateISetInfo : System.Text.Json.JsonSerializerOptions * System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;'Collection (requires 'Collection :&gt; System.Collections.Generic.ISet&lt;'Element&gt;)&gt; -&gt; System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Collection (requires 'Collection :&gt; System.Collections.Generic.ISet&lt;'Element&gt;)&gt; (requires 'Collection :&gt; System.Collections.Generic.ISet&lt;'Element&gt;)" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateISetInfo (options, collectionInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TCollection, typename TElement&gt;&#xA; where TCollection : System::Collections::Generic::ISet&lt;TElement&gt; static System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TCollection&gt; ^ CreateISetInfo(System::Text::Json::JsonSerializerOptions ^ options, System::Text::Json::Serialization::Metadata::JsonCollectionInfoValues&lt;TCollection&gt; ^ collectionInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TCollection">
          <Constraints>
            <InterfaceName>System.Collections.Generic.ISet&lt;TElement&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
        <Parameter Name="collectionInfo" Type="System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TCollection">The generic definition of the type.</typeparam>
        <typeparam name="TElement">The generic definition of the element type.</typeparam>
        <param name="options">To be added.</param>
        <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
        <summary>Creates metadata for types assignable to <see cref="T:System.Collections.Generic.ISet`1" />.</summary>
        <returns>Serialization metadata for the given type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateListInfo&lt;TCollection,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt; CreateListInfo&lt;TCollection,TElement&gt; (System.Text.Json.JsonSerializerOptions options, System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt; collectionInfo) where TCollection : System.Collections.Generic.List&lt;TElement&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TCollection&gt; CreateListInfo&lt;(class System.Collections.Generic.List`1&lt;!!TElement&gt;) TCollection, TElement&gt;(class System.Text.Json.JsonSerializerOptions options, class System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues`1&lt;!!TCollection&gt; collectionInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateListInfo``2(System.Text.Json.JsonSerializerOptions,System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateListInfo(Of TCollection As List(Of TElement), TElement As List(Of TElement)) (options As JsonSerializerOptions, collectionInfo As JsonCollectionInfoValues(Of TCollection)) As JsonTypeInfo(Of TCollection)" />
      <MemberSignature Language="F#" Value="static member CreateListInfo : System.Text.Json.JsonSerializerOptions * System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;'Collection (requires 'Collection :&gt; System.Collections.Generic.List&lt;'Element&gt;)&gt; -&gt; System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Collection (requires 'Collection :&gt; System.Collections.Generic.List&lt;'Element&gt;)&gt; (requires 'Collection :&gt; System.Collections.Generic.List&lt;'Element&gt;)" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateListInfo (options, collectionInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TCollection, typename TElement&gt;&#xA; where TCollection : System::Collections::Generic::List&lt;TElement&gt; static System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TCollection&gt; ^ CreateListInfo(System::Text::Json::JsonSerializerOptions ^ options, System::Text::Json::Serialization::Metadata::JsonCollectionInfoValues&lt;TCollection&gt; ^ collectionInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TCollection">
          <Constraints>
            <BaseTypeName>System.Collections.Generic.List&lt;TElement&gt;</BaseTypeName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
        <Parameter Name="collectionInfo" Type="System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TCollection">The generic definition of the type.</typeparam>
        <typeparam name="TElement">The generic definition of the element type.</typeparam>
        <param name="options">The <see cref="T:System.Text.Json.JsonSerializerOptions" /> to use.</param>
        <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
        <summary>Creates metadata for types assignable to <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Serialization metadata for the given type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObjectInfo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;T&gt; CreateObjectInfo&lt;T&gt; (System.Text.Json.JsonSerializerOptions options, System.Text.Json.Serialization.Metadata.JsonObjectInfoValues&lt;T&gt; objectInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!T&gt; CreateObjectInfo&lt;T&gt;(class System.Text.Json.JsonSerializerOptions options, class System.Text.Json.Serialization.Metadata.JsonObjectInfoValues`1&lt;!!T&gt; objectInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateObjectInfo``1(System.Text.Json.JsonSerializerOptions,System.Text.Json.Serialization.Metadata.JsonObjectInfoValues{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateObjectInfo(Of T) (options As JsonSerializerOptions, objectInfo As JsonObjectInfoValues(Of T)) As JsonTypeInfo(Of T)" />
      <MemberSignature Language="F#" Value="static member CreateObjectInfo : System.Text.Json.JsonSerializerOptions * System.Text.Json.Serialization.Metadata.JsonObjectInfoValues&lt;'T&gt; -&gt; System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'T&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateObjectInfo (options, objectInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;T&gt; ^ CreateObjectInfo(System::Text::Json::JsonSerializerOptions ^ options, System::Text::Json::Serialization::Metadata::JsonObjectInfoValues&lt;T&gt; ^ objectInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
        <Parameter Name="objectInfo" Type="System.Text.Json.Serialization.Metadata.JsonObjectInfoValues&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of the class or struct.</typeparam>
        <param name="options">The <see cref="T:System.Text.Json.JsonSerializerOptions" /> to initialize the metadata with.</param>
        <param name="objectInfo">Provides serialization metadata about an object type with constructors, properties, and fields.</param>
        <summary>Creates metadata for a complex class or struct.</summary>
        <returns>A <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo`1" /> instance representing the class or struct.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="options" /> or <paramref name="objectInfo" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreatePropertyInfo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.Metadata.JsonPropertyInfo CreatePropertyInfo&lt;T&gt; (System.Text.Json.JsonSerializerOptions options, System.Text.Json.Serialization.Metadata.JsonPropertyInfoValues&lt;T&gt; propertyInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.Serialization.Metadata.JsonPropertyInfo CreatePropertyInfo&lt;T&gt;(class System.Text.Json.JsonSerializerOptions options, class System.Text.Json.Serialization.Metadata.JsonPropertyInfoValues`1&lt;!!T&gt; propertyInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreatePropertyInfo``1(System.Text.Json.JsonSerializerOptions,System.Text.Json.Serialization.Metadata.JsonPropertyInfoValues{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreatePropertyInfo(Of T) (options As JsonSerializerOptions, propertyInfo As JsonPropertyInfoValues(Of T)) As JsonPropertyInfo" />
      <MemberSignature Language="F#" Value="static member CreatePropertyInfo : System.Text.Json.JsonSerializerOptions * System.Text.Json.Serialization.Metadata.JsonPropertyInfoValues&lt;'T&gt; -&gt; System.Text.Json.Serialization.Metadata.JsonPropertyInfo" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreatePropertyInfo (options, propertyInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Text::Json::Serialization::Metadata::JsonPropertyInfo ^ CreatePropertyInfo(System::Text::Json::JsonSerializerOptions ^ options, System::Text::Json::Serialization::Metadata::JsonPropertyInfoValues&lt;T&gt; ^ propertyInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.Metadata.JsonPropertyInfo</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
        <Parameter Name="propertyInfo" Type="System.Text.Json.Serialization.Metadata.JsonPropertyInfoValues&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type that the converter for the property returns or accepts when converting JSON data.</typeparam>
        <param name="options">The options to initialize the metadata with.</param>
        <param name="propertyInfo">Provides serialization metadata about the property or field.</param>
        <summary>Creates metadata for a property or field.</summary>
        <returns>A <see cref="T:System.Text.Json.Serialization.Metadata.JsonPropertyInfo" /> instance initialized with the provided metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateQueueInfo&lt;TCollection&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt; CreateQueueInfo&lt;TCollection&gt; (System.Text.Json.JsonSerializerOptions options, System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt; collectionInfo, Action&lt;TCollection,object?&gt; addFunc) where TCollection : System.Collections.IEnumerable;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TCollection&gt; CreateQueueInfo&lt;(class System.Collections.IEnumerable) TCollection&gt;(class System.Text.Json.JsonSerializerOptions options, class System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues`1&lt;!!TCollection&gt; collectionInfo, class System.Action`2&lt;!!TCollection, object&gt; addFunc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateQueueInfo``1(System.Text.Json.JsonSerializerOptions,System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues{``0},System.Action{``0,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateQueueInfo(Of TCollection As IEnumerable) (options As JsonSerializerOptions, collectionInfo As JsonCollectionInfoValues(Of TCollection), addFunc As Action(Of TCollection, Object)) As JsonTypeInfo(Of TCollection)" />
      <MemberSignature Language="F#" Value="static member CreateQueueInfo : System.Text.Json.JsonSerializerOptions * System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;'Collection (requires 'Collection :&gt; System.Collections.IEnumerable)&gt; * Action&lt;'Collection, obj (requires 'Collection :&gt; System.Collections.IEnumerable)&gt; -&gt; System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Collection (requires 'Collection :&gt; System.Collections.IEnumerable)&gt; (requires 'Collection :&gt; System.Collections.IEnumerable)" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateQueueInfo (options, collectionInfo, addFunc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TCollection&gt;&#xA; where TCollection : System::Collections::IEnumerable static System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TCollection&gt; ^ CreateQueueInfo(System::Text::Json::JsonSerializerOptions ^ options, System::Text::Json::Serialization::Metadata::JsonCollectionInfoValues&lt;TCollection&gt; ^ collectionInfo, Action&lt;TCollection, System::Object ^&gt; ^ addFunc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TCollection">
          <Constraints>
            <InterfaceName>System.Collections.IEnumerable</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
        <Parameter Name="collectionInfo" Type="System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt;" />
        <Parameter Name="addFunc" Type="System.Action&lt;TCollection,System.Object&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TCollection">The generic definition of the type.</typeparam>
        <param name="options">To be added.</param>
        <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
        <param name="addFunc">A method for adding elements to the collection when using the serializer's code-paths.</param>
        <summary>Creates metadata for types assignable to <see cref="T:System.Collections.Queue" />.</summary>
        <returns>Serialization metadata for the given type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateQueueInfo&lt;TCollection,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt; CreateQueueInfo&lt;TCollection,TElement&gt; (System.Text.Json.JsonSerializerOptions options, System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt; collectionInfo) where TCollection : System.Collections.Generic.Queue&lt;TElement&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TCollection&gt; CreateQueueInfo&lt;(class System.Collections.Generic.Queue`1&lt;!!TElement&gt;) TCollection, TElement&gt;(class System.Text.Json.JsonSerializerOptions options, class System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues`1&lt;!!TCollection&gt; collectionInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateQueueInfo``2(System.Text.Json.JsonSerializerOptions,System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateQueueInfo(Of TCollection As Queue(Of TElement), TElement As Queue(Of TElement)) (options As JsonSerializerOptions, collectionInfo As JsonCollectionInfoValues(Of TCollection)) As JsonTypeInfo(Of TCollection)" />
      <MemberSignature Language="F#" Value="static member CreateQueueInfo : System.Text.Json.JsonSerializerOptions * System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;'Collection (requires 'Collection :&gt; System.Collections.Generic.Queue&lt;'Element&gt;)&gt; -&gt; System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Collection (requires 'Collection :&gt; System.Collections.Generic.Queue&lt;'Element&gt;)&gt; (requires 'Collection :&gt; System.Collections.Generic.Queue&lt;'Element&gt;)" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateQueueInfo (options, collectionInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TCollection, typename TElement&gt;&#xA; where TCollection : System::Collections::Generic::Queue&lt;TElement&gt; static System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TCollection&gt; ^ CreateQueueInfo(System::Text::Json::JsonSerializerOptions ^ options, System::Text::Json::Serialization::Metadata::JsonCollectionInfoValues&lt;TCollection&gt; ^ collectionInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TCollection">
          <Constraints>
            <BaseTypeName>System.Collections.Generic.Queue&lt;TElement&gt;</BaseTypeName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
        <Parameter Name="collectionInfo" Type="System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TCollection">The generic definition of the type.</typeparam>
        <typeparam name="TElement">The generic definition of the element type.</typeparam>
        <param name="options">To be added.</param>
        <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
        <summary>Creates metadata for types assignable to <see cref="T:System.Collections.Generic.Queue`1" />.</summary>
        <returns>Serialization metadata for the given type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateStackInfo&lt;TCollection&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt; CreateStackInfo&lt;TCollection&gt; (System.Text.Json.JsonSerializerOptions options, System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt; collectionInfo, Action&lt;TCollection,object?&gt; addFunc) where TCollection : System.Collections.IEnumerable;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TCollection&gt; CreateStackInfo&lt;(class System.Collections.IEnumerable) TCollection&gt;(class System.Text.Json.JsonSerializerOptions options, class System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues`1&lt;!!TCollection&gt; collectionInfo, class System.Action`2&lt;!!TCollection, object&gt; addFunc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateStackInfo``1(System.Text.Json.JsonSerializerOptions,System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues{``0},System.Action{``0,System.Object})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateStackInfo(Of TCollection As IEnumerable) (options As JsonSerializerOptions, collectionInfo As JsonCollectionInfoValues(Of TCollection), addFunc As Action(Of TCollection, Object)) As JsonTypeInfo(Of TCollection)" />
      <MemberSignature Language="F#" Value="static member CreateStackInfo : System.Text.Json.JsonSerializerOptions * System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;'Collection (requires 'Collection :&gt; System.Collections.IEnumerable)&gt; * Action&lt;'Collection, obj (requires 'Collection :&gt; System.Collections.IEnumerable)&gt; -&gt; System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Collection (requires 'Collection :&gt; System.Collections.IEnumerable)&gt; (requires 'Collection :&gt; System.Collections.IEnumerable)" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateStackInfo (options, collectionInfo, addFunc)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TCollection&gt;&#xA; where TCollection : System::Collections::IEnumerable static System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TCollection&gt; ^ CreateStackInfo(System::Text::Json::JsonSerializerOptions ^ options, System::Text::Json::Serialization::Metadata::JsonCollectionInfoValues&lt;TCollection&gt; ^ collectionInfo, Action&lt;TCollection, System::Object ^&gt; ^ addFunc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TCollection">
          <Constraints>
            <InterfaceName>System.Collections.IEnumerable</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
        <Parameter Name="collectionInfo" Type="System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt;" />
        <Parameter Name="addFunc" Type="System.Action&lt;TCollection,System.Object&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TCollection">The generic definition of the type.</typeparam>
        <param name="options">To be added.</param>
        <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
        <param name="addFunc">A method for adding elements to the collection when using the serializer's code-paths.</param>
        <summary>Creates metadata for types assignable to <see cref="T:System.Collections.Stack" />.</summary>
        <returns>Serialization metadata for the given type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateStackInfo&lt;TCollection,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt; CreateStackInfo&lt;TCollection,TElement&gt; (System.Text.Json.JsonSerializerOptions options, System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt; collectionInfo) where TCollection : System.Collections.Generic.Stack&lt;TElement&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TCollection&gt; CreateStackInfo&lt;(class System.Collections.Generic.Stack`1&lt;!!TElement&gt;) TCollection, TElement&gt;(class System.Text.Json.JsonSerializerOptions options, class System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues`1&lt;!!TCollection&gt; collectionInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateStackInfo``2(System.Text.Json.JsonSerializerOptions,System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateStackInfo(Of TCollection As Stack(Of TElement), TElement As Stack(Of TElement)) (options As JsonSerializerOptions, collectionInfo As JsonCollectionInfoValues(Of TCollection)) As JsonTypeInfo(Of TCollection)" />
      <MemberSignature Language="F#" Value="static member CreateStackInfo : System.Text.Json.JsonSerializerOptions * System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;'Collection (requires 'Collection :&gt; System.Collections.Generic.Stack&lt;'Element&gt;)&gt; -&gt; System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Collection (requires 'Collection :&gt; System.Collections.Generic.Stack&lt;'Element&gt;)&gt; (requires 'Collection :&gt; System.Collections.Generic.Stack&lt;'Element&gt;)" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateStackInfo (options, collectionInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TCollection, typename TElement&gt;&#xA; where TCollection : System::Collections::Generic::Stack&lt;TElement&gt; static System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TCollection&gt; ^ CreateStackInfo(System::Text::Json::JsonSerializerOptions ^ options, System::Text::Json::Serialization::Metadata::JsonCollectionInfoValues&lt;TCollection&gt; ^ collectionInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TCollection&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TCollection">
          <Constraints>
            <BaseTypeName>System.Collections.Generic.Stack&lt;TElement&gt;</BaseTypeName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
        <Parameter Name="collectionInfo" Type="System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues&lt;TCollection&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TCollection">The generic definition of the type.</typeparam>
        <typeparam name="TElement">The generic definition of the element type.</typeparam>
        <param name="options">To be added.</param>
        <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
        <summary>Creates metadata for types assignable to <see cref="T:System.Collections.Generic.Stack`1" />.</summary>
        <returns>Serialization metadata for the given type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateValueInfo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;T&gt; CreateValueInfo&lt;T&gt; (System.Text.Json.JsonSerializerOptions options, System.Text.Json.Serialization.JsonConverter converter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!T&gt; CreateValueInfo&lt;T&gt;(class System.Text.Json.JsonSerializerOptions options, class System.Text.Json.Serialization.JsonConverter converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateValueInfo``1(System.Text.Json.JsonSerializerOptions,System.Text.Json.Serialization.JsonConverter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateValueInfo(Of T) (options As JsonSerializerOptions, converter As JsonConverter) As JsonTypeInfo(Of T)" />
      <MemberSignature Language="F#" Value="static member CreateValueInfo : System.Text.Json.JsonSerializerOptions * System.Text.Json.Serialization.JsonConverter -&gt; System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'T&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.CreateValueInfo (options, converter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;T&gt; ^ CreateValueInfo(System::Text::Json::JsonSerializerOptions ^ options, System::Text::Json::Serialization::JsonConverter ^ converter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
        <Parameter Name="converter" Type="System.Text.Json.Serialization.JsonConverter" />
      </Parameters>
      <Docs>
        <typeparam name="T">The generic type definition.</typeparam>
        <param name="options">To be added.</param>
        <param name="converter">To be added.</param>
        <summary>Creates metadata for a primitive or a type with a custom converter.</summary>
        <returns>A <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo`1" /> instance representing the type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DateTimeConverter">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.JsonConverter&lt;DateTime&gt; DateTimeConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Json.Serialization.JsonConverter`1&lt;valuetype System.DateTime&gt; DateTimeConverter" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Serialization.Metadata.JsonMetadataServices.DateTimeConverter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DateTimeConverter As JsonConverter(Of DateTime)" />
      <MemberSignature Language="F#" Value="member this.DateTimeConverter : System.Text.Json.Serialization.JsonConverter&lt;DateTime&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.DateTimeConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Json::Serialization::JsonConverter&lt;DateTime&gt; ^ DateTimeConverter { System::Text::Json::Serialization::JsonConverter&lt;DateTime&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter&lt;System.DateTime&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that converts <see cref="T:System.DateTime" /> values.</summary>
        <value>An <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <see cref="T:System.DateTime" /> values.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DateTimeOffsetConverter">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.JsonConverter&lt;DateTimeOffset&gt; DateTimeOffsetConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Json.Serialization.JsonConverter`1&lt;valuetype System.DateTimeOffset&gt; DateTimeOffsetConverter" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Serialization.Metadata.JsonMetadataServices.DateTimeOffsetConverter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DateTimeOffsetConverter As JsonConverter(Of DateTimeOffset)" />
      <MemberSignature Language="F#" Value="member this.DateTimeOffsetConverter : System.Text.Json.Serialization.JsonConverter&lt;DateTimeOffset&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.DateTimeOffsetConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Json::Serialization::JsonConverter&lt;DateTimeOffset&gt; ^ DateTimeOffsetConverter { System::Text::Json::Serialization::JsonConverter&lt;DateTimeOffset&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter&lt;System.DateTimeOffset&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that converts <see cref="T:System.DateTimeOffset" /> values.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DecimalConverter">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.JsonConverter&lt;decimal&gt; DecimalConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Json.Serialization.JsonConverter`1&lt;valuetype System.Decimal&gt; DecimalConverter" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Serialization.Metadata.JsonMetadataServices.DecimalConverter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DecimalConverter As JsonConverter(Of Decimal)" />
      <MemberSignature Language="F#" Value="member this.DecimalConverter : System.Text.Json.Serialization.JsonConverter&lt;decimal&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.DecimalConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Json::Serialization::JsonConverter&lt;System::Decimal&gt; ^ DecimalConverter { System::Text::Json::Serialization::JsonConverter&lt;System::Decimal&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that converts <see cref="T:System.Decimal" /> values.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DoubleConverter">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.JsonConverter&lt;double&gt; DoubleConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Json.Serialization.JsonConverter`1&lt;float64&gt; DoubleConverter" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Serialization.Metadata.JsonMetadataServices.DoubleConverter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DoubleConverter As JsonConverter(Of Double)" />
      <MemberSignature Language="F#" Value="member this.DoubleConverter : System.Text.Json.Serialization.JsonConverter&lt;double&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.DoubleConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Json::Serialization::JsonConverter&lt;double&gt; ^ DoubleConverter { System::Text::Json::Serialization::JsonConverter&lt;double&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that converts <see cref="T:System.Double" /> values.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumConverter&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.JsonConverter&lt;T&gt; GetEnumConverter&lt;T&gt; (System.Text.Json.JsonSerializerOptions options) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.Serialization.JsonConverter`1&lt;!!T&gt; GetEnumConverter&lt;struct .ctor (class System.ValueType) T&gt;(class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Serialization.Metadata.JsonMetadataServices.GetEnumConverter``1(System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnumConverter(Of T As Structure) (options As JsonSerializerOptions) As JsonConverter(Of T)" />
      <MemberSignature Language="F#" Value="static member GetEnumConverter : System.Text.Json.JsonSerializerOptions -&gt; System.Text.Json.Serialization.JsonConverter&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.GetEnumConverter options" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Text::Json::Serialization::JsonConverter&lt;T&gt; ^ GetEnumConverter(System::Text::Json::JsonSerializerOptions ^ options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
      </Parameters>
      <Docs>
        <typeparam name="T">The generic definition for the enum type.</typeparam>
        <param name="options">The <see cref="T:System.Text.Json.JsonSerializerOptions" /> to use for serialization and deserialization.</param>
        <summary>Creates a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <typeparamref name="T" /> values.</summary>
        <returns>A <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <typeparamref name="T" /> values.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNullableConverter&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.JsonConverter&lt;T?&gt; GetNullableConverter&lt;T&gt; (System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;T&gt; underlyingTypeInfo) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.Serialization.JsonConverter`1&lt;valuetype System.Nullable`1&lt;!!T&gt;&gt; GetNullableConverter&lt;struct .ctor (class System.ValueType) T&gt;(class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!T&gt; underlyingTypeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Serialization.Metadata.JsonMetadataServices.GetNullableConverter``1(System.Text.Json.Serialization.Metadata.JsonTypeInfo{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNullableConverter(Of T As Structure) (underlyingTypeInfo As JsonTypeInfo(Of T)) As JsonConverter(Of Nullable(Of T))" />
      <MemberSignature Language="F#" Value="static member GetNullableConverter : System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'T (requires 'T : struct)&gt; -&gt; System.Text.Json.Serialization.JsonConverter&lt;Nullable&lt;'T&gt;&gt; (requires 'T : struct)" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.GetNullableConverter underlyingTypeInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static System::Text::Json::Serialization::JsonConverter&lt;Nullable&lt;T&gt;&gt; ^ GetNullableConverter(System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;T&gt; ^ underlyingTypeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter&lt;System.Nullable&lt;T&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="underlyingTypeInfo" Type="System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">The generic definition for the underlying nullable type.</typeparam>
        <param name="underlyingTypeInfo">Serialization metadata for the underlying nullable type.</param>
        <summary>Creates a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <typeparamref name="T??" /> values.</summary>
        <returns>A <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <typeparamref name="T??" /> values</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUnsupportedTypeConverter&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.JsonConverter&lt;T&gt; GetUnsupportedTypeConverter&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.Serialization.JsonConverter`1&lt;!!T&gt; GetUnsupportedTypeConverter&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.Serialization.Metadata.JsonMetadataServices.GetUnsupportedTypeConverter``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetUnsupportedTypeConverter(Of T) () As JsonConverter(Of T)" />
      <MemberSignature Language="F#" Value="static member GetUnsupportedTypeConverter : unit -&gt; System.Text.Json.Serialization.JsonConverter&lt;'T&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.GetUnsupportedTypeConverter " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Text::Json::Serialization::JsonConverter&lt;T&gt; ^ GetUnsupportedTypeConverter();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">The generic definition for the type.</typeparam>
        <summary>Gets a type converter that throws a <see cref="T:System.NotSupportedException" />.</summary>
        <returns>A <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that throws <see cref="T:System.NotSupportedException" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GuidConverter">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.JsonConverter&lt;Guid&gt; GuidConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Json.Serialization.JsonConverter`1&lt;valuetype System.Guid&gt; GuidConverter" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Serialization.Metadata.JsonMetadataServices.GuidConverter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property GuidConverter As JsonConverter(Of Guid)" />
      <MemberSignature Language="F#" Value="member this.GuidConverter : System.Text.Json.Serialization.JsonConverter&lt;Guid&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.GuidConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Json::Serialization::JsonConverter&lt;Guid&gt; ^ GuidConverter { System::Text::Json::Serialization::JsonConverter&lt;Guid&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter&lt;System.Guid&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that converts <see cref="T:System.Guid" /> values.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Int16Converter">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.JsonConverter&lt;short&gt; Int16Converter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Json.Serialization.JsonConverter`1&lt;int16&gt; Int16Converter" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Serialization.Metadata.JsonMetadataServices.Int16Converter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Int16Converter As JsonConverter(Of Short)" />
      <MemberSignature Language="F#" Value="member this.Int16Converter : System.Text.Json.Serialization.JsonConverter&lt;int16&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.Int16Converter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Json::Serialization::JsonConverter&lt;short&gt; ^ Int16Converter { System::Text::Json::Serialization::JsonConverter&lt;short&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter&lt;System.Int16&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that converts <see cref="T:System.Int16" /> values.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Int32Converter">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.JsonConverter&lt;int&gt; Int32Converter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Json.Serialization.JsonConverter`1&lt;int32&gt; Int32Converter" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Serialization.Metadata.JsonMetadataServices.Int32Converter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Int32Converter As JsonConverter(Of Integer)" />
      <MemberSignature Language="F#" Value="member this.Int32Converter : System.Text.Json.Serialization.JsonConverter&lt;int&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.Int32Converter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Json::Serialization::JsonConverter&lt;int&gt; ^ Int32Converter { System::Text::Json::Serialization::JsonConverter&lt;int&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that converts <see cref="T:System.Int32" /> values.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Int64Converter">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.JsonConverter&lt;long&gt; Int64Converter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Json.Serialization.JsonConverter`1&lt;int64&gt; Int64Converter" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Serialization.Metadata.JsonMetadataServices.Int64Converter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Int64Converter As JsonConverter(Of Long)" />
      <MemberSignature Language="F#" Value="member this.Int64Converter : System.Text.Json.Serialization.JsonConverter&lt;int64&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.Int64Converter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Json::Serialization::JsonConverter&lt;long&gt; ^ Int64Converter { System::Text::Json::Serialization::JsonConverter&lt;long&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that converts <see cref="T:System.Int64" /> values.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="JsonArrayConverter">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.JsonConverter&lt;System.Text.Json.Nodes.JsonArray&gt; JsonArrayConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Json.Serialization.JsonConverter`1&lt;class System.Text.Json.Nodes.JsonArray&gt; JsonArrayConverter" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Serialization.Metadata.JsonMetadataServices.JsonArrayConverter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property JsonArrayConverter As JsonConverter(Of JsonArray)" />
      <MemberSignature Language="F#" Value="member this.JsonArrayConverter : System.Text.Json.Serialization.JsonConverter&lt;System.Text.Json.Nodes.JsonArray&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.JsonArrayConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Json::Serialization::JsonConverter&lt;System::Text::Json::Nodes::JsonArray ^&gt; ^ JsonArrayConverter { System::Text::Json::Serialization::JsonConverter&lt;System::Text::Json::Nodes::JsonArray ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter&lt;System.Text.Json.Nodes.JsonArray&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that converts <see cref="T:System.Json.JsonArray" /> values.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="JsonElementConverter">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.JsonConverter&lt;System.Text.Json.JsonElement&gt; JsonElementConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Json.Serialization.JsonConverter`1&lt;valuetype System.Text.Json.JsonElement&gt; JsonElementConverter" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Serialization.Metadata.JsonMetadataServices.JsonElementConverter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property JsonElementConverter As JsonConverter(Of JsonElement)" />
      <MemberSignature Language="F#" Value="member this.JsonElementConverter : System.Text.Json.Serialization.JsonConverter&lt;System.Text.Json.JsonElement&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.JsonElementConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Json::Serialization::JsonConverter&lt;System::Text::Json::JsonElement&gt; ^ JsonElementConverter { System::Text::Json::Serialization::JsonConverter&lt;System::Text::Json::JsonElement&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter&lt;System.Text.Json.JsonElement&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a JSON converter that converts <see cref="T:System.Text.Json.JsonElement" /> values.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="JsonNodeConverter">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.JsonConverter&lt;System.Text.Json.Nodes.JsonNode&gt; JsonNodeConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Json.Serialization.JsonConverter`1&lt;class System.Text.Json.Nodes.JsonNode&gt; JsonNodeConverter" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Serialization.Metadata.JsonMetadataServices.JsonNodeConverter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property JsonNodeConverter As JsonConverter(Of JsonNode)" />
      <MemberSignature Language="F#" Value="member this.JsonNodeConverter : System.Text.Json.Serialization.JsonConverter&lt;System.Text.Json.Nodes.JsonNode&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.JsonNodeConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Json::Serialization::JsonConverter&lt;System::Text::Json::Nodes::JsonNode ^&gt; ^ JsonNodeConverter { System::Text::Json::Serialization::JsonConverter&lt;System::Text::Json::Nodes::JsonNode ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter&lt;System.Text.Json.Nodes.JsonNode&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that converts <see cref="T:System.Text.Json.Nodes.JsonNode" /> values.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="JsonObjectConverter">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.JsonConverter&lt;System.Text.Json.Nodes.JsonObject&gt; JsonObjectConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Json.Serialization.JsonConverter`1&lt;class System.Text.Json.Nodes.JsonObject&gt; JsonObjectConverter" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Serialization.Metadata.JsonMetadataServices.JsonObjectConverter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property JsonObjectConverter As JsonConverter(Of JsonObject)" />
      <MemberSignature Language="F#" Value="member this.JsonObjectConverter : System.Text.Json.Serialization.JsonConverter&lt;System.Text.Json.Nodes.JsonObject&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.JsonObjectConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Json::Serialization::JsonConverter&lt;System::Text::Json::Nodes::JsonObject ^&gt; ^ JsonObjectConverter { System::Text::Json::Serialization::JsonConverter&lt;System::Text::Json::Nodes::JsonObject ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter&lt;System.Text.Json.Nodes.JsonObject&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that converts <see cref="T:System.Json.JsonObject" /> values.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="JsonValueConverter">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.JsonConverter&lt;System.Text.Json.Nodes.JsonValue&gt; JsonValueConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Json.Serialization.JsonConverter`1&lt;class System.Text.Json.Nodes.JsonValue&gt; JsonValueConverter" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Serialization.Metadata.JsonMetadataServices.JsonValueConverter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property JsonValueConverter As JsonConverter(Of JsonValue)" />
      <MemberSignature Language="F#" Value="member this.JsonValueConverter : System.Text.Json.Serialization.JsonConverter&lt;System.Text.Json.Nodes.JsonValue&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.JsonValueConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Json::Serialization::JsonConverter&lt;System::Text::Json::Nodes::JsonValue ^&gt; ^ JsonValueConverter { System::Text::Json::Serialization::JsonConverter&lt;System::Text::Json::Nodes::JsonValue ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter&lt;System.Text.Json.Nodes.JsonValue&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that converts <see cref="T:System.Json.JsonValue" /> values.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ObjectConverter">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.JsonConverter&lt;object&gt; ObjectConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Json.Serialization.JsonConverter`1&lt;object&gt; ObjectConverter" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Serialization.Metadata.JsonMetadataServices.ObjectConverter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ObjectConverter As JsonConverter(Of Object)" />
      <MemberSignature Language="F#" Value="member this.ObjectConverter : System.Text.Json.Serialization.JsonConverter&lt;obj&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.ObjectConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Json::Serialization::JsonConverter&lt;System::Object ^&gt; ^ ObjectConverter { System::Text::Json::Serialization::JsonConverter&lt;System::Object ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that converts <see cref="T:System.Object" /> values.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SByteConverter">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.JsonConverter&lt;sbyte&gt; SByteConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Json.Serialization.JsonConverter`1&lt;int8&gt; SByteConverter" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Serialization.Metadata.JsonMetadataServices.SByteConverter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SByteConverter As JsonConverter(Of SByte)" />
      <MemberSignature Language="F#" Value="member this.SByteConverter : System.Text.Json.Serialization.JsonConverter&lt;sbyte&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.SByteConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Json::Serialization::JsonConverter&lt;System::SByte&gt; ^ SByteConverter { System::Text::Json::Serialization::JsonConverter&lt;System::SByte&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter&lt;System.SByte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that converts <see cref="T:System.SByte" /> values.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SingleConverter">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.JsonConverter&lt;float&gt; SingleConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Json.Serialization.JsonConverter`1&lt;float32&gt; SingleConverter" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Serialization.Metadata.JsonMetadataServices.SingleConverter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SingleConverter As JsonConverter(Of Single)" />
      <MemberSignature Language="F#" Value="member this.SingleConverter : System.Text.Json.Serialization.JsonConverter&lt;single&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.SingleConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Json::Serialization::JsonConverter&lt;float&gt; ^ SingleConverter { System::Text::Json::Serialization::JsonConverter&lt;float&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that converts <see cref="T:System.Single" /> values.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StringConverter">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.JsonConverter&lt;string&gt; StringConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Json.Serialization.JsonConverter`1&lt;string&gt; StringConverter" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Serialization.Metadata.JsonMetadataServices.StringConverter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StringConverter As JsonConverter(Of String)" />
      <MemberSignature Language="F#" Value="member this.StringConverter : System.Text.Json.Serialization.JsonConverter&lt;string&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.StringConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Json::Serialization::JsonConverter&lt;System::String ^&gt; ^ StringConverter { System::Text::Json::Serialization::JsonConverter&lt;System::String ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that converts <see cref="T:System.String" /> values.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TimeSpanConverter">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.JsonConverter&lt;TimeSpan&gt; TimeSpanConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Json.Serialization.JsonConverter`1&lt;valuetype System.TimeSpan&gt; TimeSpanConverter" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Serialization.Metadata.JsonMetadataServices.TimeSpanConverter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TimeSpanConverter As JsonConverter(Of TimeSpan)" />
      <MemberSignature Language="F#" Value="member this.TimeSpanConverter : System.Text.Json.Serialization.JsonConverter&lt;TimeSpan&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.TimeSpanConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Json::Serialization::JsonConverter&lt;TimeSpan&gt; ^ TimeSpanConverter { System::Text::Json::Serialization::JsonConverter&lt;TimeSpan&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter&lt;System.TimeSpan&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a JSON converter that converts <see cref="T:System.TimeSpan" /> values.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UInt16Converter">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.JsonConverter&lt;ushort&gt; UInt16Converter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Json.Serialization.JsonConverter`1&lt;unsigned int16&gt; UInt16Converter" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Serialization.Metadata.JsonMetadataServices.UInt16Converter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UInt16Converter As JsonConverter(Of UShort)" />
      <MemberSignature Language="F#" Value="member this.UInt16Converter : System.Text.Json.Serialization.JsonConverter&lt;uint16&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.UInt16Converter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Json::Serialization::JsonConverter&lt;System::UInt16&gt; ^ UInt16Converter { System::Text::Json::Serialization::JsonConverter&lt;System::UInt16&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter&lt;System.UInt16&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that converts <see cref="T:System.UInt16" /> values.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UInt32Converter">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.JsonConverter&lt;uint&gt; UInt32Converter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Json.Serialization.JsonConverter`1&lt;unsigned int32&gt; UInt32Converter" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Serialization.Metadata.JsonMetadataServices.UInt32Converter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UInt32Converter As JsonConverter(Of UInteger)" />
      <MemberSignature Language="F#" Value="member this.UInt32Converter : System.Text.Json.Serialization.JsonConverter&lt;uint32&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.UInt32Converter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Json::Serialization::JsonConverter&lt;System::UInt32&gt; ^ UInt32Converter { System::Text::Json::Serialization::JsonConverter&lt;System::UInt32&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter&lt;System.UInt32&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that converts <see cref="T:System.UInt32" /> values.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UInt64Converter">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.JsonConverter&lt;ulong&gt; UInt64Converter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Json.Serialization.JsonConverter`1&lt;unsigned int64&gt; UInt64Converter" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Serialization.Metadata.JsonMetadataServices.UInt64Converter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UInt64Converter As JsonConverter(Of ULong)" />
      <MemberSignature Language="F#" Value="member this.UInt64Converter : System.Text.Json.Serialization.JsonConverter&lt;uint64&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.UInt64Converter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Json::Serialization::JsonConverter&lt;System::UInt64&gt; ^ UInt64Converter { System::Text::Json::Serialization::JsonConverter&lt;System::UInt64&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter&lt;System.UInt64&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that converts <see cref="T:System.UInt64" /> values.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriConverter">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.JsonConverter&lt;Uri&gt; UriConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Json.Serialization.JsonConverter`1&lt;class System.Uri&gt; UriConverter" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Serialization.Metadata.JsonMetadataServices.UriConverter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UriConverter As JsonConverter(Of Uri)" />
      <MemberSignature Language="F#" Value="member this.UriConverter : System.Text.Json.Serialization.JsonConverter&lt;Uri&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.UriConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Json::Serialization::JsonConverter&lt;Uri ^&gt; ^ UriConverter { System::Text::Json::Serialization::JsonConverter&lt;Uri ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter&lt;System.Uri&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that converts <see cref="T:System.Uri" /> values.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VersionConverter">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.JsonConverter&lt;Version&gt; VersionConverter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Json.Serialization.JsonConverter`1&lt;class System.Version&gt; VersionConverter" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Serialization.Metadata.JsonMetadataServices.VersionConverter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property VersionConverter As JsonConverter(Of Version)" />
      <MemberSignature Language="F#" Value="member this.VersionConverter : System.Text.Json.Serialization.JsonConverter&lt;Version&gt;" Usage="System.Text.Json.Serialization.Metadata.JsonMetadataServices.VersionConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Json::Serialization::JsonConverter&lt;Version ^&gt; ^ VersionConverter { System::Text::Json::Serialization::JsonConverter&lt;Version ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter&lt;System.Version&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an object that converts <see cref="T:System.Version" /> values.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is for use by the output of the System.Text.Json source generator and should not be called directly.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
