<Type Name="NegotiateAuthentication" FullName="System.Net.Security.NegotiateAuthentication">
  <TypeSignature Language="C#" Value="public sealed class NegotiateAuthentication : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit NegotiateAuthentication extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Security.NegotiateAuthentication" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class NegotiateAuthentication&#xA;Implements IDisposable" />
  <TypeSignature Language="F#" Value="type NegotiateAuthentication = class&#xA;    interface IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class NegotiateAuthentication sealed : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Security</AssemblyName>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>9.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Represents a stateful authentication exchange that uses the Negotiate, NTLM, or Kerberos security protocols to authenticate the client or server, in client-server communication.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NegotiateAuthentication (System.Net.Security.NegotiateAuthenticationClientOptions clientOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Security.NegotiateAuthenticationClientOptions clientOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateAuthentication.#ctor(System.Net.Security.NegotiateAuthenticationClientOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (clientOptions As NegotiateAuthenticationClientOptions)" />
      <MemberSignature Language="F#" Value="new System.Net.Security.NegotiateAuthentication : System.Net.Security.NegotiateAuthenticationClientOptions -&gt; System.Net.Security.NegotiateAuthentication" Usage="new System.Net.Security.NegotiateAuthentication clientOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NegotiateAuthentication(System::Net::Security::NegotiateAuthenticationClientOptions ^ clientOptions);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="clientOptions" Type="System.Net.Security.NegotiateAuthenticationClientOptions" />
      </Parameters>
      <Docs>
        <param name="clientOptions">The property bag for the authentication options.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Net.Security.NegotiateAuthentication" /> for client-side authentication session.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NegotiateAuthentication (System.Net.Security.NegotiateAuthenticationServerOptions serverOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Security.NegotiateAuthenticationServerOptions serverOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateAuthentication.#ctor(System.Net.Security.NegotiateAuthenticationServerOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (serverOptions As NegotiateAuthenticationServerOptions)" />
      <MemberSignature Language="F#" Value="new System.Net.Security.NegotiateAuthentication : System.Net.Security.NegotiateAuthenticationServerOptions -&gt; System.Net.Security.NegotiateAuthentication" Usage="new System.Net.Security.NegotiateAuthentication serverOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NegotiateAuthentication(System::Net::Security::NegotiateAuthenticationServerOptions ^ serverOptions);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="serverOptions" Type="System.Net.Security.NegotiateAuthenticationServerOptions" />
      </Parameters>
      <Docs>
        <param name="serverOptions">The property bag for the authentication options.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Net.Security.NegotiateAuthentication" /> for server-side authentication session.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ComputeIntegrityCheck">
      <MemberSignature Language="C#" Value="public void ComputeIntegrityCheck (ReadOnlySpan&lt;byte&gt; message, System.Buffers.IBufferWriter&lt;byte&gt; signatureWriter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ComputeIntegrityCheck(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; message, class System.Buffers.IBufferWriter`1&lt;unsigned int8&gt; signatureWriter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateAuthentication.ComputeIntegrityCheck(System.ReadOnlySpan{System.Byte},System.Buffers.IBufferWriter{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ComputeIntegrityCheck (message As ReadOnlySpan(Of Byte), signatureWriter As IBufferWriter(Of Byte))" />
      <MemberSignature Language="F#" Value="member this.ComputeIntegrityCheck : ReadOnlySpan&lt;byte&gt; * System.Buffers.IBufferWriter&lt;byte&gt; -&gt; unit" Usage="negotiateAuthentication.ComputeIntegrityCheck (message, signatureWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ComputeIntegrityCheck(ReadOnlySpan&lt;System::Byte&gt; message, System::Buffers::IBufferWriter&lt;System::Byte&gt; ^ signatureWriter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-9.0" />
        <Parameter Name="signatureWriter" Type="System.Buffers.IBufferWriter&lt;System.Byte&gt;" Index="1" FrameworkAlternate="net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="message">Input message for MIC calculation.</param>
        <param name="signatureWriter">Buffer writer where the MIC is written.</param>
        <summary>Computes the integrity check of a given message.</summary>
        <remarks>
          <p>Implements the GSSAPI GetMIC operation.</p>
          <p>The method modifies the internal state and may update sequence numbers depending on the selected algorithm. Two successive invocations thus don't produce the same result and it's important to carefully pair GetMIC and VerifyMIC calls on the both sides of the authenticated session.</p>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Authentication failed or has not occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateAuthentication.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="negotiateAuthentication.Dispose " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Releases the unmanaged resources used by the <see cref="T:System.Net.Security.NegotiateAuthentication" /> and optionally releases the managed resources.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOutgoingBlob">
      <MemberSignature Language="C#" Value="public byte[]? GetOutgoingBlob (ReadOnlySpan&lt;byte&gt; incomingBlob, out System.Net.Security.NegotiateAuthenticationStatusCode statusCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetOutgoingBlob(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; incomingBlob, [out] valuetype System.Net.Security.NegotiateAuthenticationStatusCode&amp; statusCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateAuthentication.GetOutgoingBlob(System.ReadOnlySpan{System.Byte},System.Net.Security.NegotiateAuthenticationStatusCode@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOutgoingBlob (incomingBlob As ReadOnlySpan(Of Byte), ByRef statusCode As NegotiateAuthenticationStatusCode) As Byte()" />
      <MemberSignature Language="F#" Value="member this.GetOutgoingBlob : ReadOnlySpan&lt;byte&gt; * NegotiateAuthenticationStatusCode -&gt; byte[]" Usage="negotiateAuthentication.GetOutgoingBlob (incomingBlob, statusCode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetOutgoingBlob(ReadOnlySpan&lt;System::Byte&gt; incomingBlob, [Runtime::InteropServices::Out] System::Net::Security::NegotiateAuthenticationStatusCode % statusCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="incomingBlob" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="statusCode" Type="System.Net.Security.NegotiateAuthenticationStatusCode" RefType="out" />
      </Parameters>
      <Docs>
        <param name="incomingBlob">Incoming authentication token, or empty value when initiating the authentication exchange.</param>
        <param name="statusCode">Status code returned by the authentication provider.</param>
        <summary>Evaluates an authentication token sent by the other party and returns a token in response.</summary>
        <returns>An outgoing authentication token to be sent to the other party.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

When initiating the authentication exchange, one of the parties starts with an empty incomingBlob parameter.

Successful authentication returns either the <xref:System.Net.Security.NegotiateAuthenticationStatusCode.Completed>
             or <xref:System.Net.Security.NegotiateAuthenticationStatusCode.ContinueNeeded> status code.
             Any other status code indicates an unrecoverable error.

When <xref:System.Net.Security.NegotiateAuthenticationStatusCode.ContinueNeeded> is returned, the
             return value is an authentication token to be transported to the other party.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOutgoingBlob">
      <MemberSignature Language="C#" Value="public string? GetOutgoingBlob (string? incomingBlob, out System.Net.Security.NegotiateAuthenticationStatusCode statusCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetOutgoingBlob(string incomingBlob, [out] valuetype System.Net.Security.NegotiateAuthenticationStatusCode&amp; statusCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateAuthentication.GetOutgoingBlob(System.String,System.Net.Security.NegotiateAuthenticationStatusCode@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOutgoingBlob (incomingBlob As String, ByRef statusCode As NegotiateAuthenticationStatusCode) As String" />
      <MemberSignature Language="F#" Value="member this.GetOutgoingBlob : string * NegotiateAuthenticationStatusCode -&gt; string" Usage="negotiateAuthentication.GetOutgoingBlob (incomingBlob, statusCode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetOutgoingBlob(System::String ^ incomingBlob, [Runtime::InteropServices::Out] System::Net::Security::NegotiateAuthenticationStatusCode % statusCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="incomingBlob" Type="System.String" />
        <Parameter Name="statusCode" Type="System.Net.Security.NegotiateAuthenticationStatusCode" RefType="out" />
      </Parameters>
      <Docs>
        <param name="incomingBlob">Incoming authentication token, or empty value when initiating the authentication exchange. Encoded as base64.</param>
        <param name="statusCode">Status code returned by the authentication provider.</param>
        <summary>Evaluates an authentication token sent by the other party and returns a token in response.</summary>
        <returns>An outgoing authentication token to be sent to the other party, encoded as base64.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

When initiating the authentication exchange, one of the parties starts
             with an empty incomingBlob parameter.

Successful authentication returns either the <xref:System.Net.Security.NegotiateAuthenticationStatusCode.Completed>
             or <xref:System.Net.Security.NegotiateAuthenticationStatusCode.ContinueNeeded> status code.
             Any other status code indicates an unrecoverable error.

When <xref:System.Net.Security.NegotiateAuthenticationStatusCode.ContinueNeeded> is returned, the
             return value is an authentication token to be transported to the other party.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImpersonationLevel">
      <MemberSignature Language="C#" Value="public System.Security.Principal.TokenImpersonationLevel ImpersonationLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Principal.TokenImpersonationLevel ImpersonationLevel" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateAuthentication.ImpersonationLevel" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ImpersonationLevel As TokenImpersonationLevel" />
      <MemberSignature Language="F#" Value="member this.ImpersonationLevel : System.Security.Principal.TokenImpersonationLevel" Usage="System.Net.Security.NegotiateAuthentication.ImpersonationLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::TokenImpersonationLevel ImpersonationLevel { System::Security::Principal::TokenImpersonationLevel get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Principal.TokenImpersonationLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates the negotiated level of impersonation.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAuthenticated">
      <MemberSignature Language="C#" Value="public bool IsAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateAuthentication.IsAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAuthenticated As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsAuthenticated : bool" Usage="System.Net.Security.NegotiateAuthentication.IsAuthenticated" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAuthenticated { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether authentication was successfully completed and the session was established.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEncrypted">
      <MemberSignature Language="C#" Value="public bool IsEncrypted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEncrypted" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateAuthentication.IsEncrypted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEncrypted As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsEncrypted : bool" Usage="System.Net.Security.NegotiateAuthentication.IsEncrypted" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEncrypted { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether data encryption was negotiated.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMutuallyAuthenticated">
      <MemberSignature Language="C#" Value="public bool IsMutuallyAuthenticated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMutuallyAuthenticated" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateAuthentication.IsMutuallyAuthenticated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMutuallyAuthenticated As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsMutuallyAuthenticated : bool" Usage="System.Net.Security.NegotiateAuthentication.IsMutuallyAuthenticated" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMutuallyAuthenticated { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether both server and client have been authenticated.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsServer">
      <MemberSignature Language="C#" Value="public bool IsServer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsServer" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateAuthentication.IsServer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsServer As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsServer : bool" Usage="System.Net.Security.NegotiateAuthentication.IsServer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsServer { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the local side of the authentication is representing the server.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSigned">
      <MemberSignature Language="C#" Value="public bool IsSigned { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSigned" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateAuthentication.IsSigned" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSigned As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsSigned : bool" Usage="System.Net.Security.NegotiateAuthentication.IsSigned" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSigned { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether data signing was negotiated.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Package">
      <MemberSignature Language="C#" Value="public string Package { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Package" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateAuthentication.Package" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Package As String" />
      <MemberSignature Language="F#" Value="member this.Package : string" Usage="System.Net.Security.NegotiateAuthentication.Package" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Package { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[get: System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the name of the negotiated authentication package.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The negotiated authentication package is only available when the session
             authentication was finished (see <xref:System.Net.Security.NegotiateAuthentication.IsAuthenticated>). For
             unfinished authentication sessions, the value is undefined and usually
             returns the initial authentication package name specified in
             <xref:System.Net.Security.NegotiateAuthenticationClientOptions.Package> or
             <xref:System.Net.Security.NegotiateAuthenticationServerOptions.Package>.

If the Negotiate package was used for authentication, the value of this
             property will be Kerberos, NTLM, or any other specific protocol that was
             negotiated between both sides of the authentication.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectionLevel">
      <MemberSignature Language="C#" Value="public System.Net.Security.ProtectionLevel ProtectionLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Security.ProtectionLevel ProtectionLevel" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateAuthentication.ProtectionLevel" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtectionLevel As ProtectionLevel" />
      <MemberSignature Language="F#" Value="member this.ProtectionLevel : System.Net.Security.ProtectionLevel" Usage="System.Net.Security.NegotiateAuthentication.ProtectionLevel" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Security::ProtectionLevel ProtectionLevel { System::Net::Security::ProtectionLevel get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.ProtectionLevel</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indicates the negotiated level of protection.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The negotiated level of protection is only available when the session
            authentication was finished (see <xref:System.Net.Security.NegotiateAuthentication.IsAuthenticated>). The
            protection level can be higher than the initially requested protection
            level specified by <xref:System.Net.Security.NegotiateAuthenticationClientOptions.RequiredProtectionLevel> or
            <xref:System.Net.Security.NegotiateAuthenticationServerOptions.RequiredProtectionLevel>.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoteIdentity">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IIdentity RemoteIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IIdentity RemoteIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateAuthentication.RemoteIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteIdentity As IIdentity" />
      <MemberSignature Language="F#" Value="member this.RemoteIdentity : System.Security.Principal.IIdentity" Usage="System.Net.Security.NegotiateAuthentication.RemoteIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Principal::IIdentity ^ RemoteIdentity { System::Security::Principal::IIdentity ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[get: System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets information about the identity of the remote party.</summary>
        <value>An <see cref="T:System.Security.Principal.IIdentity" /> object that describes the identity of the remote endpoint.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Authentication failed or has not occurred.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">System error occurred when trying to retrieve the identity.</exception>
      </Docs>
    </Member>
    <Member MemberName="TargetName">
      <MemberSignature Language="C#" Value="public string? TargetName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TargetName" />
      <MemberSignature Language="DocId" Value="P:System.Net.Security.NegotiateAuthentication.TargetName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TargetName As String" />
      <MemberSignature Language="F#" Value="member this.TargetName : string" Usage="System.Net.Security.NegotiateAuthentication.TargetName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TargetName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[get: System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the target name (service principal name) of the server.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For the server side of the authentication, the property returns the target name
             specified by the client after successful authentication (see <xref:System.Net.Security.NegotiateAuthentication.IsAuthenticated>).

For the client side of the authentication, the property returns the target name
             specified in <xref:System.Net.Security.NegotiateAuthenticationClientOptions.TargetName>.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unwrap">
      <MemberSignature Language="C#" Value="public System.Net.Security.NegotiateAuthenticationStatusCode Unwrap (ReadOnlySpan&lt;byte&gt; input, System.Buffers.IBufferWriter&lt;byte&gt; outputWriter, out bool wasEncrypted);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Security.NegotiateAuthenticationStatusCode Unwrap(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; input, class System.Buffers.IBufferWriter`1&lt;unsigned int8&gt; outputWriter, [out] bool&amp; wasEncrypted) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateAuthentication.Unwrap(System.ReadOnlySpan{System.Byte},System.Buffers.IBufferWriter{System.Byte},System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Unwrap (input As ReadOnlySpan(Of Byte), outputWriter As IBufferWriter(Of Byte), ByRef wasEncrypted As Boolean) As NegotiateAuthenticationStatusCode" />
      <MemberSignature Language="F#" Value="member this.Unwrap : ReadOnlySpan&lt;byte&gt; * System.Buffers.IBufferWriter&lt;byte&gt; * bool -&gt; System.Net.Security.NegotiateAuthenticationStatusCode" Usage="negotiateAuthentication.Unwrap (input, outputWriter, wasEncrypted)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Security::NegotiateAuthenticationStatusCode Unwrap(ReadOnlySpan&lt;System::Byte&gt; input, System::Buffers::IBufferWriter&lt;System::Byte&gt; ^ outputWriter, [Runtime::InteropServices::Out] bool % wasEncrypted);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.NegotiateAuthenticationStatusCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="outputWriter" Type="System.Buffers.IBufferWriter&lt;System.Byte&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="wasEncrypted" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Input message to be unwrapped.</param>
        <param name="outputWriter">Buffer writter where the unwrapped message is written.</param>
        <param name="wasEncrypted">When this method returns, contains a value that indicates whether the wrapped message had encryption applied.</param>
        <summary>Unwraps an input message with signature or encryption applied by the other party.</summary>
        <returns>
          <ul>
            <li>
              <see cref="F:System.Net.Security.NegotiateAuthenticationStatusCode.Completed" /> on success.</li>
            <li>
              <see cref="F:System.Net.Security.NegotiateAuthenticationStatusCode.MessageAltered" /> if the message signature was invalid.</li>
            <li>
              <see cref="F:System.Net.Security.NegotiateAuthenticationStatusCode.InvalidToken" /> if the wrapped message was in invalid format.</li>
            <li>Other <see cref="T:System.Net.Security.NegotiateAuthenticationStatusCode" /> values on failure.</li>
          </ul>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Authentication failed or has not occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnwrapInPlace">
      <MemberSignature Language="C#" Value="public System.Net.Security.NegotiateAuthenticationStatusCode UnwrapInPlace (Span&lt;byte&gt; input, out int unwrappedOffset, out int unwrappedLength, out bool wasEncrypted);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Security.NegotiateAuthenticationStatusCode UnwrapInPlace(valuetype System.Span`1&lt;unsigned int8&gt; input, [out] int32&amp; unwrappedOffset, [out] int32&amp; unwrappedLength, [out] bool&amp; wasEncrypted) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateAuthentication.UnwrapInPlace(System.Span{System.Byte},System.Int32@,System.Int32@,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Function UnwrapInPlace (input As Span(Of Byte), ByRef unwrappedOffset As Integer, ByRef unwrappedLength As Integer, ByRef wasEncrypted As Boolean) As NegotiateAuthenticationStatusCode" />
      <MemberSignature Language="F#" Value="member this.UnwrapInPlace : Span&lt;byte&gt; * int * int * bool -&gt; System.Net.Security.NegotiateAuthenticationStatusCode" Usage="negotiateAuthentication.UnwrapInPlace (input, unwrappedOffset, unwrappedLength, wasEncrypted)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Security::NegotiateAuthenticationStatusCode UnwrapInPlace(Span&lt;System::Byte&gt; input, [Runtime::InteropServices::Out] int % unwrappedOffset, [Runtime::InteropServices::Out] int % unwrappedLength, [Runtime::InteropServices::Out] bool % wasEncrypted);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.NegotiateAuthenticationStatusCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="unwrappedOffset" Type="System.Int32" RefType="out" />
        <Parameter Name="unwrappedLength" Type="System.Int32" RefType="out" />
        <Parameter Name="wasEncrypted" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">The input message to be unwrapped. When this method returns, contains the decoded data.</param>
        <param name="unwrappedOffset">When this method returns, contains the offset in the input buffer where the unwrapped message was written.</param>
        <param name="unwrappedLength">When this method returns, contains the length of the unwrapped message.</param>
        <param name="wasEncrypted">When this method returns, contains a value that specifies whether the wrapped message had encryption applied.</param>
        <summary>Unwraps, in place, an input message with signature or encryption applied by the other party.</summary>
        <returns>
          <ul>
            <li>
              <see cref="F:System.Net.Security.NegotiateAuthenticationStatusCode.Completed" /> on success.</li>
            <li>
              <see cref="F:System.Net.Security.NegotiateAuthenticationStatusCode.MessageAltered" /> if the message signature was invalid.</li>
            <li>
              <see cref="F:System.Net.Security.NegotiateAuthenticationStatusCode.InvalidToken" /> if the wrapped message was in invalid format.</li>
            <li>Other <see cref="T:System.Net.Security.NegotiateAuthenticationStatusCode" /> values on failure.</li>
          </ul>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Authentication failed or has not occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="VerifyIntegrityCheck">
      <MemberSignature Language="C#" Value="public bool VerifyIntegrityCheck (ReadOnlySpan&lt;byte&gt; message, ReadOnlySpan&lt;byte&gt; signature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyIntegrityCheck(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; message, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; signature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateAuthentication.VerifyIntegrityCheck(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function VerifyIntegrityCheck (message As ReadOnlySpan(Of Byte), signature As ReadOnlySpan(Of Byte)) As Boolean" />
      <MemberSignature Language="F#" Value="member this.VerifyIntegrityCheck : ReadOnlySpan&lt;byte&gt; * ReadOnlySpan&lt;byte&gt; -&gt; bool" Usage="negotiateAuthentication.VerifyIntegrityCheck (message, signature)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool VerifyIntegrityCheck(ReadOnlySpan&lt;System::Byte&gt; message, ReadOnlySpan&lt;System::Byte&gt; signature);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-9.0" />
        <Parameter Name="signature" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="1" FrameworkAlternate="net-9.0" />
      </Parameters>
      <Docs>
        <param name="message">Input message for MIC calculation.</param>
        <param name="signature">MIC to be verified.</param>
        <summary>Verifies the message integrity check of a given message.</summary>
        <returns>
          <see langword="true" /> if the MIC is successfully verified, otherwise <see langword="false" />.</returns>
        <remarks>
          <p>Implements the GSSAPI VerifyMIC operation.</p>
          <p>The method modifies the internal state and may update sequence numbers depending on the selected algorithm. Two successive invocations thus don't produce the same result and it's important to carefully pair GetMIC and VerifyMIC calls on the both sides of the authenticated session.</p>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Authentication failed or has not occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Wrap">
      <MemberSignature Language="C#" Value="public System.Net.Security.NegotiateAuthenticationStatusCode Wrap (ReadOnlySpan&lt;byte&gt; input, System.Buffers.IBufferWriter&lt;byte&gt; outputWriter, bool requestEncryption, out bool isEncrypted);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Security.NegotiateAuthenticationStatusCode Wrap(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; input, class System.Buffers.IBufferWriter`1&lt;unsigned int8&gt; outputWriter, bool requestEncryption, [out] bool&amp; isEncrypted) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Security.NegotiateAuthentication.Wrap(System.ReadOnlySpan{System.Byte},System.Buffers.IBufferWriter{System.Byte},System.Boolean,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Wrap (input As ReadOnlySpan(Of Byte), outputWriter As IBufferWriter(Of Byte), requestEncryption As Boolean, ByRef isEncrypted As Boolean) As NegotiateAuthenticationStatusCode" />
      <MemberSignature Language="F#" Value="member this.Wrap : ReadOnlySpan&lt;byte&gt; * System.Buffers.IBufferWriter&lt;byte&gt; * bool * bool -&gt; System.Net.Security.NegotiateAuthenticationStatusCode" Usage="negotiateAuthentication.Wrap (input, outputWriter, requestEncryption, isEncrypted)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Security::NegotiateAuthenticationStatusCode Wrap(ReadOnlySpan&lt;System::Byte&gt; input, System::Buffers::IBufferWriter&lt;System::Byte&gt; ^ outputWriter, bool requestEncryption, [Runtime::InteropServices::Out] bool % isEncrypted);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Security</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.NegotiateAuthenticationStatusCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="outputWriter" Type="System.Buffers.IBufferWriter&lt;System.Byte&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="requestEncryption" Type="System.Boolean" />
        <Parameter Name="isEncrypted" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="input">Input message to be wrapped.</param>
        <param name="outputWriter">Buffer writter where the wrapped message is written.</param>
        <param name="requestEncryption">
          <see langword="true" /> to request encryption; otherwise, <see langword="false" />.</param>
        <param name="isEncrypted">When this method returns, contains a value that indicates whether encryption was applied in the wrapping.</param>
        <summary>Wraps an input message with a signature and optionally an encryption.</summary>
        <returns>
          <see cref="F:System.Net.Security.NegotiateAuthenticationStatusCode.Completed" /> on success, or other <see cref="T:System.Net.Security.NegotiateAuthenticationStatusCode" /> values on failure.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Like the [GSS_Wrap](https://datatracker.ietf.org/doc/html/rfc2743#page-65) API, the authentication protocol implementation may choose to override the requested value in the requestEncryption parameter. This may result in either downgrade or upgrade of the protection level.

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Authentication failed or has not occurred.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
