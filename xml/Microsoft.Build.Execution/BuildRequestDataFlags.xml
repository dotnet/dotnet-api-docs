<Type Name="BuildRequestDataFlags" FullName="Microsoft.Build.Execution.BuildRequestDataFlags">
  <TypeSignature Language="C#" Value="public enum BuildRequestDataFlags" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed BuildRequestDataFlags extends System.Enum" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Build.Execution.BuildRequestDataFlags" />
  <TypeSignature Language="VB.NET" Value="Public Enum BuildRequestDataFlags" />
  <TypeSignature Language="C++ CLI" Value="public enum class BuildRequestDataFlags" />
  <TypeSignature Language="F#" Value="type BuildRequestDataFlags = " />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Build</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>15.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Attributes>
    <Attribute>
      <AttributeName>System.Flags</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
            Flags providing additional control over the build request
            </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks 

The `IgnoreExistingProjectState` flag is provided only for those cases where the client knows that the new build request does not depend on the project state generated by a previous request. Setting this flag can provide a performance boost in the case of incompatible node affinities, because MSBuild would otherwise have to serialize the project state from one node to another. Serializing the project state can be expensive, depending on the amount of data the project has previously generated.  
  
The `IgnoreExistingProjectState` flag has no effect on target results, so if a previous request has built a target, the new request will not rebuild the target. Additionally, none of the project state mutations which occurred as a consequence of previously building that target will be reapplied.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ClearCachesAfterBuild">
      <MemberSignature Language="C#" Value="ClearCachesAfterBuild" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Execution.BuildRequestDataFlags ClearCachesAfterBuild = int32(8)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Execution.BuildRequestDataFlags.ClearCachesAfterBuild" />
      <MemberSignature Language="VB.NET" Value="ClearCachesAfterBuild" />
      <MemberSignature Language="C++ CLI" Value="ClearCachesAfterBuild" />
      <MemberSignature Language="F#" Value="ClearCachesAfterBuild = 8" Usage="Microsoft.Build.Execution.BuildRequestDataFlags.ClearCachesAfterBuild" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.BuildRequestDataFlags</ReturnType>
      </ReturnValue>
      <MemberValue>8</MemberValue>
      <Docs>
        <summary>
            When this flag is present, caches including the <see cref="T:Microsoft.Build.Evaluation.ProjectRootElementCache" /> will be cleared
            after the build request completes.  This is used when the build request is known to modify a lot of
            state such as restoring packages or generating parts of the import graph.
            </summary>
      </Docs>
    </Member>
    <Member MemberName="IgnoreExistingProjectState">
      <MemberSignature Language="C#" Value="IgnoreExistingProjectState" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Execution.BuildRequestDataFlags IgnoreExistingProjectState = int32(4)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Execution.BuildRequestDataFlags.IgnoreExistingProjectState" />
      <MemberSignature Language="VB.NET" Value="IgnoreExistingProjectState" />
      <MemberSignature Language="C++ CLI" Value="IgnoreExistingProjectState" />
      <MemberSignature Language="F#" Value="IgnoreExistingProjectState = 4" Usage="Microsoft.Build.Execution.BuildRequestDataFlags.IgnoreExistingProjectState" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.BuildRequestDataFlags</ReturnType>
      </ReturnValue>
      <MemberValue>4</MemberValue>
      <Docs>
        <summary>
            When this flag is present and the project has previously been built on a node whose affinity is
            incompatible with the affinity this request requires, we will ignore the project state (but not
            target results) that were previously generated.
            </summary>
        <remarks>
            This usually is not desired behavior.  It is only provided for those cases where the client
            knows that the new build request does not depend on project state generated by a previous request.  Setting
            this flag can provide a performance boost in the case of incompatible node affinities, as MSBuild would
            otherwise have to serialize the project state from one node to another, which may be 
            expensive depending on how much data the project previously generated.
            
            This flag has no effect on target results, so if a previous request already built a target, the new 
            request will not re-build that target (nor will any of the project state mutations which previously
            occurred as a consequence of building that target be re-applied.)
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreMissingEmptyAndInvalidImports">
      <MemberSignature Language="C#" Value="IgnoreMissingEmptyAndInvalidImports" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Execution.BuildRequestDataFlags IgnoreMissingEmptyAndInvalidImports = int32(64)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Execution.BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports" />
      <MemberSignature Language="VB.NET" Value="IgnoreMissingEmptyAndInvalidImports" />
      <MemberSignature Language="C++ CLI" Value="IgnoreMissingEmptyAndInvalidImports" />
      <MemberSignature Language="F#" Value="IgnoreMissingEmptyAndInvalidImports = 64" Usage="Microsoft.Build.Execution.BuildRequestDataFlags.IgnoreMissingEmptyAndInvalidImports" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.BuildRequestDataFlags</ReturnType>
      </ReturnValue>
      <MemberValue>64</MemberValue>
      <Docs>
        <summary>
            When this flag is present, projects loaded during build will ignore missing imports (<see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.IgnoreMissingImports" /> and <see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.IgnoreInvalidImports" />).
            This is especially useful during a restore since some imports might come from packages that haven't been restored yet.
            </summary>
      </Docs>
    </Member>
    <Member MemberName="None">
      <MemberSignature Language="C#" Value="None" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Execution.BuildRequestDataFlags None = int32(0)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Execution.BuildRequestDataFlags.None" />
      <MemberSignature Language="VB.NET" Value="None" />
      <MemberSignature Language="C++ CLI" Value="None" />
      <MemberSignature Language="F#" Value="None = 0" Usage="Microsoft.Build.Execution.BuildRequestDataFlags.None" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.BuildRequestDataFlags</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>
            No flags.
            </summary>
      </Docs>
    </Member>
    <Member MemberName="ProvideProjectStateAfterBuild">
      <MemberSignature Language="C#" Value="ProvideProjectStateAfterBuild" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Execution.BuildRequestDataFlags ProvideProjectStateAfterBuild = int32(2)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild" />
      <MemberSignature Language="VB.NET" Value="ProvideProjectStateAfterBuild" />
      <MemberSignature Language="C++ CLI" Value="ProvideProjectStateAfterBuild" />
      <MemberSignature Language="F#" Value="ProvideProjectStateAfterBuild = 2" Usage="Microsoft.Build.Execution.BuildRequestDataFlags.ProvideProjectStateAfterBuild" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.BuildRequestDataFlags</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary>
            When this flag is present, the <see cref="T:Microsoft.Build.Execution.BuildResult" /> issued in response to this request will
            include <see cref="P:Microsoft.Build.Execution.BuildResult.ProjectStateAfterBuild" />.
            </summary>
      </Docs>
    </Member>
    <Member MemberName="ProvideSubsetOfStateAfterBuild">
      <MemberSignature Language="C#" Value="ProvideSubsetOfStateAfterBuild" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Execution.BuildRequestDataFlags ProvideSubsetOfStateAfterBuild = int32(32)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Execution.BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild" />
      <MemberSignature Language="VB.NET" Value="ProvideSubsetOfStateAfterBuild" />
      <MemberSignature Language="C++ CLI" Value="ProvideSubsetOfStateAfterBuild" />
      <MemberSignature Language="F#" Value="ProvideSubsetOfStateAfterBuild = 32" Usage="Microsoft.Build.Execution.BuildRequestDataFlags.ProvideSubsetOfStateAfterBuild" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.BuildRequestDataFlags</ReturnType>
      </ReturnValue>
      <MemberValue>32</MemberValue>
      <Docs>
        <summary>
            When this flag is present, the <see cref="T:Microsoft.Build.Execution.BuildResult" /> issued in response to this request will
            include a <see cref="P:Microsoft.Build.Execution.BuildResult.ProjectStateAfterBuild" /> that includes ONLY the
            explicitly-requested properties, items, and metadata.
            </summary>
      </Docs>
    </Member>
    <Member MemberName="ReplaceExistingProjectInstance">
      <MemberSignature Language="C#" Value="ReplaceExistingProjectInstance" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Execution.BuildRequestDataFlags ReplaceExistingProjectInstance = int32(1)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Execution.BuildRequestDataFlags.ReplaceExistingProjectInstance" />
      <MemberSignature Language="VB.NET" Value="ReplaceExistingProjectInstance" />
      <MemberSignature Language="C++ CLI" Value="ReplaceExistingProjectInstance" />
      <MemberSignature Language="F#" Value="ReplaceExistingProjectInstance = 1" Usage="Microsoft.Build.Execution.BuildRequestDataFlags.ReplaceExistingProjectInstance" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.BuildRequestDataFlags</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary>
            When this flag is present, the existing ProjectInstance in the build will be replaced by this one.
            </summary>
      </Docs>
    </Member>
    <Member MemberName="SkipNonexistentTargets">
      <MemberSignature Language="C#" Value="SkipNonexistentTargets" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype Microsoft.Build.Execution.BuildRequestDataFlags SkipNonexistentTargets = int32(16)" />
      <MemberSignature Language="DocId" Value="F:Microsoft.Build.Execution.BuildRequestDataFlags.SkipNonexistentTargets" />
      <MemberSignature Language="VB.NET" Value="SkipNonexistentTargets" />
      <MemberSignature Language="C++ CLI" Value="SkipNonexistentTargets" />
      <MemberSignature Language="F#" Value="SkipNonexistentTargets = 16" Usage="Microsoft.Build.Execution.BuildRequestDataFlags.SkipNonexistentTargets" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.BuildRequestDataFlags</ReturnType>
      </ReturnValue>
      <MemberValue>16</MemberValue>
      <Docs>
        <summary>
            When this flag is present, the top level target(s) in the build request will be skipped if those targets
            are not defined in the Project to build. This only applies to this build request (if another target calls
            the "missing target" at any other point this will still result in an error).
            </summary>
      </Docs>
    </Member>
  </Members>
</Type>
