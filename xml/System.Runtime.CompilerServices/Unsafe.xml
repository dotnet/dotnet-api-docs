<Type Name="Unsafe" FullName="System.Runtime.CompilerServices.Unsafe">
  <TypeSignature Language="C#" Value="public static class Unsafe" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Unsafe extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.CompilerServices.Unsafe" />
  <TypeSignature Language="VB.NET" Value="Public Class Unsafe" />
  <TypeSignature Language="F#" Value="type Unsafe = class" />
  <TypeSignature Language="C++ CLI" Value="public ref class Unsafe abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.4.0</AssemblyVersion>
    <AssemblyVersion>4.0.4.1</AssemblyVersion>
    <AssemblyVersion>4.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.6.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="System.Runtime.CompilerServices.Unsafe" FromVersion="7.0.0.0" To="System.Runtime" ToVersion="7.0.0.0" FrameworkAlternate="net-7.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Contains generic, low-level functionality for manipulating managed and unmanaged pointers.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks

> [!WARNING]
> This type is intended for advanced pointer manipulation scenarios. Callers are assumed to be familiar with [ECMA-335](https://www.ecma-international.org/publications-and-standards/standards/ecma-335/), Sec. II.14.4 and III.1.1.5, and with the [ECMA-335 CLI Specification Addendum](https://github.com/dotnet/runtime/blob/main/docs/design/specs/Ecma-335-Augments.md).
>
> Most APIs on this type do not perform any argument checking or validation. Incorrect use of these APIs could corrupt process memory or destabilize the .NET runtime.

This type is typically used by low-level library authors who want to write high-performance code and are willing to suppress .NET's typical type safety checks to meet their performance goals.

Consider the following example, which reverses the elements within a `Span<T>`.

> [!NOTE]
> These examples exist simply for demonstration purposes. In real-world applications, developers should instead use helper functions like <xref:System.MemoryExtensions.Reverse%2A>, which are better optimized than even these examples.

```cs
// A safe, verifiable way to reverse a Span<T>.
static void Reverse<T>(Span<T> span)
{
  while (span.Length > 1)
  {
    T firstElement = span[0];
    T lastElement = span[^1];
    span[0] = lastElement;
    span[^1] = firstElement;
    span = span[1..^1];
  }
}
```

This method is fully type-safe and the .NET runtime may insert bounds checks to help enforce safety. However, low-level library authors may want to suppress .NET's normal safety checks in order to improve the performance of their own code. Such developers would typically rely on static analysis tools or their own code reviews to help enforce correctness. The `Unsafe` APIs allow a developer to rewrite this code using unverifiable constructs, as the following example shows.

```cs
// A correct but unverifiable way to reverse a Span<T>.
static void Reverse<T>(Span<T> span)
{
  if (span.Length > 1)
  {
    ref T refLeft = ref MemoryMarshal.GetReference(span);
    ref T refRight = ref Unsafe.Add(ref refLeft, span.Length - 1);
    do
    {
      T leftElement = refLeft;
      T rightElement = refRight;
      refLeft = rightElement;
      refRight = leftElement;
      refLeft = ref Unsafe.Add(ref refLeft, 1);
      refRight = ref Unsafe.Subtract(ref refRight, 1);
    } while (Unsafe.IsAddressLessThan(ref refLeft, ref refRight));
  }
}
```

Since the `Unsafe` APIs suppress typical type-safety validation, it is up to callers to ensure that the code they're writing is legal. Misuse of these APIs could cause access violations, create GC holes, produce incorrect codegen, or otherwise induce undefined and destabilizing behaviors within the .NET runtime.

]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void* Add&lt;T&gt; (void* source, int elementOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void* Add&lt;T&gt;(void* source, int32 elementOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.Add``1(System.Void*,System.Int32)" />
      <MemberSignature Language="F#" Value="static member Add : nativeptr&lt;unit&gt; * int -&gt; nativeptr&lt;unit&gt;" Usage="System.Runtime.CompilerServices.Unsafe.Add (source, elementOffset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void* Add(void* source, int elementOffset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void*</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Void*" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="elementOffset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type whose size will be used as a scale factor for <paramref name="elementOffset" />.</typeparam>
        <param name="source">The unmanaged pointer to add the offset to.</param>
        <param name="elementOffset">The offset to add.</param>
        <summary>Adds an element offset to the given unmanaged pointer.</summary>
        <returns>A new unmanaged pointer that reflects the addition of the specified offset to the source pointer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The `elementOffset` parameter is the number of `T`-sized elements (not bytes) to add to the `source` pointer. For example, given a source pointer _ptr_, the call `Unsafe.Add<int>(ptr, 20)` will return a new pointer whose address points 80 bytes (= 20 elements \* 4 bytes per element) beyond _ptr_.

If `elementOffset` is a calculated value rather than a hardcoded literal, callers should consider the possibility of integer overflow. For example, in the call `Unsafe.Add<int>(ptr, a * b)`, the caller must ensure the intermediate value `a * b` does not overflow the bounds of `Int32`.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref T Add&lt;T&gt; (ref T source, int elementOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Add&lt;T&gt;(!!T&amp; source, int32 elementOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.Add``1(``0@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add(Of T) (ByRef source As T, elementOffset As Integer) As T" />
      <MemberSignature Language="F#" Value="static member Add : 'T * int -&gt; 'T" Usage="System.Runtime.CompilerServices.Unsafe.Add (source, elementOffset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T % Add(T % source, int elementOffset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="T" RefType="ref" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-1.1;netcore-3.0;netcore-3.1" />
        <Parameter Name="elementOffset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-1.1;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">The elemental type of the managed pointer.</typeparam>
        <param name="source">The managed pointer to add the offset to.</param>
        <param name="elementOffset">The offset to add.</param>
        <summary>Adds an offset to the given managed pointer.</summary>
        <returns>A new managed pointer that reflects the addition of the specified offset to the source pointer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The `elementOffset` parameter is the number of `T`-sized elements (not bytes) to add to the `source` pointer. For example, given a source pointer _ptr_ of type `ref int`, the call `Unsafe.Add<int>(ref ptr, 20)` will return a new pointer whose address points 80 bytes (= 20 elements \* 4 bytes per element) beyond _ptr_.

If `elementOffset` is a calculated value rather than a hardcoded literal, callers should consider the possibility of integer overflow. For example, in the call `Unsafe.Add<int>(ref ptr, a * b)`, the caller must ensure the intermediate value `a * b` does not overflow the bounds of `Int32`.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref T Add&lt;T&gt; (ref T source, IntPtr elementOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Add&lt;T&gt;(!!T&amp; source, native int elementOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.Add``1(``0@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add(Of T) (ByRef source As T, elementOffset As IntPtr) As T" />
      <MemberSignature Language="F#" Value="static member Add : 'T * nativeint -&gt; 'T" Usage="System.Runtime.CompilerServices.Unsafe.Add (source, elementOffset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T % Add(T % source, IntPtr elementOffset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="T" RefType="ref" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="elementOffset" Type="System.IntPtr" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">The elemental type of the managed pointer.</typeparam>
        <param name="source">The managed pointer to add the offset to.</param>
        <param name="elementOffset">The offset to add.</param>
        <summary>Adds an element offset to the given managed pointer.</summary>
        <returns>A new managed pointer that reflects the addition of the specified offset to the source pointer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The `elementOffset` parameter is the number of `T`-sized elements (not bytes) to add to the `source` pointer. For example, given a source pointer _ptr_ of type `ref int`, the call `Unsafe.Add<int>(ref ptr, (nint)20)` will return a new pointer whose address points 80 bytes (= 20 elements \* 4 bytes per element) beyond _ptr_.

If `elementOffset` is a calculated value rather than a hardcoded literal, callers should consider the possibility of integer overflow. For example, in the call `Unsafe.Add<int>(ref ptr, a * b)`, the caller must ensure the intermediate value `a * b` does not overflow the bounds of `IntPtr`.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref T Add&lt;T&gt; (ref T source, nuint elementOffset);" FrameworkAlternate="net-6.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Add&lt;T&gt;(!!T&amp; source, native unsigned int elementOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.Add``1(``0@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add(Of T) (ByRef source As T, elementOffset As UIntPtr) As T" />
      <MemberSignature Language="F#" Value="static member Add : 'T * unativeint -&gt; 'T" Usage="System.Runtime.CompilerServices.Unsafe.Add (source, elementOffset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T % Add(T % source, UIntPtr elementOffset);" />
      <MemberSignature Language="C#" Value="public static ref T Add&lt;T&gt; (ref T source, UIntPtr elementOffset);" FrameworkAlternate="net-7.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="T" RefType="ref" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="elementOffset" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-6.0;net-7.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-6.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.NativeInteger]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NativeInteger&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The elemental type of the managed pointer.</typeparam>
        <param name="source">The managed pointer to add the offset to.</param>
        <param name="elementOffset">The offset to add.</param>
        <summary>Adds an element offset to the given managed pointer.</summary>
        <returns>A new managed pointer that reflects the addition of the specified offset to the source pointer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The `elementOffset` parameter is the number of `T`-sized elements (not bytes) to add to the `source` pointer. For example, given a source pointer _ptr_ of type `ref int`, the call `Unsafe.Add<int>(ref ptr, (nuint)20)` will return a new pointer whose address points 80 bytes (= 20 elements \* 4 bytes per element) beyond _ptr_.

If `elementOffset` is a calculated value rather than a hardcoded literal, callers should consider the possibility of integer overflow. For example, in the call `Unsafe.Add<int>(ref ptr, a * b)`, the caller must ensure the intermediate value `a * b` does not overflow the bounds of `UIntPtr`.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddByteOffset&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref T AddByteOffset&lt;T&gt; (ref T source, IntPtr byteOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T AddByteOffset&lt;T&gt;(!!T&amp; source, native int byteOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.AddByteOffset``1(``0@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddByteOffset(Of T) (ByRef source As T, byteOffset As IntPtr) As T" />
      <MemberSignature Language="F#" Value="static member AddByteOffset : 'T * nativeint -&gt; 'T" Usage="System.Runtime.CompilerServices.Unsafe.AddByteOffset (source, byteOffset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T % AddByteOffset(T % source, IntPtr byteOffset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="T" RefType="ref" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="byteOffset" Type="System.IntPtr" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">The elemental type of the managed pointer.</typeparam>
        <param name="source">The managed pointer to add the offset to.</param>
        <param name="byteOffset">The offset to add.</param>
        <summary>Adds a byte offset to the given managed pointer.</summary>
        <returns>A new managed pointer that reflects the addition of the specified byte offset to the source pointer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The `byteOffset` parameter is the number of bytes to add to the `source` pointer. For example, given a source pointer _ptr_ of type `ref int`, the call `Unsafe.AddByteOffset<int>(ref ptr, 20)` will return a new pointer whose address points 20 bytes beyond _ptr_.

If `byteOffset` is a calculated value rather than a hardcoded literal, callers should consider the possibility of integer overflow. For example, in the call `Unsafe.AddByteOffset<int>(ref ptr, a * b)`, the caller must ensure the intermediate value `a * b` does not overflow the bounds of `IntPtr`.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddByteOffset&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref T AddByteOffset&lt;T&gt; (ref T source, nuint byteOffset);" FrameworkAlternate="net-6.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T AddByteOffset&lt;T&gt;(!!T&amp; source, native unsigned int byteOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.AddByteOffset``1(``0@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AddByteOffset(Of T) (ByRef source As T, byteOffset As UIntPtr) As T" />
      <MemberSignature Language="F#" Value="static member AddByteOffset : 'T * unativeint -&gt; 'T" Usage="System.Runtime.CompilerServices.Unsafe.AddByteOffset (source, byteOffset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T % AddByteOffset(T % source, UIntPtr byteOffset);" />
      <MemberSignature Language="C#" Value="public static ref T AddByteOffset&lt;T&gt; (ref T source, UIntPtr byteOffset);" FrameworkAlternate="net-7.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="T" RefType="ref" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="byteOffset" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-6.0;net-7.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-6.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.NativeInteger]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NativeInteger&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The elemental type of the managed pointer.</typeparam>
        <param name="source">The managed pointer to add the offset to.</param>
        <param name="byteOffset">The offset to add.</param>
        <summary>Adds a byte offset to the given managed pointer.</summary>
        <returns>A new managed pointer that reflects the addition of the specified byte offset to the source pointer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The `byteOffset` parameter is the number of bytes to add to the `source` pointer. For example, given a source pointer _ptr_ of type `ref int`, the call `Unsafe.AddByteOffset<int>(ref ptr, (nuint)20)` will return a new pointer whose address points 20 bytes beyond _ptr_.

If `byteOffset` is a calculated value rather than a hardcoded literal, callers should consider the possibility of integer overflow. For example, in the call `Unsafe.AddByteOffset<int>(ref ptr, a * b)`, the caller must ensure the intermediate value `a * b` does not overflow the bounds of `UIntPtr`.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreSame&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool AreSame&lt;T&gt; (ref T left, ref T right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool AreSame&lt;T&gt;(!!T&amp; left, !!T&amp; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.AreSame``1(``0@,``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AreSame(Of T) (ByRef left As T, ByRef right As T) As Boolean" />
      <MemberSignature Language="F#" Value="static member AreSame : 'T * 'T -&gt; bool" Usage="System.Runtime.CompilerServices.Unsafe.AreSame (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool AreSame(T % left, T % right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="T" RefType="ref" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-1.1;netcore-3.0;netcore-3.1">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0;net-6.0;net-7.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.AllowNull]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.AllowNull&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="T" RefType="ref" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-1.1;netcore-3.0;netcore-3.1">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0;net-6.0;net-7.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.AllowNull]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.AllowNull&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The elemental type of the managed pointers.</typeparam>
        <param name="left">The first managed pointer to compare.</param>
        <param name="right">The second managed pointer to compare.</param>
        <summary>Determines whether the specified managed pointers point to the same location.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> point to the same location; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="As&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T As&lt;T&gt; (object o) where T : class;" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;netcore-1.0;netcore-1.1;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T As&lt;class T&gt;(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.As``1(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function As(Of T As Class) (o As Object) As T" />
      <MemberSignature Language="F#" Value="static member As : obj -&gt; 'T (requires 'T : null)" Usage="System.Runtime.CompilerServices.Unsafe.As o" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T As(System::Object ^ o);" />
      <MemberSignature Language="C#" Value="public static T? As&lt;T&gt; (object? o) where T : class;" FrameworkAlternate="net-5.0;net-6.0;net-7.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type which the object will be cast to.</typeparam>
        <param name="o">The object to cast.</param>
        <summary>Casts the given object to the specified type.</summary>
        <returns>The original object, cast to the given type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is used to cast an object to the given type, suppressing the runtime's normal type safety checks. It is the caller's responsibility to ensure that the cast is legal. No `InvalidCastException` will be thrown.

The behavior of `Unsafe.As<T>(o)` is only well-defined if the typical "safe" casting operation `(T)o` would have succeeded. Use of this API to circumvent casts that would otherwise have failed is unsupported and could result in runtime instability.

To help enforce correct usage, developers might consider using a standard cast or a debug-only assert in their code, as shown in the following examples.

```cs
void ReinterpretCastAndUse_Sample1(object o)
{
  // Assume that we know through some other means that 'o' is a string,
  // and we want our library's debug builds to verify this.
  // One way to do this is through a standard-style cast.
  // A standard-style cast will throw InvalidCastException at runtime if the cast fails.
  // n.b. Casts of null objects to reference types will succeed.

#if DEBUG
  string s = (string)o;
#else
  string s = Unsafe.As<string>(o);
#endif

  DoSomethingWith(s);
}

void ReinterpretCastAndUse_Sample2(object o)
{
  // Another way to check this is through a debug-only assert.
  // Failed assertions will trigger attached debuggers or terminate the application immediately.
  // Calls to Debug.Assert are removed from release builds.

  Debug.Assert(o is null or string, "Unsafe.As call below is illegal!");
  string s = Unsafe.As<string>(o);

  DoSomethingWith(s);
}
```

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="As&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static ref TTo As&lt;TFrom,TTo&gt; (ref TFrom source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TTo As&lt;TFrom, TTo&gt;(!!TFrom&amp; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.As``2(``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function As(Of TFrom, TTo) (ByRef source As TFrom) As TTo" />
      <MemberSignature Language="F#" Value="static member As : 'From -&gt; 'o" Usage="System.Runtime.CompilerServices.Unsafe.As source" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; static TTo % As(TFrom % source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>TTo</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom" />
        <TypeParameter Name="TTo" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="TFrom" RefType="ref" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-1.1;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="TFrom">The type of managed pointer to reinterpret.</typeparam>
        <typeparam name="TTo">The desired type of the managed pointer.</typeparam>
        <param name="source">The managed pointer to reinterpret.</param>
        <summary>Reinterprets the given managed pointer as a new managed pointer to a value of type <typeparamref name="TTo" />.</summary>
        <returns>A managed pointer to a value of type <typeparamref name="TTo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is conceptually similar to C++'s `reinterpret_cast<>`. It is the caller's responsibility to ensure that the cast is legal. No runtime check will be performed.

Only the managed pointer is reinterpreted. The referenced value itself will remain unchanged. Consider the following example.

```cs
int[] intArray = new int[] { 0x1234_5678 }; // a 1-element array
ref int refToInt32 = ref intArray[0]; // managed pointer to first Int32 in array
ref short refToInt16 = ref Unsafe.As<int, short>(ref refToInt32); // reinterpret as managed pointer to Int16
Console.WriteLine($"0x{refToInt16:x4}");
```

The output of this program depends on the endianness of the current machine. On big-endian architectures, this code outputs `0x1234`. On little-endian architectures, this code outputs `0x5678`.

When casting a managed pointer from a narrower type to a wider type, the caller must ensure that dereferencing the pointer will not incur an out-of-bounds access. The caller is also responsible for ensuring that the resulting pointer is properly aligned for the referenced type. For more information on alignment assumptions, see [ECMA-335](https://www.ecma-international.org/publications-and-standards/standards/ecma-335/), Sec. I.12.6.2 ("Alignment").

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsPointer&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void* AsPointer&lt;T&gt; (ref T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void* AsPointer&lt;T&gt;(!!T&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.AsPointer``1(``0@)" />
      <MemberSignature Language="F#" Value="static member AsPointer : 'T -&gt; nativeptr&lt;unit&gt;" Usage="System.Runtime.CompilerServices.Unsafe.AsPointer value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void* AsPointer(T % value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void*</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" RefType="ref" />
      </Parameters>
      <Docs>
        <typeparam name="T">The elemental type of the managed pointer.</typeparam>
        <param name="value">The managed pointer to convert.</param>
        <summary>Converts a managed pointer into an unmanaged pointer.</summary>
        <returns>An unmanaged pointer corresponding to the original source pointer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Unmanaged pointers are not tracked by the .NET garbage collector. If the original managed pointer points within a GC-managed object, the caller must ensure that the source object is pinned. If the source object is not pinned and the GC relocates the object, dereferencing the unmanaged pointer could cause an access violation.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsRef&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref T AsRef&lt;T&gt; (void* source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T AsRef&lt;T&gt;(void* source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.AsRef``1(System.Void*)" />
      <MemberSignature Language="F#" Value="static member AsRef : nativeptr&lt;unit&gt; -&gt; 'T" Usage="System.Runtime.CompilerServices.Unsafe.AsRef source" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T % AsRef(void* source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Void*" />
      </Parameters>
      <Docs>
        <typeparam name="T">The elemental type of the managed pointer.</typeparam>
        <param name="source">The unmanaged pointer to convert.</param>
        <summary>Converts an unmanaged pointer into a managed pointer to a value of type <typeparamref name="T" />.</summary>
        <returns>A managed pointer to a value of type <typeparamref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The caller is responsible for ensuring that the resulting managed pointer is properly aligned for the referenced type. For more information on alignment requirements, see [ECMA-335](https://www.ecma-international.org/publications-and-standards/standards/ecma-335/), Sec. I.12.6.2 ("Alignment").

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsRef&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref T AsRef&lt;T&gt; (in T source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T AsRef&lt;T&gt;([in]!!T&amp; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.AsRef``1(``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsRef(Of T) (ByRef source As T) As T" />
      <MemberSignature Language="F#" Value="static member AsRef : 'T -&gt; 'T" Usage="System.Runtime.CompilerServices.Unsafe.AsRef source" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T % AsRef(T % source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="T" RefType="ref" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0;net-6.0;net-7.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The underlying type of the reference.</typeparam>
        <param name="source">The read-only reference to reinterpret.</param>
        <summary>Reinterprets the given read-only reference as a mutable reference.</summary>
        <returns>A mutable reference to a value of type <typeparamref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API is conceptually similar to C++'s `const_cast<>`. It is the caller's responsibility to ensure that no data is written to the referenced location. The runtime contains internal logic predicated on the assumption that readonly references truly are immutable, and callers who violate this invariant may trigger undefined behavior within the runtime.

`AsRef` is typically used for passing a readonly reference into methods like <xref:System.Runtime.CompilerServices.Unsafe.Add%2A>, which accept mutable managed pointers as arguments. Consider the following example.

```cs
int ComputeSumOfElements(ref int refToFirstElement, nint numElements)
{
  int sum = 0;
  for (nint i = 0; i < numElements; i++)
  {
    sum += Unsafe.Add(ref refToFirstElement, i);
  }
}
```

If the input parameter is `ref readonly int refToFirstElement` instead of `ref int refToFirstElement`, the previous example will not compile, since readonly references cannot be used as arguments to `Add`. Instead, `AsRef` can be used to remove the immutability constraint and allow compilation to succeed, as shown in the following example.

```cs
int ComputeSumOfElements(ref readonly int refToFirstElement, nint numElements)
{
  int sum = 0;
  for (nint i = 0; i < numElements; i++)
  {
    sum += Unsafe.Add(ref Unsafe.AsRef(ref refToFirstElement), i);
  }
}
```

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ByteOffset&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static IntPtr ByteOffset&lt;T&gt; (ref T origin, ref T target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ByteOffset&lt;T&gt;(!!T&amp; origin, !!T&amp; target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.ByteOffset``1(``0@,``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ByteOffset(Of T) (ByRef origin As T, ByRef target As T) As IntPtr" />
      <MemberSignature Language="F#" Value="static member ByteOffset : 'T * 'T -&gt; nativeint" Usage="System.Runtime.CompilerServices.Unsafe.ByteOffset (origin, target)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static IntPtr ByteOffset(T % origin, T % target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="origin" Type="T" RefType="ref" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0;net-6.0;net-7.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.AllowNull]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.AllowNull&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="target" Type="T" RefType="ref" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0;net-6.0;net-7.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.AllowNull]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.AllowNull&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The elemental type of the managed pointers.</typeparam>
        <param name="origin">The managed pointer to the origin.</param>
        <param name="target">The managed pointer to the target.</param>
        <summary>Determines the byte offset from origin to target from the given managed pointers.</summary>
        <returns>The byte offset from origin to target, that is, <paramref name="target" /> - <paramref name="origin" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The return value of this method is a moment-in-time result. If `origin` and `target` each reference different objects in GC-managed address space, the GC could relocate items between calls, causing the result of this method to change.

The return value is guaranteed stable if `origin` and `target` point to the same managed object.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Copy&lt;T&gt; (void* destination, ref T source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy&lt;T&gt;(void* destination, !!T&amp; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.Copy``1(System.Void*,``0@)" />
      <MemberSignature Language="F#" Value="static member Copy : nativeptr&lt;unit&gt; * 'T -&gt; unit" Usage="System.Runtime.CompilerServices.Unsafe.Copy (destination, source)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Copy(void* destination, T % source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="destination" Type="System.Void*" />
        <Parameter Name="source" Type="T" RefType="ref" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of value to copy.</typeparam>
        <param name="destination">The location to copy to.</param>
        <param name="source">A reference to the value to copy.</param>
        <summary>Copies a value of type <typeparamref name="T" /> to the given location.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Both `destination` and `source` are assumed to be properly aligned for pointers to data of type `T`. For more information on alignment assumptions, see [ECMA-335](https://www.ecma-international.org/publications-and-standards/standards/ecma-335/), Sec. I.12.6.2 ("Alignment").

This method is roughly equivalent to the following code.

```cs
static void Copy<T>(void* destination, ref T source)
{
  T data = source; // dereference source
  *(T*)destination = data;
}
```

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Copy&lt;T&gt; (ref T destination, void* source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy&lt;T&gt;(!!T&amp; destination, void* source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.Copy``1(``0@,System.Void*)" />
      <MemberSignature Language="F#" Value="static member Copy : 'T * nativeptr&lt;unit&gt; -&gt; unit" Usage="System.Runtime.CompilerServices.Unsafe.Copy (destination, source)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Copy(T % destination, void* source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="destination" Type="T" RefType="ref" />
        <Parameter Name="source" Type="System.Void*" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of value to copy.</typeparam>
        <param name="destination">The location to copy to.</param>
        <param name="source">A pointer to the value to copy.</param>
        <summary>Copies a value of type <typeparamref name="T" /> to the given location.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Both `destination` and `source` are assumed to be properly aligned for pointers to data of type `T`. For more information on alignment assumptions, see [ECMA-335](https://www.ecma-international.org/publications-and-standards/standards/ecma-335/), Sec. I.12.6.2 ("Alignment").

This method is roughly equivalent to the following code.

```cs
static void Copy<T>(ref T destination, void* source)
{
  T data = *(T*)source; // reinterpret cast source as T* and dereference
  destination = data;
}
```

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyBlock">
      <MemberSignature Language="C#" Value="public static void CopyBlock (ref byte destination, ref byte source, uint byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyBlock(unsigned int8&amp; destination, unsigned int8&amp; source, unsigned int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.CopyBlock(System.Byte@,System.Byte@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyBlock (ByRef destination As Byte, ByRef source As Byte, byteCount As UInteger)" />
      <MemberSignature Language="F#" Value="static member CopyBlock : byte * byte * uint32 -&gt; unit" Usage="System.Runtime.CompilerServices.Unsafe.CopyBlock (destination, source, byteCount)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyBlock(System::Byte % destination, System::Byte % source, System::UInt32 byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Byte" RefType="ref" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="source" Type="System.Byte" RefType="ref" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="byteCount" Type="System.UInt32" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="destination">The managed pointer corresponding to the destination address to copy to.</param>
        <param name="source">The managed pointer corresponding to the source address to copy from.</param>
        <param name="byteCount">The number of bytes to copy.</param>
        <summary>Copies bytes from the source address to the destination address.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API corresponds to the `cpblk` opcode. Both the `destination` and `source` pointers are assumed to be pointer-aligned. See [ECMA-335](https://www.ecma-international.org/publications-and-standards/standards/ecma-335/), Sec. III.3.30 ("cpblk - copy data from memory to memory") for more information.

> [!CAUTION]
> This API is not intended for copying arbitrary-length runs of memory. Consider instead using <xref:System.Buffer.MemoryCopy%2A> or <xref:System.Span%601.CopyTo%2A> for this scenario.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyBlock">
      <MemberSignature Language="C#" Value="public static void CopyBlock (void* destination, void* source, uint byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyBlock(void* destination, void* source, unsigned int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.CopyBlock(System.Void*,System.Void*,System.UInt32)" />
      <MemberSignature Language="F#" Value="static member CopyBlock : nativeptr&lt;unit&gt; * nativeptr&lt;unit&gt; * uint32 -&gt; unit" Usage="System.Runtime.CompilerServices.Unsafe.CopyBlock (destination, source, byteCount)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyBlock(void* destination, void* source, System::UInt32 byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Void*" />
        <Parameter Name="source" Type="System.Void*" />
        <Parameter Name="byteCount" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="destination">The unmanaged pointer corresponding to the destination address to copy to.</param>
        <param name="source">The unmanaged pointer corresponding to the source address to copy from.</param>
        <param name="byteCount">The number of bytes to copy.</param>
        <summary>Copies bytes from the source address to the destination address.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API corresponds to the `cpblk` opcode. Both the `destination` and `source` pointers are assumed to be pointer-aligned. See [ECMA-335](https://www.ecma-international.org/publications-and-standards/standards/ecma-335/), Sec. III.3.30 ("cpblk - copy data from memory to memory") for more information.

> [!CAUTION]
> This API is not intended for copying arbitrary-length runs of memory. Consider instead using <xref:System.Buffer.MemoryCopy%2A> or <xref:System.Span%601.CopyTo%2A> for this scenario.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyBlockUnaligned">
      <MemberSignature Language="C#" Value="public static void CopyBlockUnaligned (ref byte destination, ref byte source, uint byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyBlockUnaligned(unsigned int8&amp; destination, unsigned int8&amp; source, unsigned int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.CopyBlockUnaligned(System.Byte@,System.Byte@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopyBlockUnaligned (ByRef destination As Byte, ByRef source As Byte, byteCount As UInteger)" />
      <MemberSignature Language="F#" Value="static member CopyBlockUnaligned : byte * byte * uint32 -&gt; unit" Usage="System.Runtime.CompilerServices.Unsafe.CopyBlockUnaligned (destination, source, byteCount)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyBlockUnaligned(System::Byte % destination, System::Byte % source, System::UInt32 byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Byte" RefType="ref" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="source" Type="System.Byte" RefType="ref" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="byteCount" Type="System.UInt32" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="destination">The managed pointer corresponding to the destination address to copy to.</param>
        <param name="source">The managed pointer corresponding to the source address to copy from.</param>
        <param name="byteCount">The number of bytes to copy.</param>
        <summary>Copies bytes from the source address to the destination address without assuming architecture dependent alignment of the addresses.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API corresponds to the `unaligned.1 cpblk` opcode sequence. No alignment assumptions are made about the `destination` or `source` pointers. See [ECMA-335](https://www.ecma-international.org/publications-and-standards/standards/ecma-335/), Sec. III.3.30 ("cpblk - copy data from memory to memory") and Sec. III.2.5 ("unaligned. (prefix) - pointer instruction might be unaligned") for more information.

> [!CAUTION]
> This API is not intended for copying arbitrary-length runs of memory. Consider instead using <xref:System.Buffer.MemoryCopy%2A> or <xref:System.Span%601.CopyTo%2A> for this scenario.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyBlockUnaligned">
      <MemberSignature Language="C#" Value="public static void CopyBlockUnaligned (void* destination, void* source, uint byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopyBlockUnaligned(void* destination, void* source, unsigned int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.CopyBlockUnaligned(System.Void*,System.Void*,System.UInt32)" />
      <MemberSignature Language="F#" Value="static member CopyBlockUnaligned : nativeptr&lt;unit&gt; * nativeptr&lt;unit&gt; * uint32 -&gt; unit" Usage="System.Runtime.CompilerServices.Unsafe.CopyBlockUnaligned (destination, source, byteCount)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CopyBlockUnaligned(void* destination, void* source, System::UInt32 byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Void*" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="source" Type="System.Void*" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="byteCount" Type="System.UInt32" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="destination">The unmanaged pointer corresponding to the destination address to copy to.</param>
        <param name="source">The unmanaged pointer corresponding to the source address to copy from.</param>
        <param name="byteCount">The number of bytes to copy.</param>
        <summary>Copies bytes from the source address to the destination address without assuming architecture dependent alignment of the addresses.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API corresponds to the `unaligned.1 cpblk` opcode sequence. No alignment assumptions are made about the `destination` or `source` pointers. See [ECMA-335](https://www.ecma-international.org/publications-and-standards/standards/ecma-335/), Sec. III.3.30 ("cpblk - copy data from memory to memory") and Sec. III.2.5 ("unaligned. (prefix) - pointer instruction might be unaligned") for more information.

> [!CAUTION]
> This API is not intended for copying arbitrary-length runs of memory. Consider instead using <xref:System.Buffer.MemoryCopy%2A> or <xref:System.Span%601.CopyTo%2A> for this scenario.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitBlock">
      <MemberSignature Language="C#" Value="public static void InitBlock (ref byte startAddress, byte value, uint byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void InitBlock(unsigned int8&amp; startAddress, unsigned int8 value, unsigned int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.InitBlock(System.Byte@,System.Byte,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub InitBlock (ByRef startAddress As Byte, value As Byte, byteCount As UInteger)" />
      <MemberSignature Language="F#" Value="static member InitBlock : byte * byte * uint32 -&gt; unit" Usage="System.Runtime.CompilerServices.Unsafe.InitBlock (startAddress, value, byteCount)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void InitBlock(System::Byte % startAddress, System::Byte value, System::UInt32 byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startAddress" Type="System.Byte" RefType="ref" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="value" Type="System.Byte" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="byteCount" Type="System.UInt32" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="startAddress">The managed pointer referencing the start of the memory block to initialize.</param>
        <param name="value">The value to initialize all bytes of the memory block to.</param>
        <param name="byteCount">The number of bytes to initialize.</param>
        <summary>Initializes a block of memory at the given location with a given initial value.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API corresponds to the `initblk` opcode. The `startAddress` pointer is assumed to be pointer-aligned. See [ECMA-335](https://www.ecma-international.org/publications-and-standards/standards/ecma-335/), Sec. III.3.36 ("initblk - initialize a block of memory to a value") for more information.

> [!CAUTION]
> This API is not intended for initializing arbitrary-length runs of memory. Consider instead using <xref:System.Span%601.Fill%2A> for this scenario.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitBlock">
      <MemberSignature Language="C#" Value="public static void InitBlock (void* startAddress, byte value, uint byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void InitBlock(void* startAddress, unsigned int8 value, unsigned int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.InitBlock(System.Void*,System.Byte,System.UInt32)" />
      <MemberSignature Language="F#" Value="static member InitBlock : nativeptr&lt;unit&gt; * byte * uint32 -&gt; unit" Usage="System.Runtime.CompilerServices.Unsafe.InitBlock (startAddress, value, byteCount)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void InitBlock(void* startAddress, System::Byte value, System::UInt32 byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startAddress" Type="System.Void*" />
        <Parameter Name="value" Type="System.Byte" />
        <Parameter Name="byteCount" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="startAddress">The unmanaged pointer referencing the start of the memory block to initialize.</param>
        <param name="value">The value to initialize all bytes of the memory block to.</param>
        <param name="byteCount">The number of bytes to initialize.</param>
        <summary>Initializes a block of memory at the given location with a given initial value.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API corresponds to the `initblk` opcode. The `startAddress` pointer is assumed to be pointer-aligned. See [ECMA-335](https://www.ecma-international.org/publications-and-standards/standards/ecma-335/), Sec. III.3.36 ("initblk - initialize a block of memory to a value") for more information.

> [!CAUTION]
> This API is not intended for initializing arbitrary-length runs of memory. Consider instead using <xref:System.Span%601.Fill%2A> for this scenario.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitBlockUnaligned">
      <MemberSignature Language="C#" Value="public static void InitBlockUnaligned (ref byte startAddress, byte value, uint byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void InitBlockUnaligned(unsigned int8&amp; startAddress, unsigned int8 value, unsigned int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.InitBlockUnaligned(System.Byte@,System.Byte,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub InitBlockUnaligned (ByRef startAddress As Byte, value As Byte, byteCount As UInteger)" />
      <MemberSignature Language="F#" Value="static member InitBlockUnaligned : byte * byte * uint32 -&gt; unit" Usage="System.Runtime.CompilerServices.Unsafe.InitBlockUnaligned (startAddress, value, byteCount)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void InitBlockUnaligned(System::Byte % startAddress, System::Byte value, System::UInt32 byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startAddress" Type="System.Byte" RefType="ref" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="value" Type="System.Byte" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="byteCount" Type="System.UInt32" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="startAddress">The managed pointer referencing the start of the memory block to initialize.</param>
        <param name="value">The value to initialize all bytes of the memory block to.</param>
        <param name="byteCount">The number of bytes to initialize.</param>
        <summary>Initializes a block of memory at the given location with a given initial value without assuming architecture dependent alignment of the address.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API corresponds to the `unaligned.1 initblk` opcode sequence. No alignment assumption is made about the `startAddress` pointer. See [ECMA-335](https://www.ecma-international.org/publications-and-standards/standards/ecma-335/), Sec. III.3.36 ("initblk - initialize a block of memory to a value") and Sec. III.2.5 ("unaligned. (prefix) - pointer instruction might be unaligned") for more information.

> [!CAUTION]
> This API is not intended for initializing arbitrary-length runs of memory. Consider instead using <xref:System.Span%601.Fill%2A> for this scenario.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitBlockUnaligned">
      <MemberSignature Language="C#" Value="public static void InitBlockUnaligned (void* startAddress, byte value, uint byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void InitBlockUnaligned(void* startAddress, unsigned int8 value, unsigned int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.InitBlockUnaligned(System.Void*,System.Byte,System.UInt32)" />
      <MemberSignature Language="F#" Value="static member InitBlockUnaligned : nativeptr&lt;unit&gt; * byte * uint32 -&gt; unit" Usage="System.Runtime.CompilerServices.Unsafe.InitBlockUnaligned (startAddress, value, byteCount)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void InitBlockUnaligned(void* startAddress, System::Byte value, System::UInt32 byteCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startAddress" Type="System.Void*" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="value" Type="System.Byte" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="byteCount" Type="System.UInt32" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="startAddress">The unmanaged pointer referencing the start of the memory block to initialize.</param>
        <param name="value">The value to initialize all bytes of the memory block to.</param>
        <param name="byteCount">The number of bytes to initialize.</param>
        <summary>Initializes a block of memory at the given location with a given initial value without assuming architecture dependent alignment of the address.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API corresponds to the `unaligned.1 initblk` opcode sequence. No alignment assumption is made about the `startAddress` pointer. See [ECMA-335](https://www.ecma-international.org/publications-and-standards/standards/ecma-335/), Sec. III.3.36 ("initblk - initialize a block of memory to a value") and Sec. III.2.5 ("unaligned. (prefix) - pointer instruction might be unaligned") for more information.

> [!CAUTION]
> This API is not intended for initializing arbitrary-length runs of memory. Consider instead using <xref:System.Span%601.Fill%2A> for this scenario.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAddressGreaterThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsAddressGreaterThan&lt;T&gt; (ref T left, ref T right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsAddressGreaterThan&lt;T&gt;(!!T&amp; left, !!T&amp; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.IsAddressGreaterThan``1(``0@,``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsAddressGreaterThan(Of T) (ByRef left As T, ByRef right As T) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsAddressGreaterThan : 'T * 'T -&gt; bool" Usage="System.Runtime.CompilerServices.Unsafe.IsAddressGreaterThan (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool IsAddressGreaterThan(T % left, T % right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="T" RefType="ref" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0;net-6.0;net-7.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.AllowNull]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.AllowNull&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="T" RefType="ref" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0;net-6.0;net-7.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.AllowNull]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.AllowNull&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The elemental type of the managed pointer.</typeparam>
        <param name="left">The first managed pointer to compare.</param>
        <param name="right">The second managed pointer to compare.</param>
        <summary>Returns a value that indicates whether a specified managed pointer is greater than another specified managed pointer.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This check is conceptually similar to `(void*)(&left) > (void*)(&right)`.

The return value of this method is a moment-in-time result. If `left` and `right` each reference different objects in GC-managed address space, the GC could relocate items between calls, causing the result of this method to change.

The return value is guaranteed stable if `left` and `right` point to the same managed object.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAddressLessThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsAddressLessThan&lt;T&gt; (ref T left, ref T right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsAddressLessThan&lt;T&gt;(!!T&amp; left, !!T&amp; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.IsAddressLessThan``1(``0@,``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsAddressLessThan(Of T) (ByRef left As T, ByRef right As T) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsAddressLessThan : 'T * 'T -&gt; bool" Usage="System.Runtime.CompilerServices.Unsafe.IsAddressLessThan (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool IsAddressLessThan(T % left, T % right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="T" RefType="ref" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0;net-6.0;net-7.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.AllowNull]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.AllowNull&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="T" RefType="ref" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0;net-6.0;net-7.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.AllowNull]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.AllowNull&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The elemental type of the managed pointer.</typeparam>
        <param name="left">The first managed pointer to compare.</param>
        <param name="right">The second managed pointer to compare.</param>
        <summary>Returns a value that indicates whether a specified managed pointer is less than another specified managed pointer.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This check is conceptually similar to `(void*)(&left) < (void*)(&right)`.

The return value of this method is a moment-in-time result. If `left` and `right` each reference different objects in GC-managed address space, the GC could relocate items between calls, causing the result of this method to change.

The return value is guaranteed stable if `left` and `right` point to the same managed object.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNullRef&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsNullRef&lt;T&gt; (ref T source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullRef&lt;T&gt;(!!T&amp; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.IsNullRef``1(``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullRef(Of T) (ByRef source As T) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsNullRef : 'T -&gt; bool" Usage="System.Runtime.CompilerServices.Unsafe.IsNullRef source" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool IsNullRef(T % source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="T" RefType="ref" Index="0" FrameworkAlternate="net-5.0;net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">The elemental type of the managed pointer.</typeparam>
        <param name="source">The managed pointer to check.</param>
        <summary>Determines if a given managed pointer to a value of type <typeparamref name="T" /> is a null reference.</summary>
        <returns>
          <see langword="true" /> if <paramref name="source" /> is a null reference; otherwise, <see langword="false" />.</returns>
        <remarks>This check is conceptually similar to <code>(void*)(&amp;source) == nullptr</code>.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NullRef&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref T NullRef&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T NullRef&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.NullRef``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function NullRef(Of T) () As T" />
      <MemberSignature Language="F#" Value="static member NullRef : unit -&gt; 'T" Usage="System.Runtime.CompilerServices.Unsafe.NullRef " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T % NullRef();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">The elemental type of the managed pointer.</typeparam>
        <summary>Returns a null managed pointer to a value of type <typeparamref name="T" />.</summary>
        <returns>A null managed pointer to a value of type <typeparamref name="T" />.</returns>
        <remarks>The return value is conceptually similar to <code>ref *((T*)null)</code>.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Read&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Read&lt;T&gt; (void* source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Read&lt;T&gt;(void* source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.Read``1(System.Void*)" />
      <MemberSignature Language="F#" Value="static member Read : nativeptr&lt;unit&gt; -&gt; 'T" Usage="System.Runtime.CompilerServices.Unsafe.Read source" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Read(void* source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Void*" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of the value to read.</typeparam>
        <param name="source">An unmanaged pointer containing the address to read from.</param>
        <summary>Reads a value of type <typeparamref name="T" /> from the given location.
         </summary>
        <returns>A value of type <typeparamref name="T" /> read from the given location.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!CAUTION]
> The caller must ensure that there are `SizeOf<T>()` bytes of readable memory available starting at the location pointed to by `source`. Access violations may occur if this requirement is not met.

`source` is assumed to be a properly aligned pointer to a value of type `T`. For more information on alignment assumptions, see [ECMA-335](https://www.ecma-international.org/publications-and-standards/standards/ecma-335/), Sec. I.12.6.2 ("Alignment").

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadUnaligned&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T ReadUnaligned&lt;T&gt; (ref byte source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T ReadUnaligned&lt;T&gt;(unsigned int8&amp; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.ReadUnaligned``1(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadUnaligned(Of T) (ByRef source As Byte) As T" />
      <MemberSignature Language="F#" Value="static member ReadUnaligned : byte -&gt; 'T" Usage="System.Runtime.CompilerServices.Unsafe.ReadUnaligned source" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T ReadUnaligned(System::Byte % source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Byte" RefType="ref" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of the value to read.</typeparam>
        <param name="source">A managed pointer containing the address to read from.</param>
        <summary>Reads a value of type <typeparamref name="T" /> from the given address without assuming architecture dependent alignment of the source address.</summary>
        <returns>A value of type <typeparamref name="T" /> read from the given address.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!CAUTION]
> The caller must ensure that there are `SizeOf<T>()` bytes of readable memory available starting at the location pointed to by `source`. Access violations may occur if this requirement is not met.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadUnaligned&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T ReadUnaligned&lt;T&gt; (void* source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T ReadUnaligned&lt;T&gt;(void* source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.ReadUnaligned``1(System.Void*)" />
      <MemberSignature Language="F#" Value="static member ReadUnaligned : nativeptr&lt;unit&gt; -&gt; 'T" Usage="System.Runtime.CompilerServices.Unsafe.ReadUnaligned source" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T ReadUnaligned(void* source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Void*" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of the value to read.</typeparam>
        <param name="source">An unmanaged pointer containing the address to read from.</param>
        <summary>Reads a value of type <typeparamref name="T" /> from the given location without assuming architecture dependent alignment of the source address.</summary>
        <returns>A value of type <typeparamref name="T" /> read from the given location.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!CAUTION]
> The caller must ensure that there are `SizeOf<T>()` bytes of readable memory available starting at the location pointed to by `source`. Access violations may occur if this requirement is not met.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int SizeOf&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 SizeOf&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.SizeOf``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SizeOf(Of T) () As Integer" />
      <MemberSignature Language="F#" Value="static member SizeOf : unit -&gt; int" Usage="System.Runtime.CompilerServices.Unsafe.SizeOf " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int SizeOf();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">The type whose size is to be retrieved.</typeparam>
        <summary>Returns the size of a value of the given type parameter.</summary>
        <returns>The size, in bytes, of a value of type <typeparamref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This API corresponds to the `sizeof` opcode. If `T` is a reference type, the return value is the size of the reference itself (equal to `sizeof(void*)`). See [ECMA-335](https://www.ecma-international.org/publications-and-standards/standards/ecma-335/), Sec. III.4.25  ("sizeof - load the size, in bytes, of a type") for more information.

> [!CAUTION]
> This API returns the size of the _managed_ view of the type. For the size of the _unmanaged_ view of the type, such as needed for interop purposes, use <xref:System.Runtime.InteropServices.Marshal.SizeOf%2A>.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipInit&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void SkipInit&lt;T&gt; (out T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SkipInit&lt;T&gt;([out] !!T&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.SkipInit``1(``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SkipInit(Of T) (ByRef value As T)" />
      <MemberSignature Language="F#" Value="static member SkipInit : 'T -&gt; unit" Usage="System.Runtime.CompilerServices.Unsafe.SkipInit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void SkipInit([Runtime::InteropServices::Out] T % value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="T" RefType="out" Index="0" FrameworkAlternate="net-5.0;net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of the reference.</typeparam>
        <param name="value">The reference whose initialization should be skipped.</param>
        <summary>Bypasses definite assignment rules for a given reference.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This method is typically used to avoid double-initialization when initializing union-type structs. Consider the following example, which produces a C# compiler error.

```cs
using System;
using System.Runtime.InteropServices;

public static MyUnionStruct MyMethod() {
    MyUnionStruct value;
    value.SomeIntField = 42;
    return value; // CS0165: Use of unassigned local variable 'value'
}

[StructLayout(LayoutKind.Explicit)]
public struct MyUnionStruct
{
    [FieldOffset(0)]
    public int SomeIntField;

    [FieldOffset(0)]
    public byte SomeByteField;
}
```

This error occurs because the compiler expects _all_ fields of the struct to be initialized before the struct is used or returned to the caller.

One way to avoid this compiler error is to ensure the entire struct is zero-initialized before individual fields are set, as shown in the following example.

```cs
// This sample compiles successfully.
public static MyUnionStruct MyMethod() {
    MyUnionStruct value = default; // the struct is now guaranteed assigned
    value.SomeIntField = 42;
    return value;
}
```

If you want to avoid the initial zero-initialization, you can call the `SkipInit` method can be used to suppress the compiler warning.

```cs
using System.Runtime.CompilerServices;

// This sample also compiles successfully.
public static MyUnionStruct MyMethod() {
    MyUnionStruct value;
    Unsafe.SkipInit(out value); // compiler believes the struct has been guaranteed assigned
    value.SomeIntField = 42;
    return value;
}
```

> [!WARNING]
> Take care to ensure that the struct has been initialized appropriately, otherwise the struct's fields could contain uninitialized data from the stack.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void* Subtract&lt;T&gt; (void* source, int elementOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void* Subtract&lt;T&gt;(void* source, int32 elementOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.Subtract``1(System.Void*,System.Int32)" />
      <MemberSignature Language="F#" Value="static member Subtract : nativeptr&lt;unit&gt; * int -&gt; nativeptr&lt;unit&gt;" Usage="System.Runtime.CompilerServices.Unsafe.Subtract (source, elementOffset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void* Subtract(void* source, int elementOffset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void*</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Void*" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="elementOffset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type whose size will be used as a scale factor for <paramref name="elementOffset" />.</typeparam>
        <param name="source">The unmanaged pointer to subtract the offset from.</param>
        <param name="elementOffset">The offset to subtract.</param>
        <summary>Subtracts an element offset from the given unmanaged pointer.</summary>
        <returns>A new unmanaged pointer that reflects the subtraction of the specified offset from the source pointer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The `elementOffset` parameter is the number of `T`-sized elements (not bytes) to remove from the `source` pointer. For example, given a source pointer _ptr_, the call `Unsafe.Subtract<int>(ptr, 20)` will return a new pointer whose address points 80 bytes (= 20 elements \* 4 bytes per element) before _ptr_.

If `elementOffset` is a calculated value rather than a hardcoded literal, callers should consider the possibility of integer overflow. For example, in the call `Unsafe.Subtract<int>(ptr, a * b)`, the caller must ensure the intermediate value `a * b` does not overflow the bounds of `Int32`.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref T Subtract&lt;T&gt; (ref T source, int elementOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Subtract&lt;T&gt;(!!T&amp; source, int32 elementOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.Subtract``1(``0@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract(Of T) (ByRef source As T, elementOffset As Integer) As T" />
      <MemberSignature Language="F#" Value="static member Subtract : 'T * int -&gt; 'T" Usage="System.Runtime.CompilerServices.Unsafe.Subtract (source, elementOffset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T % Subtract(T % source, int elementOffset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="T" RefType="ref" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-1.1;netcore-3.0;netcore-3.1" />
        <Parameter Name="elementOffset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-1.1;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">The elemental type of the managed pointer.</typeparam>
        <param name="source">The managed pointer to subtract the offset from.</param>
        <param name="elementOffset">The offset to subtract.</param>
        <summary>Subtracts an offset from the given managed pointer.</summary>
        <returns>A new managed pointer that reflects the subtraction of the specified offset from the source pointer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The `elementOffset` parameter is the number of `T`-sized elements (not bytes) to subtract from the `source` pointer. For example, given a source pointer _ptr_ of type `ref int`, the call `Unsafe.Subtract<int>(ref ptr, 20)` will return a new pointer whose address points 80 bytes (= 20 elements \* 4 bytes per element) before _ptr_.

If `elementOffset` is a calculated value rather than a hardcoded literal, callers should consider the possibility of integer overflow. For example, in the call `Unsafe.Subtract<int>(ref ptr, a * b)`, the caller must ensure the intermediate value `a * b` does not overflow the bounds of `Int32`.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref T Subtract&lt;T&gt; (ref T source, IntPtr elementOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Subtract&lt;T&gt;(!!T&amp; source, native int elementOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.Subtract``1(``0@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract(Of T) (ByRef source As T, elementOffset As IntPtr) As T" />
      <MemberSignature Language="F#" Value="static member Subtract : 'T * nativeint -&gt; 'T" Usage="System.Runtime.CompilerServices.Unsafe.Subtract (source, elementOffset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T % Subtract(T % source, IntPtr elementOffset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="T" RefType="ref" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="elementOffset" Type="System.IntPtr" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">The elemental type of the managed pointer.</typeparam>
        <param name="source">The managed pointer to subtract the offset from.</param>
        <param name="elementOffset">The offset to subtract.</param>
        <summary>Subtracts an element offset from the given managed pointer.</summary>
        <returns>A new managed pointer that reflects the subtraction of the specified offset from the source pointer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The `elementOffset` parameter is the number of `T`-sized elements (not bytes) to subtract from the `source` pointer. For example, given a source pointer _ptr_ of type `ref int`, the call `Unsafe.Subtract<int>(ref ptr, (nint)20)` will return a new pointer whose address points 80 bytes (= 20 elements \* 4 bytes per element) before _ptr_.

If `elementOffset` is a calculated value rather than a hardcoded literal, callers should consider the possibility of integer overflow. For example, in the call `Unsafe.Subtract<int>(ref ptr, a * b)`, the caller must ensure the intermediate value `a * b` does not overflow the bounds of `IntPtr`.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref T Subtract&lt;T&gt; (ref T source, nuint elementOffset);" FrameworkAlternate="net-6.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Subtract&lt;T&gt;(!!T&amp; source, native unsigned int elementOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.Subtract``1(``0@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract(Of T) (ByRef source As T, elementOffset As UIntPtr) As T" />
      <MemberSignature Language="F#" Value="static member Subtract : 'T * unativeint -&gt; 'T" Usage="System.Runtime.CompilerServices.Unsafe.Subtract (source, elementOffset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T % Subtract(T % source, UIntPtr elementOffset);" />
      <MemberSignature Language="C#" Value="public static ref T Subtract&lt;T&gt; (ref T source, UIntPtr elementOffset);" FrameworkAlternate="net-7.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="T" RefType="ref" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="elementOffset" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-6.0;net-7.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-6.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.NativeInteger]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NativeInteger&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The elemental type of the managed pointer.</typeparam>
        <param name="source">The managed pointer to subtract the offset from.</param>
        <param name="elementOffset">The offset to subtract.</param>
        <summary>Subtracts an element offset from the given managed pointer.</summary>
        <returns>A new managed pointer that reflects the subtraction of the specified offset from the source pointer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The `elementOffset` parameter is the number of `T`-sized elements (not bytes) to subtract from the `source` pointer. For example, given a source pointer _ptr_ of type `ref int`, the call `Unsafe.Subtract<int>(ref ptr, (nuint)20)` will return a new pointer whose address points 80 bytes (= 20 elements \* 4 bytes per element) before _ptr_.

If `elementOffset` is a calculated value rather than a hardcoded literal, callers should consider the possibility of integer overflow. For example, in the call `Unsafe.Subtract<int>(ref ptr, a * b)`, the caller must ensure the intermediate value `a * b` does not overflow the bounds of `UIntPtr`.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractByteOffset&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref T SubtractByteOffset&lt;T&gt; (ref T source, IntPtr byteOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T SubtractByteOffset&lt;T&gt;(!!T&amp; source, native int byteOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.SubtractByteOffset``1(``0@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractByteOffset(Of T) (ByRef source As T, byteOffset As IntPtr) As T" />
      <MemberSignature Language="F#" Value="static member SubtractByteOffset : 'T * nativeint -&gt; 'T" Usage="System.Runtime.CompilerServices.Unsafe.SubtractByteOffset (source, byteOffset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T % SubtractByteOffset(T % source, IntPtr byteOffset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="T" RefType="ref" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="byteOffset" Type="System.IntPtr" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">The elemental type of the managed pointer.</typeparam>
        <param name="source">The managed pointer to subtract the offset from.</param>
        <param name="byteOffset">The offset to subtract.</param>
        <summary>Subtracts a byte offset from the given managed pointer.</summary>
        <returns>A new managed pointer that reflects the subtraction of the specified byte offset from the source pointer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The `byteOffset` parameter is the number of bytes to remove from the `source` pointer. For example, given a source pointer _ptr_ of type `ref int`, the call `Unsafe.SubtractByteOffset<int>(ref ptr, 20)` will return a new pointer whose address points 20 bytes before _ptr_.

If `byteOffset` is a calculated value rather than a hardcoded literal, callers should consider the possibility of integer overflow. For example, in the call `Unsafe.SubtractByteOffset<int>(ref ptr, a * b)`, the caller must ensure the intermediate value `a * b` does not overflow the bounds of `IntPtr`.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractByteOffset&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref T SubtractByteOffset&lt;T&gt; (ref T source, nuint byteOffset);" FrameworkAlternate="net-6.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T SubtractByteOffset&lt;T&gt;(!!T&amp; source, native unsigned int byteOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.SubtractByteOffset``1(``0@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SubtractByteOffset(Of T) (ByRef source As T, byteOffset As UIntPtr) As T" />
      <MemberSignature Language="F#" Value="static member SubtractByteOffset : 'T * unativeint -&gt; 'T" Usage="System.Runtime.CompilerServices.Unsafe.SubtractByteOffset (source, byteOffset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T % SubtractByteOffset(T % source, UIntPtr byteOffset);" />
      <MemberSignature Language="C#" Value="public static ref T SubtractByteOffset&lt;T&gt; (ref T source, UIntPtr byteOffset);" FrameworkAlternate="net-7.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="T" RefType="ref" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="byteOffset" Type="System.UIntPtr" Index="1" FrameworkAlternate="net-6.0;net-7.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-6.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.NativeInteger]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NativeInteger&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The elemental type of the managed pointer.</typeparam>
        <param name="source">The managed pointer to subtract the offset from.</param>
        <param name="byteOffset">The offset to subtract.</param>
        <summary>Subtracts a byte offset from the given managed pointer.</summary>
        <returns>A new managed pointer that reflects the subtraction of the specified byte offset from the source pointer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The `byteOffset` parameter is the number of bytes to subtract from the `source` pointer. For example, given a source pointer _ptr_ of type `ref int`, the call `Unsafe.SubtractByteOffset<int>(ref ptr, (nuint)20)` will return a new pointer whose address points 20 bytes before _ptr_.

If `byteOffset` is a calculated value rather than a hardcoded literal, callers should consider the possibility of integer overflow. For example, in the call `Unsafe.SubtractByteOffset<int>(ref ptr, a * b)`, the caller must ensure the intermediate value `a * b` does not overflow the bounds of `UIntPtr`.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref T Unbox&lt;T&gt; (object box) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Unbox&lt;struct .ctor (class System.ValueType) T&gt;(object box) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.Unbox``1(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Unbox(Of T As Structure) (box As Object) As T" />
      <MemberSignature Language="F#" Value="static member Unbox : obj -&gt; 'T (requires 'T : struct)" Usage="System.Runtime.CompilerServices.Unsafe.Unbox box" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class static T % Unbox(System::Object ^ box);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="box" Type="System.Object" Index="0" FrameworkAlternate="dotnet-plat-ext-3.0;netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type to be unboxed.</typeparam>
        <param name="box">The value to unbox.</param>
        <summary>Returns a <see langword="mutable ref" /> to a boxed value.</summary>
        <returns>A <see langword="mutable ref" /> to the boxed value <paramref name="box" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

The `Unbox<T>` method is simply a wrapper for the IL [unbox](xref:System.Reflection.Emit.OpCodes.Unbox) instruction. It is useful as a performance optimization. Whenever an API that takes an <xref:System.Object> needs to be called repeatedly with different values of a value type, the same box object can be reused rather than a new one created each time.

The `Unbox<T>` method has an important usage constraint that is not enforced by language compilers and that is the responsibility of the caller. The IL `unbox` instruction returns a controlled-mutability managed pointer. Because .NET and .NET language compilers cannot represent this constraint, the `Unbox<T>` method returns a normal mutable `ref T`. However developers **must not** mutate the returned reference unless they are certain that `T` is a mutable struct type. For example, because the numeric primitives such as <xref:System.Int32> are not mutable struct types, the following code is not suppported:

```csharp
// The following line is NOT SUPPORTED.
Unsafe.Unbox<int>(obj) = 30;
```

In contrast, a type such as <xref:System.Drawing.Point?<displayProperty=nameWithType> is a mutable struct with public property setters, so mutating the boxed value by calling the property setters is supported:

```csharp
// The following lines are legal and supported.
Unsafe.Unbox<System.Drawing.Point>(obj).X = 50;
Unsafe.Unbox<System.Drawing.Point>(obj).Y = 70;
```

However, replacing the entire reference wholesale is not supported, even if the reference is to a mutable struct type.

```csharp
// Resetting the reference to default(T) is NOT SUPPORTED.
Unsafe.Unbox<System.Drawing.Point>(obj) = default(System.Drawing.Point);

// Setting the reference to a completely new value is NOT SUPPORTED.
Unsafe.Unbox<System.Drawing.Point>(obj) = new System.Drawing.Point(50, 70);
```

For more information, including detailed discussion of the usage constraints of this instruction, see sections III.1.8.1.2.2 ("Controlled-mutability managed pointers") and III.4.32 ("unbox -- convert boxed value type to its raw form") in [ECMA-335: Common Language Infrastructure (CLI)](https://www.ecma-international.org/publications-and-standards/standards/ecma-335/).

]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <paramref name="box" /> is <see langword="null" />, and <typeparamref name="T" /> is a non-nullable value type.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="box" /> is not a boxed value type.

-or-

<paramref name="box" /> is not a boxed <typeparamref name="T" />.
         </exception>
        <exception cref="T:System.TypeLoadException">
          <typeparamref name="T" /> cannot be found.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Write&lt;T&gt; (void* destination, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write&lt;T&gt;(void* destination, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.Write``1(System.Void*,``0)" />
      <MemberSignature Language="F#" Value="static member Write : nativeptr&lt;unit&gt; * 'T -&gt; unit" Usage="System.Runtime.CompilerServices.Unsafe.Write (destination, value)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Write(void* destination, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="destination" Type="System.Void*" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of the value to write.</typeparam>
        <param name="destination">The location to write to.</param>
        <param name="value">The value to write.</param>
        <summary>Writes a value of type <typeparamref name="T" /> to the given location.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!CAUTION]
> The caller must ensure that there are `SizeOf<T>()` bytes of writable memory available starting at the location pointed to by `destination`. Access violations may occur if this requirement is not met.

`destination` is assumed to be a properly aligned pointer to a value of type `T`. For more information on alignment assumptions, see [ECMA-335](https://www.ecma-international.org/publications-and-standards/standards/ecma-335/), Sec. I.12.6.2 ("Alignment").

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteUnaligned&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void WriteUnaligned&lt;T&gt; (ref byte destination, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteUnaligned&lt;T&gt;(unsigned int8&amp; destination, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.WriteUnaligned``1(System.Byte@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteUnaligned(Of T) (ByRef destination As Byte, value As T)" />
      <MemberSignature Language="F#" Value="static member WriteUnaligned : byte * 'T -&gt; unit" Usage="System.Runtime.CompilerServices.Unsafe.WriteUnaligned (destination, value)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void WriteUnaligned(System::Byte % destination, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="destination" Type="System.Byte" RefType="ref" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of the value to write.</typeparam>
        <param name="destination">A managed pointer containing the address to write to.</param>
        <param name="value">The value to write.</param>
        <summary>Writes a value of type <typeparamref name="T" /> to the given location without assuming architecture dependent alignment of the destination address.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!CAUTION]
> The caller must ensure that there are `SizeOf<T>()` bytes of writable memory available starting at the location pointed to by `destination`. Access violations may occur if this requirement is not met.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteUnaligned&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void WriteUnaligned&lt;T&gt; (void* destination, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteUnaligned&lt;T&gt;(void* destination, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.Unsafe.WriteUnaligned``1(System.Void*,``0)" />
      <MemberSignature Language="F#" Value="static member WriteUnaligned : nativeptr&lt;unit&gt; * 'T -&gt; unit" Usage="System.Runtime.CompilerServices.Unsafe.WriteUnaligned (destination, value)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void WriteUnaligned(void* destination, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.CompilerServices.Unsafe</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.1</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.6.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="destination" Type="System.Void*" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
        <Parameter Name="value" Type="T" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;net-5.0;net-6.0;net-7.0;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <typeparam name="T">The type of the value to write.</typeparam>
        <param name="destination">A managed pointer containing the address to write to.</param>
        <param name="value">The value to write.</param>
        <summary>Writes a value of type <typeparamref name="T" /> to the given location without assuming architecture dependent alignment of the destination address.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

> [!CAUTION]
> The caller must ensure that there are `SizeOf<T>()` bytes of writable memory available starting at the location pointed to by `destination`. Access violations may occur if this requirement is not met.

]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
