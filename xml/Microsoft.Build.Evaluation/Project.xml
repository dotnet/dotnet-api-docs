<Type Name="Project" FullName="Microsoft.Build.Evaluation.Project">
  <TypeSignature Language="C#" Value="public class Project" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Project extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Build.Evaluation.Project" />
  <TypeSignature Language="VB.NET" Value="Public Class Project" />
  <TypeSignature Language="C++ CLI" Value="public ref class Project" />
  <TypeSignature Language="F#" Value="type Project = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Build</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>15.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore">
      <AttributeName Language="C#">[System.Diagnostics.DebuggerDisplay("{FullPath} EffectiveToolsVersion={ToolsVersion} #GlobalProperties={_data.GlobalPropertiesDictionary.Count} #Properties={_data.Properties.Count} #ItemTypes={_data.ItemTypes.Count} #ItemDefinitions={_data.ItemDefinitions.Count} #Items={_data.Items.Count} #Targets={_data.Targets.Count}")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerDisplay("{FullPath} EffectiveToolsVersion={ToolsVersion} #GlobalProperties={_data.GlobalPropertiesDictionary.Count} #Properties={_data.Properties.Count} #ItemTypes={_data.ItemTypes.Count} #ItemDefinitions={_data.ItemDefinitions.Count} #Items={_data.Items.Count} #Targets={_data.Targets.Count}")&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName Language="C#">[System.Diagnostics.DebuggerDisplay("{FullPath} EffectiveToolsVersion={ToolsVersion} #GlobalProperties={data.globalProperties.Count} #Properties={data.Properties.Count} #ItemTypes={data.ItemTypes.Count} #ItemDefinitions={data.ItemDefinitions.Count} #Items={data.Items.Count} #Targets={data.Targets.Count}")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerDisplay("{FullPath} EffectiveToolsVersion={ToolsVersion} #GlobalProperties={data.globalProperties.Count} #Properties={data.Properties.Count} #ItemTypes={data.ItemTypes.Count} #ItemDefinitions={data.ItemDefinitions.Count} #Items={data.Items.Count} #Targets={data.Targets.Count}")&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
            Represents an evaluated project with design time semantics.
            Always backed by XML; can be built directly, or an instance can be cloned off to add virtual items/properties and build.
            Edits to this project always update the backing XML.
            </summary>
      </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Constructs an empty project using the global project collection global properties and default tools version.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
            Construct an empty project, evaluating with the global project collection's
            global properties and default tools version.
            Project will be added to the global project collection when it is named.
            </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This project is added to the global project collection when it is given the full path to the source project file, typically by saving the project.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (Microsoft.Build.Construction.ProjectRootElement xml);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Build.Construction.ProjectRootElement xml) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Construction.ProjectRootElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xml As ProjectRootElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(Microsoft::Build::Construction::ProjectRootElement ^ xml);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : Microsoft.Build.Construction.ProjectRootElement -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project xml" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="xml" Type="Microsoft.Build.Construction.ProjectRootElement" />
      </Parameters>
      <Docs>
        <param name="xml">ProjectRootElement to use</param>
        <summary>
            Construct over a ProjectRootElement object, evaluating with the global project collection's
            global properties and default tools version.
            Project is added to the global project collection if it has a name, or else when it is named.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This project is added to the global project collection when either this project or the given project root is given the full path to the source project file.  
  
 Throws InvalidProjectFileException if the evaluation fails. Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Evaluation.NewProjectFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (newProjectFileOptions As NewProjectFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(Microsoft::Build::Evaluation::NewProjectFileOptions newProjectFileOptions);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : Microsoft.Build.Evaluation.NewProjectFileOptions -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project newProjectFileOptions" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="newProjectFileOptions" Type="Microsoft.Build.Evaluation.NewProjectFileOptions" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="newProjectFileOptions">To be added.</param>
        <summary>
            Construct an empty project, evaluating with the global project collection's
            global properties and default tools version.
            Project will be added to the global project collection when it is named.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (Microsoft.Build.Evaluation.ProjectCollection projectCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Build.Evaluation.ProjectCollection projectCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Evaluation.ProjectCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (projectCollection As ProjectCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : Microsoft.Build.Evaluation.ProjectCollection -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project projectCollection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
      </Parameters>
      <Docs>
        <param name="projectCollection">The project collection that the new project is added to.</param>
        <summary>
            Construct an empty project, evaluating with the specified project collection's
            global properties and default tools version.
            Project will be added to the specified project collection when it is named.
            </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This project is added to the given project collection when it is given the full path to the source project file, typically by saving the project.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (string projectFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string projectFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (projectFile As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::String ^ projectFile);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : string -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project projectFile" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="projectFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="projectFile">The source project file to be evaluated.</param>
        <summary>
            Construct over an existing project file, evaluating with the global project collection's
            global properties and default tools version.
            Project is added to the global project collection.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            May throw IO-related exceptions.
            </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The project is added to the global project collection.  
  
 Throws InvalidOperationException if there is already a project in the project collection that evaluates this source project file. May throw IO-related exceptions.  
  
 ]]></format>
        </remarks>
        <exception cref="T:Microsoft.Build.Exceptions.InvalidProjectFileException">If the evaluation fails.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (System.Xml.XmlReader xmlReader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlReader xmlReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.Xml.XmlReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xmlReader As XmlReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::Xml::XmlReader ^ xmlReader);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : System.Xml.XmlReader -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project xmlReader" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="xmlReader">Xml reader to read project from</param>
        <summary>
            Construct over a text reader over project xml, evaluating with the global project collection's
            global properties and default tools version.
            Project will be added to the global project collection when it is named.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This project is added to the global project collection when it is given the full path to the source project file, typically by saving the project.  
  
 Throws InvalidProjectFileException if the evaluation fails. Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Build.Evaluation.ProjectCollection projectCollection, valuetype Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.NewProjectFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (projectCollection As ProjectCollection, newProjectFileOptions As NewProjectFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection, Microsoft::Build::Evaluation::NewProjectFileOptions newProjectFileOptions);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : Microsoft.Build.Evaluation.ProjectCollection * Microsoft.Build.Evaluation.NewProjectFileOptions -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (projectCollection, newProjectFileOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="newProjectFileOptions" Type="Microsoft.Build.Evaluation.NewProjectFileOptions" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="projectCollection">To be added.</param>
        <param name="newProjectFileOptions">To be added.</param>
        <summary>
            Construct an empty project, evaluating with the specified project collection's
            global properties and default tools version.
            Project will be added to the specified project collection when it is named.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Build.Construction.ProjectRootElement xml, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Construction.ProjectRootElement,System.Collections.Generic.IDictionary{System.String,System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xml As ProjectRootElement, globalProperties As IDictionary(Of String, String), toolsVersion As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(Microsoft::Build::Construction::ProjectRootElement ^ xml, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : Microsoft.Build.Construction.ProjectRootElement * System.Collections.Generic.IDictionary&lt;string, string&gt; * string -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xml, globalProperties, toolsVersion)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xml" Type="Microsoft.Build.Construction.ProjectRootElement" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xml">ProjectRootElement to use</param>
        <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
        <param name="toolsVersion">Tools version to evaluate with. May be null</param>
        <summary>
            Construct over a ProjectRootElement object, evaluating with specified
            global properties and toolset, either or both of which may be null.
            Project is added to the global project collection if it has a name, or else when it is named.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This project is added to the global project collection when either this project or the given project root is given the full path to the source project file.  
  
 Throws InvalidProjectFileException if the evaluation fails. Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (globalProperties As IDictionary(Of String, String), toolsVersion As String, projectCollection As ProjectCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (globalProperties, toolsVersion, projectCollection)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
      </Parameters>
      <Docs>
        <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
        <param name="toolsVersion">Tools version to evaluate with. May be null</param>
        <param name="projectCollection">The <see cref="P:Microsoft.Build.Evaluation.Project.ProjectCollection" /> the project is added to.</param>
        <summary>
            Construct an empty project, evaluating with the specified project collection and
            the specified global properties and default tools version, either of which may be null.
            Project will be added to the specified project collection when it is named.
            </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The project is added to the specified project collection when it is given the full path to the source project file, typically by saving the project.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (string projectFile, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string projectFile, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (projectFile As String, globalProperties As IDictionary(Of String, String), toolsVersion As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::String ^ projectFile, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : string * System.Collections.Generic.IDictionary&lt;string, string&gt; * string -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (projectFile, globalProperties, toolsVersion)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="projectFile" Type="System.String" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="projectFile">The path to the source project file to be evaluated.</param>
        <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
        <param name="toolsVersion">Tools version to evaluate with. May be null.</param>
        <summary>
            Construct over an existing project file, evaluating with specified
            global properties and toolset, either or both of which may be null.
            Project is added to the global project collection.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            May throw IO-related exceptions.
            </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The project is added to the global project collection.  
  
 Throws InvalidProjectFileException if the evaluation fails. Throws InvalidOperationException if there is already an equivalent project loaded in the project collection. May throw IO-related exceptions.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlReader xmlReader, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.Xml.XmlReader,System.Collections.Generic.IDictionary{System.String,System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xmlReader As XmlReader, globalProperties As IDictionary(Of String, String), toolsVersion As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::Xml::XmlReader ^ xmlReader, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : System.Xml.XmlReader * System.Collections.Generic.IDictionary&lt;string, string&gt; * string -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xmlReader, globalProperties, toolsVersion)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xmlReader">Xml reader to read project from</param>
        <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
        <param name="toolsVersion">Tools version to evaluate with. May be null</param>
        <summary>
            Construct over a text reader over project xml, evaluating with specified
            global properties and toolset, either or both of which may be null.
            Project will be added to the global project collection when it is named.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This project is added to the global project collection when it is given the full path to the source project file, typically by saving the project.  
  
 Throws InvalidProjectFileException if the evaluation fails. Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Build.Construction.ProjectRootElement xml, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Construction.ProjectRootElement,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xml As ProjectRootElement, globalProperties As IDictionary(Of String, String), toolsVersion As String, projectCollection As ProjectCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(Microsoft::Build::Construction::ProjectRootElement ^ xml, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : Microsoft.Build.Construction.ProjectRootElement * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xml, globalProperties, toolsVersion, projectCollection)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="xml" Type="Microsoft.Build.Construction.ProjectRootElement" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
      </Parameters>
      <Docs>
        <param name="xml">ProjectRootElement to use</param>
        <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
        <param name="toolsVersion">Tools version to evaluate with. May be null</param>
        <param name="projectCollection">The <see cref="P:Microsoft.Build.Evaluation.Project.ProjectCollection" /> the project is added to.</param>
        <summary>
            Construct over a ProjectRootElement object, evaluating with specified
            global properties and toolset, either or both of which may be null.
            Project is added to the global project collection if it has a name, or else when it is named.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This project is added to the given project collection when either this project or the given project root is given the full path to the source project file.  
  
 Throws InvalidProjectFileException if the evaluation fails. Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection, valuetype Microsoft.Build.Evaluation.NewProjectFileOptions newProjectFileOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.NewProjectFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (globalProperties As IDictionary(Of String, String), toolsVersion As String, projectCollection As ProjectCollection, newProjectFileOptions As NewProjectFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection, Microsoft::Build::Evaluation::NewProjectFileOptions newProjectFileOptions);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection * Microsoft.Build.Evaluation.NewProjectFileOptions -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (globalProperties, toolsVersion, projectCollection, newProjectFileOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="toolsVersion" Type="System.String" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" Index="2" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="newProjectFileOptions" Type="Microsoft.Build.Evaluation.NewProjectFileOptions" Index="3" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
        <param name="toolsVersion">Tools version to evaluate with. May be null</param>
        <param name="projectCollection">The <see cref="P:Microsoft.Build.Evaluation.Project.ProjectCollection" /> the project is added to.</param>
        <param name="newProjectFileOptions">The <see cref="T:Microsoft.Build.Evaluation.NewProjectFileOptions" /> to use for the new project.</param>
        <summary>
            Construct an empty project, evaluating with the specified project collection and
            the specified global properties and default tools version, either of which may be null.
            Project will be added to the specified project collection when it is named.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (string projectFile, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string projectFile, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (projectFile As String, globalProperties As IDictionary(Of String, String), toolsVersion As String, projectCollection As ProjectCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::String ^ projectFile, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : string * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (projectFile, globalProperties, toolsVersion, projectCollection)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="projectFile" Type="System.String" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
      </Parameters>
      <Docs>
        <param name="projectFile">The project file</param>
        <param name="globalProperties">The global properties. May be null.</param>
        <param name="toolsVersion">The tools version. May be null.</param>
        <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
        <summary>
            Construct over an existing project file, evaluating with the specified global properties and 
            using the tools version provided, either or both of which may be null.
            Project is added to the global project collection.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            May throw IO-related exceptions.
            </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The project is added to the given project collection.  
  
 Throws InvalidProjectFileException if the evaluation fails. Throws InvalidOperationException if there is already an equivalent project loaded in the project collection. May throw IO-related exceptions.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlReader xmlReader, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.Xml.XmlReader,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xmlReader As XmlReader, globalProperties As IDictionary(Of String, String), toolsVersion As String, projectCollection As ProjectCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::Xml::XmlReader ^ xmlReader, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : System.Xml.XmlReader * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xmlReader, globalProperties, toolsVersion, projectCollection)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
      </Parameters>
      <Docs>
        <param name="xmlReader">Xml reader to read project from</param>
        <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
        <param name="toolsVersion">Tools version to evaluate with. May be null</param>
        <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
        <summary>
            Construct over a text reader over project xml, evaluating with specified
            global properties and toolset, either or both of which may be null.
            Project will be added to the specified project collection when it is named.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This project is added to the given project collection when either this project or the given project root is given the full path to the source project file.  
  
 Throws InvalidProjectFileException if the evaluation fails. Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Build.Construction.ProjectRootElement xml, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection, valuetype Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Construction.ProjectRootElement,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.ProjectLoadSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xml As ProjectRootElement, globalProperties As IDictionary(Of String, String), toolsVersion As String, projectCollection As ProjectCollection, loadSettings As ProjectLoadSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(Microsoft::Build::Construction::ProjectRootElement ^ xml, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection, Microsoft::Build::Evaluation::ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : Microsoft.Build.Construction.ProjectRootElement * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection * Microsoft.Build.Evaluation.ProjectLoadSettings -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xml, globalProperties, toolsVersion, projectCollection, loadSettings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xml" Type="Microsoft.Build.Construction.ProjectRootElement" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
        <Parameter Name="loadSettings" Type="Microsoft.Build.Evaluation.ProjectLoadSettings" />
      </Parameters>
      <Docs>
        <param name="xml">ProjectRootElement to use</param>
        <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
        <param name="toolsVersion">Tools version to evaluate with. May be null</param>
        <param name="projectCollection">The <see cref="P:Microsoft.Build.Evaluation.Project.ProjectCollection" /> the project is added to.</param>
        <param name="loadSettings">The <see cref="T:Microsoft.Build.Evaluation.ProjectLoadSettings" /> to use for evaluation.</param>
        <summary>
            Construct over a ProjectRootElement object, evaluating with specified
            global properties and toolset, either or both of which may be null.
            Project is added to the global project collection if it has a name, or else when it is named.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This project is added to the given project collection when either this project or the given project root is given the full path to the source project file.  
  
 Throws InvalidProjectFileException if the evaluation fails. Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (string projectFile, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string projectFile, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection, valuetype Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.ProjectLoadSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (projectFile As String, globalProperties As IDictionary(Of String, String), toolsVersion As String, projectCollection As ProjectCollection, loadSettings As ProjectLoadSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::String ^ projectFile, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection, Microsoft::Build::Evaluation::ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : string * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection * Microsoft.Build.Evaluation.ProjectLoadSettings -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (projectFile, globalProperties, toolsVersion, projectCollection, loadSettings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="projectFile" Type="System.String" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
        <Parameter Name="loadSettings" Type="Microsoft.Build.Evaluation.ProjectLoadSettings" />
      </Parameters>
      <Docs>
        <param name="projectFile">The project file</param>
        <param name="globalProperties">The global properties. May be null.</param>
        <param name="toolsVersion">The tools version. May be null.</param>
        <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
        <param name="loadSettings">The load settings for this project.</param>
        <summary>
            Construct over an existing project file, evaluating with the specified global properties and 
            using the tools version provided, either or both of which may be null.
            Project is added to the global project collection.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            May throw IO-related exceptions.
            </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The project is added to the given project collection.  
  
 Throws InvalidProjectFileException if the evaluation fails. Throws InvalidOperationException if there is already an equivalent project loaded in the project collection. May throw IO-related exceptions.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlReader xmlReader, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection, valuetype Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.Xml.XmlReader,System.Collections.Generic.IDictionary{System.String,System.String},System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.ProjectLoadSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xmlReader As XmlReader, globalProperties As IDictionary(Of String, String), toolsVersion As String, projectCollection As ProjectCollection, loadSettings As ProjectLoadSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::Xml::XmlReader ^ xmlReader, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection, Microsoft::Build::Evaluation::ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : System.Xml.XmlReader * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * Microsoft.Build.Evaluation.ProjectCollection * Microsoft.Build.Evaluation.ProjectLoadSettings -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xmlReader, globalProperties, toolsVersion, projectCollection, loadSettings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" />
        <Parameter Name="toolsVersion" Type="System.String" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" />
        <Parameter Name="loadSettings" Type="Microsoft.Build.Evaluation.ProjectLoadSettings" />
      </Parameters>
      <Docs>
        <param name="xmlReader">Xml reader to read project from</param>
        <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
        <param name="toolsVersion">Tools version to evaluate with. May be null</param>
        <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
        <param name="loadSettings">The <see cref="T:Microsoft.Build.Evaluation.ProjectLoadSettings" /> to use for evaluation.</param>
        <summary>
            Construct over a text reader over project xml, evaluating with specified
            global properties and toolset, either or both of which may be null.
            Project will be added to the specified project collection when it is named.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This project is added to the given project collection when either this project or the given project root is given the full path to the source project file.  
  
 Throws InvalidProjectFileException if the evaluation fails. Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (Microsoft.Build.Construction.ProjectRootElement xml, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Build.Construction.ProjectRootElement xml, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, string subToolsetVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection, valuetype Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(Microsoft.Build.Construction.ProjectRootElement,System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.ProjectLoadSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xml As ProjectRootElement, globalProperties As IDictionary(Of String, String), toolsVersion As String, subToolsetVersion As String, projectCollection As ProjectCollection, loadSettings As ProjectLoadSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(Microsoft::Build::Construction::ProjectRootElement ^ xml, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, System::String ^ subToolsetVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection, Microsoft::Build::Evaluation::ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : Microsoft.Build.Construction.ProjectRootElement * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * string * Microsoft.Build.Evaluation.ProjectCollection * Microsoft.Build.Evaluation.ProjectLoadSettings -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xml, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xml" Type="Microsoft.Build.Construction.ProjectRootElement" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="toolsVersion" Type="System.String" Index="2" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="subToolsetVersion" Type="System.String" Index="3" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" Index="4" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="loadSettings" Type="Microsoft.Build.Evaluation.ProjectLoadSettings" Index="5" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="xml">ProjectRootElement to use</param>
        <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
        <param name="toolsVersion">Tools version to evaluate with. May be null</param>
        <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
        <param name="projectCollection">The <see cref="P:Microsoft.Build.Evaluation.Project.ProjectCollection" /> the project is added to.</param>
        <param name="loadSettings">The <see cref="T:Microsoft.Build.Evaluation.ProjectLoadSettings" /> to use for evaluation.</param>
        <summary>
            Construct over a ProjectRootElement object, evaluating with specified
            global properties and toolset, either or both of which may be null.
            Project is added to the global project collection if it has a name, or else when it is named.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This project is added to the given project collection when either this project or the given project root is given the full path to the source project file.  
  
 Throws InvalidProjectFileException if the evaluation fails. Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (string projectFile, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string projectFile, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, string subToolsetVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection, valuetype Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.ProjectLoadSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (projectFile As String, globalProperties As IDictionary(Of String, String), toolsVersion As String, subToolsetVersion As String, projectCollection As ProjectCollection, loadSettings As ProjectLoadSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::String ^ projectFile, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, System::String ^ subToolsetVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection, Microsoft::Build::Evaluation::ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : string * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * string * Microsoft.Build.Evaluation.ProjectCollection * Microsoft.Build.Evaluation.ProjectLoadSettings -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (projectFile, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="projectFile" Type="System.String" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="toolsVersion" Type="System.String" Index="2" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="subToolsetVersion" Type="System.String" Index="3" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" Index="4" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="loadSettings" Type="Microsoft.Build.Evaluation.ProjectLoadSettings" Index="5" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="projectFile">The project file</param>
        <param name="globalProperties">The global properties. May be null.</param>
        <param name="toolsVersion">The tools version. May be null.</param>
        <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
        <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
        <param name="loadSettings">The load settings for this project.</param>
        <summary>
            Construct over an existing project file, evaluating with the specified global properties and 
            using the tools version provided, either or both of which may be null.
            Project is added to the global project collection.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            May throw IO-related exceptions.
            </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The project is added to the given project collection.  
  
 Throws InvalidProjectFileException if the evaluation fails. Throws InvalidOperationException if there is already an equivalent project loaded in the project collection. May throw IO-related exceptions.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Project (System.Xml.XmlReader xmlReader, System.Collections.Generic.IDictionary&lt;string,string&gt; globalProperties, string toolsVersion, string subToolsetVersion, Microsoft.Build.Evaluation.ProjectCollection projectCollection, Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlReader xmlReader, class System.Collections.Generic.IDictionary`2&lt;string, string&gt; globalProperties, string toolsVersion, string subToolsetVersion, class Microsoft.Build.Evaluation.ProjectCollection projectCollection, valuetype Microsoft.Build.Evaluation.ProjectLoadSettings loadSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.#ctor(System.Xml.XmlReader,System.Collections.Generic.IDictionary{System.String,System.String},System.String,System.String,Microsoft.Build.Evaluation.ProjectCollection,Microsoft.Build.Evaluation.ProjectLoadSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xmlReader As XmlReader, globalProperties As IDictionary(Of String, String), toolsVersion As String, subToolsetVersion As String, projectCollection As ProjectCollection, loadSettings As ProjectLoadSettings)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Project(System::Xml::XmlReader ^ xmlReader, System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ globalProperties, System::String ^ toolsVersion, System::String ^ subToolsetVersion, Microsoft::Build::Evaluation::ProjectCollection ^ projectCollection, Microsoft::Build::Evaluation::ProjectLoadSettings loadSettings);" />
      <MemberSignature Language="F#" Value="new Microsoft.Build.Evaluation.Project : System.Xml.XmlReader * System.Collections.Generic.IDictionary&lt;string, string&gt; * string * string * Microsoft.Build.Evaluation.ProjectCollection * Microsoft.Build.Evaluation.ProjectLoadSettings -&gt; Microsoft.Build.Evaluation.Project" Usage="new Microsoft.Build.Evaluation.Project (xmlReader, globalProperties, toolsVersion, subToolsetVersion, projectCollection, loadSettings)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xmlReader" Type="System.Xml.XmlReader" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="globalProperties" Type="System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="toolsVersion" Type="System.String" Index="2" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="subToolsetVersion" Type="System.String" Index="3" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="projectCollection" Type="Microsoft.Build.Evaluation.ProjectCollection" Index="4" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="loadSettings" Type="Microsoft.Build.Evaluation.ProjectLoadSettings" Index="5" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="xmlReader">Xml reader to read project from</param>
        <param name="globalProperties">Global properties to evaluate with. May be null in which case the containing project collection's global properties will be used.</param>
        <param name="toolsVersion">Tools version to evaluate with. May be null</param>
        <param name="subToolsetVersion">Sub-toolset version to explicitly evaluate the toolset with.  May be null.</param>
        <param name="projectCollection">The collection with which this project should be associated. May not be null.</param>
        <param name="loadSettings">The load settings for this project.</param>
        <summary>
            Construct over a text reader over project xml, evaluating with specified
            global properties and toolset, either or both of which may be null.
            Project will be added to the specified project collection when it is named.
            Throws InvalidProjectFileException if the evaluation fails.
            Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.
            </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This project is added to the given project collection when either this project or the given project root is given the full path to the source project file.  
  
 Throws InvalidProjectFileException if the evaluation fails. Throws InvalidOperationException if there is already an equivalent project loaded in the project collection.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddItem">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adds an item.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddItem">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt; AddItem (string itemType, string unevaluatedInclude);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IList`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; AddItem(string itemType, string unevaluatedInclude) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.AddItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddItem (itemType As String, unevaluatedInclude As String) As IList(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ AddItem(System::String ^ itemType, System::String ^ unevaluatedInclude);" />
      <MemberSignature Language="F#" Value="member this.AddItem : string * string -&gt; System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="project.AddItem (itemType, unevaluatedInclude)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" />
        <Parameter Name="unevaluatedInclude" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="itemType">The item type of the added item.</param>
        <param name="unevaluatedInclude">Include attribute of the item to be added.</param>
        <summary>
            Adds an item with no metadata to the project.
            Any metadata can be added subsequently.
            Does not modify the XML if a wildcard expression would already include the new item.
            Evaluates on a best-effort basis:
                -expands with all items. Items that are defined in the XML below the new item may be used, even though in a real evaluation they would not be.
                -only this item is evaluated. Other items that might depend on it is not affected.
            This is a convenience that it is understood does not necessarily leave the project in a perfectly self consistent state until reevaluation.
            </summary>
        <returns>The added item.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Any metadata can be added later. Does not modify the project source if a wildcard expression already includes the new item.  
  
 Evaluation takes place on a best-effort basis. Items that are defined in the project source following the new item may be used for evaluation. Only this item is evaluated. Other items that might depend on it are not affected.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddItem">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt; AddItem (string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,string&gt;&gt; metadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IList`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; AddItem(string itemType, string unevaluatedInclude, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, string&gt;&gt; metadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.AddItem(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddItem (itemType As String, unevaluatedInclude As String, metadata As IEnumerable(Of KeyValuePair(Of String, String))) As IList(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ AddItem(System::String ^ itemType, System::String ^ unevaluatedInclude, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::String ^&gt;&gt; ^ metadata);" />
      <MemberSignature Language="F#" Value="member this.AddItem : string * string * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, string&gt;&gt; -&gt; System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="project.AddItem (itemType, unevaluatedInclude, metadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" />
        <Parameter Name="unevaluatedInclude" Type="System.String" />
        <Parameter Name="metadata" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.String&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="itemType">The item type of the added item.</param>
        <param name="unevaluatedInclude">Include attribute of the item to be added.</param>
        <param name="metadata">The metadata of the added item.</param>
        <summary>
            Adds an item with metadata to the project.
            Metadata may be null, indicating no metadata.
            Does not modify the XML if a wildcard expression would already include the new item.
            Evaluates on a best-effort basis:
                -expands with all items. Items that are defined in the XML below the new item may be used, even though in a real evaluation they would not be.
                -only this item is evaluated. Other items that might depend on it is not affected.
            This is a convenience that it is understood does not necessarily leave the project in a perfectly self consistent state until reevaluation.
            </summary>
        <returns>The added item.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The metadata may be null, which indicates no metadata.  
  
 Evaluation takes place on a best-effort basis. Items that are defined in the project source following the new item may be used for evaluation. Only this item is evaluated. Other items that might depend on it are not affected.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddItemFast">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adds an item with no metadata to the project.  Makes no effort to see if an existing wildcard would already match the new item, unless it is the first item in an item group.  Makes no effort to locate the new item near similar items.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddItemFast">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt; AddItemFast (string itemType, string unevaluatedInclude);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IList`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; AddItemFast(string itemType, string unevaluatedInclude) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.AddItemFast(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddItemFast (itemType As String, unevaluatedInclude As String) As IList(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ AddItemFast(System::String ^ itemType, System::String ^ unevaluatedInclude);" />
      <MemberSignature Language="F#" Value="member this.AddItemFast : string * string -&gt; System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="project.AddItemFast (itemType, unevaluatedInclude)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" />
        <Parameter Name="unevaluatedInclude" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="itemType">The item type to be added.</param>
        <param name="unevaluatedInclude">The unevaluated Include attribute to be added to the item.</param>
        <summary>
            Adds an item with no metadata to the project.
            Makes no effort to see if an existing wildcard would already match the new item, unless it is the first item in an item group.
            Makes no effort to locate the new item near similar items.
            Appends the item to the first item group that does not have a condition and has either no children or whose first child is an item of the same type.
            Evaluates on a best-effort basis:
                -expands with all items. Items that are defined in the XML below the new item may be used, even though in a real evaluation they would not be.
                -only this item is evaluated. Other items that might depend on it is not affected.
            This is a convenience that it is understood does not necessarily leave the project in a perfectly self consistent state until reevaluation.
            </summary>
        <returns>A list of the project items added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appends the item to the first item group that does not have a condition and has either no children or whose first child is an item of the same type.  
  
 Evaluates on a best-effort basis: -expands with all items. Items that are defined in the XML below the new item may be used, even though in a real evaluation they would not be.  
  
 Only this item is evaluated. Other items that might depend on it are not affected.  
  
 This is a convenience that it is understood does not necessarily leave the project in a perfectly self consistent state until reevaluation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddItemFast">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt; AddItemFast (string itemType, string unevaluatedInclude, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,string&gt;&gt; metadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IList`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; AddItemFast(string itemType, string unevaluatedInclude, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, string&gt;&gt; metadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.AddItemFast(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddItemFast (itemType As String, unevaluatedInclude As String, metadata As IEnumerable(Of KeyValuePair(Of String, String))) As IList(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ AddItemFast(System::String ^ itemType, System::String ^ unevaluatedInclude, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::String ^&gt;&gt; ^ metadata);" />
      <MemberSignature Language="F#" Value="member this.AddItemFast : string * string * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, string&gt;&gt; -&gt; System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="project.AddItemFast (itemType, unevaluatedInclude, metadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" />
        <Parameter Name="unevaluatedInclude" Type="System.String" />
        <Parameter Name="metadata" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.String&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="itemType">The item type to be added.</param>
        <param name="unevaluatedInclude">The unevaluated Include attribute to be added to the item.</param>
        <param name="metadata">The metadata to be added.</param>
        <summary>
            Adds an item with metadata to the project.
            Metadata may be null, indicating no metadata.
            Makes no effort to see if an existing wildcard would already match the new item, unless it is the first item in an item group.
            Makes no effort to locate the new item near similar items.
            Appends the item to the first item group that does not have a condition and has either no children or whose first child is an item of the same type.
            Evaluates on a best-effort basis:
                -expands with all items. Items that are defined in the XML below the new item may be used, even though in a real evaluation they would not be.
                -only this item is evaluated. Other items that might depend on it is not affected.
            This is a convenience that it is understood does not necessarily leave the project in a perfectly self consistent state until reevaluation.
            </summary>
        <returns>A list of the project items added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Appends the item to the first item group that does not have a condition and has either no children or whose first child is an item of the same type.  
  
 Evaluates on a best-effort basis: -expands with all items. Items that are defined in the XML below the new item may be used, even though in a real evaluation they would not be.  
  
 Only this item is evaluated. Other items that might depend on it is not affected.  
  
 This is a convenience that it is understood does not necessarily leave the project in a perfectly self consistent state until reevaluation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllEvaluatedItemDefinitionMetadata">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectMetadata&gt; AllEvaluatedItemDefinitionMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectMetadata&gt; AllEvaluatedItemDefinitionMetadata" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.AllEvaluatedItemDefinitionMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllEvaluatedItemDefinitionMetadata As ICollection(Of ProjectMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectMetadata ^&gt; ^ AllEvaluatedItemDefinitionMetadata { System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectMetadata ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllEvaluatedItemDefinitionMetadata : System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectMetadata&gt;" Usage="Microsoft.Build.Evaluation.Project.AllEvaluatedItemDefinitionMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectMetadata&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Item definition metadata encountered during evaluation. These are read during the second evaluation pass.
            Unlike those returned by the ItemDefinitions property, these are ordered, and include any metadata that
            were subsequently overridden by others with the same name and item type. It does not include any 
            elements whose conditions did not evaluate to true.
            It does not include any item definition metadata added since the last evaluation.
            </summary>
        <value>All item definition metadata encountered during evaluation. This does not include any elements whose conditions did not evaluate to true, nor any item definition metadata added since the last evaluation.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Item metadata is read during the second evaluation pass. Unlike metadata returned by the ItemDefinitions property, this metadata is ordered, and includes any metadata subsequently overridden with the same name and item type.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllEvaluatedItems">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt; AllEvaluatedItems { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; AllEvaluatedItems" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.AllEvaluatedItems" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllEvaluatedItems As ICollection(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ AllEvaluatedItems { System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllEvaluatedItems : System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="Microsoft.Build.Evaluation.Project.AllEvaluatedItems" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Items encountered during evaluation. These are read during the third evaluation pass.
            Unlike those returned by the Items property, these are ordered with respect to all other items 
            encountered during evaluation, not just ordered with respect to items of the same item type.
            In some applications, like the F# language, this complete mutual ordering is significant, and such hosts
            can use this property.
            It does not include any elements whose conditions did not evaluate to true.
            It does not include any items added since the last evaluation.
            </summary>
        <value>An enumerator over all items encountered during evaluation. These are read during the third evaluation pass.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unlike those items returned by the Items property, these are ordered with respect to all other items encountered during evaluation, not just ordered with respect to items of the same item type.  
  
 In some applications, this complete mutual ordering is significant, and such hosts can use this property.  
  
 The enumeration does not include any elements whose conditions did not evaluate to true, nor does it include any items added since the last evaluation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllEvaluatedProperties">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectProperty&gt; AllEvaluatedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectProperty&gt; AllEvaluatedProperties" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.AllEvaluatedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AllEvaluatedProperties As ICollection(Of ProjectProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectProperty ^&gt; ^ AllEvaluatedProperties { System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectProperty ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AllEvaluatedProperties : System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectProperty&gt;" Usage="Microsoft.Build.Evaluation.Project.AllEvaluatedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectProperty&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Properties encountered during evaluation. These are read during the first evaluation pass.
            Unlike those returned by the Properties property, these are ordered, and includes any properties that
            were subsequently overridden by others with the same name. It does not include any 
            properties whose conditions did not evaluate to true.
            It does not include any properties added since the last evaluation.
            </summary>
        <value>All properties encountered during evaluation. This does not include any properties whose conditions did not evaluate to true, nor any properties added since the last evaluation.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 These properties are read during the first evaluation pass. Unlike properties returned by the Properties property, these are ordered, and includes any properties subsequently overridden with the same name.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Build">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Builds this project, using the default targets.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build" />
      <MemberSignature Language="VB.NET" Value="Public Function Build () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build();" />
      <MemberSignature Language="F#" Value="member this.Build : unit -&gt; bool" Usage="project.Build " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Starts a build using this project, building the default targets.
            Returns true on success, false on failure.
            Works on a privately cloned instance. To set or get
            virtual items for build purposes, clone an instance explicitly and build that.
            Does not modify the Project object.
            </summary>
        <returns>
          <see langword="true" /> on success; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To set or get virtual items for build purposes, clone a project instance explicitly and build that. This method does not modify the project object.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (Microsoft.Build.Framework.ILogger logger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(class Microsoft.Build.Framework.ILogger logger) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(Microsoft.Build.Framework.ILogger)" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (logger As ILogger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(Microsoft::Build::Framework::ILogger ^ logger);" />
      <MemberSignature Language="F#" Value="member this.Build : Microsoft.Build.Framework.ILogger -&gt; bool" Usage="project.Build logger" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logger" Type="Microsoft.Build.Framework.ILogger" />
      </Parameters>
      <Docs>
        <param name="logger">The logger to be used during the build.</param>
        <summary>
            Starts a build using this project, building the default targets and the specified logger.
            Returns true on success, false on failure.
            Works on a privately cloned instance. To set or get
            virtual items for build purposes, clone an instance explicitly and build that.
            Does not modify the Project object.
            </summary>
        <returns>
          <see langword="true" /> on success; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To set or get virtual items for build purposes, clone a project instance explicitly and build that. This method does not modify the project object.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt; loggers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Framework.ILogger&gt; loggers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger})" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (loggers As IEnumerable(Of ILogger)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ loggers);" />
      <MemberSignature Language="F#" Value="member this.Build : seq&lt;Microsoft.Build.Framework.ILogger&gt; -&gt; bool" Usage="project.Build loggers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt;" />
      </Parameters>
      <Docs>
        <param name="loggers">An enumerator over all loggers to be used during the build.</param>
        <summary>
            Starts a build using this project, building the default targets and the specified loggers.
            Returns true on success, false on failure.
            Works on a privately cloned instance. To set or get
            virtual items for build purposes, clone an instance explicitly and build that.
            Does not modify the Project object.
            </summary>
        <returns>
          <see langword="true" /> on success; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To set or get virtual items for build purposes, clone a project instance explicitly and build that. This method does not modify the project object.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (string target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(string target) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (target As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(System::String ^ target);" />
      <MemberSignature Language="F#" Value="member this.Build : string -&gt; bool" Usage="project.Build target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">The target to be built.</param>
        <summary>
            Starts a build using this project, building the specified target.
            Returns true on success, false on failure.
            Works on a privately cloned instance. To set or get
            virtual items for build purposes, clone an instance explicitly and build that.
            Does not modify the Project object.
            </summary>
        <returns>
          <see langword="true" /> on success; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To set or get virtual items for build purposes, clone a project instance explicitly and build that. This method does not modify the project object.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (string[] targets);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(string[] targets) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (targets As String()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(cli::array &lt;System::String ^&gt; ^ targets);" />
      <MemberSignature Language="F#" Value="member this.Build : string[] -&gt; bool" Usage="project.Build targets" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targets" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="targets">An array of targets to be built.</param>
        <summary>
            Starts a build using this project, building the specified targets.
            Returns true on success, false on failure.
            Works on a privately cloned instance. To set or get
            virtual items for build purposes, clone an instance explicitly and build that.
            Does not modify the Project object.
            </summary>
        <returns>
          <see langword="true" /> on success; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To set or get virtual items for build purposes, clone a project instance explicitly and build that. This method does not modify the project object.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt; loggers, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Framework.ILogger&gt; loggers, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord})" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (loggers As IEnumerable(Of ILogger), remoteLoggers As IEnumerable(Of ForwardingLoggerRecord)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ loggers, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Logging::ForwardingLoggerRecord ^&gt; ^ remoteLoggers);" />
      <MemberSignature Language="F#" Value="member this.Build : seq&lt;Microsoft.Build.Framework.ILogger&gt; * seq&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; -&gt; bool" Usage="project.Build (loggers, remoteLoggers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="loggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt;" />
        <Parameter Name="remoteLoggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt;" />
      </Parameters>
      <Docs>
        <param name="loggers">The loggers to be used during the build.</param>
        <param name="remoteLoggers">The remote loggers to be used during the build.</param>
        <summary>
            Starts a build using this project, building the default targets and the specified loggers.
            Returns true on success, false on failure.
            Works on a privately cloned instance. To set or get
            virtual items for build purposes, clone an instance explicitly and build that.
            Does not modify the Project object.
            </summary>
        <returns>
          <see langword="true" /> on success; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To set or get virtual items for build purposes, clone a project instance explicitly and build that. This method does not modify the project object.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (string target, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt; loggers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(string target, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Framework.ILogger&gt; loggers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.String,System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger})" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (target As String, loggers As IEnumerable(Of ILogger)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(System::String ^ target, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ loggers);" />
      <MemberSignature Language="F#" Value="member this.Build : string * seq&lt;Microsoft.Build.Framework.ILogger&gt; -&gt; bool" Usage="project.Build (target, loggers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="loggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt;" />
      </Parameters>
      <Docs>
        <param name="target">The target to be built.</param>
        <param name="loggers">The loggers to be used during the build.</param>
        <summary>
            Starts a build using this project, building the specified target with the specified loggers.
            Returns true on success, false on failure.
            Works on a privately cloned instance. To set or get
            virtual items for build purposes, clone an instance explicitly and build that.
            Does not modify the Project object.
            </summary>
        <returns>
          <see langword="true" /> on success; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To set or get virtual items for build purposes, clone a project instance explicitly and build that. This method does not modify the project object.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (string[] targets, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt; loggers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(string[] targets, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Framework.ILogger&gt; loggers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.String[],System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger})" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (targets As String(), loggers As IEnumerable(Of ILogger)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(cli::array &lt;System::String ^&gt; ^ targets, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ loggers);" />
      <MemberSignature Language="F#" Value="member this.Build : string[] * seq&lt;Microsoft.Build.Framework.ILogger&gt; -&gt; bool" Usage="project.Build (targets, loggers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targets" Type="System.String[]" />
        <Parameter Name="loggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt;" />
      </Parameters>
      <Docs>
        <param name="targets">The targets to be built.</param>
        <param name="loggers">The loggers to be used during the build.</param>
        <summary>
            Starts a build using this project, building the specified targets with the specified loggers.
            Returns true on success, false on failure.
            If build is disabled on this project, does not build, and returns false.
            Works on a privately cloned instance. To set or get
            virtual items for build purposes, clone an instance explicitly and build that.
            Does not modify the Project object.
            </summary>
        <returns>
          <see langword="true" /> on success; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To set or get virtual items for build purposes, clone a project instance explicitly and build that. This method does not modify the project object.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (string target, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt; loggers, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(string target, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Framework.ILogger&gt; loggers, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.String,System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord})" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (target As String, loggers As IEnumerable(Of ILogger), remoteLoggers As IEnumerable(Of ForwardingLoggerRecord)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(System::String ^ target, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ loggers, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Logging::ForwardingLoggerRecord ^&gt; ^ remoteLoggers);" />
      <MemberSignature Language="F#" Value="member this.Build : string * seq&lt;Microsoft.Build.Framework.ILogger&gt; * seq&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; -&gt; bool" Usage="project.Build (target, loggers, remoteLoggers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="loggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt;" />
        <Parameter Name="remoteLoggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt;" />
      </Parameters>
      <Docs>
        <param name="target">The target to be built.</param>
        <param name="loggers">The loggers to be used during the build.</param>
        <param name="remoteLoggers">The remote loggers to be used during the build.</param>
        <summary>
            Starts a build using this project, building the specified target with the specified loggers.
            Returns true on success, false on failure.
            Works on a privately cloned instance. To set or get
            virtual items for build purposes, clone an instance explicitly and build that.
            Does not modify the Project object.
            </summary>
        <returns>
          <see langword="true" /> on success; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To set or get virtual items for build purposes, clone a project instance explicitly and build that. This method does not modify the project object.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (string[] targets, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt; loggers, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(string[] targets, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Framework.ILogger&gt; loggers, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.String[],System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord})" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (targets As String(), loggers As IEnumerable(Of ILogger), remoteLoggers As IEnumerable(Of ForwardingLoggerRecord)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(cli::array &lt;System::String ^&gt; ^ targets, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ loggers, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Logging::ForwardingLoggerRecord ^&gt; ^ remoteLoggers);" />
      <MemberSignature Language="F#" Value="member this.Build : string[] * seq&lt;Microsoft.Build.Framework.ILogger&gt; * seq&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; -&gt; bool" Usage="project.Build (targets, loggers, remoteLoggers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targets" Type="System.String[]" />
        <Parameter Name="loggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt;" />
        <Parameter Name="remoteLoggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt;" />
      </Parameters>
      <Docs>
        <param name="targets">The targets to be built.</param>
        <param name="loggers">The loggers to be used during the build.</param>
        <param name="remoteLoggers">The remote loggers to be used during the build.</param>
        <summary>
            Starts a build using this project, building the specified targets with the specified loggers.
            Returns true on success, false on failure.
            If build is disabled on this project, does not build, and returns false.
            Works on a privately cloned instance. To set or get
            virtual items for build purposes, clone an instance explicitly and build that.
            Does not modify the Project object.
            </summary>
        <returns>
          <see langword="true" /> on success; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 To set or get virtual items for build purposes, clone a project instance explicitly and build that. This method does not modify the project object.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Build">
      <MemberSignature Language="C#" Value="public bool Build (string[] targets, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt; loggers, System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Build(string[] targets, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Framework.ILogger&gt; loggers, class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Logging.ForwardingLoggerRecord&gt; remoteLoggers, class Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Build(System.String[],System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord},Microsoft.Build.Evaluation.Context.EvaluationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function Build (targets As String(), loggers As IEnumerable(Of ILogger), remoteLoggers As IEnumerable(Of ForwardingLoggerRecord), evaluationContext As EvaluationContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Build(cli::array &lt;System::String ^&gt; ^ targets, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Framework::ILogger ^&gt; ^ loggers, System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Logging::ForwardingLoggerRecord ^&gt; ^ remoteLoggers, Microsoft::Build::Evaluation::Context::EvaluationContext ^ evaluationContext);" />
      <MemberSignature Language="F#" Value="member this.Build : string[] * seq&lt;Microsoft.Build.Framework.ILogger&gt; * seq&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt; * Microsoft.Build.Evaluation.Context.EvaluationContext -&gt; bool" Usage="project.Build (targets, loggers, remoteLoggers, evaluationContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targets" Type="System.String[]" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="loggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Framework.ILogger&gt;" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="remoteLoggers" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Logging.ForwardingLoggerRecord&gt;" Index="2" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="evaluationContext" Type="Microsoft.Build.Evaluation.Context.EvaluationContext" Index="3" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="targets">To be added.</param>
        <param name="loggers">To be added.</param>
        <param name="remoteLoggers">To be added.</param>
        <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
        <summary>
            See <see cref="M:Microsoft.Build.Evaluation.Project.Build(System.String[],System.Collections.Generic.IEnumerable{Microsoft.Build.Framework.ILogger},System.Collections.Generic.IEnumerable{Microsoft.Build.Logging.ForwardingLoggerRecord})" /></summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConditionedProperties">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,System.Collections.Generic.List&lt;string&gt;&gt; ConditionedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, class System.Collections.Generic.List`1&lt;string&gt;&gt; ConditionedProperties" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ConditionedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ConditionedProperties As IDictionary(Of String, List(Of String))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, System::Collections::Generic::List&lt;System::String ^&gt; ^&gt; ^ ConditionedProperties { System::Collections::Generic::IDictionary&lt;System::String ^, System::Collections::Generic::List&lt;System::String ^&gt; ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ConditionedProperties : System.Collections.Generic.IDictionary&lt;string, System.Collections.Generic.List&lt;string&gt;&gt;" Usage="Microsoft.Build.Evaluation.Project.ConditionedProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="msbuild-15;msbuild-15-netcore;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Collections.Generic.List&lt;System.String&gt;&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Collection of possible values implied for properties contained in the conditions found on properties,
            property groups, imports, and whens.
            
            For example, if the following conditions existed on properties in a project:
            
            Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'"
            Condition="'$(Configuration)' == 'Release'"
            
            the table would be populated with
            
            { "Configuration", { "Debug", "Release" }}
            { "Platform", { "x86" }}
            
            This is used by Visual Studio to determine the configurations defined in the project.
            </summary>
        <value>A collection of possible property values for properties used to evaluate conditions found on properties, property groups, imports, and whens. The collection is in canonical form. The name of the entry is the name of the property to be evaluated, and the value is a list of possible property values.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 For example, if the following conditions existed on properties in a project: Condition="'$(Configuration)&#124;$(Platform)' == 'Debug&#124;x86'" Condition="'$(Configuration)' == 'Release'" the table would be populated with { "Configuration", { "Debug", "Release" }} { "Platform", { "x86" }} This collection is used by Visual Studio to determine the configurations defined in the project  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateProjectInstance">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a project instance based on this project, but completely disconnected from it.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Can be used to build independently. The original project is evaluated before creating the instance, if necessary, so that the original project is marked as unmodified.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateProjectInstance">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Execution.ProjectInstance CreateProjectInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Execution.ProjectInstance CreateProjectInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.CreateProjectInstance" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateProjectInstance () As ProjectInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Execution::ProjectInstance ^ CreateProjectInstance();" />
      <MemberSignature Language="F#" Value="member this.CreateProjectInstance : unit -&gt; Microsoft.Build.Execution.ProjectInstance" Usage="project.CreateProjectInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.ProjectInstance</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Returns an instance based on this project, but completely disconnected.
            This instance can be used to build independently.
            Before creating the instance, this will reevaluate the project if necessary, so it will not be dirty.
            </summary>
        <returns>The project instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Can be used to build independently. The original project is evaluated before creating the instance, if necessary, so that the original project is marked as unmodified.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateProjectInstance">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Execution.ProjectInstance CreateProjectInstance (Microsoft.Build.Execution.ProjectInstanceSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Execution.ProjectInstance CreateProjectInstance(valuetype Microsoft.Build.Execution.ProjectInstanceSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateProjectInstance (settings As ProjectInstanceSettings) As ProjectInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Execution::ProjectInstance ^ CreateProjectInstance(Microsoft::Build::Execution::ProjectInstanceSettings settings);" />
      <MemberSignature Language="F#" Value="member this.CreateProjectInstance : Microsoft.Build.Execution.ProjectInstanceSettings -&gt; Microsoft.Build.Execution.ProjectInstance" Usage="project.CreateProjectInstance settings" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.ProjectInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="settings" Type="Microsoft.Build.Execution.ProjectInstanceSettings" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="settings">Determines whether created project instance is immutable and whether it contains a look up table to improve performance.</param>
        <summary>
            Returns an instance based on this project, but completely disconnected.
            This instance can be used to build independently.
            Before creating the instance, this will reevaluate the project if necessary, so it will not be dirty.
            The instance is immutable; none of the objects that form it can be modified. This makes it safe to 
            access concurrently from multiple threads.
            </summary>
        <returns>The project instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Can be used to build independently. The original project is evaluated before creating the instance, if necessary, so that the original project is marked as unmodified.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateProjectInstance">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Execution.ProjectInstance CreateProjectInstance (Microsoft.Build.Execution.ProjectInstanceSettings settings, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Execution.ProjectInstance CreateProjectInstance(valuetype Microsoft.Build.Execution.ProjectInstanceSettings settings, class Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings,Microsoft.Build.Evaluation.Context.EvaluationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateProjectInstance (settings As ProjectInstanceSettings, evaluationContext As EvaluationContext) As ProjectInstance" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Execution::ProjectInstance ^ CreateProjectInstance(Microsoft::Build::Execution::ProjectInstanceSettings settings, Microsoft::Build::Evaluation::Context::EvaluationContext ^ evaluationContext);" />
      <MemberSignature Language="F#" Value="member this.CreateProjectInstance : Microsoft.Build.Execution.ProjectInstanceSettings * Microsoft.Build.Evaluation.Context.EvaluationContext -&gt; Microsoft.Build.Execution.ProjectInstance" Usage="project.CreateProjectInstance (settings, evaluationContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Execution.ProjectInstance</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="settings" Type="Microsoft.Build.Execution.ProjectInstanceSettings" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="evaluationContext" Type="Microsoft.Build.Evaluation.Context.EvaluationContext" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="settings">To be added.</param>
        <param name="evaluationContext">The evaluation context to use in case reevaluation is required</param>
        <summary>
            See <see cref="M:Microsoft.Build.Evaluation.Project.CreateProjectInstance(Microsoft.Build.Execution.ProjectInstanceSettings)" /></summary>
        <returns />
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DirectoryPath">
      <MemberSignature Language="C#" Value="public string DirectoryPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DirectoryPath" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.DirectoryPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DirectoryPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DirectoryPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DirectoryPath : string" Usage="Microsoft.Build.Evaluation.Project.DirectoryPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The root directory for this project.
            Is never null: in-memory projects use the current directory from the time of load.
            </summary>
        <value>The root directory for this project. The root directory is never null; in-memory projects use the current directory at the time of project load.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableMarkDirty">
      <MemberSignature Language="C#" Value="public bool DisableMarkDirty { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisableMarkDirty" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.DisableMarkDirty" />
      <MemberSignature Language="VB.NET" Value="Public Property DisableMarkDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisableMarkDirty { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisableMarkDirty : bool with get, set" Usage="Microsoft.Build.Evaluation.Project.DisableMarkDirty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="msbuild-16;msbuild-16-netcore">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="msbuild-16;msbuild-16-netcore">
          <AttributeName Language="C#">[set: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Whether <see cref="M:Microsoft.Build.Evaluation.Project.MarkDirty">MarkDirty()</see> is temporarily disabled.
            This allows, for example, a global property to be set without the project getting
            marked dirty for reevaluation as a consequence.
            </summary>
        <value>
          <see langword="true" /> to indicate <see langword="MarkDirty" /> is temporarily disabled; otherwise, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EvaluationCounter">
      <MemberSignature Language="C#" Value="public int EvaluationCounter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 EvaluationCounter" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.EvaluationCounter" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EvaluationCounter As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int EvaluationCounter { int get(); };" />
      <MemberSignature Language="F#" Value="member this.EvaluationCounter : int" Usage="Microsoft.Build.Evaluation.Project.EvaluationCounter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Obsolete. Use <see cref="P:Microsoft.Build.Evaluation.Project.LastEvaluationId" /> instead.
            </summary>
        <value>The incremented value.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This value should be compared with previous values to see if the project has been re-evaluated. It should not be used to determine how many times the project has been re-evaluated since it may be incremented by more than one for a given re-evaluation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpandString">
      <MemberSignature Language="C#" Value="public string ExpandString (string unexpandedValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ExpandString(string unexpandedValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.ExpandString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExpandString (unexpandedValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ExpandString(System::String ^ unexpandedValue);" />
      <MemberSignature Language="F#" Value="member this.ExpandString : string -&gt; string" Usage="project.ExpandString unexpandedValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unexpandedValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="unexpandedValue">The string to be evaluated.</param>
        <summary>
            Evaluates the provided string by expanding items and properties,
            as if it was found at the very end of the project file.
            This is useful for some hosts for which this kind of best-effort
            evaluation is sufficient.
            Does not expand bare metadata expressions.
            </summary>
        <returns>The evaluated string.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This method can be used when best-effort evaluation is sufficient.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromFile">
      <MemberSignature Language="C#" Value="public static Microsoft.Build.Evaluation.Project FromFile (string file, Microsoft.Build.Definition.ProjectOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Build.Evaluation.Project FromFile(string file, class Microsoft.Build.Definition.ProjectOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.FromFile(System.String,Microsoft.Build.Definition.ProjectOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromFile (file As String, options As ProjectOptions) As Project" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Build::Evaluation::Project ^ FromFile(System::String ^ file, Microsoft::Build::Definition::ProjectOptions ^ options);" />
      <MemberSignature Language="F#" Value="static member FromFile : string * Microsoft.Build.Definition.ProjectOptions -&gt; Microsoft.Build.Evaluation.Project" Usage="Microsoft.Build.Evaluation.Project.FromFile (file, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.Project</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="file" Type="System.String" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="options" Type="Microsoft.Build.Definition.ProjectOptions" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="file">The file to evaluate the project from.</param>
        <param name="options">The <see cref="T:Microsoft.Build.Definition.ProjectOptions" /> to use.</param>
        <summary>
            Create a file based project.
            </summary>
        <returns />
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromProjectRootElement">
      <MemberSignature Language="C#" Value="public static Microsoft.Build.Evaluation.Project FromProjectRootElement (Microsoft.Build.Construction.ProjectRootElement rootElement, Microsoft.Build.Definition.ProjectOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Build.Evaluation.Project FromProjectRootElement(class Microsoft.Build.Construction.ProjectRootElement rootElement, class Microsoft.Build.Definition.ProjectOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.FromProjectRootElement(Microsoft.Build.Construction.ProjectRootElement,Microsoft.Build.Definition.ProjectOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromProjectRootElement (rootElement As ProjectRootElement, options As ProjectOptions) As Project" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Build::Evaluation::Project ^ FromProjectRootElement(Microsoft::Build::Construction::ProjectRootElement ^ rootElement, Microsoft::Build::Definition::ProjectOptions ^ options);" />
      <MemberSignature Language="F#" Value="static member FromProjectRootElement : Microsoft.Build.Construction.ProjectRootElement * Microsoft.Build.Definition.ProjectOptions -&gt; Microsoft.Build.Evaluation.Project" Usage="Microsoft.Build.Evaluation.Project.FromProjectRootElement (rootElement, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.Project</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootElement" Type="Microsoft.Build.Construction.ProjectRootElement" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="options" Type="Microsoft.Build.Definition.ProjectOptions" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="rootElement">The <see cref="T:Microsoft.Build.Construction.ProjectRootElement" /> to evaluate the project from.</param>
        <param name="options">The <see cref="T:Microsoft.Build.Definition.ProjectOptions" /> to use.</param>
        <summary>
            Create a <see cref="T:Microsoft.Build.Construction.ProjectRootElement" /> based project.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromXmlReader">
      <MemberSignature Language="C#" Value="public static Microsoft.Build.Evaluation.Project FromXmlReader (System.Xml.XmlReader reader, Microsoft.Build.Definition.ProjectOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class Microsoft.Build.Evaluation.Project FromXmlReader(class System.Xml.XmlReader reader, class Microsoft.Build.Definition.ProjectOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.FromXmlReader(System.Xml.XmlReader,Microsoft.Build.Definition.ProjectOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromXmlReader (reader As XmlReader, options As ProjectOptions) As Project" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::Build::Evaluation::Project ^ FromXmlReader(System::Xml::XmlReader ^ reader, Microsoft::Build::Definition::ProjectOptions ^ options);" />
      <MemberSignature Language="F#" Value="static member FromXmlReader : System.Xml.XmlReader * Microsoft.Build.Definition.ProjectOptions -&gt; Microsoft.Build.Evaluation.Project" Usage="Microsoft.Build.Evaluation.Project.FromXmlReader (reader, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.Project</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="options" Type="Microsoft.Build.Definition.ProjectOptions" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="reader">The <see cref="T:System.Xml.XmlReader" /> to evaluate the project from.</param>
        <param name="options">The <see cref="T:Microsoft.Build.Definition.ProjectOptions" /> to use.</param>
        <summary>
            Create a <see cref="T:System.Xml.XmlReader" /> based project.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullPath">
      <MemberSignature Language="C#" Value="public string FullPath { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullPath" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.FullPath" />
      <MemberSignature Language="VB.NET" Value="Public Property FullPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FullPath { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.FullPath : string with get, set" Usage="Microsoft.Build.Evaluation.Project.FullPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[set: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The full path to this project's file.
            May be null, if the project was not loaded from disk.
            Setter renames the project, if it already had a name.
            </summary>
        <value>The full path to the project source file, or an empty string if the project was not loaded from disk.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Setting this property on a project in a project collection renames the project.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllGlobs">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt; GetAllGlobs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;class Microsoft.Build.Evaluation.GlobResult&gt; GetAllGlobs() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetAllGlobs" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllGlobs () As List(Of GlobResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;Microsoft::Build::Evaluation::GlobResult ^&gt; ^ GetAllGlobs();" />
      <MemberSignature Language="F#" Value="member this.GetAllGlobs : unit -&gt; System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt;" Usage="project.GetAllGlobs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
             Finds all the globs specified in item includes.
             </summary>
        <returns>
             List of <see cref="T:Microsoft.Build.Evaluation.GlobResult" />.
             </returns>
        <remarks>
          <see cref="P:Microsoft.Build.Evaluation.GlobResult.MsBuildGlob" /> is a <see cref="T:Microsoft.Build.Globbing.IMSBuildGlob" /> that combines all globs in the include element and ignores
             all the fragments in the exclude attribute and all the fragments in all Remove elements that apply to the include element.
             
             Users can construct a composite glob that incorporates all the globs in the Project:
             <code>
             var uberGlob = new CompositeGlob(project.GetAllGlobs().Select(r =&gt; r.MSBuildGlob).ToArray());
             uberGlob.IsMatch("foo.cs");
             </code></remarks>
        <example>
          <code>
            <P>*.txt</P>
            <Bar Include="bar" /> (both outside and inside project cone)
            <Zar Include="C:\**\*.foo" /> (both outside and inside project cone)
            <Foo Include="*.a;*.b" Exclude="3.a" /><Foo Remove="2.a" /><Foo Include="**\*.b" Exclude="1.b;**\obj\*.b;**\bar\*.b" /><Foo Include="$(P)" /><Foo Include="*.a;@(Bar);3.a" /> (If Bar has globs, they will have been included when querying Bar ProjectItems for globs)
            <Foo Include="*.cs" Exclude="@(Bar)" /></code>
             
            Example result: 
            [
            GlobResult(glob: "C:\**\*.foo", exclude: []),
            GlobResult(glob: ["*.a", "*.b"], exclude=["3.a"], remove=["2.a"]),
            GlobResult(glob: "**\*.b", exclude=["1.b, **\obj\*.b", **\bar\*.b"]),
            GlobResult(glob: "*.txt", exclude=[]),
            GlobResult(glob: "*.a", exclude=[]),
            GlobResult(glob: "*.cs", exclude=["bar"])
            ]
             </example>
      </Docs>
    </Member>
    <Member MemberName="GetAllGlobs">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt; GetAllGlobs (Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;class Microsoft.Build.Evaluation.GlobResult&gt; GetAllGlobs(class Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetAllGlobs(Microsoft.Build.Evaluation.Context.EvaluationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllGlobs (evaluationContext As EvaluationContext) As List(Of GlobResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;Microsoft::Build::Evaluation::GlobResult ^&gt; ^ GetAllGlobs(Microsoft::Build::Evaluation::Context::EvaluationContext ^ evaluationContext);" />
      <MemberSignature Language="F#" Value="member this.GetAllGlobs : Microsoft.Build.Evaluation.Context.EvaluationContext -&gt; System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt;" Usage="project.GetAllGlobs evaluationContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evaluationContext" Type="Microsoft.Build.Evaluation.Context.EvaluationContext" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="evaluationContext">
                The evaluation context to use in case reevaluation is required.
                To avoid reevaluation use <see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements" /></param>
        <summary>
            See <see cref="M:Microsoft.Build.Evaluation.Project.GetAllGlobs" /></summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllGlobs">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt; GetAllGlobs (string itemType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;class Microsoft.Build.Evaluation.GlobResult&gt; GetAllGlobs(string itemType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetAllGlobs(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllGlobs (itemType As String) As List(Of GlobResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;Microsoft::Build::Evaluation::GlobResult ^&gt; ^ GetAllGlobs(System::String ^ itemType);" />
      <MemberSignature Language="F#" Value="member this.GetAllGlobs : string -&gt; System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt;" Usage="project.GetAllGlobs itemType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="itemType">Confine search to item elements of this type</param>
        <summary>
            Overload of <see cref="M:Microsoft.Build.Evaluation.Project.GetAllGlobs" /></summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllGlobs">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt; GetAllGlobs (string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;class Microsoft.Build.Evaluation.GlobResult&gt; GetAllGlobs(string itemType, class Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetAllGlobs(System.String,Microsoft.Build.Evaluation.Context.EvaluationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllGlobs (itemType As String, evaluationContext As EvaluationContext) As List(Of GlobResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;Microsoft::Build::Evaluation::GlobResult ^&gt; ^ GetAllGlobs(System::String ^ itemType, Microsoft::Build::Evaluation::Context::EvaluationContext ^ evaluationContext);" />
      <MemberSignature Language="F#" Value="member this.GetAllGlobs : string * Microsoft.Build.Evaluation.Context.EvaluationContext -&gt; System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt;" Usage="project.GetAllGlobs (itemType, evaluationContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.GlobResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="evaluationContext" Type="Microsoft.Build.Evaluation.Context.EvaluationContext" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="itemType">To be added.</param>
        <param name="evaluationContext">
                The evaluation context to use in case reevaluation is required.
                To avoid reevaluation use <see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements" /></param>
        <summary>
            See <see cref="M:Microsoft.Build.Evaluation.Project.GetAllGlobs(System.String)" /></summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvaluatedItemIncludeEscaped">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets evaluated, escaped value of the Include attribute of the provided items.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvaluatedItemIncludeEscaped">
      <MemberSignature Language="C#" Value="public static string GetEvaluatedItemIncludeEscaped (Microsoft.Build.Evaluation.ProjectItem item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEvaluatedItemIncludeEscaped(class Microsoft.Build.Evaluation.ProjectItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Evaluation.ProjectItem)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvaluatedItemIncludeEscaped (item As ProjectItem) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEvaluatedItemIncludeEscaped(Microsoft::Build::Evaluation::ProjectItem ^ item);" />
      <MemberSignature Language="F#" Value="static member GetEvaluatedItemIncludeEscaped : Microsoft.Build.Evaluation.ProjectItem -&gt; string" Usage="Microsoft.Build.Evaluation.Project.GetEvaluatedItemIncludeEscaped item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="Microsoft.Build.Evaluation.ProjectItem" />
      </Parameters>
      <Docs>
        <param name="item">The item to be evaluated and escaped.</param>
        <summary>
            Returns the evaluated, escaped value of the provided item's include.
            </summary>
        <returns>The evaluated, escaped value of the Include attribute of the provided items.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEvaluatedItemIncludeEscaped">
      <MemberSignature Language="C#" Value="public static string GetEvaluatedItemIncludeEscaped (Microsoft.Build.Evaluation.ProjectItemDefinition item);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEvaluatedItemIncludeEscaped(class Microsoft.Build.Evaluation.ProjectItemDefinition item) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetEvaluatedItemIncludeEscaped(Microsoft.Build.Evaluation.ProjectItemDefinition)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEvaluatedItemIncludeEscaped (item As ProjectItemDefinition) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEvaluatedItemIncludeEscaped(Microsoft::Build::Evaluation::ProjectItemDefinition ^ item);" />
      <MemberSignature Language="F#" Value="static member GetEvaluatedItemIncludeEscaped : Microsoft.Build.Evaluation.ProjectItemDefinition -&gt; string" Usage="Microsoft.Build.Evaluation.Project.GetEvaluatedItemIncludeEscaped item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="Microsoft.Build.Evaluation.ProjectItemDefinition" />
      </Parameters>
      <Docs>
        <param name="item">The item definition to be evaluated and escaped.</param>
        <summary>
            Returns the evaluated, escaped value of the provided item definition's include.
            </summary>
        <returns>The value of the Include attribute.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemProvenance">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance (Microsoft.Build.Evaluation.ProjectItem item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;class Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance(class Microsoft.Build.Evaluation.ProjectItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemProvenance (item As ProjectItem) As List(Of ProvenanceResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;Microsoft::Build::Evaluation::ProvenanceResult ^&gt; ^ GetItemProvenance(Microsoft::Build::Evaluation::ProjectItem ^ item);" />
      <MemberSignature Language="F#" Value="member this.GetItemProvenance : Microsoft.Build.Evaluation.ProjectItem -&gt; System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;" Usage="project.GetItemProvenance item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="Microsoft.Build.Evaluation.ProjectItem" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="item"> 
            The ProjectItem object that indicates: the itemspec to match and the item type to constrain the search in.
            The search is also constrained on item elements appearing before the item element that produced this <paramref name="item" />.
            The element that produced this <paramref name="item" /> is included in the results.
            </param>
        <summary>
            Overload of <see cref="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String)" /></summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemProvenance">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance (string itemToMatch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;class Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance(string itemToMatch) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemProvenance (itemToMatch As String) As List(Of ProvenanceResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;Microsoft::Build::Evaluation::ProvenanceResult ^&gt; ^ GetItemProvenance(System::String ^ itemToMatch);" />
      <MemberSignature Language="F#" Value="member this.GetItemProvenance : string -&gt; System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;" Usage="project.GetItemProvenance itemToMatch" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemToMatch" Type="System.String" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="itemToMatch">The string to perform matching against</param>
        <summary>
             Finds all the item elements in the logical project with itemspecs that match the given string:
             - elements that would include (or exclude) the string
             - elements that would update the string (not yet implemented)
             - elements that would remove the string (not yet implemented)
             </summary>
        <returns>
             A list of <see cref="T:Microsoft.Build.Evaluation.ProvenanceResult" />, sorted in project evaluation order.
             </returns>
        <remarks>
             This method and its overloads are useful for clients that need to inspect all the item elements
             that might refer to a specific item instance. For example, Visual Studio uses it to inspect
             projects with globs. Upon a file system or IDE file artifact change, VS calls this method to find all the items
             that might refer to the detected file change (e.g. 'which item elements refer to "Program.cs"?').
             It uses such information to know which elements it should edit to reflect the user or file system changes.
             
             Literal string matching tries to first match the strings. If the check fails, it then tries to match
             the strings as if they represented files: it normalizes both strings as files relative to the current project directory
            
             GetItemProvenance suffers from some sources of inaccuracy:
             - it is performed after evaluation, thus is insensitive to item data flow when item references are present
             (it sees items as they are at the end of evaluation)
             
             This API and its return types are prone to change.
             </remarks>
        <example>
             The following snippet shows what <c>GetItemProvenance("a.cs")</c> returns for various item elements
             <code><A Include="a.cs;*.cs" /> // Occurrences:2; Operation: Include; Provenance: StringLiteral | Glob
             <B Include="*.cs" Exclude="a.cs" /> // Occurrences: 1; Operation: Exclude; Provenance: StringLiteral
             <C Include="b.cs" /> // NA
             <D Include="@(A)" /> // Occurrences: 2; Operation: Include; Provenance: Inconclusive (it is an indirect occurrence from a referenced item)
             <E Include="$(P)" /> // Occurrences: 4; Operation: Include; Provenance: FromLiteral (direct reference in $P) | Glob (direct reference in $P) | Inconclusive (it is an indirect occurrence from referenced properties and items)
             <PropertyGroup><P>a.cs;*.cs;@(A)</P></PropertyGroup></code></example>
      </Docs>
    </Member>
    <Member MemberName="GetItemProvenance">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance (Microsoft.Build.Evaluation.ProjectItem item, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;class Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance(class Microsoft.Build.Evaluation.ProjectItem item, class Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem,Microsoft.Build.Evaluation.Context.EvaluationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemProvenance (item As ProjectItem, evaluationContext As EvaluationContext) As List(Of ProvenanceResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;Microsoft::Build::Evaluation::ProvenanceResult ^&gt; ^ GetItemProvenance(Microsoft::Build::Evaluation::ProjectItem ^ item, Microsoft::Build::Evaluation::Context::EvaluationContext ^ evaluationContext);" />
      <MemberSignature Language="F#" Value="member this.GetItemProvenance : Microsoft.Build.Evaluation.ProjectItem * Microsoft.Build.Evaluation.Context.EvaluationContext -&gt; System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;" Usage="project.GetItemProvenance (item, evaluationContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="Microsoft.Build.Evaluation.ProjectItem" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="evaluationContext" Type="Microsoft.Build.Evaluation.Context.EvaluationContext" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="item">To be added.</param>
        <param name="evaluationContext">
                The evaluation context to use in case reevaluation is required.
                To avoid reevaluation use <see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements" /></param>
        <summary>
            See <see cref="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(Microsoft.Build.Evaluation.ProjectItem)" /></summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemProvenance">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance (string itemToMatch, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;class Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance(string itemToMatch, class Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String,Microsoft.Build.Evaluation.Context.EvaluationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemProvenance (itemToMatch As String, evaluationContext As EvaluationContext) As List(Of ProvenanceResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;Microsoft::Build::Evaluation::ProvenanceResult ^&gt; ^ GetItemProvenance(System::String ^ itemToMatch, Microsoft::Build::Evaluation::Context::EvaluationContext ^ evaluationContext);" />
      <MemberSignature Language="F#" Value="member this.GetItemProvenance : string * Microsoft.Build.Evaluation.Context.EvaluationContext -&gt; System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;" Usage="project.GetItemProvenance (itemToMatch, evaluationContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemToMatch" Type="System.String" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="evaluationContext" Type="Microsoft.Build.Evaluation.Context.EvaluationContext" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="itemToMatch">To be added.</param>
        <param name="evaluationContext">
                The evaluation context to use in case reevaluation is required.
                To avoid reevaluation use <see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements" /></param>
        <summary>
            See <see cref="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String)" /></summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemProvenance">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance (string itemToMatch, string itemType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;class Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance(string itemToMatch, string itemType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemProvenance (itemToMatch As String, itemType As String) As List(Of ProvenanceResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;Microsoft::Build::Evaluation::ProvenanceResult ^&gt; ^ GetItemProvenance(System::String ^ itemToMatch, System::String ^ itemType);" />
      <MemberSignature Language="F#" Value="member this.GetItemProvenance : string * string -&gt; System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;" Usage="project.GetItemProvenance (itemToMatch, itemType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemToMatch" Type="System.String" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="itemType" Type="System.String" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="itemToMatch">The string to perform matching against</param>
        <param name="itemType">The item type to constrain the search in</param>
        <summary>
            Overload of <see cref="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String)" /></summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemProvenance">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance (string itemToMatch, string itemType, Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;class Microsoft.Build.Evaluation.ProvenanceResult&gt; GetItemProvenance(string itemToMatch, string itemType, class Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String,System.String,Microsoft.Build.Evaluation.Context.EvaluationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemProvenance (itemToMatch As String, itemType As String, evaluationContext As EvaluationContext) As List(Of ProvenanceResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::List&lt;Microsoft::Build::Evaluation::ProvenanceResult ^&gt; ^ GetItemProvenance(System::String ^ itemToMatch, System::String ^ itemType, Microsoft::Build::Evaluation::Context::EvaluationContext ^ evaluationContext);" />
      <MemberSignature Language="F#" Value="member this.GetItemProvenance : string * string * Microsoft.Build.Evaluation.Context.EvaluationContext -&gt; System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;" Usage="project.GetItemProvenance (itemToMatch, itemType, evaluationContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;Microsoft.Build.Evaluation.ProvenanceResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemToMatch" Type="System.String" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="itemType" Type="System.String" Index="1" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
        <Parameter Name="evaluationContext" Type="Microsoft.Build.Evaluation.Context.EvaluationContext" Index="2" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="itemToMatch">To be added.</param>
        <param name="itemType">To be added.</param>
        <param name="evaluationContext">
                The evaluation context to use in case reevaluation is required.
                To avoid reevaluation use <see cref="F:Microsoft.Build.Evaluation.ProjectLoadSettings.RecordEvaluatedItemElements" /></param>
        <summary>
            See <see cref="M:Microsoft.Build.Evaluation.Project.GetItemProvenance(System.String,System.String)" /></summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItems">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt; GetItems (string itemType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; GetItems(string itemType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetItems(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItems (itemType As String) As ICollection(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ GetItems(System::String ^ itemType);" />
      <MemberSignature Language="F#" Value="member this.GetItems : string -&gt; System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="project.GetItems itemType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="itemType">The item type to be retrieved.</param>
        <summary>
            All the items in the project of the specified
            type.
            If there are none, returns an empty list.
            Use AddItem or RemoveItem to modify items in this project.
            </summary>
        <returns>All the items in the project of the given item type, or an empty list if there are no items with the given item name.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use AddItem or RemoveItem to modify items in this project.  
  
 ]]></format>
        </remarks>
        <comments>
            data.GetItems returns a read-only collection, so no need to re-wrap it here. 
            </comments>
      </Docs>
    </Member>
    <Member MemberName="GetItemsByEvaluatedInclude">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt; GetItemsByEvaluatedInclude (string evaluatedInclude);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; GetItemsByEvaluatedInclude(string evaluatedInclude) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetItemsByEvaluatedInclude(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemsByEvaluatedInclude (evaluatedInclude As String) As ICollection(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ GetItemsByEvaluatedInclude(System::String ^ evaluatedInclude);" />
      <MemberSignature Language="F#" Value="member this.GetItemsByEvaluatedInclude : string -&gt; System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="project.GetItemsByEvaluatedInclude evaluatedInclude" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evaluatedInclude" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="evaluatedInclude">The evaluated Include attribute.</param>
        <summary>
            Returns all items that have the specified evaluated include.
            For example, all items that have the evaluated include "bar.cpp".
            Typically there will be zero or one, but sometimes there are two items with the
            same path and different item types, or even the same item types. This will return
            them all.
            </summary>
        <returns>All items that have the given evaluated Include attribute.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 For example, this method might return all items that have the evaluated Include attribute "component.cpp". Typically zero or one items are returned. However, there may be multiple items with the same path and different item types, or even with the same item types.  
  
 ]]></format>
        </remarks>
        <comments>
            data.GetItemsByEvaluatedInclude already returns a read-only collection, so no need
            to wrap it further.
            </comments>
      </Docs>
    </Member>
    <Member MemberName="GetItemsIgnoringCondition">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt; GetItemsIgnoringCondition (string itemType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; GetItemsIgnoringCondition(string itemType) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetItemsIgnoringCondition(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetItemsIgnoringCondition (itemType As String) As ICollection(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ GetItemsIgnoringCondition(System::String ^ itemType);" />
      <MemberSignature Language="F#" Value="member this.GetItemsIgnoringCondition : string -&gt; System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="project.GetItemsIgnoringCondition itemType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="itemType">The item type to be retrieved.</param>
        <summary>
            All the items in the project of the specified
            type, irrespective of whether the conditions on them evaluated to true.
            This is a read-only list: use AddItem or RemoveItem to modify items in this project.
            </summary>
        <returns>All the items in the project of the given type, whether or not their Condition attribute evaluates to true.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 This is a read-only list. Use AddItem or RemoveItem to modify items in this project.  
  
 ]]></format>
        </remarks>
        <comments>
            ItemDictionary[] returns a read only collection, so no need to wrap it. 
            </comments>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalProject">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Construction.ProjectElement&gt; GetLogicalProject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Construction.ProjectElement&gt; GetLogicalProject() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetLogicalProject" />
      <MemberSignature Language="VB.NET" Value="Public Iterator Function GetLogicalProject () As IEnumerable(Of ProjectElement)" FrameworkAlternate="msbuild-15;msbuild-15-netcore" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Construction::ProjectElement ^&gt; ^ GetLogicalProject();" />
      <MemberSignature Language="F#" Value="member this.GetLogicalProject : unit -&gt; seq&lt;Microsoft.Build.Construction.ProjectElement&gt;" Usage="project.GetLogicalProject " />
      <MemberSignature Language="VB.NET" Value="Public Function GetLogicalProject () As IEnumerable(Of ProjectElement)" FrameworkAlternate="msbuild-16;msbuild-16-netcore;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="msbuild-15;msbuild-15-netcore">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.IteratorStateMachine(typeof(Microsoft.Build.Evaluation.Project/&lt;GetLogicalProject&gt;d__136))]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IteratorStateMachine(typeof(Microsoft.Build.Evaluation.Project/&lt;GetLogicalProject&gt;d__136))&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Construction.ProjectElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Returns an iterator over the "logical project". The logical project is defined as
            the unevaluated project obtained from the single MSBuild file that is the result 
            of inlining the text of all imports of the original MSBuild project manifest file.
            </summary>
        <returns>An enumerator over all the elements in the "logical project".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The logical project is defined as the unevaluated project obtained from the single MSBuild file that is the result of including inline the text of all imports of the original MSBuild project manifest file.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadataValueEscaped">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets the escaped value of the metadatum with the provided name on the provided item.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadataValueEscaped">
      <MemberSignature Language="C#" Value="public static string GetMetadataValueEscaped (Microsoft.Build.Evaluation.ProjectMetadata metadatum);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetMetadataValueEscaped(class Microsoft.Build.Evaluation.ProjectMetadata metadatum) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMetadataValueEscaped (metadatum As ProjectMetadata) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetMetadataValueEscaped(Microsoft::Build::Evaluation::ProjectMetadata ^ metadatum);" />
      <MemberSignature Language="F#" Value="static member GetMetadataValueEscaped : Microsoft.Build.Evaluation.ProjectMetadata -&gt; string" Usage="Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped metadatum" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadatum" Type="Microsoft.Build.Evaluation.ProjectMetadata" />
      </Parameters>
      <Docs>
        <param name="metadatum">The metadatum to be escaped.</param>
        <summary>
            Gets the escaped value of the provided metadatum. 
            </summary>
        <returns>The escaped value of the provided metadatum.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadataValueEscaped">
      <MemberSignature Language="C#" Value="public static string GetMetadataValueEscaped (Microsoft.Build.Evaluation.ProjectItem item, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetMetadataValueEscaped(class Microsoft.Build.Evaluation.ProjectItem item, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectItem,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMetadataValueEscaped (item As ProjectItem, name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetMetadataValueEscaped(Microsoft::Build::Evaluation::ProjectItem ^ item, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetMetadataValueEscaped : Microsoft.Build.Evaluation.ProjectItem * string -&gt; string" Usage="Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped (item, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="Microsoft.Build.Evaluation.ProjectItem" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="item">The item whose metadata is to be escaped.</param>
        <param name="name">The name of the metadata to be escaped.</param>
        <summary>
            Gets the escaped value of the metadatum with the provided name on the provided item. 
            </summary>
        <returns>The escaped value of the metadatum with the provided name on the provided item.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadataValueEscaped">
      <MemberSignature Language="C#" Value="public static string GetMetadataValueEscaped (Microsoft.Build.Evaluation.ProjectItemDefinition item, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetMetadataValueEscaped(class Microsoft.Build.Evaluation.ProjectItemDefinition item, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped(Microsoft.Build.Evaluation.ProjectItemDefinition,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMetadataValueEscaped (item As ProjectItemDefinition, name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetMetadataValueEscaped(Microsoft::Build::Evaluation::ProjectItemDefinition ^ item, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetMetadataValueEscaped : Microsoft.Build.Evaluation.ProjectItemDefinition * string -&gt; string" Usage="Microsoft.Build.Evaluation.Project.GetMetadataValueEscaped (item, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="Microsoft.Build.Evaluation.ProjectItemDefinition" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="item">The item definition whose metadata is to be escaped.</param>
        <param name="name">The name of the metadata to be escaped.</param>
        <summary>
            Gets the escaped value of the metadatum with the provided name on the provided item definition. 
            </summary>
        <returns>The escaped value of the metadatum with the provided name on the provided item definition.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Evaluation.ProjectProperty GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Evaluation.ProjectProperty GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As ProjectProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Evaluation::ProjectProperty ^ GetProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetProperty : string -&gt; Microsoft.Build.Evaluation.ProjectProperty" Usage="project.GetProperty name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.ProjectProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the property to retrieve.</param>
        <summary>
            Get any property in the project that has the specified name,
            otherwise returns null
            </summary>
        <returns>Any property in the project that has the specified name, or <see langword="null" /> if no property of that name exists.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyValue">
      <MemberSignature Language="C#" Value="public string GetPropertyValue (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPropertyValue(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetPropertyValue(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPropertyValue (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetPropertyValue(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.GetPropertyValue : string -&gt; string" Usage="project.GetPropertyValue name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the property whose value is retrieved.</param>
        <summary>
            Get the unescaped value of a property in this project, or 
            an empty string if it does not exist.
            </summary>
        <returns>The value of the given property in this project, or an empty string if no property of that name exists. Escape sequences are converted before returning the string.</returns>
        <remarks>
            A property with a value of empty string and no property
            at all are not distinguished between by this method.
            That makes it easier to use. To find out if a property is set at
            all in the project, use GetProperty(name).
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyValueEscaped">
      <MemberSignature Language="C#" Value="public static string GetPropertyValueEscaped (Microsoft.Build.Evaluation.ProjectProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetPropertyValueEscaped(class Microsoft.Build.Evaluation.ProjectProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.GetPropertyValueEscaped(Microsoft.Build.Evaluation.ProjectProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetPropertyValueEscaped (property As ProjectProperty) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetPropertyValueEscaped(Microsoft::Build::Evaluation::ProjectProperty ^ property);" />
      <MemberSignature Language="F#" Value="static member GetPropertyValueEscaped : Microsoft.Build.Evaluation.ProjectProperty -&gt; string" Usage="Microsoft.Build.Evaluation.Project.GetPropertyValueEscaped property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.Build.Evaluation.ProjectProperty" />
      </Parameters>
      <Docs>
        <param name="property">The property to be escaped.</param>
        <summary>
            Get the escaped value of the provided property
            </summary>
        <returns>The escaped value of the provided property.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalProperties">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,string&gt; GlobalProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, string&gt; GlobalProperties" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.GlobalProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalProperties As IDictionary(Of String, String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ GlobalProperties { System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalProperties : System.Collections.Generic.IDictionary&lt;string, string&gt;" Usage="Microsoft.Build.Evaluation.Project.GlobalProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="msbuild-15;msbuild-15-netcore;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Read only dictionary of the global properties used in the evaluation
            of this project.
            </summary>
        <value>A dictionary of the global properties used for the evaluation of this project.</value>
        <remarks>
            This is the publicly exposed getter, that translates into a read-only dead IDictionary&lt;string, string&gt;.
            
            In order to easily tell when we're dirtied, setting and removing global properties is done with 
            <see cref="M:Microsoft.Build.Evaluation.Project.SetGlobalProperty(System.String,System.String)">SetGlobalProperty</see> and <see cref="M:Microsoft.Build.Evaluation.Project.RemoveGlobalProperty(System.String)">RemoveGlobalProperty</see>.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="Imports">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ResolvedImport&gt; Imports { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;valuetype Microsoft.Build.Evaluation.ResolvedImport&gt; Imports" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.Imports" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Imports As IList(Of ResolvedImport)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ResolvedImport&gt; ^ Imports { System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ResolvedImport&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Imports : System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ResolvedImport&gt;" Usage="Microsoft.Build.Evaluation.Project.Imports" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ResolvedImport&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            All the files that during evaluation contributed to this project, as ProjectRootElements,
            with the ProjectImportElement that caused them to be imported.
            This does not include projects that were never imported because a condition on an Import element was false.
            The outer ProjectRootElement that maps to this project itself is not included.
            </summary>
        <value>A list of all the files that contributed to the evaluation of this project.  
  
 The name of each item is the Import element that caused the file to be imported. The value of each item is the project root of the imported project. Import elements whose Condition attribute evaluated to false are not included.</value>
        <remarks>
            This can be used by the host to figure out what projects might be impacted by a change to a particular file.
            It could also be used, for example, to find the .user file, and use its ProjectRootElement to modify properties in it.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImportsIncludingDuplicates">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ResolvedImport&gt; ImportsIncludingDuplicates { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;valuetype Microsoft.Build.Evaluation.ResolvedImport&gt; ImportsIncludingDuplicates" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ImportsIncludingDuplicates" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ImportsIncludingDuplicates As IList(Of ResolvedImport)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ResolvedImport&gt; ^ ImportsIncludingDuplicates { System::Collections::Generic::IList&lt;Microsoft::Build::Evaluation::ResolvedImport&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ImportsIncludingDuplicates : System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ResolvedImport&gt;" Usage="Microsoft.Build.Evaluation.Project.ImportsIncludingDuplicates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;Microsoft.Build.Evaluation.ResolvedImport&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            This list will contain duplicate imports if an import is imported multiple times. However, only the first import was used in evaluation.
            </summary>
        <value>A list of duplicate imports.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBuildEnabled">
      <MemberSignature Language="C#" Value="public bool IsBuildEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBuildEnabled" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.IsBuildEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBuildEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBuildEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsBuildEnabled : bool with get, set" Usage="Microsoft.Build.Evaluation.Project.IsBuildEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="msbuild-16;msbuild-16-netcore">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="msbuild-16;msbuild-16-netcore">
          <AttributeName Language="C#">[set: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            This controls whether or not the building of targets/tasks is enabled for this
            project.  This is for security purposes in case a host wants to closely
            control which projects it allows to run targets/tasks.  By default, for a newly
            created project, we will use whatever setting is in the parent project collection.
            When build is disabled, the Build method on this class will fail. However if
            the host has already created a ProjectInstance, it can still build it. (It is 
            free to put a similar check around where it does this.)
            </summary>
        <value>
          <see langword="true" /> if the targets and tasks of this project can be built; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Can be used for security purposes. By default, a new project has the same IsBuildEnabled setting as the parent project collection that contains it. When IsBuildEnabled is false, the Build method on this project fails.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDirty">
      <MemberSignature Language="C#" Value="public bool IsDirty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDirty" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.IsDirty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDirty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDirty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDirty : bool" Usage="Microsoft.Build.Evaluation.Project.IsDirty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Whether this project is dirty such that it needs reevaluation.
            This may be because its underlying XML has changed (either through this project or another)
            either the XML of the main project or an imported file; 
            or because its toolset may have changed.
            </summary>
        <value>
          <see langword="true" /> if this project has been modified so that it must be reevaluated; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A project is modified and must be reevaluated when the underlying project source code, including changes to imported files. A project is also modified must be reevaluated if the project tool set changes.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemDefinitions">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,Microsoft.Build.Evaluation.ProjectItemDefinition&gt; ItemDefinitions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, class Microsoft.Build.Evaluation.ProjectItemDefinition&gt; ItemDefinitions" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ItemDefinitions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemDefinitions As IDictionary(Of String, ProjectItemDefinition)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, Microsoft::Build::Evaluation::ProjectItemDefinition ^&gt; ^ ItemDefinitions { System::Collections::Generic::IDictionary&lt;System::String ^, Microsoft::Build::Evaluation::ProjectItemDefinition ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemDefinitions : System.Collections.Generic.IDictionary&lt;string, Microsoft.Build.Evaluation.ProjectItemDefinition&gt;" Usage="Microsoft.Build.Evaluation.Project.ItemDefinitions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,Microsoft.Build.Evaluation.ProjectItemDefinition&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Read-only dictionary of item definitions in this project.
            Keyed by item type
            </summary>
        <value>A dictionary of item definitions in this project, keyed by item type.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt; Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; Items" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.Items" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Items As ICollection(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ Items { System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Items : System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="Microsoft.Build.Evaluation.Project.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Items in this project, ordered within groups of item types
            </summary>
        <value>An enumerator over all items in this project, ordered within groups of item types.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemsIgnoringCondition">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt; ItemsIgnoringCondition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; ItemsIgnoringCondition" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ItemsIgnoringCondition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemsIgnoringCondition As ICollection(Of ProjectItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ ItemsIgnoringCondition { System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemsIgnoringCondition : System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" Usage="Microsoft.Build.Evaluation.Project.ItemsIgnoringCondition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="msbuild-15;msbuild-15-netcore;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectItem&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Items in this project, ordered within groups of item types,
            including items whose conditions evaluated to false, or that were
            contained within item groups who themselves had conditioned evaluated to false.
            This is useful for hosts that wish to display all items, even if they might not be part 
            of the build in the current configuration.
            </summary>
        <value>An enumerator over all items in this project, ordered within groups of item types, including items whose conditions evaluate to false, or are contained within item groups whose condition evaluates to <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Can be used to display all items, even if they are not part of the build in the current configuration.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemTypes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;string&gt; ItemTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;string&gt; ItemTypes" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ItemTypes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ItemTypes As ICollection(Of String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;System::String ^&gt; ^ ItemTypes { System::Collections::Generic::ICollection&lt;System::String ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ItemTypes : System.Collections.Generic.ICollection&lt;string&gt;" Usage="Microsoft.Build.Evaluation.Project.ItemTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Item types in this project.
            This is an ordered collection.
            </summary>
        <value>An enumerator over all item types in this project. This is an ordered collection.</value>
        <remarks>To be added.</remarks>
        <comments>
            data.ItemTypes is a KeyCollection, so it doesn't need any 
            additional read-only protection
            </comments>
      </Docs>
    </Member>
    <Member MemberName="LastEvaluationId">
      <MemberSignature Language="C#" Value="public int LastEvaluationId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LastEvaluationId" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.LastEvaluationId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastEvaluationId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int LastEvaluationId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.LastEvaluationId : int" Usage="Microsoft.Build.Evaluation.Project.LastEvaluationId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The ID of the last evaluation for this Project.
            A project is always evaluated upon construction and can subsequently get evaluated multiple times via
            <see cref="M:Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary" />
            
            It is an arbitrary number that changes when this project reevaluates.
            Hosts don't know whether an evaluation actually happened in an interval, but they can compare this number to
            their previously stored value to find out, and if so perhaps decide to update their own state.
            Note that the number may not increase monotonically.
            
            This number corresponds to the <seealso cref="P:Microsoft.Build.Framework.BuildEventContext.EvaluationId" /> and can be used to connect
            evaluation logging events back to the Project instance.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MarkDirty">
      <MemberSignature Language="C#" Value="public void MarkDirty ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MarkDirty() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.MarkDirty" />
      <MemberSignature Language="VB.NET" Value="Public Sub MarkDirty ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MarkDirty();" />
      <MemberSignature Language="F#" Value="member this.MarkDirty : unit -&gt; unit" Usage="project.MarkDirty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Called to forcibly mark the project as dirty requiring reevaluation. Generally this is not necessary to set; all edits affecting
            this project will automatically make it dirty. However there are potential corner cases where it is necessary to mark the project dirty
            directly. For example, if the project has an import conditioned on a file existing on disk, and the file did not exist at
            evaluation time, then someone subsequently creates that file, the project cannot know that reevaluation would be productive.
            In such a case the host can help us by setting the dirty flag explicitly so that <see cref="M:Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary">ReevaluateIfNecessary()</see>
            will recognize an evaluation is indeed necessary.
            Does not mark the underlying project file as requiring saving.
            </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 It is seldom necessary to call this method explicitly, because all edits affecting a project automatically mark it as modified.  
  
 Sometimes, however, this method must be called. For example, a project may have an Import element whose condition depends on a file that exists on a disk. If that file does not exist at evaluation time, and it is created after evaluation, then the project must be explicitly marked as modified.  
  
 The <xref:Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary%2A> method uses this property to determine if an evaluation is necessary.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProjectCollection">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Evaluation.ProjectCollection ProjectCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Build.Evaluation.ProjectCollection ProjectCollection" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ProjectCollection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProjectCollection As ProjectCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Build::Evaluation::ProjectCollection ^ ProjectCollection { Microsoft::Build::Evaluation::ProjectCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProjectCollection : Microsoft.Build.Evaluation.ProjectCollection" Usage="Microsoft.Build.Evaluation.Project.ProjectCollection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.ProjectCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets or sets the project collection which contains this project.
            Can never be null.
            Cannot be modified.
            </summary>
        <value>The project collection that contains this project, which is never <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProjectFileLocation">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ElementLocation ProjectFileLocation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Build.Construction.ElementLocation ProjectFileLocation" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ProjectFileLocation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProjectFileLocation As ElementLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Build::Construction::ElementLocation ^ ProjectFileLocation { Microsoft::Build::Construction::ElementLocation ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProjectFileLocation : Microsoft.Build.Construction.ElementLocation" Usage="Microsoft.Build.Evaluation.Project.ProjectFileLocation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ElementLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Location of the originating file itself, not any specific content within it.
            If the file has not been given a name, returns an empty location.
            </summary>
        <value>The originating file location, or an empty location if the file has not been given a name.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Properties">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectProperty&gt; Properties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.ICollection`1&lt;class Microsoft.Build.Evaluation.ProjectProperty&gt; Properties" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.Properties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Properties As ICollection(Of ProjectProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectProperty ^&gt; ^ Properties { System::Collections::Generic::ICollection&lt;Microsoft::Build::Evaluation::ProjectProperty ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Properties : System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectProperty&gt;" Usage="Microsoft.Build.Evaluation.Project.Properties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.ICollection&lt;Microsoft.Build.Evaluation.ProjectProperty&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Properties in this project.
            Since evaluation has occurred, this is an unordered collection.
            </summary>
        <value>An enumerator over all properties in this project. Since properties are evaluated as they appear, this is an unordered collection.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReevaluateIfNecessary">
      <MemberSignature Language="C#" Value="public void ReevaluateIfNecessary ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReevaluateIfNecessary() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReevaluateIfNecessary ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReevaluateIfNecessary();" />
      <MemberSignature Language="F#" Value="member this.ReevaluateIfNecessary : unit -&gt; unit" Usage="project.ReevaluateIfNecessary " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Reevaluate the project to get it into a queryable state, if it's dirty.
            This incorporates all changes previously made to the backing XML by editing this project.
            Throws InvalidProjectFileException if the evaluation fails.
            </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The project is reevaluated only if it is marked as modified. Reevaluation incorporates all changes made to the project source code.  
  
 Throws InvalidProjectFileException if the evaluation fails.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReevaluateIfNecessary">
      <MemberSignature Language="C#" Value="public void ReevaluateIfNecessary (Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReevaluateIfNecessary(class Microsoft.Build.Evaluation.Context.EvaluationContext evaluationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary(Microsoft.Build.Evaluation.Context.EvaluationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReevaluateIfNecessary (evaluationContext As EvaluationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReevaluateIfNecessary(Microsoft::Build::Evaluation::Context::EvaluationContext ^ evaluationContext);" />
      <MemberSignature Language="F#" Value="member this.ReevaluateIfNecessary : Microsoft.Build.Evaluation.Context.EvaluationContext -&gt; unit" Usage="project.ReevaluateIfNecessary evaluationContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evaluationContext" Type="Microsoft.Build.Evaluation.Context.EvaluationContext" Index="0" FrameworkAlternate="msbuild-15;msbuild-15-netcore;msbuild-16;msbuild-16-netcore" />
      </Parameters>
      <Docs>
        <param name="evaluationContext">The <see cref="T:Microsoft.Build.Evaluation.Context.EvaluationContext" /> to use. See <see cref="T:Microsoft.Build.Evaluation.Context.EvaluationContext" /></param>
        <summary>
            See <see cref="M:Microsoft.Build.Evaluation.Project.ReevaluateIfNecessary" /></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveGlobalProperty">
      <MemberSignature Language="C#" Value="public bool RemoveGlobalProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveGlobalProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.RemoveGlobalProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveGlobalProperty (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveGlobalProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="member this.RemoveGlobalProperty : string -&gt; bool" Usage="project.RemoveGlobalProperty name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the global property to be removed.</param>
        <summary>
            Removes a global property.
            If it was set, returns true, and marks the project
            as requiring reevaluation.
            </summary>
        <returns>
          <see langword="true" /> if the value of the global property was set.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveItem">
      <MemberSignature Language="C#" Value="public bool RemoveItem (Microsoft.Build.Evaluation.ProjectItem item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveItem(class Microsoft.Build.Evaluation.ProjectItem item) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.RemoveItem(Microsoft.Build.Evaluation.ProjectItem)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveItem (item As ProjectItem) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveItem(Microsoft::Build::Evaluation::ProjectItem ^ item);" />
      <MemberSignature Language="F#" Value="member this.RemoveItem : Microsoft.Build.Evaluation.ProjectItem -&gt; bool" Usage="project.RemoveItem item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="Microsoft.Build.Evaluation.ProjectItem" />
      </Parameters>
      <Docs>
        <param name="item">The item to be removed.</param>
        <summary>
            Removes an item from the project.
            Item must be associated with this project.
            Item must not originate from an imported file.
            Returns true if the item was in this evaluated project, otherwise false.
            As a convenience, if the parent item group becomes empty, it is also removed.
            If the item originated from a wildcard or semicolon separated expression, expands that expression into multiple items first.
            Updates the evaluated project, but does not affect anything else in the project until reevaluation. For example,
            if an item of type "i" is removed, "j" which is evaluated from "@(i)" will not be modified until reevaluation.
            This is a convenience that it is understood does not necessarily leave the project in a perfectly self consistent state until reevaluation.
            </summary>
        <returns>
          <see langword="true" /> if the item is present in this evaluated project; otherwise, <see langword="false" />. Normally this method returns true, since if the requested item is not present, the method throws an exception. If the item is present only in the ItemsIgnoringCondition collection, however, the method returns <see langword="false" />.</returns>
        <remarks>
            Normally this will return true, since if the item isn't in the project, it will throw.
            The exception is removing an item that was only in ItemsIgnoringCondition.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveItems">
      <MemberSignature Language="C#" Value="public void RemoveItems (System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Evaluation.ProjectItem&gt; items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveItems(class System.Collections.Generic.IEnumerable`1&lt;class Microsoft.Build.Evaluation.ProjectItem&gt; items) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.RemoveItems(System.Collections.Generic.IEnumerable{Microsoft.Build.Evaluation.ProjectItem})" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveItems (items As IEnumerable(Of ProjectItem))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveItems(System::Collections::Generic::IEnumerable&lt;Microsoft::Build::Evaluation::ProjectItem ^&gt; ^ items);" />
      <MemberSignature Language="F#" Value="member this.RemoveItems : seq&lt;Microsoft.Build.Evaluation.ProjectItem&gt; -&gt; unit" Usage="project.RemoveItems items" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="items" Type="System.Collections.Generic.IEnumerable&lt;Microsoft.Build.Evaluation.ProjectItem&gt;" />
      </Parameters>
      <Docs>
        <param name="items">The items to be removed.</param>
        <summary>
            Removes all the specified items from the project.
            Items that are not associated with this project are skipped.
            </summary>
        <remarks>
            Removing one item could cause the backing XML
            to be expanded, which could zombie (disassociate) the next item.
            To make this case easy for the caller, if an item
            is not associated with this project it is simply skipped.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveProperty">
      <MemberSignature Language="C#" Value="public bool RemoveProperty (Microsoft.Build.Evaluation.ProjectProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RemoveProperty(class Microsoft.Build.Evaluation.ProjectProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.RemoveProperty(Microsoft.Build.Evaluation.ProjectProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveProperty (property As ProjectProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool RemoveProperty(Microsoft::Build::Evaluation::ProjectProperty ^ property);" />
      <MemberSignature Language="F#" Value="member this.RemoveProperty : Microsoft.Build.Evaluation.ProjectProperty -&gt; bool" Usage="project.RemoveProperty property" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="property" Type="Microsoft.Build.Evaluation.ProjectProperty" />
      </Parameters>
      <Docs>
        <param name="property">The property to remove.</param>
        <summary>
            Removes the specified property.
            Property must be associated with this project.
            Property must not originate from an imported file.
            Returns true if the property was in this evaluated project, otherwise false.
            As a convenience, if the parent property group becomes empty, it is also removed.
            Updates the evaluated project, but does not affect anything else in the project until reevaluation. For example,
            if "p" is removed, it will be removed from the evaluated project, but "q" which is evaluated from "$(p)" will not be modified until reevaluation.
            This is a convenience that it is understood does not necessarily leave the project in a perfectly self consistent state.
            </summary>
        <returns>
          <see langword="true" /> if the property is present in this evaluated project; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If the property group containing the property becomes empty, it is also removed.  
  
 The project is updated, but no further evaluation occurs until reevaluation. For example, if "p" is removed, "q" which is evaluated from "$(p)" is not modified until reevaluation.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Saves the project to the file system, if modified, using the default character encoding.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Save" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save();" />
      <MemberSignature Language="F#" Value="member this.Save : unit -&gt; unit" Usage="project.Save " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Save the project to the file system, if dirty.
            Uses the default encoding.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Save(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.Save : System.IO.TextWriter -&gt; unit" Usage="project.Save writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">The text writer to save the project to.</param>
        <summary>
            Save the project to the provided TextWriter, whether or not it is dirty.
            Uses the encoding of the TextWriter.
            Clears the Dirty flag.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Save(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.Save : string -&gt; unit" Usage="project.Save path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">The path to the project source code.</param>
        <summary>
            Save the project to the file system, if dirty or the path is different.
            Uses the default encoding.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Save(System.Text.Encoding)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (encoding As Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="member this.Save : System.Text.Encoding -&gt; unit" Usage="project.Save encoding" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="encoding">The character encoding used to save the project.</param>
        <summary>
            Save the project to the file system, if dirty.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.Save(System.String,System.Text.Encoding)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (path As String, encoding As Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ path, System::Text::Encoding ^ encoding);" />
      <MemberSignature Language="F#" Value="member this.Save : string * System.Text.Encoding -&gt; unit" Usage="project.Save (path, encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">The path to the project source code.</param>
        <param name="encoding">The character encoding used to save the project.</param>
        <summary>
            Save the project to the file system, if dirty or the path is different.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveLogicalProject">
      <MemberSignature Language="C#" Value="public void SaveLogicalProject (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveLogicalProject(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.SaveLogicalProject(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveLogicalProject (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveLogicalProject(System::IO::TextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="member this.SaveLogicalProject : System.IO.TextWriter -&gt; unit" Usage="project.SaveLogicalProject writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">The writer that saves the project file.</param>
        <summary>
            Saves a "logical" or "preprocessed" project file, that includes all the imported 
            files as if they formed a single file.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetGlobalProperty">
      <MemberSignature Language="C#" Value="public bool SetGlobalProperty (string name, string escapedValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SetGlobalProperty(string name, string escapedValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.SetGlobalProperty(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetGlobalProperty (name As String, escapedValue As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SetGlobalProperty(System::String ^ name, System::String ^ escapedValue);" />
      <MemberSignature Language="F#" Value="member this.SetGlobalProperty : string * string -&gt; bool" Usage="project.SetGlobalProperty (name, escapedValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="escapedValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the global property to set.</param>
        <param name="escapedValue">The new value of the global property.</param>
        <summary>
            Change a global property after the project has been evaluated.
            If the value changes, this makes the project require reevaluation.
            If the value changes, returns true, otherwise false.
            </summary>
        <returns>
          <see langword="true" /> if the value changes; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetProperty">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Evaluation.ProjectProperty SetProperty (string name, string unevaluatedValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class Microsoft.Build.Evaluation.ProjectProperty SetProperty(string name, string unevaluatedValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Build.Evaluation.Project.SetProperty(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetProperty (name As String, unevaluatedValue As String) As ProjectProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Build::Evaluation::ProjectProperty ^ SetProperty(System::String ^ name, System::String ^ unevaluatedValue);" />
      <MemberSignature Language="F#" Value="member this.SetProperty : string * string -&gt; Microsoft.Build.Evaluation.ProjectProperty" Usage="project.SetProperty (name, unevaluatedValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Evaluation.ProjectProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="unevaluatedValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the property to set.</param>
        <param name="unevaluatedValue">The new unevaluated value of the property.</param>
        <summary>
            Set or add a property with the specified name and value.
            Overwrites the value of any property with the same name already in the collection if it did not originate in an imported file.
            If there is no such existing property, uses this heuristic:
            Updates the last existing property with the specified name that has no condition on itself or its property group, if any,
            and is in this project file rather than an imported file.
            Otherwise, adds a new property in the first property group without a condition, creating a property group if necessary after
            the last existing property group, else at the start of the project.
            Returns the property set.
            Evaluates on a best-effort basis:
                -expands with all properties. Properties that are defined in the XML below the new property may be used, even though in a real evaluation they would not be.
                -only this property is evaluated. Anything else that would depend on its value is not affected.
            This is a convenience that it is understood does not necessarily leave the project in a perfectly self consistent state until reevaluation.
            </summary>
        <returns>The property.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If there is no property with the given name, updates the last existing property with the given name that has no condition on itself or its property group, unless it originated in an imported file.  
  
 Otherwise, adds a new property in the first property group without a condition, creating a property group if necessary after the last existing property group, else at the start of the project.  
  
 Evaluation takes place on a best-effort basis. Properties that are defined in the project source following the new property may be used for evaluation. Only this property is evaluated. Other properties that might depend on it are not affected.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipEvaluation">
      <MemberSignature Language="C#" Value="public bool SkipEvaluation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipEvaluation" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.SkipEvaluation" />
      <MemberSignature Language="VB.NET" Value="Public Property SkipEvaluation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SkipEvaluation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SkipEvaluation : bool with get, set" Usage="Microsoft.Build.Evaluation.Project.SkipEvaluation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="msbuild-16;msbuild-16-netcore">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="msbuild-16;msbuild-16-netcore">
          <AttributeName Language="C#">[set: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Whether ReevaluateIfNecessary is temporarily disabled.
            This is useful when the host expects to make a number of reads and writes 
            to the project, and wants to temporarily sacrifice correctness for performance.
            </summary>
        <value>A flag that determines whether ReevaluateIfNecessary is temporarily disabled.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubToolsetVersion">
      <MemberSignature Language="C#" Value="public string SubToolsetVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SubToolsetVersion" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.SubToolsetVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SubToolsetVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SubToolsetVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SubToolsetVersion : string" Usage="Microsoft.Build.Evaluation.Project.SubToolsetVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The sub-toolset version that, combined with the ToolsVersion, was used to determine
            the toolset properties for this project.  
            </summary>
        <value>The SubToolsetVersion attribute value, or an empty string if the attribute is not present.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Targets">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,Microsoft.Build.Execution.ProjectTargetInstance&gt; Targets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IDictionary`2&lt;string, class Microsoft.Build.Execution.ProjectTargetInstance&gt; Targets" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.Targets" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Targets As IDictionary(Of String, ProjectTargetInstance)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IDictionary&lt;System::String ^, Microsoft::Build::Execution::ProjectTargetInstance ^&gt; ^ Targets { System::Collections::Generic::IDictionary&lt;System::String ^, Microsoft::Build::Execution::ProjectTargetInstance ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Targets : System.Collections.Generic.IDictionary&lt;string, Microsoft.Build.Execution.ProjectTargetInstance&gt;" Usage="Microsoft.Build.Evaluation.Project.Targets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="msbuild-15;msbuild-15-netcore;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,Microsoft.Build.Execution.ProjectTargetInstance&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Targets in the project. The key to the dictionary is the target's name.
            Overridden targets are not included in this collection.
            This collection is read-only.
            </summary>
        <value>A read-only dictionary of all targets in this project, keyed by target name. Overridden targets are not included in this collection. </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ThrowInsteadOfSplittingItemElement">
      <MemberSignature Language="C#" Value="public bool ThrowInsteadOfSplittingItemElement { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ThrowInsteadOfSplittingItemElement" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ThrowInsteadOfSplittingItemElement" />
      <MemberSignature Language="VB.NET" Value="Public Property ThrowInsteadOfSplittingItemElement As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ThrowInsteadOfSplittingItemElement { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ThrowInsteadOfSplittingItemElement : bool with get, set" Usage="Microsoft.Build.Evaluation.Project.ThrowInsteadOfSplittingItemElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="msbuild-16;msbuild-16-netcore">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="msbuild-16;msbuild-16-netcore">
          <AttributeName Language="C#">[set: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
             Certain item operations split the item element in multiple elements if the include
             contains globs, references to items or properties, or multiple item values.
            
             The items operations that may expand item elements are:
             - <see cref="M:Microsoft.Build.Evaluation.Project.RemoveItem(Microsoft.Build.Evaluation.ProjectItem)" />
             - <see cref="M:Microsoft.Build.Evaluation.Project.RemoveItems(System.Collections.Generic.IEnumerable{Microsoft.Build.Evaluation.ProjectItem})" />
             - <see cref="M:Microsoft.Build.Evaluation.Project.AddItem(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})" />
             - <see cref="M:Microsoft.Build.Evaluation.Project.AddItemFast(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})" />
             - <see cref="M:Microsoft.Build.Evaluation.ProjectItem.Rename(System.String)" />
             - <see cref="M:Microsoft.Build.Evaluation.ProjectItem.RemoveMetadata(System.String)" />
             - <see cref="M:Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(System.String,System.String)" />
             - <see cref="M:Microsoft.Build.Evaluation.ProjectItem.SetMetadataValue(System.String,System.String,System.Boolean)" />
             
             When this property is set to true, the previous item operations throw an <exception cref="T:System.InvalidOperationException" />
             instead of expanding the item element. 
             </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolsVersion">
      <MemberSignature Language="C#" Value="public string ToolsVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ToolsVersion" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.ToolsVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ToolsVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ToolsVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ToolsVersion : string" Usage="Microsoft.Build.Evaluation.Project.ToolsVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The tools version this project was evaluated with, if any.
            Not necessarily the same as the tools version on the Project tag, if any;
            it may have been externally specified, for example with a /tv switch.
            The actual tools version on the Project tag, can be gotten from <see cref="P:Microsoft.Build.Evaluation.Project.Xml">Xml.ToolsVersion</see>.
            Cannot be changed once the project has been created.
            </summary>
        <value>The tools version that this project was evaluated with, if any.</value>
        <remarks>
            Set by construction.
            </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xml">
      <MemberSignature Language="C#" Value="public Microsoft.Build.Construction.ProjectRootElement Xml { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Build.Construction.ProjectRootElement Xml" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Build.Evaluation.Project.Xml" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Xml As ProjectRootElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Build::Construction::ProjectRootElement ^ Xml { Microsoft::Build::Construction::ProjectRootElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Xml : Microsoft.Build.Construction.ProjectRootElement" Usage="Microsoft.Build.Evaluation.Project.Xml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Build</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>15.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName Language="C#">[get: System.Diagnostics.DebuggerStepThrough]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.DebuggerStepThrough&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Build.Construction.ProjectRootElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The backing Xml project.
            Can never be null
            </summary>
        <value>The root project associated with this project, which can never be <see langword="null" />.</value>
        <remarks>
            There is no setter here as that doesn't make sense. If you have a new ProjectRootElement, evaluate it into a new Project.
            </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
