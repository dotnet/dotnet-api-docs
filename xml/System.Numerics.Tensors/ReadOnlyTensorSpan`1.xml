<Type Name="ReadOnlyTensorSpan&lt;T&gt;" FullName="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;">
  <TypeSignature Language="C#" Value="public readonly ref struct ReadOnlyTensorSpan&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit ReadOnlyTensorSpan`1&lt;T&gt; extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />
  <TypeSignature Language="VB.NET" Value="Public Structure ReadOnlyTensorSpan(Of T)" />
  <TypeSignature Language="F#" Value="type ReadOnlyTensorSpan&lt;'T&gt; = struct" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public value class ReadOnlyTensorSpan" />
  <AssemblyInfo>
    <AssemblyName>System.Numerics.Tensors</AssemblyName>
    <AssemblyVersion>9.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T">
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.Experimental("SYSLIB5001", UrlFormat="https://aka.ms/dotnet-warnings/{0}")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.Experimental("SYSLIB5001", UrlFormat="https://aka.ms/dotnet-warnings/{0}")&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Diagnostics.DebuggerDisplay("{ToString(),raw}")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerDisplay("{ToString(),raw}")&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Diagnostics.DebuggerTypeProxy(typeof(System.Numerics.Tensors.TensorSpanDebugView&lt;&gt;))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerTypeProxy(typeof(System.Numerics.Tensors.TensorSpanDebugView&lt;&gt;))&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.CompilerServices.CompilerFeatureRequired("RefStructs")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.CompilerFeatureRequired("RefStructs")&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.CompilerServices.IsByRefLike]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsByRefLike&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">To be added.</typeparam>
    <summary>
            ReadOnlyTensorSpan represents a contiguous region of arbitrary memory. Unlike arrays, it can point to either managed
            or native memory, or to memory allocated on the stack. It is type-safe and memory-safe.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReadOnlyTensorSpan (Array? array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As Array)" />
      <MemberSignature Language="F#" Value="new System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt; : Array -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="new System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt; array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReadOnlyTensorSpan(Array ^ array);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">The target array.</param>
        <summary>
            Creates a new <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> over the provided <see cref="T:System.Array" />. The new <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> will
            have a rank of 1 and a length equal to the length of the provided <see cref="T:System.Array" />.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReadOnlyTensorSpan (ReadOnlySpan&lt;T&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(System.ReadOnlySpan{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (span As ReadOnlySpan(Of T))" />
      <MemberSignature Language="F#" Value="new System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt; : ReadOnlySpan&lt;'T&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="new System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt; span" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReadOnlyTensorSpan(ReadOnlySpan&lt;T&gt; span);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="span">The target span.</param>
        <summary>
            Creates a new <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> over the provided <see cref="T:System.ReadOnlySpan`1" />. The new <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> will
            have a rank of 1 and a length equal to the length of the provided <see cref="T:System.ReadOnlySpan`1" />.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReadOnlyTensorSpan (T[]? array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T())" />
      <MemberSignature Language="F#" Value="new System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt; : 'T[] -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="new System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt; array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReadOnlyTensorSpan(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">The target array.</param>
        <summary>
            Creates a new span over the entirety of the target array.
            </summary>
        <remarks>Returns default when <paramref name="array" /> is null.</remarks>
        <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array" /> is covariant and array's type is not exactly T[].</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReadOnlyTensorSpan (T* data, IntPtr dataLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T* data, native int dataLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(`0*,System.IntPtr)" />
      <MemberSignature Language="F#" Value="new System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt; : nativeptr&lt;'T&gt; * nativeint -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="new System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt; (data, dataLength)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReadOnlyTensorSpan(T* data, IntPtr dataLength);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="data" Type="T*">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="dataLength" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="data">An unmanaged data to memory.</param>
        <param name="dataLength">The number of elements the unmanaged memory can hold.</param>
        <summary>
            Creates a new span over the target unmanaged buffer.  Clearly this
            is quite dangerous the length is not checked.
            But if this creation is correct, then all subsequent uses are correct.
            </summary>
        <remarks>Clearly this is quite dangerous the length is not checked. But if this creation is correct, then all subsequent uses are correct.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReadOnlyTensorSpan (ReadOnlySpan&lt;T&gt; span, scoped ReadOnlySpan&lt;IntPtr&gt; lengths, scoped ReadOnlySpan&lt;IntPtr&gt; strides);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;!T&gt; span, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(System.ReadOnlySpan{`0},System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (span As ReadOnlySpan(Of T), lengths As ReadOnlySpan(Of IntPtr), strides As ReadOnlySpan(Of IntPtr))" />
      <MemberSignature Language="F#" Value="new System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt; : ReadOnlySpan&lt;'T&gt; * ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="new System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt; (span, lengths, strides)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReadOnlyTensorSpan(ReadOnlySpan&lt;T&gt; span, ReadOnlySpan&lt;IntPtr&gt; lengths, ReadOnlySpan&lt;IntPtr&gt; strides);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="span" Type="System.ReadOnlySpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="span">The target span.</param>
        <param name="lengths">The lengths of each dimension.</param>
        <param name="strides">The strides for each dimension. Will be automatically calculated if not provided.</param>
        <summary>
            Creates a new <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> over the provided <see cref="T:System.Span`1" /> using the specified lengths and strides.
            If the strides are not provided, they will be automatically calculated.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReadOnlyTensorSpan (Array? array, scoped ReadOnlySpan&lt;System.Buffers.NIndex&gt; startIndex, scoped ReadOnlySpan&lt;IntPtr&gt; lengths, scoped ReadOnlySpan&lt;IntPtr&gt; strides);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Array array, valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NIndex&gt; startIndex, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(System.Array,System.ReadOnlySpan{System.Buffers.NIndex},System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As Array, startIndex As ReadOnlySpan(Of NIndex), lengths As ReadOnlySpan(Of IntPtr), strides As ReadOnlySpan(Of IntPtr))" />
      <MemberSignature Language="F#" Value="new System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt; : Array * ReadOnlySpan&lt;System.Buffers.NIndex&gt; * ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="new System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt; (array, startIndex, lengths, strides)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReadOnlyTensorSpan(Array ^ array, ReadOnlySpan&lt;System::Buffers::NIndex&gt; startIndex, ReadOnlySpan&lt;IntPtr&gt; lengths, ReadOnlySpan&lt;IntPtr&gt; strides);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="System.Array">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="startIndex" Type="System.ReadOnlySpan&lt;System.Buffers.NIndex&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">The target array.</param>
        <param name="startIndex">The starting offset for each dimension.</param>
        <param name="lengths">The lengths of each dimension.</param>
        <param name="strides">The strides for each dimension. Will be automatically calculated if not provided.</param>
        <summary>
            Creates a new <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> over the provided <see cref="T:System.Array" /> using the specified start offsets, lengths, and strides.
            If the strides are not provided, they will be automatically calculated.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReadOnlyTensorSpan (Array? array, scoped ReadOnlySpan&lt;int&gt; start, scoped ReadOnlySpan&lt;IntPtr&gt; lengths, scoped ReadOnlySpan&lt;IntPtr&gt; strides);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Array array, valuetype System.ReadOnlySpan`1&lt;int32&gt; start, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(System.Array,System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As Array, start As ReadOnlySpan(Of Integer), lengths As ReadOnlySpan(Of IntPtr), strides As ReadOnlySpan(Of IntPtr))" />
      <MemberSignature Language="F#" Value="new System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt; : Array * ReadOnlySpan&lt;int&gt; * ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="new System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt; (array, start, lengths, strides)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReadOnlyTensorSpan(Array ^ array, ReadOnlySpan&lt;int&gt; start, ReadOnlySpan&lt;IntPtr&gt; lengths, ReadOnlySpan&lt;IntPtr&gt; strides);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="System.Array">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="start" Type="System.ReadOnlySpan&lt;System.Int32&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">The target array.</param>
        <param name="start">The starting offset for each dimension.</param>
        <param name="lengths">The lengths of each dimension.</param>
        <param name="strides">The strides for each dimension. Will be automatically calculated if not provided.</param>
        <summary>
            Creates a new <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> over the provided <see cref="T:System.Array" /> using the specified start offsets, lengths, and strides.
            If the strides are not provided, they will be automatically calculated.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReadOnlyTensorSpan (T* data, IntPtr dataLength, scoped ReadOnlySpan&lt;IntPtr&gt; lengths, scoped ReadOnlySpan&lt;IntPtr&gt; strides);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T* data, native int dataLength, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(`0*,System.IntPtr,System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="F#" Value="new System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt; : nativeptr&lt;'T&gt; * nativeint * ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="new System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt; (data, dataLength, lengths, strides)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReadOnlyTensorSpan(T* data, IntPtr dataLength, ReadOnlySpan&lt;IntPtr&gt; lengths, ReadOnlySpan&lt;IntPtr&gt; strides);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="data" Type="T*">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="dataLength" Type="System.IntPtr" />
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">An unmanaged data to memory.</param>
        <param name="dataLength">The number of elements the unmanaged memory can hold.</param>
        <param name="lengths">The lengths of the dimensions. If default is provided its assumed to have 1 dimension with a length equal to the length of the data.</param>
        <param name="strides">The lengths of the strides. If nothing is provided it figures out the default stride configuration.</param>
        <summary>
            Creates a new span over the target unmanaged buffer.  Clearly this
            is quite dangerous, because the length is not checked.
            But if this creation is correct, then all subsequent uses are correct.
            </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
            Thrown when <typeparamref name="T" /> is reference type or contains pointers and hence cannot be stored in unmanaged memory.
            </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified length is negative.
            </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReadOnlyTensorSpan (T[]? array, Index startIndex, scoped ReadOnlySpan&lt;IntPtr&gt; lengths, scoped ReadOnlySpan&lt;IntPtr&gt; strides);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array, valuetype System.Index startIndex, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(`0[],System.Index,System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T(), startIndex As Index, lengths As ReadOnlySpan(Of IntPtr), strides As ReadOnlySpan(Of IntPtr))" />
      <MemberSignature Language="F#" Value="new System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt; : 'T[] * Index * ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="new System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt; (array, startIndex, lengths, strides)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReadOnlyTensorSpan(cli::array &lt;T&gt; ^ array, Index startIndex, ReadOnlySpan&lt;IntPtr&gt; lengths, ReadOnlySpan&lt;IntPtr&gt; strides);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="startIndex" Type="System.Index" />
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">The target array.</param>
        <param name="startIndex">The index at which to begin the span.</param>
        <param name="lengths">The lengths of the dimensions. If default is provided its assumed to have 1 dimension with a length equal to the length of the data.</param>
        <param name="strides">The strides of each dimension. If default or span of length 0 is provided then strides will be automatically calculated.</param>
        <summary>
            Creates a new span over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
        <remarks>Returns default when <paramref name="array" /> is null.</remarks>
        <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array" /> is covariant and array's type is not exactly T[].</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="startIndex" /> or end index is not in the range (&lt;0 or &gt;FlattenedLength).
            </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReadOnlyTensorSpan (T[]? array, int start, scoped ReadOnlySpan&lt;IntPtr&gt; lengths, scoped ReadOnlySpan&lt;IntPtr&gt; strides);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array, int32 start, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.#ctor(`0[],System.Int32,System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T(), start As Integer, lengths As ReadOnlySpan(Of IntPtr), strides As ReadOnlySpan(Of IntPtr))" />
      <MemberSignature Language="F#" Value="new System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt; : 'T[] * int * ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="new System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt; (array, start, lengths, strides)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReadOnlyTensorSpan(cli::array &lt;T&gt; ^ array, int start, ReadOnlySpan&lt;IntPtr&gt; lengths, ReadOnlySpan&lt;IntPtr&gt; strides);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">The target array.</param>
        <param name="start">The index at which to begin the span.</param>
        <param name="lengths">The lengths of the dimensions. If default is provided its assumed to have 1 dimension with a length equal to the length of the data.</param>
        <param name="strides">The strides of each dimension. If default or span of length 0 is provided then strides will be automatically calculated.</param>
        <summary>
            Creates a new span over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
        <remarks>Returns default when <paramref name="array" /> is null.</remarks>
        <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array" /> is covariant and array's type is not exactly T[].</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start" /> or end index is not in the range (&lt;0 or &gt;FlattenedLength).
            </exception>
      </Docs>
    </Member>
    <Member MemberName="CastUp&lt;TDerived&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; CastUp&lt;TDerived&gt; (System.Numerics.Tensors.ReadOnlyTensorSpan&lt;TDerived&gt; items) where TDerived : class, T;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!T&gt; CastUp&lt;class (!T) TDerived&gt;(valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!TDerived&gt; items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.CastUp``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CastUp(Of TDerived As {Class, T}) (items As ReadOnlyTensorSpan(Of TDerived)) As ReadOnlyTensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member CastUp : System.Numerics.Tensors.ReadOnlyTensorSpan&lt;#'T&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;.CastUp items" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TDerived&gt;&#xA; where TDerived : class, T static System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; CastUp(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;TDerived&gt; items);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TDerived">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <BaseTypeName>T</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="items" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;TDerived&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TDerived">The element type of the source read-only span, which must be derived from <typeparamref name="T" />.</typeparam>
        <param name="items">The source read-only span. No copy is made.</param>
        <summary>
            Casts a read-only span of <typeparamref name="TDerived" /> to a read-only span of <typeparamref name="T" />.
            </summary>
        <returns>A read-only span with elements cast to the new type.</returns>
        <remarks>This method uses a covariant cast, producing a read-only span that shares the same memory as the source. The relationships expressed in the type constraints ensure that the cast is a safe operation.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (scoped System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.CopyTo(System.Numerics.Tensors.TensorSpan{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As TensorSpan(Of T))" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.Numerics.Tensors.TensorSpan&lt;'T&gt; -&gt; unit" Usage="readOnlyTensorSpan.CopyTo destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(System::Numerics::Tensors::TensorSpan&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="destination">The span to copy items into.</param>
        <summary>
            Copies the contents of this read-only span into destination span. If the source
            and destinations overlap, this method behaves as if the original values in
            a temporary location before the destination is overwritten.
            </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
            Thrown when the destination ReadOnlyTensorSpan is shorter than the source ReadOnlyTensorSpan.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; Empty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!T&gt; Empty" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.ReadOnlyTensorSpan`1.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Empty As ReadOnlyTensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Empty : System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;.Empty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; Empty { System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Returns a 0-length read-only span whose base is the null pointer.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object? obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="readOnlyTensorSpan.Equals obj" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Obsolete("Equals() on ReadOnlyTensorSpan will always throw an exception. Use the equality operator instead.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Equals() on ReadOnlyTensorSpan will always throw an exception. Use the equality operator instead.")&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <summary>
            This method is not supported as spans cannot be boxed. To compare two spans, use operator==.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
            Always thrown by this method.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="FlattenedLength">
      <MemberSignature Language="C#" Value="public IntPtr FlattenedLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int FlattenedLength" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.ReadOnlyTensorSpan`1.FlattenedLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FlattenedLength As IntPtr" />
      <MemberSignature Language="F#" Value="member this.FlattenedLength : nativeint" Usage="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;.FlattenedLength" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr FlattenedLength { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The number of items in the span.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FlattenTo">
      <MemberSignature Language="C#" Value="public void FlattenTo (scoped Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FlattenTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.FlattenTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub FlattenTo (destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="member this.FlattenTo : Span&lt;'T&gt; -&gt; unit" Usage="readOnlyTensorSpan.FlattenTo destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FlattenTo(Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="destination">The span to copy items into.</param>
        <summary>
            Flattens the contents of this span into the provided <see cref="T:System.Span`1" />.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As ReadOnlyTensorSpan(Of T).Enumerator" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;.Enumerator" Usage="readOnlyTensorSpan.GetEnumerator " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets an enumerator for this span.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="readOnlyTensorSpan.GetHashCode " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Obsolete("GetHashCode() on ReadOnlyTensorSpan will always throw an exception.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("GetHashCode() on ReadOnlyTensorSpan will always throw an exception.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            This method is not supported as spans cannot be boxed.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
            Always thrown by this method.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="GetPinnableReference">
      <MemberSignature Language="C#" Value="public ref readonly T GetPinnableReference ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T GetPinnableReference() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.GetPinnableReference" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPinnableReference () As T" />
      <MemberSignature Language="F#" Value="member this.GetPinnableReference : unit -&gt; 'T" Usage="readOnlyTensorSpan.GetPinnableReference " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T&amp; ^ GetPinnableReference();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>T</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Returns a reference to the 0th element of the ReadOnlyTensorSpan. If the ReadOnlyTensorSpan is empty, returns null reference.
            It can be used for pinning and is required to support the use of span within a fixed statement.
            </summary>
        <returns>To be added.</returns>
        <remarks>If the ReadOnlyTensorSpan is empty, returns <see langword="null" /> reference. It can be used for pinning and is required to support the use of span within a fixed statement.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.ReadOnlyTensorSpan`1.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsEmpty : bool" Usage="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;.IsEmpty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEmpty { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets a value indicating whether this <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> is empty.
            </summary>
        <value>
          <see langword="true" /> if this span is empty; otherwise, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public ref readonly T this[scoped ReadOnlySpan&lt;System.Buffers.NIndex&gt; indexes] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NIndex&gt;)" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.ReadOnlyTensorSpan`1.Item(System.ReadOnlySpan{System.Buffers.NIndex})" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(indexes As ReadOnlySpan(Of NIndex)) As T" />
      <MemberSignature Language="F#" Value="member this.Item(ReadOnlySpan&lt;System.Buffers.NIndex&gt;) : 'T" Usage="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;.Item" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T&amp; ^ default[ReadOnlySpan&lt;System::Buffers::NIndex&gt;] { T&amp; ^ get(ReadOnlySpan&lt;System::Buffers::NIndex&gt; indexes); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexes" Type="System.ReadOnlySpan&lt;System.Buffers.NIndex&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indexes" />
        <summary>
            Returns a reference to specified element of the ReadOnlyTensorSpan.
            </summary>
        <value />
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException">
            Thrown when any index is less than 0 or any index is greater than or equal to FlattenedLength
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; this[scoped ReadOnlySpan&lt;System.Buffers.NRange&gt; ranges] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!T&gt; Item(valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NRange&gt;)" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.ReadOnlyTensorSpan`1.Item(System.ReadOnlySpan{System.Buffers.NRange})" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(ranges As ReadOnlySpan(Of NRange)) As ReadOnlyTensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="member this.Item(ReadOnlySpan&lt;System.Buffers.NRange&gt;) : System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;.Item" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; default[ReadOnlySpan&lt;System::Buffers::NRange&gt;] { System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; get(ReadOnlySpan&lt;System::Buffers::NRange&gt; ranges); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ranges" Type="System.ReadOnlySpan&lt;System.Buffers.NRange&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="ranges" />
        <summary>
            Returns a slice of the ReadOnlyTensorSpan.
            </summary>
        <value />
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException">
            Thrown when any index is less than 0 or any index is greater than or equal to FlattenedLength
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public ref readonly T this[scoped ReadOnlySpan&lt;IntPtr&gt; indexes] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(valuetype System.ReadOnlySpan`1&lt;native int&gt;)" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.ReadOnlyTensorSpan`1.Item(System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(indexes As ReadOnlySpan(Of IntPtr)) As T" />
      <MemberSignature Language="F#" Value="member this.Item(ReadOnlySpan&lt;nativeint&gt;) : 'T" Usage="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;.Item" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T&amp; ^ default[ReadOnlySpan&lt;IntPtr&gt;] { T&amp; ^ get(ReadOnlySpan&lt;IntPtr&gt; indexes); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexes" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indexes" />
        <summary>
            Returns a reference to specified element of the ReadOnlyTensorSpan.
            </summary>
        <value />
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException">
            Thrown when any index is less than 0 or any index is greater than or equal to FlattenedLength
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Lengths">
      <MemberSignature Language="C#" Value="public ReadOnlySpan&lt;IntPtr&gt; Lengths { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;native int&gt; Lengths" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.ReadOnlyTensorSpan`1.Lengths" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Lengths As ReadOnlySpan(Of IntPtr)" />
      <MemberSignature Language="F#" Value="member this.Lengths : ReadOnlySpan&lt;nativeint&gt;" Usage="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;.Lengths" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ReadOnlySpan&lt;IntPtr&gt; Lengths { ReadOnlySpan&lt;IntPtr&gt; get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.UnscopedRef]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.UnscopedRef&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.IntPtr&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the length of each dimension in this <see cref="T:System.Numerics.Tensors.TensorSpan`1" />.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!T&gt; left, valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.op_Equality(System.Numerics.Tensors.ReadOnlyTensorSpan{`0},System.Numerics.Tensors.ReadOnlyTensorSpan{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As ReadOnlyTensorSpan(Of T), right As ReadOnlyTensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt; * System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt; -&gt; bool" Usage="left = right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>
            Returns true if left and right point at the same memory and have the same length.  Note that
            this does *not* check to see if the *contents* are equal.
            </summary>
        <returns>
          <see langword="true" /> if left and right point at the same memory and have the same length. This operator does *not* check if the *contents* are equal.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; (T[]? array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!T&gt; op_Implicit(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.op_Implicit(`0[])~System.Numerics.Tensors.ReadOnlyTensorSpan{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (array As T()) As ReadOnlyTensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member op_Implicit : 'T[] -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;.op_Implicit array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt;(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!T&gt; left, valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.op_Inequality(System.Numerics.Tensors.ReadOnlyTensorSpan{`0},System.Numerics.Tensors.ReadOnlyTensorSpan{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As ReadOnlyTensorSpan(Of T), right As ReadOnlyTensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt; * System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt; -&gt; bool" Usage="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;.op_Inequality (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>
            Returns false if left and right point at the same memory and have the same length.  Note that
            this does *not* check to see if the *contents* are equal.
            </summary>
        <returns>
          <see langword="false" /> if left and right point at the same memory and have the same length. This operator does *not* check if the *contents* are unequal.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.ReadOnlyTensorSpan`1.Rank" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rank As Integer" />
      <MemberSignature Language="F#" Value="member this.Rank : int" Usage="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;.Rank" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Rank { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the rank, aka the number of dimensions, of this <see cref="T:System.Numerics.Tensors.TensorSpan`1" />.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; Slice (scoped ReadOnlySpan&lt;System.Buffers.NIndex&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!T&gt; Slice(valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NIndex&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.Slice(System.ReadOnlySpan{System.Buffers.NIndex})" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (indexes As ReadOnlySpan(Of NIndex)) As ReadOnlyTensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="member this.Slice : ReadOnlySpan&lt;System.Buffers.NIndex&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="readOnlyTensorSpan.Slice indexes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; Slice(ReadOnlySpan&lt;System::Buffers::NIndex&gt; indexes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexes" Type="System.ReadOnlySpan&lt;System.Buffers.NIndex&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indexes">The indexes for the slice.</param>
        <summary>
            Returns a reference to specified element of the TensorSpan.
            </summary>
        <returns />
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException">
            Thrown when any index is less than 0 or any index is greater than or equal to FlattenedLength
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; Slice (scoped ReadOnlySpan&lt;System.Buffers.NRange&gt; ranges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!T&gt; Slice(valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NRange&gt; ranges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.Slice(System.ReadOnlySpan{System.Buffers.NRange})" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (ranges As ReadOnlySpan(Of NRange)) As ReadOnlyTensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="member this.Slice : ReadOnlySpan&lt;System.Buffers.NRange&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="readOnlyTensorSpan.Slice ranges" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; Slice(ReadOnlySpan&lt;System::Buffers::NRange&gt; ranges);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ranges" Type="System.ReadOnlySpan&lt;System.Buffers.NRange&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="ranges">The ranges for the slice</param>
        <summary>
            Forms a slice out of the given span
            </summary>
        <returns>A <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> based on the provided <paramref name="ranges" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Strides">
      <MemberSignature Language="C#" Value="public ReadOnlySpan&lt;IntPtr&gt; Strides { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;native int&gt; Strides" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.ReadOnlyTensorSpan`1.Strides" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Strides As ReadOnlySpan(Of IntPtr)" />
      <MemberSignature Language="F#" Value="member this.Strides : ReadOnlySpan&lt;nativeint&gt;" Usage="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;.Strides" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ReadOnlySpan&lt;IntPtr&gt; Strides { ReadOnlySpan&lt;IntPtr&gt; get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.UnscopedRef]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.UnscopedRef&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.IntPtr&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the strides of this <see cref="T:System.Numerics.Tensors.TensorSpan`1" /></summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="readOnlyTensorSpan.ToString " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Returns a <see cref="T:System.String" /> with the name of the type and the number of elements.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCopyTo">
      <MemberSignature Language="C#" Value="public bool TryCopyTo (scoped System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryCopyTo(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.TryCopyTo(System.Numerics.Tensors.TensorSpan{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryCopyTo (destination As TensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryCopyTo : System.Numerics.Tensors.TensorSpan&lt;'T&gt; -&gt; bool" Usage="readOnlyTensorSpan.TryCopyTo destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryCopyTo(System::Numerics::Tensors::TensorSpan&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="destination">The span to copy items into.</param>
        <summary>
            Copies the contents of this read-only span into destination span. If the source
            and destinations overlap, this method behaves as if the original values in
            a temporary location before the destination is overwritten.
            </summary>
        <returns>If the destination span is shorter than the source span, this method
            return false and no data is written to the destination.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFlattenTo">
      <MemberSignature Language="C#" Value="public bool TryFlattenTo (scoped Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFlattenTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.ReadOnlyTensorSpan`1.TryFlattenTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFlattenTo (destination As Span(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFlattenTo : Span&lt;'T&gt; -&gt; bool" Usage="readOnlyTensorSpan.TryFlattenTo destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryFlattenTo(Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="destination">The span to copy items into.</param>
        <summary>
            Flattens the contents of this span into the provided <see cref="T:System.Span`1" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
