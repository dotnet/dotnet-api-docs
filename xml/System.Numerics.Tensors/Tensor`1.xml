<Type Name="Tensor&lt;T&gt;" FullName="System.Numerics.Tensors.Tensor&lt;T&gt;">
  <TypeSignature Language="C#" Value="public sealed class Tensor&lt;T&gt; : System.Collections.Generic.IEnumerable&lt;T&gt;, System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;, System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Tensor`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.IEnumerable, class System.Numerics.Tensors.IReadOnlyTensor`2&lt;class System.Numerics.Tensors.Tensor`1&lt;!T&gt;, !T&gt;, class System.Numerics.Tensors.ITensor`2&lt;class System.Numerics.Tensors.Tensor`1&lt;!T&gt;, !T&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Tensors.Tensor`1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Tensor(Of T)&#xA;Implements IEnumerable(Of T), IReadOnlyTensor(Of Tensor(Of T), T), ITensor(Of Tensor(Of T), T)" />
  <TypeSignature Language="F#" Value="type Tensor&lt;'T&gt; = class&#xA;    interface ITensor&lt;Tensor&lt;'T&gt;, 'T&gt;&#xA;    interface IReadOnlyTensor&lt;Tensor&lt;'T&gt;, 'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Tensor sealed : System::Collections::Generic::IEnumerable&lt;T&gt;, System::Numerics::Tensors::IReadOnlyTensor&lt;System::Numerics::Tensors::Tensor&lt;T&gt; ^, T&gt;, System::Numerics::Tensors::ITensor&lt;System::Numerics::Tensors::Tensor&lt;T&gt; ^, T&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Numerics.Tensors</AssemblyName>
    <AssemblyVersion>9.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T">
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.Tensors.IReadOnlyTensor&lt;TSelf,T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.Experimental("SYSLIB5001", UrlFormat="https://aka.ms/dotnet-warnings/{0}")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.Experimental("SYSLIB5001", UrlFormat="https://aka.ms/dotnet-warnings/{0}")&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">To be added.</typeparam>
    <summary>
            Represents a tensor.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="AsReadOnlyTensorSpan">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; AsReadOnlyTensorSpan ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!T&gt; AsReadOnlyTensorSpan() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.AsReadOnlyTensorSpan" />
      <MemberSignature Language="VB.NET" Value="Public Function AsReadOnlyTensorSpan () As ReadOnlyTensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="abstract member AsReadOnlyTensorSpan : unit -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;&#xA;override this.AsReadOnlyTensorSpan : unit -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="tensor.AsReadOnlyTensorSpan " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; AsReadOnlyTensorSpan();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.IReadOnlyTensor`2.AsReadOnlyTensorSpan</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Converts this <see cref="T:System.Numerics.Tensors.Tensor`1" /> to a <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> pointing to the same backing memory."/&gt;
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsReadOnlyTensorSpan">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; AsReadOnlyTensorSpan (scoped ReadOnlySpan&lt;System.Buffers.NIndex&gt; startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!T&gt; AsReadOnlyTensorSpan(valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NIndex&gt; startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.Buffers.NIndex})" />
      <MemberSignature Language="VB.NET" Value="Public Function AsReadOnlyTensorSpan (startIndex As ReadOnlySpan(Of NIndex)) As ReadOnlyTensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="abstract member AsReadOnlyTensorSpan : ReadOnlySpan&lt;System.Buffers.NIndex&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;&#xA;override this.AsReadOnlyTensorSpan : ReadOnlySpan&lt;System.Buffers.NIndex&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="tensor.AsReadOnlyTensorSpan startIndex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; AsReadOnlyTensorSpan(ReadOnlySpan&lt;System::Buffers::NIndex&gt; startIndex);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.IReadOnlyTensor`2.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.Buffers.NIndex})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.ReadOnlySpan&lt;System.Buffers.NIndex&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="startIndex">The start indexes you want in the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /></param>
        <summary>
            Converts this <see cref="T:System.Numerics.Tensors.Tensor`1" /> to a <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> pointing to the same backing memory based on the provided start indexes."/&gt;
            </summary>
        <returns />
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsReadOnlyTensorSpan">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; AsReadOnlyTensorSpan (scoped ReadOnlySpan&lt;System.Buffers.NRange&gt; start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!T&gt; AsReadOnlyTensorSpan(valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NRange&gt; start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.Buffers.NRange})" />
      <MemberSignature Language="VB.NET" Value="Public Function AsReadOnlyTensorSpan (start As ReadOnlySpan(Of NRange)) As ReadOnlyTensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="abstract member AsReadOnlyTensorSpan : ReadOnlySpan&lt;System.Buffers.NRange&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;&#xA;override this.AsReadOnlyTensorSpan : ReadOnlySpan&lt;System.Buffers.NRange&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="tensor.AsReadOnlyTensorSpan start" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; AsReadOnlyTensorSpan(ReadOnlySpan&lt;System::Buffers::NRange&gt; start);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.IReadOnlyTensor`2.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.Buffers.NRange})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.ReadOnlySpan&lt;System.Buffers.NRange&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="start">The ranges you want in the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /></param>
        <summary>
            Converts this <see cref="T:System.Numerics.Tensors.Tensor`1" /> to a <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> pointing to the same backing memory based on the provided ranges."/&gt;
            </summary>
        <returns />
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsReadOnlyTensorSpan">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; AsReadOnlyTensorSpan (scoped ReadOnlySpan&lt;IntPtr&gt; start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!T&gt; AsReadOnlyTensorSpan(valuetype System.ReadOnlySpan`1&lt;native int&gt; start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function AsReadOnlyTensorSpan (start As ReadOnlySpan(Of IntPtr)) As ReadOnlyTensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="abstract member AsReadOnlyTensorSpan : ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;&#xA;override this.AsReadOnlyTensorSpan : ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="tensor.AsReadOnlyTensorSpan start" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; AsReadOnlyTensorSpan(ReadOnlySpan&lt;IntPtr&gt; start);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.IReadOnlyTensor`2.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.IntPtr})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="start">The start locations you want in the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /></param>
        <summary>
            Converts this <see cref="T:System.Numerics.Tensors.Tensor`1" /> to a <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> pointing to the same backing memory based on the provided start locations."/&gt;
            </summary>
        <returns />
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsTensorSpan">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.TensorSpan&lt;T&gt; AsTensorSpan ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Numerics.Tensors.TensorSpan`1&lt;!T&gt; AsTensorSpan() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.AsTensorSpan" />
      <MemberSignature Language="VB.NET" Value="Public Function AsTensorSpan () As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="abstract member AsTensorSpan : unit -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;&#xA;override this.AsTensorSpan : unit -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="tensor.AsTensorSpan " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Numerics::Tensors::TensorSpan&lt;T&gt; AsTensorSpan();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.ITensor`2.AsTensorSpan</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Converts this <see cref="T:System.Numerics.Tensors.Tensor`1" /> to a <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> pointing to the same backing memory."/&gt;
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.TensorSpan`1" />
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsTensorSpan">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.TensorSpan&lt;T&gt; AsTensorSpan (scoped ReadOnlySpan&lt;System.Buffers.NIndex&gt; startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Numerics.Tensors.TensorSpan`1&lt;!T&gt; AsTensorSpan(valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NIndex&gt; startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.AsTensorSpan(System.ReadOnlySpan{System.Buffers.NIndex})" />
      <MemberSignature Language="VB.NET" Value="Public Function AsTensorSpan (startIndex As ReadOnlySpan(Of NIndex)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="abstract member AsTensorSpan : ReadOnlySpan&lt;System.Buffers.NIndex&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;&#xA;override this.AsTensorSpan : ReadOnlySpan&lt;System.Buffers.NIndex&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="tensor.AsTensorSpan startIndex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Numerics::Tensors::TensorSpan&lt;T&gt; AsTensorSpan(ReadOnlySpan&lt;System::Buffers::NIndex&gt; startIndex);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.ITensor`2.AsTensorSpan(System.ReadOnlySpan{System.Buffers.NIndex})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.ReadOnlySpan&lt;System.Buffers.NIndex&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="startIndex">The ranges you want in the <see cref="T:System.Numerics.Tensors.TensorSpan`1" />.</param>
        <summary>
            Converts this <see cref="T:System.Numerics.Tensors.Tensor`1" /> to a <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> pointing to the same backing memory based on the provided start indexes."/&gt;
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> based on the provided ranges.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsTensorSpan">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.TensorSpan&lt;T&gt; AsTensorSpan (scoped ReadOnlySpan&lt;System.Buffers.NRange&gt; start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Numerics.Tensors.TensorSpan`1&lt;!T&gt; AsTensorSpan(valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NRange&gt; start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.AsTensorSpan(System.ReadOnlySpan{System.Buffers.NRange})" />
      <MemberSignature Language="VB.NET" Value="Public Function AsTensorSpan (start As ReadOnlySpan(Of NRange)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="abstract member AsTensorSpan : ReadOnlySpan&lt;System.Buffers.NRange&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;&#xA;override this.AsTensorSpan : ReadOnlySpan&lt;System.Buffers.NRange&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="tensor.AsTensorSpan start" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Numerics::Tensors::TensorSpan&lt;T&gt; AsTensorSpan(ReadOnlySpan&lt;System::Buffers::NRange&gt; start);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.ITensor`2.AsTensorSpan(System.ReadOnlySpan{System.Buffers.NRange})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.ReadOnlySpan&lt;System.Buffers.NRange&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="start">The ranges you want in the <see cref="T:System.Numerics.Tensors.TensorSpan`1" />.</param>
        <summary>
            Converts this <see cref="T:System.Numerics.Tensors.Tensor`1" /> to a <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> pointing to the same backing memory based on the provided ranges."/&gt;
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> based on the provided ranges.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsTensorSpan">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.TensorSpan&lt;T&gt; AsTensorSpan (scoped ReadOnlySpan&lt;IntPtr&gt; start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Numerics.Tensors.TensorSpan`1&lt;!T&gt; AsTensorSpan(valuetype System.ReadOnlySpan`1&lt;native int&gt; start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.AsTensorSpan(System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function AsTensorSpan (start As ReadOnlySpan(Of IntPtr)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="abstract member AsTensorSpan : ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;&#xA;override this.AsTensorSpan : ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="tensor.AsTensorSpan start" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Numerics::Tensors::TensorSpan&lt;T&gt; AsTensorSpan(ReadOnlySpan&lt;IntPtr&gt; start);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.ITensor`2.AsTensorSpan(System.ReadOnlySpan{System.IntPtr})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="start">The start location you want in the <see cref="T:System.Numerics.Tensors.TensorSpan`1" />.</param>
        <summary>
            Converts this <see cref="T:System.Numerics.Tensors.Tensor`1" /> to a <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> pointing to the same backing memory based on the provided start locations."/&gt;
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> based on the provided ranges.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="tensor.Clear " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.ITensor`2.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Clears the contents of this tensor.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.CopyTo(System.Numerics.Tensors.TensorSpan{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As TensorSpan(Of T))" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : System.Numerics.Tensors.TensorSpan&lt;'T&gt; -&gt; unit&#xA;override this.CopyTo : System.Numerics.Tensors.TensorSpan&lt;'T&gt; -&gt; unit" Usage="tensor.CopyTo destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(System::Numerics::Tensors::TensorSpan&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.IReadOnlyTensor`2.CopyTo(System.Numerics.Tensors.TensorSpan{`1})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="destination">The span to copy items into.</param>
        <summary>
            Copies the contents of this tensor into destination span. If the source
            and destinations overlap, this method behaves as if the original values in
            a temporary location before the destination is overwritten.
            </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
            Thrown when the destination TensorSpan is shorter than the source Tensor.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Empty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Numerics.Tensors.Tensor`1&lt;!T&gt; Empty" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Empty As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Empty : System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="Empty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::Tensors::Tensor&lt;T&gt; ^ Empty { System::Numerics::Tensors::Tensor&lt;T&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.IReadOnlyTensor`2.Empty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[get: System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The Empty Tensor.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public void Fill (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Fill(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.Fill(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Fill (value As T)" />
      <MemberSignature Language="F#" Value="abstract member Fill : 'T -&gt; unit&#xA;override this.Fill : 'T -&gt; unit" Usage="tensor.Fill value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Fill(T value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.ITensor`2.Fill(`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>
            Fills the contents of this span with the given value.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FlattenedLength">
      <MemberSignature Language="C#" Value="public IntPtr FlattenedLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int FlattenedLength" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.FlattenedLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FlattenedLength As IntPtr" />
      <MemberSignature Language="F#" Value="member this.FlattenedLength : nativeint" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.FlattenedLength" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr FlattenedLength { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.IReadOnlyTensor`2.FlattenedLength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The number of items in the <see cref="T:System.Numerics.Tensors.Tensor`1" />.
            </summary>
        <value>
          <see cref="T:System.IntPtr" /> with the number of items.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FlattenTo">
      <MemberSignature Language="C#" Value="public void FlattenTo (Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FlattenTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.FlattenTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub FlattenTo (destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="abstract member FlattenTo : Span&lt;'T&gt; -&gt; unit&#xA;override this.FlattenTo : Span&lt;'T&gt; -&gt; unit" Usage="tensor.FlattenTo destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void FlattenTo(Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.IReadOnlyTensor`2.FlattenTo(System.Span{`1})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="destination">The span to copy items into.</param>
        <summary>
            Flattens the contents of this Tensor into the provided <see cref="T:System.Span`1" />.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerator&lt;T&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator(Of T)" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;'T&gt;" Usage="tensor.GetEnumerator " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerator&lt;T&gt; ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Gets an <see cref="T:System.Collections.Generic.IEnumerator`1" /> for the <see cref="T:System.Numerics.Tensors.Tensor`1" />.
            </summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerator`1" />
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="tensor.GetHashCode " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Gets the hash code for the <see cref="T:System.Numerics.Tensors.Tensor`1" />.
            </summary>
        <returns>The hash code of the tensor.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">In all cases.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPinnableReference">
      <MemberSignature Language="C#" Value="public ref T GetPinnableReference ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance !T GetPinnableReference() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.GetPinnableReference" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPinnableReference () As T" />
      <MemberSignature Language="F#" Value="abstract member GetPinnableReference : unit -&gt; 'T&#xA;override this.GetPinnableReference : unit -&gt; 'T" Usage="tensor.GetPinnableReference " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual T % GetPinnableReference();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.ITensor`2.GetPinnableReference</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Returns a reference to the 0th element of the Tensor. If the Tensor is empty, returns null reference.
            It can be used for pinning and is required to support the use of Tensor within a fixed statement.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsEmpty : bool" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.IsEmpty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEmpty { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.IReadOnlyTensor`2.IsEmpty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets a value indicating whether this <see cref="T:System.Numerics.Tensors.Tensor`1" /> is empty.
            </summary>
        <value>
          <see langword="true" /> if this tensor is empty; otherwise, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPinned">
      <MemberSignature Language="C#" Value="public bool IsPinned { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPinned" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.IsPinned" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPinned As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsPinned : bool" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.IsPinned" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPinned { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.IReadOnlyTensor`2.IsPinned</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets a value indicating whether the backing memory of the <see cref="T:System.Numerics.Tensors.Tensor`1" /> is pinned."/&gt;
            </summary>
        <value>
          <see langword="true" /> if the backing memory is pinned; otherwise, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.Tensor&lt;T&gt; this[System.Numerics.Tensors.Tensor&lt;bool&gt; filter] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Numerics.Tensors.Tensor`1&lt;!T&gt; Item(class System.Numerics.Tensors.Tensor`1&lt;bool&gt;)" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.Item(System.Numerics.Tensors.Tensor{System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(filter As Tensor(Of Boolean)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="member this.Item(System.Numerics.Tensors.Tensor&lt;bool&gt;) : System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.Item" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Numerics::Tensors::Tensor&lt;T&gt; ^ default[System::Numerics::Tensors::Tensor&lt;bool&gt; ^] { System::Numerics::Tensors::Tensor&lt;T&gt; ^ get(System::Numerics::Tensors::Tensor&lt;bool&gt; ^ filter); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[get: System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <param name="filter" />
        <summary />
        <value />
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public ref T this[scoped ReadOnlySpan&lt;System.Buffers.NIndex&gt; indexes] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NIndex&gt;)" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.Item(System.ReadOnlySpan{System.Buffers.NIndex})" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(indexes As ReadOnlySpan(Of NIndex)) As T" />
      <MemberSignature Language="F#" Value="member this.Item(ReadOnlySpan&lt;System.Buffers.NIndex&gt;) : 'T" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.Item" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T % default[ReadOnlySpan&lt;System::Buffers::NIndex&gt;] { T % get(ReadOnlySpan&lt;System::Buffers::NIndex&gt; indexes); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexes" Type="System.ReadOnlySpan&lt;System.Buffers.NIndex&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indexes" />
        <summary>
            Returns a reference to specified element of the Tensor.
            </summary>
        <value />
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException">
            Thrown when index less than 0 or index greater than or equal to FlattenedLength
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.Tensor&lt;T&gt; this[scoped ReadOnlySpan&lt;System.Buffers.NRange&gt; ranges] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Numerics.Tensors.Tensor`1&lt;!T&gt; Item(valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NRange&gt;)" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.Item(System.ReadOnlySpan{System.Buffers.NRange})" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(ranges As ReadOnlySpan(Of NRange)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="member this.Item(ReadOnlySpan&lt;System.Buffers.NRange&gt;) : System.Numerics.Tensors.Tensor&lt;'T&gt; with get, set" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.Item" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Numerics::Tensors::Tensor&lt;T&gt; ^ default[ReadOnlySpan&lt;System::Buffers::NRange&gt;] { System::Numerics::Tensors::Tensor&lt;T&gt; ^ get(ReadOnlySpan&lt;System::Buffers::NRange&gt; ranges); void set(ReadOnlySpan&lt;System::Buffers::NRange&gt; ranges, System::Numerics::Tensors::Tensor&lt;T&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.ITensor`2.Item(System.ReadOnlySpan{System.Buffers.NRange})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ranges" Type="System.ReadOnlySpan&lt;System.Buffers.NRange&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="ranges" />
        <summary>
            Returns a slice of the Tensor.
            </summary>
        <value />
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException">
            Thrown when any index is less than 0 or any index is greater than or equal to FlattenedLength
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public ref T this[scoped ReadOnlySpan&lt;IntPtr&gt; indexes] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(valuetype System.ReadOnlySpan`1&lt;native int&gt;)" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.Item(System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(indexes As ReadOnlySpan(Of IntPtr)) As T" />
      <MemberSignature Language="F#" Value="member this.Item(ReadOnlySpan&lt;nativeint&gt;) : 'T" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.Item" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T % default[ReadOnlySpan&lt;IntPtr&gt;] { T % get(ReadOnlySpan&lt;IntPtr&gt; indexes); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexes" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indexes" />
        <summary>
            Returns a reference to specified element of the Tensor.
            </summary>
        <value />
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException">
            Thrown when index less than 0 or index greater than or equal to FlattenedLength
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Lengths">
      <MemberSignature Language="C#" Value="public ReadOnlySpan&lt;IntPtr&gt; Lengths { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;native int&gt; Lengths" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.Lengths" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Lengths As ReadOnlySpan(Of IntPtr)" />
      <MemberSignature Language="F#" Value="member this.Lengths : ReadOnlySpan&lt;nativeint&gt;" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.Lengths" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ReadOnlySpan&lt;IntPtr&gt; Lengths { ReadOnlySpan&lt;IntPtr&gt; get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.IReadOnlyTensor`2.Lengths</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.IntPtr&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the length of each dimension in this <see cref="T:System.Numerics.Tensors.Tensor`1" />.
            </summary>
        <value>
          <see cref="T:System.ReadOnlySpan`1" /> with the lengths of each dimension.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!T&gt; op_Implicit(class System.Numerics.Tensors.Tensor`1&lt;!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.op_Implicit(System.Numerics.Tensors.Tensor{`0})~System.Numerics.Tensors.ReadOnlyTensorSpan{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Tensor(Of T)) As ReadOnlyTensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Numerics.Tensors.Tensor&lt;'T&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.op_Implicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt;(System::Numerics::Tensors::Tensor&lt;T&gt; ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Tensors.TensorSpan&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Tensors.TensorSpan`1&lt;!T&gt; op_Implicit(class System.Numerics.Tensors.Tensor`1&lt;!T&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.op_Implicit(System.Numerics.Tensors.Tensor{`0})~System.Numerics.Tensors.TensorSpan{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Tensor(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Numerics.Tensors.Tensor&lt;'T&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.op_Implicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Tensors::TensorSpan&lt;T&gt;(System::Numerics::Tensors::Tensor&lt;T&gt; ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Tensors.Tensor&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Numerics.Tensors.Tensor`1&lt;!T&gt; op_Implicit(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.op_Implicit(`0[])~System.Numerics.Tensors.Tensor{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (array As T()) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member op_Implicit : 'T[] -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.op_Implicit array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Tensors::Tensor&lt;T&gt; ^(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.Rank" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rank As Integer" />
      <MemberSignature Language="F#" Value="member this.Rank : int" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.Rank" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Rank { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.IReadOnlyTensor`2.Rank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets a value indicating the rank, or number of dimensions, of this <see cref="T:System.Numerics.Tensors.Tensor`1" />.
            </summary>
        <value>
          <see cref="T:System.IntPtr" /> with the number of dimensions.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.Tensor&lt;T&gt; Slice (scoped ReadOnlySpan&lt;System.Buffers.NIndex&gt; startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Numerics.Tensors.Tensor`1&lt;!T&gt; Slice(valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NIndex&gt; startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.Slice(System.ReadOnlySpan{System.Buffers.NIndex})" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (startIndex As ReadOnlySpan(Of NIndex)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="abstract member Slice : ReadOnlySpan&lt;System.Buffers.NIndex&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;&#xA;override this.Slice : ReadOnlySpan&lt;System.Buffers.NIndex&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="tensor.Slice startIndex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Numerics::Tensors::Tensor&lt;T&gt; ^ Slice(ReadOnlySpan&lt;System::Buffers::NIndex&gt; startIndex);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.IReadOnlyTensor`2.Slice(System.ReadOnlySpan{System.Buffers.NIndex})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.ReadOnlySpan&lt;System.Buffers.NIndex&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="startIndex">The start indexes for the slice</param>
        <summary>
            Forms a slice out of the given tensor
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> as a copy of the provided ranges.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.Tensor&lt;T&gt; Slice (scoped ReadOnlySpan&lt;System.Buffers.NRange&gt; start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Numerics.Tensors.Tensor`1&lt;!T&gt; Slice(valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NRange&gt; start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.Slice(System.ReadOnlySpan{System.Buffers.NRange})" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (start As ReadOnlySpan(Of NRange)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="abstract member Slice : ReadOnlySpan&lt;System.Buffers.NRange&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;&#xA;override this.Slice : ReadOnlySpan&lt;System.Buffers.NRange&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="tensor.Slice start" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Numerics::Tensors::Tensor&lt;T&gt; ^ Slice(ReadOnlySpan&lt;System::Buffers::NRange&gt; start);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.IReadOnlyTensor`2.Slice(System.ReadOnlySpan{System.Buffers.NRange})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.ReadOnlySpan&lt;System.Buffers.NRange&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="start">The ranges for the slice</param>
        <summary>
            Forms a slice out of the given tensor
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> as a copy of the provided ranges.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.Tensor&lt;T&gt; Slice (scoped ReadOnlySpan&lt;IntPtr&gt; start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Numerics.Tensors.Tensor`1&lt;!T&gt; Slice(valuetype System.ReadOnlySpan`1&lt;native int&gt; start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.Slice(System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (start As ReadOnlySpan(Of IntPtr)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="abstract member Slice : ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;&#xA;override this.Slice : ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="tensor.Slice start" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Numerics::Tensors::Tensor&lt;T&gt; ^ Slice(ReadOnlySpan&lt;IntPtr&gt; start);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.IReadOnlyTensor`2.Slice(System.ReadOnlySpan{System.IntPtr})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="start">The start indexes for the slice</param>
        <summary>
            Forms a slice out of the given tensor
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> as a copy of the provided ranges.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Strides">
      <MemberSignature Language="C#" Value="public ReadOnlySpan&lt;IntPtr&gt; Strides { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;native int&gt; Strides" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.Strides" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Strides As ReadOnlySpan(Of IntPtr)" />
      <MemberSignature Language="F#" Value="member this.Strides : ReadOnlySpan&lt;nativeint&gt;" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.Strides" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ReadOnlySpan&lt;IntPtr&gt; Strides { ReadOnlySpan&lt;IntPtr&gt; get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.IReadOnlyTensor`2.Strides</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.IntPtr&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the strides of each dimension in this <see cref="T:System.Numerics.Tensors.Tensor`1" />.
            </summary>
        <value>
          <see cref="T:System.ReadOnlySpan`1" /> with the strides of each dimension.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;'T&gt;&#xA;override this.System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;'T&gt;" Usage="tensor.System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator " />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Gets an <see cref="T:System.Collections.Generic.IEnumerator`1" /> for the <see cref="T:System.Numerics.Tensors.Tensor`1" />.
            </summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerator`1" />
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IEnumerable.GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.System.Collections.IEnumerable.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="tensor.System.Collections.IEnumerable.GetEnumerator " />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Gets an <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Numerics.Tensors.Tensor`1" />."/&gt;
            </summary>
        <returns />
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.GetPinnableReference">
      <MemberSignature Language="C#" Value="ref readonly T IReadOnlyTensor&lt;Tensor&lt;T&gt;,T&gt;.GetPinnableReference ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance !T System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.GetPinnableReference() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.System#Numerics#Tensors#IReadOnlyTensor&lt;System#Numerics#Tensors#Tensor&lt;T&gt;,T&gt;#GetPinnableReference" />
      <MemberSignature Language="VB.NET" Value="Function GetPinnableReference () As T Implements IReadOnlyTensor(Of Tensor(Of T), T).GetPinnableReference" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.GetPinnableReference : unit -&gt; 'T&#xA;override this.System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.GetPinnableReference : unit -&gt; 'T" Usage="tensor.System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.GetPinnableReference " />
      <MemberSignature Language="C++ CLI" Value=" virtual T&amp; ^ System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.GetPinnableReference() = System::Numerics::Tensors::IReadOnlyTensor&lt;System::Numerics::Tensors::Tensor&lt;T&gt; ^, T&gt;::GetPinnableReference;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.IReadOnlyTensor`2.GetPinnableReference</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>T</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Returns a reference to the 0th element of the ReadOnlyTensor. If the ReadOnlyTensor is empty, returns null reference.
            It can be used for pinning and is required to support the use of ReadOnlyTensor within a fixed statement.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item">
      <MemberSignature Language="C#" Value="T System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item[scoped ReadOnlySpan&lt;System.Buffers.NIndex&gt; indexes] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item(valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NIndex&gt;)" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.System#Numerics#Tensors#IReadOnlyTensor&lt;System#Numerics#Tensors#Tensor&lt;T&gt;,T&gt;#Item(System.ReadOnlySpan{System.Buffers.NIndex})" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Item(indexes As ReadOnlySpan(Of NIndex)) As T Implements IReadOnlyTensor(Of Tensor(Of T), T).Item" />
      <MemberSignature Language="F#" Value="member this.System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item(ReadOnlySpan&lt;System.Buffers.NIndex&gt;) : 'T" Usage="System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item" />
      <MemberSignature Language="C++ CLI" Value="property T System::Numerics::Tensors::IReadOnlyTensor&lt;System::Numerics::Tensors::Tensor&lt;T&gt;,T&gt;::Item[ReadOnlySpan&lt;System::Buffers::NIndex&gt;] { T get(ReadOnlySpan&lt;System::Buffers::NIndex&gt; indexes); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.IReadOnlyTensor`2.Item(System.ReadOnlySpan{System.Buffers.NIndex})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexes" Type="System.ReadOnlySpan&lt;System.Buffers.NIndex&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indexes" />
        <summary>
            Returns the specified element of the ReadOnlyTensor.
            </summary>
        <value />
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException">
            Thrown when index less than 0 or index greater than or equal to FlattenedLength
            </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item">
      <MemberSignature Language="C#" Value="System.Numerics.Tensors.Tensor&lt;T&gt; System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item[scoped ReadOnlySpan&lt;System.Buffers.NRange&gt; ranges] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Numerics.Tensors.Tensor`1&lt;!T&gt; System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item(valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NRange&gt;)" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.System#Numerics#Tensors#IReadOnlyTensor&lt;System#Numerics#Tensors#Tensor&lt;T&gt;,T&gt;#Item(System.ReadOnlySpan{System.Buffers.NRange})" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Item(ranges As ReadOnlySpan(Of NRange)) As Tensor(Of T) Implements IReadOnlyTensor(Of Tensor(Of T), T).Item" />
      <MemberSignature Language="F#" Value="member this.System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item(ReadOnlySpan&lt;System.Buffers.NRange&gt;) : System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Numerics::Tensors::Tensor&lt;T&gt; ^ System::Numerics::Tensors::IReadOnlyTensor&lt;System::Numerics::Tensors::Tensor&lt;T&gt;,T&gt;::Item[ReadOnlySpan&lt;System::Buffers::NRange&gt;] { System::Numerics::Tensors::Tensor&lt;T&gt; ^ get(ReadOnlySpan&lt;System::Buffers::NRange&gt; ranges); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.IReadOnlyTensor`2.Item(System.ReadOnlySpan{System.Buffers.NRange})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ranges" Type="System.ReadOnlySpan&lt;System.Buffers.NRange&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="ranges" />
        <summary>
            Returns a slice of the ReadOnlyTensor.
            </summary>
        <value />
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException">
            Thrown when any index is less than 0 or any index is greater than or equal to FlattenedLength
            </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item">
      <MemberSignature Language="C#" Value="T System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item[scoped ReadOnlySpan&lt;IntPtr&gt; indexes] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item(valuetype System.ReadOnlySpan`1&lt;native int&gt;)" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.System#Numerics#Tensors#IReadOnlyTensor&lt;System#Numerics#Tensors#Tensor&lt;T&gt;,T&gt;#Item(System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Item(indexes As ReadOnlySpan(Of IntPtr)) As T Implements IReadOnlyTensor(Of Tensor(Of T), T).Item" />
      <MemberSignature Language="F#" Value="member this.System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item(ReadOnlySpan&lt;nativeint&gt;) : 'T" Usage="System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item" />
      <MemberSignature Language="C++ CLI" Value="property T System::Numerics::Tensors::IReadOnlyTensor&lt;System::Numerics::Tensors::Tensor&lt;T&gt;,T&gt;::Item[ReadOnlySpan&lt;IntPtr&gt;] { T get(ReadOnlySpan&lt;IntPtr&gt; indexes); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.IReadOnlyTensor`2.Item(System.ReadOnlySpan{System.IntPtr})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexes" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indexes" />
        <summary>
            Returns the specified element of the ReadOnlyTensor.
            </summary>
        <value />
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException">
            Thrown when index less than 0 or index greater than or equal to FlattenedLength
            </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Lengths">
      <MemberSignature Language="C#" Value="ReadOnlySpan&lt;IntPtr&gt; System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Lengths { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;native int&gt; System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Lengths" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.System#Numerics#Tensors#IReadOnlyTensor&lt;System#Numerics#Tensors#Tensor&lt;T&gt;,T&gt;#Lengths" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Lengths As ReadOnlySpan(Of IntPtr) Implements IReadOnlyTensor(Of Tensor(Of T), T).Lengths" />
      <MemberSignature Language="F#" Value="member this.System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Lengths : ReadOnlySpan&lt;nativeint&gt;" Usage="System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Lengths" />
      <MemberSignature Language="C++ CLI" Value="property ReadOnlySpan&lt;IntPtr&gt; System::Numerics::Tensors::IReadOnlyTensor&lt;System::Numerics::Tensors::Tensor&lt;T&gt;,T&gt;::Lengths { ReadOnlySpan&lt;IntPtr&gt; get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.IReadOnlyTensor`2.Lengths</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.IntPtr&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the length of each dimension in this <see cref="T:System.Numerics.Tensors.Tensor`1" />.
            </summary>
        <value>
          <see cref="T:System.ReadOnlySpan`1" /> with the lengths of each dimension.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Strides">
      <MemberSignature Language="C#" Value="ReadOnlySpan&lt;IntPtr&gt; System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Strides { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;native int&gt; System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Strides" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.System#Numerics#Tensors#IReadOnlyTensor&lt;System#Numerics#Tensors#Tensor&lt;T&gt;,T&gt;#Strides" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Strides As ReadOnlySpan(Of IntPtr) Implements IReadOnlyTensor(Of Tensor(Of T), T).Strides" />
      <MemberSignature Language="F#" Value="member this.System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Strides : ReadOnlySpan&lt;nativeint&gt;" Usage="System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Strides" />
      <MemberSignature Language="C++ CLI" Value="property ReadOnlySpan&lt;IntPtr&gt; System::Numerics::Tensors::IReadOnlyTensor&lt;System::Numerics::Tensors::Tensor&lt;T&gt;,T&gt;::Strides { ReadOnlySpan&lt;IntPtr&gt; get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.IReadOnlyTensor`2.Strides</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.IntPtr&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the strides of each dimension in this <see cref="T:System.Numerics.Tensors.Tensor`1" />.
            </summary>
        <value>
          <see cref="T:System.ReadOnlySpan`1" /> with the strides of each dimension.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Create">
      <MemberSignature Language="C#" Value="static System.Numerics.Tensors.Tensor&lt;T&gt; ITensor&lt;Tensor&lt;T&gt;,T&gt;.Create (ReadOnlySpan&lt;IntPtr&gt; lengths, bool pinned);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!T&gt; System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Create(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.System#Numerics#Tensors#ITensor&lt;System#Numerics#Tensors#Tensor&lt;T&gt;,T&gt;#Create(System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function Create (lengths As ReadOnlySpan(Of IntPtr), pinned As Boolean) As Tensor(Of T) Implements ITensor(Of Tensor(Of T), T).Create" />
      <MemberSignature Language="F#" Value="static member System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Create : ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Create (lengths, pinned)" />
      <MemberSignature Language="C++ CLI" Value=" static System::Numerics::Tensors::Tensor&lt;T&gt; ^ System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Create(ReadOnlySpan&lt;IntPtr&gt; lengths, bool pinned) = System::Numerics::Tensors::ITensor&lt;System::Numerics::Tensors::Tensor&lt;T&gt; ^, T&gt;::Create;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.ITensor`2.Create(System.ReadOnlySpan{System.IntPtr},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;" />
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="lengths">A <see cref="T:System.ReadOnlySpan`1" /> indicating the lengths of each dimension.</param>
        <param name="pinned">A <see cref="T:System.Boolean" /> whether the underlying data should be pinned or not.</param>
        <summary>
            Creates a <see cref="T:System.Numerics.Tensors.Tensor`1" /> and initializes it with the default value of T. If <paramref name="pinned" /> is true, the memory will be pinned.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Create">
      <MemberSignature Language="C#" Value="static System.Numerics.Tensors.Tensor&lt;T&gt; ITensor&lt;Tensor&lt;T&gt;,T&gt;.Create (ReadOnlySpan&lt;IntPtr&gt; lengths, ReadOnlySpan&lt;IntPtr&gt; strides, bool pinned);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!T&gt; System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Create(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.System#Numerics#Tensors#ITensor&lt;System#Numerics#Tensors#Tensor&lt;T&gt;,T&gt;#Create(System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function Create (lengths As ReadOnlySpan(Of IntPtr), strides As ReadOnlySpan(Of IntPtr), pinned As Boolean) As Tensor(Of T) Implements ITensor(Of Tensor(Of T), T).Create" />
      <MemberSignature Language="F#" Value="static member System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Create : ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Create (lengths, strides, pinned)" />
      <MemberSignature Language="C++ CLI" Value=" static System::Numerics::Tensors::Tensor&lt;T&gt; ^ System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Create(ReadOnlySpan&lt;IntPtr&gt; lengths, ReadOnlySpan&lt;IntPtr&gt; strides, bool pinned) = System::Numerics::Tensors::ITensor&lt;System::Numerics::Tensors::Tensor&lt;T&gt; ^, T&gt;::Create;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.ITensor`2.Create(System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;" />
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;" />
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="lengths">A <see cref="T:System.ReadOnlySpan`1" /> indicating the lengths of each dimension.</param>
        <param name="strides">A <see cref="T:System.ReadOnlySpan`1" /> indicating the strides of each dimension.</param>
        <param name="pinned">A <see cref="T:System.Boolean" /> whether the underlying data should be pinned or not.</param>
        <summary>
            Creates a <see cref="T:System.Numerics.Tensors.Tensor`1" /> and initializes it with the default value of T. If <paramref name="pinned" /> is true, the memory will be pinned.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.CreateUninitialized">
      <MemberSignature Language="C#" Value="static System.Numerics.Tensors.Tensor&lt;T&gt; ITensor&lt;Tensor&lt;T&gt;,T&gt;.CreateUninitialized (ReadOnlySpan&lt;IntPtr&gt; lengths, bool pinned);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!T&gt; System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.CreateUninitialized(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.System#Numerics#Tensors#ITensor&lt;System#Numerics#Tensors#Tensor&lt;T&gt;,T&gt;#CreateUninitialized(System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function CreateUninitialized (lengths As ReadOnlySpan(Of IntPtr), pinned As Boolean) As Tensor(Of T) Implements ITensor(Of Tensor(Of T), T).CreateUninitialized" />
      <MemberSignature Language="F#" Value="static member System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.CreateUninitialized : ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.CreateUninitialized (lengths, pinned)" />
      <MemberSignature Language="C++ CLI" Value=" static System::Numerics::Tensors::Tensor&lt;T&gt; ^ System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.CreateUninitialized(ReadOnlySpan&lt;IntPtr&gt; lengths, bool pinned) = System::Numerics::Tensors::ITensor&lt;System::Numerics::Tensors::Tensor&lt;T&gt; ^, T&gt;::CreateUninitialized;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.ITensor`2.CreateUninitialized(System.ReadOnlySpan{System.IntPtr},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;" />
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="lengths">A <see cref="T:System.ReadOnlySpan`1" /> indicating the lengths of each dimension.</param>
        <param name="pinned">A <see cref="T:System.Boolean" /> whether the underlying data should be pinned or not.</param>
        <summary>
            Creates a <see cref="T:System.Numerics.Tensors.Tensor`1" /> and does not initialize it. If <paramref name="pinned" /> is true, the memory will be pinned.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.CreateUninitialized">
      <MemberSignature Language="C#" Value="static System.Numerics.Tensors.Tensor&lt;T&gt; ITensor&lt;Tensor&lt;T&gt;,T&gt;.CreateUninitialized (ReadOnlySpan&lt;IntPtr&gt; lengths, ReadOnlySpan&lt;IntPtr&gt; strides, bool pinned);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!T&gt; System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.CreateUninitialized(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.System#Numerics#Tensors#ITensor&lt;System#Numerics#Tensors#Tensor&lt;T&gt;,T&gt;#CreateUninitialized(System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function CreateUninitialized (lengths As ReadOnlySpan(Of IntPtr), strides As ReadOnlySpan(Of IntPtr), pinned As Boolean) As Tensor(Of T) Implements ITensor(Of Tensor(Of T), T).CreateUninitialized" />
      <MemberSignature Language="F#" Value="static member System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.CreateUninitialized : ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.CreateUninitialized (lengths, strides, pinned)" />
      <MemberSignature Language="C++ CLI" Value=" static System::Numerics::Tensors::Tensor&lt;T&gt; ^ System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.CreateUninitialized(ReadOnlySpan&lt;IntPtr&gt; lengths, ReadOnlySpan&lt;IntPtr&gt; strides, bool pinned) = System::Numerics::Tensors::ITensor&lt;System::Numerics::Tensors::Tensor&lt;T&gt; ^, T&gt;::CreateUninitialized;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.ITensor`2.CreateUninitialized(System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;" />
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;" />
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="lengths">A <see cref="T:System.ReadOnlySpan`1" /> indicating the lengths of each dimension.</param>
        <param name="strides">A <see cref="T:System.ReadOnlySpan`1" /> indicating the strides of each dimension.</param>
        <param name="pinned">A <see cref="T:System.Boolean" /> whether the underlying data should be pinned or not.</param>
        <summary>
            Creates a <see cref="T:System.Numerics.Tensors.Tensor`1" /> and does not initialize it. If <paramref name="pinned" /> is true, the memory will be pinned.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.System#Numerics#Tensors#ITensor&lt;System#Numerics#Tensors#Tensor&lt;T&gt;,T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ITensor(Of Tensor(Of T), T).IsReadOnly" />
      <MemberSignature Language="F#" Value="member this.System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.IsReadOnly : bool" Usage="System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Numerics::Tensors::ITensor&lt;System::Numerics::Tensors::Tensor&lt;T&gt;,T&gt;::IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.ITensor`2.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item">
      <MemberSignature Language="C#" Value="T System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item[scoped ReadOnlySpan&lt;System.Buffers.NIndex&gt; indexes] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item(valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NIndex&gt;)" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.System#Numerics#Tensors#ITensor&lt;System#Numerics#Tensors#Tensor&lt;T&gt;,T&gt;#Item(System.ReadOnlySpan{System.Buffers.NIndex})" />
      <MemberSignature Language="VB.NET" Value=" Property Item(indexes As ReadOnlySpan(Of NIndex)) As T Implements ITensor(Of Tensor(Of T), T).Item" />
      <MemberSignature Language="F#" Value="member this.System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item(ReadOnlySpan&lt;System.Buffers.NIndex&gt;) : 'T with get, set" Usage="System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item" />
      <MemberSignature Language="C++ CLI" Value="property T System::Numerics::Tensors::ITensor&lt;System::Numerics::Tensors::Tensor&lt;T&gt;,T&gt;::Item[ReadOnlySpan&lt;System::Buffers::NIndex&gt;] { T get(ReadOnlySpan&lt;System::Buffers::NIndex&gt; indexes); void set(ReadOnlySpan&lt;System::Buffers::NIndex&gt; indexes, T value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.ITensor`2.Item(System.ReadOnlySpan{System.Buffers.NIndex})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexes" Type="System.ReadOnlySpan&lt;System.Buffers.NIndex&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indexes" />
        <summary>
            Returns the specified element of the Tensor.
            </summary>
        <value />
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException">
            Thrown when index less than 0 or index greater than or equal to FlattenedLength
            </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item">
      <MemberSignature Language="C#" Value="T System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item[scoped ReadOnlySpan&lt;IntPtr&gt; indexes] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item(valuetype System.ReadOnlySpan`1&lt;native int&gt;)" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.System#Numerics#Tensors#ITensor&lt;System#Numerics#Tensors#Tensor&lt;T&gt;,T&gt;#Item(System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value=" Property Item(indexes As ReadOnlySpan(Of IntPtr)) As T Implements ITensor(Of Tensor(Of T), T).Item" />
      <MemberSignature Language="F#" Value="member this.System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item(ReadOnlySpan&lt;nativeint&gt;) : 'T with get, set" Usage="System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item" />
      <MemberSignature Language="C++ CLI" Value="property T System::Numerics::Tensors::ITensor&lt;System::Numerics::Tensors::Tensor&lt;T&gt;,T&gt;::Item[ReadOnlySpan&lt;IntPtr&gt;] { T get(ReadOnlySpan&lt;IntPtr&gt; indexes); void set(ReadOnlySpan&lt;IntPtr&gt; indexes, T value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.ITensor`2.Item(System.ReadOnlySpan{System.IntPtr})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexes" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indexes" />
        <summary>
            Returns the specified element of the Tensor.
            </summary>
        <value />
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException">
            Thrown when index less than 0 or index greater than or equal to FlattenedLength
            </exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (scoped ReadOnlySpan&lt;IntPtr&gt; maximumLengths);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(valuetype System.ReadOnlySpan`1&lt;native int&gt; maximumLengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.ToString(System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (maximumLengths As ReadOnlySpan(Of IntPtr)) As String" />
      <MemberSignature Language="F#" Value="override this.ToString : ReadOnlySpan&lt;nativeint&gt; -&gt; string" Usage="tensor.ToString maximumLengths" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(ReadOnlySpan&lt;IntPtr&gt; maximumLengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maximumLengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="maximumLengths">Maximum Length of each dimension</param>
        <summary>
            Creates a <see cref="T:System.String" /> representation of the <see cref="T:System.Numerics.Tensors.TensorSpan`1" />."/&gt;
            </summary>
        <returns>A <see cref="T:System.String" /> representation of the <see cref="T:System.Numerics.Tensors.Tensor`1" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCopyTo">
      <MemberSignature Language="C#" Value="public bool TryCopyTo (System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryCopyTo(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.TryCopyTo(System.Numerics.Tensors.TensorSpan{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryCopyTo (destination As TensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member TryCopyTo : System.Numerics.Tensors.TensorSpan&lt;'T&gt; -&gt; bool&#xA;override this.TryCopyTo : System.Numerics.Tensors.TensorSpan&lt;'T&gt; -&gt; bool" Usage="tensor.TryCopyTo destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryCopyTo(System::Numerics::Tensors::TensorSpan&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.IReadOnlyTensor`2.TryCopyTo(System.Numerics.Tensors.TensorSpan{`1})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="destination">The span to copy items into.</param>
        <summary>
            Copies the contents of this tensor into destination span. If the source
            and destinations overlap, this method behaves as if the original values in
            a temporary location before the destination is overwritten.
            </summary>
        <returns>If the destination span is shorter than the source tensor, this method
            return false and no data is written to the destination.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFlattenTo">
      <MemberSignature Language="C#" Value="public bool TryFlattenTo (Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryFlattenTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.TryFlattenTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFlattenTo (destination As Span(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member TryFlattenTo : Span&lt;'T&gt; -&gt; bool&#xA;override this.TryFlattenTo : Span&lt;'T&gt; -&gt; bool" Usage="tensor.TryFlattenTo destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryFlattenTo(Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.IReadOnlyTensor`2.TryFlattenTo(System.Span{`1})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="destination">The span to copy items into.</param>
        <summary>
            Flattens the contents of this Tensor into the provided <see cref="T:System.Span`1" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
