<Type Name="Tensor&lt;T&gt;" FullName="System.Numerics.Tensors.Tensor&lt;T&gt;">
  <TypeSignature Language="C#" Value="public sealed class Tensor&lt;T&gt; : System.Collections.Generic.IEnumerable&lt;T&gt;, System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;, System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Tensor`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.IEnumerable, class System.Numerics.Tensors.IReadOnlyTensor, class System.Numerics.Tensors.IReadOnlyTensor`2&lt;class System.Numerics.Tensors.Tensor`1&lt;!T&gt;, !T&gt;, class System.Numerics.Tensors.ITensor, class System.Numerics.Tensors.ITensor`2&lt;class System.Numerics.Tensors.Tensor`1&lt;!T&gt;, !T&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Tensors.Tensor`1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Tensor(Of T)&#xA;Implements IEnumerable(Of T), IReadOnlyTensor(Of Tensor(Of T), T), ITensor(Of Tensor(Of T), T)" />
  <TypeSignature Language="F#" Value="type Tensor&lt;'T&gt; = class&#xA;    interface ITensor&lt;Tensor&lt;'T&gt;, 'T&gt;&#xA;    interface ITensor&#xA;    interface IReadOnlyTensor&#xA;    interface IReadOnlyTensor&lt;Tensor&lt;'T&gt;, 'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Tensor sealed : System::Collections::Generic::IEnumerable&lt;T&gt;, System::Numerics::Tensors::IReadOnlyTensor&lt;System::Numerics::Tensors::Tensor&lt;T&gt; ^, T&gt;, System::Numerics::Tensors::ITensor&lt;System::Numerics::Tensors::Tensor&lt;T&gt; ^, T&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Numerics.Tensors</AssemblyName>
    <AssemblyVersion>9.0.0.0</AssemblyVersion>
    <AssemblyVersion>9.0.0.1</AssemblyVersion>
    <AssemblyVersion>9.0.0.2</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T">
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.Tensors.IReadOnlyTensor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.Tensors.IReadOnlyTensor&lt;TSelf,T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.Tensors.ITensor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.Experimental("SYSLIB5001", UrlFormat="https://aka.ms/dotnet-warnings/{0}")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.Experimental("SYSLIB5001", UrlFormat="https://aka.ms/dotnet-warnings/{0}")&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">To be added.</typeparam>
    <summary>
            Represents a tensor.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="AsReadOnlyTensorSpan">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; AsReadOnlyTensorSpan ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!T&gt; AsReadOnlyTensorSpan() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.AsReadOnlyTensorSpan" />
      <MemberSignature Language="VB.NET" Value="Public Function AsReadOnlyTensorSpan () As ReadOnlyTensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="abstract member AsReadOnlyTensorSpan : unit -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;&#xA;override this.AsReadOnlyTensorSpan : unit -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="tensor.AsReadOnlyTensorSpan " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; AsReadOnlyTensorSpan();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.IReadOnlyTensor`2.AsReadOnlyTensorSpan</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-10.0-pp">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Converts this <see cref="T:System.Numerics.Tensors.Tensor`1" /> to a <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> pointing to the same backing memory."/&gt;
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />
        </returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.AsReadOnlyTensorSpan" />
      </Docs>
    </Member>
    <Member MemberName="AsReadOnlyTensorSpan">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; AsReadOnlyTensorSpan (scoped ReadOnlySpan&lt;System.Buffers.NIndex&gt; startIndexes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!T&gt; AsReadOnlyTensorSpan(valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NIndex&gt; startIndexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.Buffers.NIndex})" />
      <MemberSignature Language="VB.NET" Value="Public Function AsReadOnlyTensorSpan (startIndexes As ReadOnlySpan(Of NIndex)) As ReadOnlyTensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="abstract member AsReadOnlyTensorSpan : ReadOnlySpan&lt;System.Buffers.NIndex&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;&#xA;override this.AsReadOnlyTensorSpan : ReadOnlySpan&lt;System.Buffers.NIndex&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="tensor.AsReadOnlyTensorSpan startIndexes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; AsReadOnlyTensorSpan(ReadOnlySpan&lt;System::Buffers::NIndex&gt; startIndexes);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.IReadOnlyTensor`2.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.Buffers.NIndex})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-10.0-pp">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndexes" Type="System.ReadOnlySpan&lt;System.Buffers.NIndex&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="net-10.0-pp;net-9.0-pp">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="startIndexes">To be added.</param>
        <summary>
            Converts this <see cref="T:System.Numerics.Tensors.Tensor`1" /> to a <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> pointing to the same backing memory based on the provided start indexes."/&gt;
            </summary>
        <returns />
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.Buffers.NIndex})" />
      </Docs>
    </Member>
    <Member MemberName="AsReadOnlyTensorSpan">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; AsReadOnlyTensorSpan (scoped ReadOnlySpan&lt;System.Buffers.NRange&gt; ranges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!T&gt; AsReadOnlyTensorSpan(valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NRange&gt; ranges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.Buffers.NRange})" />
      <MemberSignature Language="VB.NET" Value="Public Function AsReadOnlyTensorSpan (ranges As ReadOnlySpan(Of NRange)) As ReadOnlyTensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="abstract member AsReadOnlyTensorSpan : ReadOnlySpan&lt;System.Buffers.NRange&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;&#xA;override this.AsReadOnlyTensorSpan : ReadOnlySpan&lt;System.Buffers.NRange&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="tensor.AsReadOnlyTensorSpan ranges" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; AsReadOnlyTensorSpan(ReadOnlySpan&lt;System::Buffers::NRange&gt; ranges);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.IReadOnlyTensor`2.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.Buffers.NRange})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-10.0-pp">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ranges" Type="System.ReadOnlySpan&lt;System.Buffers.NRange&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="net-10.0-pp;net-9.0-pp">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="ranges">To be added.</param>
        <summary>
            Converts this <see cref="T:System.Numerics.Tensors.Tensor`1" /> to a <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> pointing to the same backing memory based on the provided ranges."/&gt;
            </summary>
        <returns />
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.Buffers.NRange})" />
      </Docs>
    </Member>
    <Member MemberName="AsReadOnlyTensorSpan">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; AsReadOnlyTensorSpan (scoped ReadOnlySpan&lt;IntPtr&gt; startIndexes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!T&gt; AsReadOnlyTensorSpan(valuetype System.ReadOnlySpan`1&lt;native int&gt; startIndexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function AsReadOnlyTensorSpan (startIndexes As ReadOnlySpan(Of IntPtr)) As ReadOnlyTensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="abstract member AsReadOnlyTensorSpan : ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;&#xA;override this.AsReadOnlyTensorSpan : ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="tensor.AsReadOnlyTensorSpan startIndexes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; AsReadOnlyTensorSpan(ReadOnlySpan&lt;IntPtr&gt; startIndexes);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.IReadOnlyTensor`2.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.IntPtr})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-10.0-pp">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndexes" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="net-10.0-pp;net-9.0-pp">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="startIndexes">To be added.</param>
        <summary>
            Converts this <see cref="T:System.Numerics.Tensors.Tensor`1" /> to a <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> pointing to the same backing memory based on the provided start locations."/&gt;
            </summary>
        <returns />
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.AsReadOnlyTensorSpan(System.ReadOnlySpan{System.IntPtr})" />
      </Docs>
    </Member>
    <Member MemberName="AsTensorSpan">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.TensorSpan&lt;T&gt; AsTensorSpan ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Numerics.Tensors.TensorSpan`1&lt;!T&gt; AsTensorSpan() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.AsTensorSpan" />
      <MemberSignature Language="VB.NET" Value="Public Function AsTensorSpan () As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="abstract member AsTensorSpan : unit -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;&#xA;override this.AsTensorSpan : unit -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="tensor.AsTensorSpan " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Numerics::Tensors::TensorSpan&lt;T&gt; AsTensorSpan();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.ITensor`2.AsTensorSpan</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-10.0-pp">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Converts this <see cref="T:System.Numerics.Tensors.Tensor`1" /> to a <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> pointing to the same backing memory."/&gt;
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.TensorSpan`1" />
        </returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.Tensors.ITensor`2.AsTensorSpan" />
      </Docs>
    </Member>
    <Member MemberName="AsTensorSpan">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.TensorSpan&lt;T&gt; AsTensorSpan (scoped ReadOnlySpan&lt;System.Buffers.NIndex&gt; startIndexes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Numerics.Tensors.TensorSpan`1&lt;!T&gt; AsTensorSpan(valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NIndex&gt; startIndexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.AsTensorSpan(System.ReadOnlySpan{System.Buffers.NIndex})" />
      <MemberSignature Language="VB.NET" Value="Public Function AsTensorSpan (startIndexes As ReadOnlySpan(Of NIndex)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="abstract member AsTensorSpan : ReadOnlySpan&lt;System.Buffers.NIndex&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;&#xA;override this.AsTensorSpan : ReadOnlySpan&lt;System.Buffers.NIndex&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="tensor.AsTensorSpan startIndexes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Numerics::Tensors::TensorSpan&lt;T&gt; AsTensorSpan(ReadOnlySpan&lt;System::Buffers::NIndex&gt; startIndexes);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.ITensor`2.AsTensorSpan(System.ReadOnlySpan{System.Buffers.NIndex})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-10.0-pp">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndexes" Type="System.ReadOnlySpan&lt;System.Buffers.NIndex&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="net-10.0-pp;net-9.0-pp">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="startIndexes">To be added.</param>
        <summary>
            Converts this <see cref="T:System.Numerics.Tensors.Tensor`1" /> to a <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> pointing to the same backing memory based on the provided start indexes."/&gt;
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> based on the provided ranges.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.Tensors.ITensor`2.AsTensorSpan(System.ReadOnlySpan{System.Buffers.NIndex})" />
      </Docs>
    </Member>
    <Member MemberName="AsTensorSpan">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.TensorSpan&lt;T&gt; AsTensorSpan (scoped ReadOnlySpan&lt;System.Buffers.NRange&gt; ranges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Numerics.Tensors.TensorSpan`1&lt;!T&gt; AsTensorSpan(valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NRange&gt; ranges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.AsTensorSpan(System.ReadOnlySpan{System.Buffers.NRange})" />
      <MemberSignature Language="VB.NET" Value="Public Function AsTensorSpan (ranges As ReadOnlySpan(Of NRange)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="abstract member AsTensorSpan : ReadOnlySpan&lt;System.Buffers.NRange&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;&#xA;override this.AsTensorSpan : ReadOnlySpan&lt;System.Buffers.NRange&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="tensor.AsTensorSpan ranges" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Numerics::Tensors::TensorSpan&lt;T&gt; AsTensorSpan(ReadOnlySpan&lt;System::Buffers::NRange&gt; ranges);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.ITensor`2.AsTensorSpan(System.ReadOnlySpan{System.Buffers.NRange})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-10.0-pp">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ranges" Type="System.ReadOnlySpan&lt;System.Buffers.NRange&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="net-10.0-pp;net-9.0-pp">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="ranges">To be added.</param>
        <summary>
            Converts this <see cref="T:System.Numerics.Tensors.Tensor`1" /> to a <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> pointing to the same backing memory based on the provided ranges."/&gt;
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> based on the provided ranges.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.Tensors.ITensor`2.AsTensorSpan(System.ReadOnlySpan{System.Buffers.NRange})" />
      </Docs>
    </Member>
    <Member MemberName="AsTensorSpan">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.TensorSpan&lt;T&gt; AsTensorSpan (scoped ReadOnlySpan&lt;IntPtr&gt; startIndexes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Numerics.Tensors.TensorSpan`1&lt;!T&gt; AsTensorSpan(valuetype System.ReadOnlySpan`1&lt;native int&gt; startIndexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.AsTensorSpan(System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function AsTensorSpan (startIndexes As ReadOnlySpan(Of IntPtr)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="abstract member AsTensorSpan : ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;&#xA;override this.AsTensorSpan : ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="tensor.AsTensorSpan startIndexes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Numerics::Tensors::TensorSpan&lt;T&gt; AsTensorSpan(ReadOnlySpan&lt;IntPtr&gt; startIndexes);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.ITensor`2.AsTensorSpan(System.ReadOnlySpan{System.IntPtr})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-10.0-pp">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndexes" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="net-10.0-pp;net-9.0-pp">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="startIndexes">To be added.</param>
        <summary>
            Converts this <see cref="T:System.Numerics.Tensors.Tensor`1" /> to a <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> pointing to the same backing memory based on the provided start locations."/&gt;
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> based on the provided ranges.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.Tensors.ITensor`2.AsTensorSpan(System.ReadOnlySpan{System.IntPtr})" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="tensor.Clear " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.ITensor.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Clears the contents of this tensor.
            </summary>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.Tensors.ITensor.Clear" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (scoped in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.CopyTo(System.Numerics.Tensors.TensorSpan{`0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (ByRef destination As TensorSpan(Of T))" />
      <MemberSignature Language="F#" Value="member this.CopyTo : TensorSpan -&gt; unit" Usage="tensor.CopyTo destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.CopyTo(System.Numerics.Tensors.TensorSpan{`1}@|System.Runtime.InteropServices.InAttribute)" />
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Empty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Numerics.Tensors.Tensor`1&lt;!T&gt; Empty" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Empty As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Empty : System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="Empty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::Tensors::Tensor&lt;T&gt; ^ Empty { System::Numerics::Tensors::Tensor&lt;T&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.IReadOnlyTensor`2.Empty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an empty tensor.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public void Fill (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Fill(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.Fill(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Fill (value As T)" />
      <MemberSignature Language="F#" Value="abstract member Fill : 'T -&gt; unit&#xA;override this.Fill : 'T -&gt; unit" Usage="tensor.Fill value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Fill(T value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.ITensor`2.Fill(`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>
            Fills the contents of this span with the given value.
            </summary>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.Tensors.ITensor`2.Fill(`1)" />
      </Docs>
    </Member>
    <Member MemberName="FlattenedLength">
      <MemberSignature Language="C#" Value="public IntPtr FlattenedLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int FlattenedLength" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.FlattenedLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FlattenedLength As IntPtr" />
      <MemberSignature Language="F#" Value="member this.FlattenedLength : nativeint" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.FlattenedLength" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr FlattenedLength { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.IReadOnlyTensor.FlattenedLength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The number of items in the <see cref="T:System.Numerics.Tensors.Tensor`1" />.
            </summary>
        <value>
          <see cref="T:System.IntPtr" /> with the number of items.</value>
        <remarks>To be added.</remarks>
        <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.FlattenedLength" />
      </Docs>
    </Member>
    <Member MemberName="FlattenTo">
      <MemberSignature Language="C#" Value="public void FlattenTo (scoped Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FlattenTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.FlattenTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub FlattenTo (destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="abstract member FlattenTo : Span&lt;'T&gt; -&gt; unit&#xA;override this.FlattenTo : Span&lt;'T&gt; -&gt; unit" Usage="tensor.FlattenTo destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void FlattenTo(Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.IReadOnlyTensor`2.FlattenTo(System.Span{`1})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="destination">The span to copy items into.</param>
        <summary>
            Flattens the contents of this Tensor into the provided <see cref="T:System.Span`1" />.
            </summary>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.FlattenTo(System.Span{`1})" />
      </Docs>
    </Member>
    <Member MemberName="GetDimensionSpan">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.TensorDimensionSpan&lt;T&gt; GetDimensionSpan (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Numerics.Tensors.TensorDimensionSpan`1&lt;!T&gt; GetDimensionSpan(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.GetDimensionSpan(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetDimensionSpan (dimension As Integer) As TensorDimensionSpan(Of T)" />
      <MemberSignature Language="F#" Value="abstract member GetDimensionSpan : int -&gt; System.Numerics.Tensors.TensorDimensionSpan&lt;'T&gt;&#xA;override this.GetDimensionSpan : int -&gt; System.Numerics.Tensors.TensorDimensionSpan&lt;'T&gt;" Usage="tensor.GetDimensionSpan dimension" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Numerics::Tensors::TensorDimensionSpan&lt;T&gt; GetDimensionSpan(int dimension);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.ITensor`2.GetDimensionSpan(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorDimensionSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-10.0-pp">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.Tensors.ITensor`2.GetDimensionSpan(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.Tensor&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Numerics.Tensors.Tensor`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As Tensor(Of T).Enumerator" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;.Enumerator" Usage="tensor.GetEnumerator " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Numerics::Tensors::Tensor&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets an enumerator for the readonly tensor.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerator`1" />
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPinnableReference">
      <MemberSignature Language="C#" Value="public ref T GetPinnableReference ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance !T GetPinnableReference() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.GetPinnableReference" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPinnableReference () As T" />
      <MemberSignature Language="F#" Value="abstract member GetPinnableReference : unit -&gt; 'T&#xA;override this.GetPinnableReference : unit -&gt; 'T" Usage="tensor.GetPinnableReference " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual T % GetPinnableReference();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.ITensor`2.GetPinnableReference</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Returns a reference to the 0th element of the Tensor. If the Tensor is empty, returns null reference.
            It can be used for pinning and is required to support the use of Tensor within a fixed statement.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.Tensors.ITensor`2.GetPinnableReference" />
      </Docs>
    </Member>
    <Member MemberName="GetPinnedHandle">
      <MemberSignature Language="C#" Value="public System.Buffers.MemoryHandle GetPinnedHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Buffers.MemoryHandle GetPinnedHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.GetPinnedHandle" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPinnedHandle () As MemoryHandle" />
      <MemberSignature Language="F#" Value="abstract member GetPinnedHandle : unit -&gt; System.Buffers.MemoryHandle&#xA;override this.GetPinnedHandle : unit -&gt; System.Buffers.MemoryHandle" Usage="tensor.GetPinnedHandle " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Buffers::MemoryHandle GetPinnedHandle();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.IReadOnlyTensor.GetPinnedHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Buffers.MemoryHandle</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Pins and gets a <see cref="T:System.Buffers.MemoryHandle" /> to the backing memory.
            </summary>
        <returns>A <see cref="T:System.Buffers.MemoryHandle" /> which has pinned the backing memory.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor.GetPinnedHandle" />
      </Docs>
    </Member>
    <Member MemberName="HasAnyDenseDimensions">
      <MemberSignature Language="C#" Value="public bool HasAnyDenseDimensions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAnyDenseDimensions" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.HasAnyDenseDimensions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasAnyDenseDimensions As Boolean" />
      <MemberSignature Language="F#" Value="member this.HasAnyDenseDimensions : bool" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.HasAnyDenseDimensions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasAnyDenseDimensions { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.IReadOnlyTensor.HasAnyDenseDimensions</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.HasAnyDenseDimensions" />
      </Docs>
    </Member>
    <Member MemberName="IsDense">
      <MemberSignature Language="C#" Value="public bool IsDense { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDense" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.IsDense" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDense As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsDense : bool" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.IsDense" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDense { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.IReadOnlyTensor.IsDense</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.IsDense" />
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsEmpty : bool" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.IsEmpty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEmpty { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.IReadOnlyTensor.IsEmpty</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets a value indicating whether this <see cref="T:System.Numerics.Tensors.Tensor`1" /> is empty.
            </summary>
        <value>
          <see langword="true" /> if this tensor is empty; otherwise, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.IsEmpty" />
      </Docs>
    </Member>
    <Member MemberName="IsPinned">
      <MemberSignature Language="C#" Value="public bool IsPinned { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPinned" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.IsPinned" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPinned As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsPinned : bool" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.IsPinned" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPinned { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.IReadOnlyTensor.IsPinned</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets a value indicating whether the backing memory of the <see cref="T:System.Numerics.Tensors.Tensor`1" /> is pinned."/&gt;
            </summary>
        <value>
          <see langword="true" /> if the backing memory is pinned; otherwise, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.IsPinned" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public ref T this[scoped ReadOnlySpan&lt;System.Buffers.NIndex&gt; indexes] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NIndex&gt;)" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.Item(System.ReadOnlySpan{System.Buffers.NIndex})" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(indexes As ReadOnlySpan(Of NIndex)) As T" />
      <MemberSignature Language="F#" Value="member this.Item(ReadOnlySpan&lt;System.Buffers.NIndex&gt;) : 'T" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.Item" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T % default[ReadOnlySpan&lt;System::Buffers::NIndex&gt;] { T % get(ReadOnlySpan&lt;System::Buffers::NIndex&gt; indexes); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.ITensor`2.Item(System.ReadOnlySpan{System.Buffers.NIndex})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexes" Type="System.ReadOnlySpan&lt;System.Buffers.NIndex&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="net-10.0-pp;net-9.0-pp">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indexes" />
        <summary>
            Returns a reference to specified element of the Tensor.
            </summary>
        <value />
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException">
            Thrown when index less than 0 or index greater than or equal to FlattenedLength
            </exception>
        <inheritdoc cref="P:System.Numerics.Tensors.TensorSpan`1.Item(System.ReadOnlySpan{System.Buffers.NIndex})" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.Tensor&lt;T&gt; this[scoped ReadOnlySpan&lt;System.Buffers.NRange&gt; ranges] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Numerics.Tensors.Tensor`1&lt;!T&gt; Item(valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NRange&gt;)" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.Item(System.ReadOnlySpan{System.Buffers.NRange})" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(ranges As ReadOnlySpan(Of NRange)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="member this.Item(ReadOnlySpan&lt;System.Buffers.NRange&gt;) : System.Numerics.Tensors.Tensor&lt;'T&gt; with get, set" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.Item" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Numerics::Tensors::Tensor&lt;T&gt; ^ default[ReadOnlySpan&lt;System::Buffers::NRange&gt;] { System::Numerics::Tensors::Tensor&lt;T&gt; ^ get(ReadOnlySpan&lt;System::Buffers::NRange&gt; ranges); void set(ReadOnlySpan&lt;System::Buffers::NRange&gt; ranges, System::Numerics::Tensors::Tensor&lt;T&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.ITensor`2.Item(System.ReadOnlySpan{System.Buffers.NRange})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ranges" Type="System.ReadOnlySpan&lt;System.Buffers.NRange&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="net-10.0-pp;net-9.0-pp">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="ranges" />
        <summary>
            Returns a slice of the Tensor.
            </summary>
        <value />
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException">
            Thrown when any index is less than 0 or any index is greater than or equal to FlattenedLength
            </exception>
        <inheritdoc cref="P:System.Numerics.Tensors.TensorSpan`1.Item(System.ReadOnlySpan{System.Buffers.NRange})" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public ref T this[scoped ReadOnlySpan&lt;IntPtr&gt; indexes] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(valuetype System.ReadOnlySpan`1&lt;native int&gt;)" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.Item(System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(indexes As ReadOnlySpan(Of IntPtr)) As T" />
      <MemberSignature Language="F#" Value="member this.Item(ReadOnlySpan&lt;nativeint&gt;) : 'T" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.Item" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T % default[ReadOnlySpan&lt;IntPtr&gt;] { T % get(ReadOnlySpan&lt;IntPtr&gt; indexes); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.ITensor`2.Item(System.ReadOnlySpan{System.IntPtr})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexes" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="net-10.0-pp;net-9.0-pp">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indexes" />
        <summary>
            Returns a reference to specified element of the Tensor.
            </summary>
        <value />
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException">
            Thrown when index less than 0 or index greater than or equal to FlattenedLength
            </exception>
        <inheritdoc cref="P:System.Numerics.Tensors.TensorSpan`1.Item(System.ReadOnlySpan{System.IntPtr})" />
      </Docs>
    </Member>
    <Member MemberName="Lengths">
      <MemberSignature Language="C#" Value="public ReadOnlySpan&lt;IntPtr&gt; Lengths { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;native int&gt; Lengths" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.Lengths" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Lengths As ReadOnlySpan(Of IntPtr)" />
      <MemberSignature Language="F#" Value="member this.Lengths : ReadOnlySpan&lt;nativeint&gt;" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.Lengths" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ReadOnlySpan&lt;IntPtr&gt; Lengths { ReadOnlySpan&lt;IntPtr&gt; get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.IReadOnlyTensor.Lengths</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.IntPtr&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the length of each dimension in this <see cref="T:System.Numerics.Tensors.Tensor`1" />.
            </summary>
        <value>
          <see cref="T:System.ReadOnlySpan`1" /> with the lengths of each dimension.</value>
        <remarks>To be added.</remarks>
        <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.Lengths" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; tensor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!T&gt; op_Implicit(class System.Numerics.Tensors.Tensor`1&lt;!T&gt; tensor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.op_Implicit(System.Numerics.Tensors.Tensor{`0})~System.Numerics.Tensors.ReadOnlyTensorSpan{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (tensor As Tensor(Of T)) As ReadOnlyTensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Numerics.Tensors.Tensor&lt;'T&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.op_Implicit tensor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt;(System::Numerics::Tensors::Tensor&lt;T&gt; ^ tensor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-10.0-pp">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="tensor">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Tensors.TensorSpan&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; tensor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Tensors.TensorSpan`1&lt;!T&gt; op_Implicit(class System.Numerics.Tensors.Tensor`1&lt;!T&gt; tensor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.op_Implicit(System.Numerics.Tensors.Tensor{`0})~System.Numerics.Tensors.TensorSpan{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (tensor As Tensor(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Numerics.Tensors.Tensor&lt;'T&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.op_Implicit tensor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Tensors::TensorSpan&lt;T&gt;(System::Numerics::Tensors::Tensor&lt;T&gt; ^ tensor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-10.0-pp">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="tensor">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Tensors.Tensor&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname class System.Numerics.Tensors.Tensor`1&lt;!T&gt; op_Implicit(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.op_Implicit(`0[])~System.Numerics.Tensors.Tensor{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (array As T()) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member op_Implicit : 'T[] -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.op_Implicit array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Tensors::Tensor&lt;T&gt; ^(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.Rank" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rank As Integer" />
      <MemberSignature Language="F#" Value="member this.Rank : int" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.Rank" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Rank { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.IReadOnlyTensor.Rank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets a value indicating the rank, or number of dimensions, of this <see cref="T:System.Numerics.Tensors.Tensor`1" />.
            </summary>
        <value>
          <see cref="T:System.IntPtr" /> with the number of dimensions.</value>
        <remarks>To be added.</remarks>
        <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.Rank" />
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.Tensor&lt;T&gt; Slice (scoped ReadOnlySpan&lt;System.Buffers.NIndex&gt; startIndexes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Numerics.Tensors.Tensor`1&lt;!T&gt; Slice(valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NIndex&gt; startIndexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.Slice(System.ReadOnlySpan{System.Buffers.NIndex})" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (startIndexes As ReadOnlySpan(Of NIndex)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="abstract member Slice : ReadOnlySpan&lt;System.Buffers.NIndex&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;&#xA;override this.Slice : ReadOnlySpan&lt;System.Buffers.NIndex&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="tensor.Slice startIndexes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Numerics::Tensors::Tensor&lt;T&gt; ^ Slice(ReadOnlySpan&lt;System::Buffers::NIndex&gt; startIndexes);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.IReadOnlyTensor`2.Slice(System.ReadOnlySpan{System.Buffers.NIndex})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-10.0-pp">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndexes" Type="System.ReadOnlySpan&lt;System.Buffers.NIndex&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="net-10.0-pp;net-9.0-pp">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="startIndexes">To be added.</param>
        <summary>
            Forms a slice out of the given tensor
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> without copying the provided ranges.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.Slice(System.ReadOnlySpan{System.Buffers.NIndex})" />
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.Tensor&lt;T&gt; Slice (scoped ReadOnlySpan&lt;System.Buffers.NRange&gt; ranges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Numerics.Tensors.Tensor`1&lt;!T&gt; Slice(valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NRange&gt; ranges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.Slice(System.ReadOnlySpan{System.Buffers.NRange})" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (ranges As ReadOnlySpan(Of NRange)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="abstract member Slice : ReadOnlySpan&lt;System.Buffers.NRange&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;&#xA;override this.Slice : ReadOnlySpan&lt;System.Buffers.NRange&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="tensor.Slice ranges" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Numerics::Tensors::Tensor&lt;T&gt; ^ Slice(ReadOnlySpan&lt;System::Buffers::NRange&gt; ranges);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.IReadOnlyTensor`2.Slice(System.ReadOnlySpan{System.Buffers.NRange})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-10.0-pp">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ranges" Type="System.ReadOnlySpan&lt;System.Buffers.NRange&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="net-10.0-pp;net-9.0-pp">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="ranges">To be added.</param>
        <summary>
            Forms a slice out of the given tensor
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> without copying the provided ranges.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.Slice(System.ReadOnlySpan{System.Buffers.NRange})" />
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.Tensor&lt;T&gt; Slice (scoped ReadOnlySpan&lt;IntPtr&gt; startIndexes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Numerics.Tensors.Tensor`1&lt;!T&gt; Slice(valuetype System.ReadOnlySpan`1&lt;native int&gt; startIndexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.Slice(System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (startIndexes As ReadOnlySpan(Of IntPtr)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="abstract member Slice : ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;&#xA;override this.Slice : ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="tensor.Slice startIndexes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Numerics::Tensors::Tensor&lt;T&gt; ^ Slice(ReadOnlySpan&lt;IntPtr&gt; startIndexes);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.IReadOnlyTensor`2.Slice(System.ReadOnlySpan{System.IntPtr})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-10.0-pp">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndexes" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="net-10.0-pp;net-9.0-pp">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="startIndexes">To be added.</param>
        <summary>
            Forms a slice out of the given tensor
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> without copying the provided ranges.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.Slice(System.ReadOnlySpan{System.IntPtr})" />
      </Docs>
    </Member>
    <Member MemberName="Strides">
      <MemberSignature Language="C#" Value="public ReadOnlySpan&lt;IntPtr&gt; Strides { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;native int&gt; Strides" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.Strides" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Strides As ReadOnlySpan(Of IntPtr)" />
      <MemberSignature Language="F#" Value="member this.Strides : ReadOnlySpan&lt;nativeint&gt;" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.Strides" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ReadOnlySpan&lt;IntPtr&gt; Strides { ReadOnlySpan&lt;IntPtr&gt; get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.IReadOnlyTensor.Strides</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.IntPtr&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the strides of each dimension in this <see cref="T:System.Numerics.Tensors.Tensor`1" />.
            </summary>
        <value>
          <see cref="T:System.ReadOnlySpan`1" /> with the strides of each dimension.</value>
        <remarks>To be added.</remarks>
        <inheritdoc cref="P:System.Numerics.Tensors.IReadOnlyTensor.Strides" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;'T&gt;&#xA;override this.System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;'T&gt;" Usage="tensor.System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator " />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Gets an <see cref="T:System.Collections.Generic.IEnumerator`1" /> for the <see cref="T:System.Numerics.Tensors.Tensor`1" />.
            </summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerator`1" />
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="F#" Value="abstract member System.Collections.IEnumerable.GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.System.Collections.IEnumerable.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="tensor.System.Collections.IEnumerable.GetEnumerator " />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Gets an <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Numerics.Tensors.Tensor`1" />."/&gt;
            </summary>
        <returns />
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.Tensors.IReadOnlyTensor.Item">
      <MemberSignature Language="C#" Value="object? System.Numerics.Tensors.IReadOnlyTensor.Item[scoped ReadOnlySpan&lt;System.Buffers.NIndex&gt; indexes] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Numerics.Tensors.IReadOnlyTensor.Item(valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NIndex&gt;)" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.System#Numerics#Tensors#IReadOnlyTensor#Item(System.ReadOnlySpan{System.Buffers.NIndex})" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Item(indexes As ReadOnlySpan(Of NIndex)) As Object Implements IReadOnlyTensor.Item" />
      <MemberSignature Language="F#" Value="member this.System.Numerics.Tensors.IReadOnlyTensor.Item(ReadOnlySpan&lt;System.Buffers.NIndex&gt;) : obj" Usage="System.Numerics.Tensors.IReadOnlyTensor.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Numerics::Tensors::IReadOnlyTensor::Item[ReadOnlySpan&lt;System::Buffers::NIndex&gt;] { System::Object ^ get(ReadOnlySpan&lt;System::Buffers::NIndex&gt; indexes); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.IReadOnlyTensor.Item(System.ReadOnlySpan{System.Buffers.NIndex})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexes" Type="System.ReadOnlySpan&lt;System.Buffers.NIndex&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="net-10.0-pp;net-9.0-pp">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indexes">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.Tensors.IReadOnlyTensor.Item">
      <MemberSignature Language="C#" Value="object? System.Numerics.Tensors.IReadOnlyTensor.Item[scoped ReadOnlySpan&lt;IntPtr&gt; indexes] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Numerics.Tensors.IReadOnlyTensor.Item(valuetype System.ReadOnlySpan`1&lt;native int&gt;)" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.System#Numerics#Tensors#IReadOnlyTensor#Item(System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Item(indexes As ReadOnlySpan(Of IntPtr)) As Object Implements IReadOnlyTensor.Item" />
      <MemberSignature Language="F#" Value="member this.System.Numerics.Tensors.IReadOnlyTensor.Item(ReadOnlySpan&lt;nativeint&gt;) : obj" Usage="System.Numerics.Tensors.IReadOnlyTensor.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Numerics::Tensors::IReadOnlyTensor::Item[ReadOnlySpan&lt;IntPtr&gt;] { System::Object ^ get(ReadOnlySpan&lt;IntPtr&gt; indexes); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.IReadOnlyTensor.Item(System.ReadOnlySpan{System.IntPtr})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexes" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="net-10.0-pp;net-9.0-pp">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indexes">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.CopyTo">
      <MemberSignature Language="C#" Value="void IReadOnlyTensor&lt;Tensor&lt;T&gt;,T&gt;.CopyTo (scoped in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.CopyTo([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.System#Numerics#Tensors#IReadOnlyTensor&lt;System#Numerics#Tensors#Tensor&lt;T&gt;,T&gt;#CopyTo(System.Numerics.Tensors.TensorSpan{`0}@|System.Runtime.InteropServices.InAttribute)" />
      <MemberSignature Language="VB.NET" Value="Sub CopyTo (destination As TensorSpan(Of T)) Implements IReadOnlyTensor(Of Tensor(Of T), T).CopyTo" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.CopyTo : TensorSpan -&gt; unit&#xA;override this.System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.CopyTo : TensorSpan -&gt; unit" Usage="tensor.System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.CopyTo destination" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.CopyTo(System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ destination) = System::Numerics::Tensors::IReadOnlyTensor&lt;System::Numerics::Tensors::Tensor&lt;T&gt; ^, T&gt;::CopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.IReadOnlyTensor`2.CopyTo(System.Numerics.Tensors.TensorSpan{`1}@|System.Runtime.InteropServices.InAttribute)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.GetDimensionSpan">
      <MemberSignature Language="C#" Value="System.Numerics.Tensors.ReadOnlyTensorDimensionSpan&lt;T&gt; IReadOnlyTensor&lt;Tensor&lt;T&gt;,T&gt;.GetDimensionSpan (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Numerics.Tensors.ReadOnlyTensorDimensionSpan`1&lt;!T&gt; System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.GetDimensionSpan(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.System#Numerics#Tensors#IReadOnlyTensor&lt;System#Numerics#Tensors#Tensor&lt;T&gt;,T&gt;#GetDimensionSpan(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Function GetDimensionSpan (dimension As Integer) As ReadOnlyTensorDimensionSpan(Of T) Implements IReadOnlyTensor(Of Tensor(Of T), T).GetDimensionSpan" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.GetDimensionSpan : int -&gt; System.Numerics.Tensors.ReadOnlyTensorDimensionSpan&lt;'T&gt;&#xA;override this.System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.GetDimensionSpan : int -&gt; System.Numerics.Tensors.ReadOnlyTensorDimensionSpan&lt;'T&gt;" Usage="tensor.System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.GetDimensionSpan dimension" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Numerics::Tensors::ReadOnlyTensorDimensionSpan&lt;T&gt; System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.GetDimensionSpan(int dimension) = System::Numerics::Tensors::IReadOnlyTensor&lt;System::Numerics::Tensors::Tensor&lt;T&gt; ^, T&gt;::GetDimensionSpan;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.IReadOnlyTensor`2.GetDimensionSpan(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorDimensionSpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.GetPinnableReference">
      <MemberSignature Language="C#" Value="ref readonly T IReadOnlyTensor&lt;Tensor&lt;T&gt;,T&gt;.GetPinnableReference ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance !T System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.GetPinnableReference() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.System#Numerics#Tensors#IReadOnlyTensor&lt;System#Numerics#Tensors#Tensor&lt;T&gt;,T&gt;#GetPinnableReference" />
      <MemberSignature Language="VB.NET" Value="Function GetPinnableReference () As T Implements IReadOnlyTensor(Of Tensor(Of T), T).GetPinnableReference" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.GetPinnableReference : unit -&gt; 'T&#xA;override this.System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.GetPinnableReference : unit -&gt; 'T" Usage="tensor.System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.GetPinnableReference " />
      <MemberSignature Language="C++ CLI" Value=" virtual T&amp; ^ System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.GetPinnableReference() = System::Numerics::Tensors::IReadOnlyTensor&lt;System::Numerics::Tensors::Tensor&lt;T&gt; ^, T&gt;::GetPinnableReference;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.IReadOnlyTensor`2.GetPinnableReference</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>T</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-10.0-pp">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Returns a reference to the 0th element of the ReadOnlyTensor. If the ReadOnlyTensor is empty, returns null reference.
            It can be used for pinning and is required to support the use of ReadOnlyTensor within a fixed statement.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item">
      <MemberSignature Language="C#" Value="ref readonly T System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item[scoped ReadOnlySpan&lt;System.Buffers.NIndex&gt; indexes] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item(valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NIndex&gt;)" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.System#Numerics#Tensors#IReadOnlyTensor&lt;System#Numerics#Tensors#Tensor&lt;T&gt;,T&gt;#Item(System.ReadOnlySpan{System.Buffers.NIndex})" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Item(indexes As ReadOnlySpan(Of NIndex)) As T Implements IReadOnlyTensor(Of Tensor(Of T), T).Item" />
      <MemberSignature Language="F#" Value="member this.System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item(ReadOnlySpan&lt;System.Buffers.NIndex&gt;) : 'T" Usage="System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item" />
      <MemberSignature Language="C++ CLI" Value="property T&amp; ^ System::Numerics::Tensors::IReadOnlyTensor&lt;System::Numerics::Tensors::Tensor&lt;T&gt;,T&gt;::Item[ReadOnlySpan&lt;System::Buffers::NIndex&gt;] { T&amp; ^ get(ReadOnlySpan&lt;System::Buffers::NIndex&gt; indexes); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.IReadOnlyTensor`2.Item(System.ReadOnlySpan{System.Buffers.NIndex})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexes" Type="System.ReadOnlySpan&lt;System.Buffers.NIndex&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="net-10.0-pp;net-9.0-pp">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indexes" />
        <summary>
            Returns the specified element of the ReadOnlyTensor.
            </summary>
        <value />
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException">
            Thrown when index less than 0 or index greater than or equal to FlattenedLength
            </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item">
      <MemberSignature Language="C#" Value="ref readonly T System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item[scoped ReadOnlySpan&lt;IntPtr&gt; indexes] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item(valuetype System.ReadOnlySpan`1&lt;native int&gt;)" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.System#Numerics#Tensors#IReadOnlyTensor&lt;System#Numerics#Tensors#Tensor&lt;T&gt;,T&gt;#Item(System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Item(indexes As ReadOnlySpan(Of IntPtr)) As T Implements IReadOnlyTensor(Of Tensor(Of T), T).Item" />
      <MemberSignature Language="F#" Value="member this.System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item(ReadOnlySpan&lt;nativeint&gt;) : 'T" Usage="System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Item" />
      <MemberSignature Language="C++ CLI" Value="property T&amp; ^ System::Numerics::Tensors::IReadOnlyTensor&lt;System::Numerics::Tensors::Tensor&lt;T&gt;,T&gt;::Item[ReadOnlySpan&lt;IntPtr&gt;] { T&amp; ^ get(ReadOnlySpan&lt;IntPtr&gt; indexes); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.IReadOnlyTensor`2.Item(System.ReadOnlySpan{System.IntPtr})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexes" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="net-10.0-pp;net-9.0-pp">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indexes" />
        <summary>
            Returns the specified element of the ReadOnlyTensor.
            </summary>
        <value />
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException">
            Thrown when index less than 0 or index greater than or equal to FlattenedLength
            </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.TryCopyTo">
      <MemberSignature Language="C#" Value="bool IReadOnlyTensor&lt;Tensor&lt;T&gt;,T&gt;.TryCopyTo (scoped in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.TryCopyTo([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.System#Numerics#Tensors#IReadOnlyTensor&lt;System#Numerics#Tensors#Tensor&lt;T&gt;,T&gt;#TryCopyTo(System.Numerics.Tensors.TensorSpan{`0}@|System.Runtime.InteropServices.InAttribute)" />
      <MemberSignature Language="VB.NET" Value="Function TryCopyTo (destination As TensorSpan(Of T)) As Boolean Implements IReadOnlyTensor(Of Tensor(Of T), T).TryCopyTo" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.TryCopyTo : TensorSpan -&gt; bool&#xA;override this.System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.TryCopyTo : TensorSpan -&gt; bool" Usage="tensor.System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.TryCopyTo destination" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Numerics.Tensors.IReadOnlyTensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.TryCopyTo(System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ destination) = System::Numerics::Tensors::IReadOnlyTensor&lt;System::Numerics::Tensors::Tensor&lt;T&gt; ^, T&gt;::TryCopyTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.IReadOnlyTensor`2.TryCopyTo(System.Numerics.Tensors.TensorSpan{`1}@|System.Runtime.InteropServices.InAttribute)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.Tensors.ITensor.Fill">
      <MemberSignature Language="C#" Value="void ITensor.Fill (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Numerics.Tensors.ITensor.Fill(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.System#Numerics#Tensors#ITensor#Fill(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Fill (value As Object) Implements ITensor.Fill" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.Tensors.ITensor.Fill : obj -&gt; unit&#xA;override this.System.Numerics.Tensors.ITensor.Fill : obj -&gt; unit" Usage="tensor.System.Numerics.Tensors.ITensor.Fill value" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Numerics.Tensors.ITensor.Fill(System::Object ^ value) = System::Numerics::Tensors::ITensor::Fill;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.ITensor.Fill(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.Tensors.ITensor.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Numerics.Tensors.ITensor.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Numerics.Tensors.ITensor.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.System#Numerics#Tensors#ITensor#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ITensor.IsReadOnly" />
      <MemberSignature Language="F#" Value="member this.System.Numerics.Tensors.ITensor.IsReadOnly : bool" Usage="System.Numerics.Tensors.ITensor.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Numerics::Tensors::ITensor::IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.ITensor.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.Tensors.ITensor.Item">
      <MemberSignature Language="C#" Value="object? System.Numerics.Tensors.ITensor.Item[scoped ReadOnlySpan&lt;System.Buffers.NIndex&gt; indexes] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Numerics.Tensors.ITensor.Item(valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NIndex&gt;)" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.System#Numerics#Tensors#ITensor#Item(System.ReadOnlySpan{System.Buffers.NIndex})" />
      <MemberSignature Language="VB.NET" Value=" Property Item(indexes As ReadOnlySpan(Of NIndex)) As Object Implements ITensor.Item" />
      <MemberSignature Language="F#" Value="member this.System.Numerics.Tensors.ITensor.Item(ReadOnlySpan&lt;System.Buffers.NIndex&gt;) : obj with get, set" Usage="System.Numerics.Tensors.ITensor.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Numerics::Tensors::ITensor::Item[ReadOnlySpan&lt;System::Buffers::NIndex&gt;] { System::Object ^ get(ReadOnlySpan&lt;System::Buffers::NIndex&gt; indexes); void set(ReadOnlySpan&lt;System::Buffers::NIndex&gt; indexes, System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.ITensor.Item(System.ReadOnlySpan{System.Buffers.NIndex})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexes" Type="System.ReadOnlySpan&lt;System.Buffers.NIndex&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="net-10.0-pp;net-9.0-pp">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indexes">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.Tensors.ITensor.Item">
      <MemberSignature Language="C#" Value="object? System.Numerics.Tensors.ITensor.Item[scoped ReadOnlySpan&lt;IntPtr&gt; indexes] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Numerics.Tensors.ITensor.Item(valuetype System.ReadOnlySpan`1&lt;native int&gt;)" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.Tensor`1.System#Numerics#Tensors#ITensor#Item(System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value=" Property Item(indexes As ReadOnlySpan(Of IntPtr)) As Object Implements ITensor.Item" />
      <MemberSignature Language="F#" Value="member this.System.Numerics.Tensors.ITensor.Item(ReadOnlySpan&lt;nativeint&gt;) : obj with get, set" Usage="System.Numerics.Tensors.ITensor.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Numerics::Tensors::ITensor::Item[ReadOnlySpan&lt;IntPtr&gt;] { System::Object ^ get(ReadOnlySpan&lt;IntPtr&gt; indexes); void set(ReadOnlySpan&lt;IntPtr&gt; indexes, System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.Tensors.ITensor.Item(System.ReadOnlySpan{System.IntPtr})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexes" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="net-10.0-pp;net-9.0-pp">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indexes">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Create">
      <MemberSignature Language="C#" Value="static System.Numerics.Tensors.Tensor&lt;T&gt; ITensor&lt;Tensor&lt;T&gt;,T&gt;.Create (scoped ReadOnlySpan&lt;IntPtr&gt; lengths, bool pinned);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!T&gt; System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Create(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.System#Numerics#Tensors#ITensor&lt;System#Numerics#Tensors#Tensor&lt;T&gt;,T&gt;#Create(System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function Create (lengths As ReadOnlySpan(Of IntPtr), pinned As Boolean) As Tensor(Of T) Implements ITensor(Of Tensor(Of T), T).Create" />
      <MemberSignature Language="F#" Value="static member System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Create : ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Create (lengths, pinned)" />
      <MemberSignature Language="C++ CLI" Value=" static System::Numerics::Tensors::Tensor&lt;T&gt; ^ System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Create(ReadOnlySpan&lt;IntPtr&gt; lengths, bool pinned) = System::Numerics::Tensors::ITensor&lt;System::Numerics::Tensors::Tensor&lt;T&gt; ^, T&gt;::Create;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.ITensor`2.Create(System.ReadOnlySpan{System.IntPtr},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="lengths">A <see cref="T:System.ReadOnlySpan`1" /> indicating the lengths of each dimension.</param>
        <param name="pinned">A <see cref="T:System.Boolean" /> whether the underlying data should be pinned or not.</param>
        <summary>
            Creates a <see cref="T:System.Numerics.Tensors.Tensor`1" /> and initializes it with the default value of T. If <paramref name="pinned" /> is true, the memory will be pinned.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Create">
      <MemberSignature Language="C#" Value="static System.Numerics.Tensors.Tensor&lt;T&gt; ITensor&lt;Tensor&lt;T&gt;,T&gt;.Create (scoped ReadOnlySpan&lt;IntPtr&gt; lengths, scoped ReadOnlySpan&lt;IntPtr&gt; strides, bool pinned);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!T&gt; System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Create(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.System#Numerics#Tensors#ITensor&lt;System#Numerics#Tensors#Tensor&lt;T&gt;,T&gt;#Create(System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function Create (lengths As ReadOnlySpan(Of IntPtr), strides As ReadOnlySpan(Of IntPtr), pinned As Boolean) As Tensor(Of T) Implements ITensor(Of Tensor(Of T), T).Create" />
      <MemberSignature Language="F#" Value="static member System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Create : ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Create (lengths, strides, pinned)" />
      <MemberSignature Language="C++ CLI" Value=" static System::Numerics::Tensors::Tensor&lt;T&gt; ^ System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.Create(ReadOnlySpan&lt;IntPtr&gt; lengths, ReadOnlySpan&lt;IntPtr&gt; strides, bool pinned) = System::Numerics::Tensors::ITensor&lt;System::Numerics::Tensors::Tensor&lt;T&gt; ^, T&gt;::Create;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.ITensor`2.Create(System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="lengths">A <see cref="T:System.ReadOnlySpan`1" /> indicating the lengths of each dimension.</param>
        <param name="strides">A <see cref="T:System.ReadOnlySpan`1" /> indicating the strides of each dimension.</param>
        <param name="pinned">A <see cref="T:System.Boolean" /> whether the underlying data should be pinned or not.</param>
        <summary>
            Creates a <see cref="T:System.Numerics.Tensors.Tensor`1" /> and initializes it with the default value of T. If <paramref name="pinned" /> is true, the memory will be pinned.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.CreateUninitialized">
      <MemberSignature Language="C#" Value="static System.Numerics.Tensors.Tensor&lt;T&gt; ITensor&lt;Tensor&lt;T&gt;,T&gt;.CreateUninitialized (scoped ReadOnlySpan&lt;IntPtr&gt; lengths, bool pinned);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!T&gt; System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.CreateUninitialized(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.System#Numerics#Tensors#ITensor&lt;System#Numerics#Tensors#Tensor&lt;T&gt;,T&gt;#CreateUninitialized(System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function CreateUninitialized (lengths As ReadOnlySpan(Of IntPtr), pinned As Boolean) As Tensor(Of T) Implements ITensor(Of Tensor(Of T), T).CreateUninitialized" />
      <MemberSignature Language="F#" Value="static member System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.CreateUninitialized : ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.CreateUninitialized (lengths, pinned)" />
      <MemberSignature Language="C++ CLI" Value=" static System::Numerics::Tensors::Tensor&lt;T&gt; ^ System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.CreateUninitialized(ReadOnlySpan&lt;IntPtr&gt; lengths, bool pinned) = System::Numerics::Tensors::ITensor&lt;System::Numerics::Tensors::Tensor&lt;T&gt; ^, T&gt;::CreateUninitialized;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.ITensor`2.CreateUninitialized(System.ReadOnlySpan{System.IntPtr},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="lengths">A <see cref="T:System.ReadOnlySpan`1" /> indicating the lengths of each dimension.</param>
        <param name="pinned">A <see cref="T:System.Boolean" /> whether the underlying data should be pinned or not.</param>
        <summary>
            Creates a <see cref="T:System.Numerics.Tensors.Tensor`1" /> and does not initialize it. If <paramref name="pinned" /> is true, the memory will be pinned.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.CreateUninitialized">
      <MemberSignature Language="C#" Value="static System.Numerics.Tensors.Tensor&lt;T&gt; ITensor&lt;Tensor&lt;T&gt;,T&gt;.CreateUninitialized (scoped ReadOnlySpan&lt;IntPtr&gt; lengths, scoped ReadOnlySpan&lt;IntPtr&gt; strides, bool pinned);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!T&gt; System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.CreateUninitialized(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.System#Numerics#Tensors#ITensor&lt;System#Numerics#Tensors#Tensor&lt;T&gt;,T&gt;#CreateUninitialized(System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function CreateUninitialized (lengths As ReadOnlySpan(Of IntPtr), strides As ReadOnlySpan(Of IntPtr), pinned As Boolean) As Tensor(Of T) Implements ITensor(Of Tensor(Of T), T).CreateUninitialized" />
      <MemberSignature Language="F#" Value="static member System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.CreateUninitialized : ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor&lt;'T&gt;.System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.CreateUninitialized (lengths, strides, pinned)" />
      <MemberSignature Language="C++ CLI" Value=" static System::Numerics::Tensors::Tensor&lt;T&gt; ^ System.Numerics.Tensors.ITensor&lt;System.Numerics.Tensors.Tensor&lt;T&gt;,T&gt;.CreateUninitialized(ReadOnlySpan&lt;IntPtr&gt; lengths, ReadOnlySpan&lt;IntPtr&gt; strides, bool pinned) = System::Numerics::Tensors::ITensor&lt;System::Numerics::Tensors::Tensor&lt;T&gt; ^, T&gt;::CreateUninitialized;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.ITensor`2.CreateUninitialized(System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="lengths">A <see cref="T:System.ReadOnlySpan`1" /> indicating the lengths of each dimension.</param>
        <param name="strides">A <see cref="T:System.ReadOnlySpan`1" /> indicating the strides of each dimension.</param>
        <param name="pinned">A <see cref="T:System.Boolean" /> whether the underlying data should be pinned or not.</param>
        <summary>
            Creates a <see cref="T:System.Numerics.Tensors.Tensor`1" /> and does not initialize it. If <paramref name="pinned" /> is true, the memory will be pinned.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToDenseTensor">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.Tensor&lt;T&gt; ToDenseTensor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Numerics.Tensors.Tensor`1&lt;!T&gt; ToDenseTensor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.ToDenseTensor" />
      <MemberSignature Language="VB.NET" Value="Public Function ToDenseTensor () As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="abstract member ToDenseTensor : unit -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;&#xA;override this.ToDenseTensor : unit -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="tensor.ToDenseTensor " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Numerics::Tensors::Tensor&lt;T&gt; ^ ToDenseTensor();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.IReadOnlyTensor`2.ToDenseTensor</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.ToDenseTensor" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (scoped ReadOnlySpan&lt;IntPtr&gt; maximumLengths);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(valuetype System.ReadOnlySpan`1&lt;native int&gt; maximumLengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.ToString(System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (maximumLengths As ReadOnlySpan(Of IntPtr)) As String" />
      <MemberSignature Language="F#" Value="override this.ToString : ReadOnlySpan&lt;nativeint&gt; -&gt; string" Usage="tensor.ToString maximumLengths" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(ReadOnlySpan&lt;IntPtr&gt; maximumLengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-10.0-pp">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maximumLengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="net-10.0-pp;net-9.0-pp">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="maximumLengths">Maximum Length of each dimension</param>
        <summary>
            Creates a <see cref="T:System.String" /> representation of the <see cref="T:System.Numerics.Tensors.TensorSpan`1" />."/&gt;
            </summary>
        <returns>A <see cref="T:System.String" /> representation of the <see cref="T:System.Numerics.Tensors.Tensor`1" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCopyTo">
      <MemberSignature Language="C#" Value="public bool TryCopyTo (scoped in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryCopyTo([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.TryCopyTo(System.Numerics.Tensors.TensorSpan{`0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryCopyTo (ByRef destination As TensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryCopyTo : TensorSpan -&gt; bool" Usage="tensor.TryCopyTo destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryCopyTo(System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.TryCopyTo(System.Numerics.Tensors.TensorSpan{`1}@|System.Runtime.InteropServices.InAttribute)" />
      </Docs>
    </Member>
    <Member MemberName="TryFlattenTo">
      <MemberSignature Language="C#" Value="public bool TryFlattenTo (scoped Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryFlattenTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor`1.TryFlattenTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFlattenTo (destination As Span(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member TryFlattenTo : Span&lt;'T&gt; -&gt; bool&#xA;override this.TryFlattenTo : Span&lt;'T&gt; -&gt; bool" Usage="tensor.TryFlattenTo destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryFlattenTo(Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.Tensors.IReadOnlyTensor`2.TryFlattenTo(System.Span{`1})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="destination">The span to copy items into.</param>
        <summary>
            Flattens the contents of this Tensor into the provided <see cref="T:System.Span`1" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.Tensors.IReadOnlyTensor`2.TryFlattenTo(System.Span{`1})" />
      </Docs>
    </Member>
  </Members>
</Type>
