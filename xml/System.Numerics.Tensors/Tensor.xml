<Type Name="Tensor" FullName="System.Numerics.Tensors.Tensor">
  <TypeSignature Language="C#" Value="public static class Tensor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Tensor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Tensors.Tensor" />
  <TypeSignature Language="VB.NET" Value="Public Module Tensor" />
  <TypeSignature Language="F#" Value="type Tensor = class" />
  <TypeSignature Language="C++ CLI" Value="public ref class Tensor abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Numerics.Tensors</AssemblyName>
    <AssemblyVersion>9.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>To be added.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Abs&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Abs&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Abs&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Abs``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Abs(Of T As INumberBase(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Abs input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Abs(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Abs&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Abs&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Abs``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Abs(Of T As INumberBase(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Abs : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Abs (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Abs(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">The <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> destination.</param>
        <summary>Takes the absolute value of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Acos&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Acos&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Acos&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Acos``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Acos(Of T As ITrigonometricFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Acos : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Acos input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Acos(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Acos&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Acos&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Acos&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Acos``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Acos(Of T As ITrigonometricFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Acos : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Acos (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Acos(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Takes the inverse cosine of each element of the <see cref="T:System.Numerics.Tensors.Tensor`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Acosh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Acosh&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Acosh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Acosh``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Acosh(Of T As IHyperbolicFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Acosh : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Acosh input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Acosh(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Acosh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Acosh&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Acosh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Acosh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Acosh(Of T As IHyperbolicFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Acosh : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Acosh (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Acosh(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Takes the inverse hyperbolic cosine of each element of the <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcosPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; AcosPi&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; AcosPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.AcosPi``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AcosPi(Of T As ITrigonometricFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member AcosPi : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.AcosPi input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ AcosPi(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcosPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; AcosPi&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; AcosPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.AcosPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcosPi(Of T As ITrigonometricFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member AcosPi : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.AcosPi (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ AcosPi(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Takes the inverse hyperbolic cosine divided by pi of each element of the <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Add&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Add&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Add``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Add(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Add (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Add(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Add&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input, T val) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Add&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, !!T val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Add``1(System.Numerics.Tensors.Tensor{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (input As Tensor(Of T), val As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Add (input, val)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Add(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, T val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="val" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Add&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Add&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Add``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Add : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Add (left, right, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Add(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Adds each element of <paramref name="x" /> to each element of <paramref name="y" /> and returns a new <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Add&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, T val, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Add&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, !!T val, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Add``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (ByRef input As ReadOnlyTensorSpan(Of T), val As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Add : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Add (input, val, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Add(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, T val, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="val" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Adds <paramref name="y" /> to each element of <paramref name="x" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Asin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Asin&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Asin&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Asin``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Asin(Of T As ITrigonometricFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Asin : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Asin input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Asin(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Asin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Asin&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Asin&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Asin``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Asin(Of T As ITrigonometricFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Asin : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Asin (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Asin(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Takes the inverse sin of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Asinh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Asinh&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Asinh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Asinh``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Asinh(Of T As IHyperbolicFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Asinh : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Asinh input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Asinh(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Asinh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Asinh&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Asinh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Asinh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Asinh(Of T As IHyperbolicFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Asinh : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Asinh (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Asinh(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Takes the inverse hyperbolic sine of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsinPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; AsinPi&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; AsinPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.AsinPi``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AsinPi(Of T As ITrigonometricFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member AsinPi : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.AsinPi input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ AsinPi(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsinPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; AsinPi&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; AsinPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.AsinPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function AsinPi(Of T As ITrigonometricFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member AsinPi : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.AsinPi (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ AsinPi(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Takes the inverse hyperbolic sine divided by pi of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsReadOnlyTensorSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; AsReadOnlyTensorSpan&lt;T&gt; (this T[]? array, scoped ReadOnlySpan&lt;IntPtr&gt; shape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt; AsReadOnlyTensorSpan&lt;T&gt;(!!T[] array, valuetype System.ReadOnlySpan`1&lt;native int&gt; shape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.AsReadOnlyTensorSpan``1(``0[],System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsReadOnlyTensorSpan(Of T) (array As T(), shape As ReadOnlySpan(Of IntPtr)) As ReadOnlyTensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member AsReadOnlyTensorSpan : 'T[] * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.AsReadOnlyTensorSpan (array, shape)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; AsReadOnlyTensorSpan(cli::array &lt;T&gt; ^ array, ReadOnlySpan&lt;IntPtr&gt; shape);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="shape" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The type of the elements in the array</typeparam>
        <param name="array">The <see cref="T:System.Array" /> with the data</param>
        <param name="shape">To be added.</param>
        <summary>Creates a TensorSpan from an array.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsTensorSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; AsTensorSpan&lt;T&gt; (this T[]? array, scoped ReadOnlySpan&lt;IntPtr&gt; shape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; AsTensorSpan&lt;T&gt;(!!T[] array, valuetype System.ReadOnlySpan`1&lt;native int&gt; shape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.AsTensorSpan``1(``0[],System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsTensorSpan(Of T) (array As T(), shape As ReadOnlySpan(Of IntPtr)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member AsTensorSpan : 'T[] * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.AsTensorSpan (array, shape)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::TensorSpan&lt;T&gt; AsTensorSpan(cli::array &lt;T&gt; ^ array, ReadOnlySpan&lt;IntPtr&gt; shape);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="shape" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The type of the elements in the array</typeparam>
        <param name="array">The <see cref="T:System.Array" /> with the data</param>
        <param name="shape">To be added.</param>
        <summary>Creates a TensorSpan from an array.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Atan&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Atan&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atan``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Atan(Of T As ITrigonometricFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Atan : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atan input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Atan(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Atan&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Atan&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atan``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Atan(Of T As ITrigonometricFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Atan : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atan (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Atan(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Takes the arc tangent of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Atan2&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Atan2&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atan2``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Atan2(Of T As IFloatingPointIeee754(Of T)) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Atan2 : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atan2 (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Atan2(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Atan2&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Atan2&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atan2``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Atan2(Of T As IFloatingPointIeee754(Of T)) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Atan2 : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atan2 (left, right, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Atan2(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Takes the arc tangent of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2Pi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Atan2Pi&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Atan2Pi&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atan2Pi``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Atan2Pi(Of T As IFloatingPointIeee754(Of T)) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Atan2Pi : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atan2Pi (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Atan2Pi(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2Pi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Atan2Pi&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Atan2Pi&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atan2Pi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Atan2Pi(Of T As IFloatingPointIeee754(Of T)) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Atan2Pi : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atan2Pi (left, right, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Atan2Pi(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Takes the arc tangent of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />, divides each element by pi, and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atanh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Atanh&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Atanh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atanh``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Atanh(Of T As IHyperbolicFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Atanh : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atanh input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Atanh(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atanh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Atanh&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Atanh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atanh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Atanh(Of T As IHyperbolicFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Atanh : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atanh (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Atanh(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Takes the inverse hyperbolic tangent of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AtanPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; AtanPi&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; AtanPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.AtanPi``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AtanPi(Of T As ITrigonometricFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member AtanPi : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.AtanPi input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ AtanPi(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AtanPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; AtanPi&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; AtanPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.AtanPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function AtanPi(Of T As ITrigonometricFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member AtanPi : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.AtanPi (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ AtanPi(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Takes the inverse hyperbolic tangent divided by pi of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BitwiseAnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; BitwiseAnd&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; BitwiseAnd&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.BitwiseAnd``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BitwiseAnd(Of T As IBitwiseOperators(Of T, T, T)) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member BitwiseAnd : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.BitwiseAnd (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ BitwiseAnd(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BitwiseAnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; BitwiseAnd&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; BitwiseAnd&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.BitwiseAnd``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function BitwiseAnd(Of T As IBitwiseOperators(Of T, T, T)) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member BitwiseAnd : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.BitwiseAnd (left, right, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ BitwiseAnd(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise <see langword="bitwise and" /> of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BitwiseOr&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; BitwiseOr&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; BitwiseOr&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.BitwiseOr``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BitwiseOr(Of T As IBitwiseOperators(Of T, T, T)) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member BitwiseOr : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.BitwiseOr (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ BitwiseOr(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BitwiseOr&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; BitwiseOr&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; BitwiseOr&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.BitwiseOr``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function BitwiseOr(Of T As IBitwiseOperators(Of T, T, T)) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member BitwiseOr : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.BitwiseOr (left, right, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ BitwiseOr(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise <see langword="bitwise or" /> of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Broadcast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Broadcast&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; lengthsSource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Broadcast&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; lengthsSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Broadcast``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Broadcast(Of T) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef lengthsSource As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Broadcast : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Broadcast (input, lengthsSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Broadcast(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % lengthsSource);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="lengthsSource" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="lengthsSource">Other <see cref="T:System.Numerics.Tensors.Tensor`1" /> to make shapes broadcastable.</param>
        <summary>Broadcasts the data from <paramref name="source" /> to the smallest broadcastable shape compatible with <paramref name="lengthsSource" />. Creates a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> and allocates new memory.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Broadcast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Broadcast&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, scoped ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Broadcast&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Broadcast``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function Broadcast(Of T) (ByRef input As ReadOnlyTensorSpan(Of T), lengths As ReadOnlySpan(Of IntPtr)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Broadcast : ReadOnlyTensorSpan * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Broadcast (input, lengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Broadcast(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="lengths">
          <see cref="T:System.ReadOnlySpan`1" /> of the desired new shape.</param>
        <summary>Broadcasts the data from <paramref name="source" /> to the new shape <paramref name="lengths" />. Creates a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> and allocates new memory.  
 If the shape of the <paramref name="source" /> is not compatible with the new shape, an exception is thrown.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">The shapes are not broadcast compatible.</exception>
      </Docs>
    </Member>
    <Member MemberName="BroadcastTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void BroadcastTo&lt;T&gt; (this in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; source, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BroadcastTo&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; source, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.BroadcastTo``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub BroadcastTo(Of T) (ByRef source As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T))" />
      <MemberSignature Language="F#" Value="static member BroadcastTo : ReadOnlyTensorSpan * TensorSpan -&gt; unit" Usage="System.Numerics.Tensors.Tensor.BroadcastTo (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void BroadcastTo(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % source, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">Input <see cref="T:System.Numerics.Tensors.TensorSpan`1" />.</param>
        <param name="destination">To be added.</param>
        <summary>Broadcasts the data from <paramref name="source" /> to <paramref name="destination" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BroadcastTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void BroadcastTo&lt;T&gt; (this System.Numerics.Tensors.Tensor&lt;T&gt; source, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BroadcastTo&lt;T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; source, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.BroadcastTo``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub BroadcastTo(Of T) (source As Tensor(Of T), ByRef destination As TensorSpan(Of T))" />
      <MemberSignature Language="F#" Value="static member BroadcastTo : System.Numerics.Tensors.Tensor&lt;'T&gt; * TensorSpan -&gt; unit" Usage="System.Numerics.Tensors.Tensor.BroadcastTo (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void BroadcastTo(System::Numerics::Tensors::Tensor&lt;T&gt; ^ source, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" RefType="this" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">Input <see cref="T:System.Numerics.Tensors.TensorSpan`1" />.</param>
        <param name="destination">To be added.</param>
        <summary>Broadcasts the data from <paramref name="source" /> to <paramref name="destination" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BroadcastTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void BroadcastTo&lt;T&gt; (this in System.Numerics.Tensors.TensorSpan&lt;T&gt; source, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BroadcastTo&lt;T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; source, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.BroadcastTo``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub BroadcastTo(Of T) (ByRef source As TensorSpan(Of T), ByRef destination As TensorSpan(Of T))" />
      <MemberSignature Language="F#" Value="static member BroadcastTo : TensorSpan * TensorSpan -&gt; unit" Usage="System.Numerics.Tensors.Tensor.BroadcastTo (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void BroadcastTo(System::Numerics::Tensors::TensorSpan&lt;T&gt; % source, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">Input <see cref="T:System.Numerics.Tensors.TensorSpan`1" />.</param>
        <param name="destination">Other <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> to make shapes broadcastable.</param>
        <summary>Broadcasts the data from <paramref name="source" /> to <paramref name="destination" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cbrt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Cbrt&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Cbrt&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Cbrt``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Cbrt(Of T As IRootFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Cbrt : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Cbrt input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Cbrt(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cbrt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Cbrt&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Cbrt&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Cbrt``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Cbrt(Of T As IRootFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Cbrt : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Cbrt (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Cbrt(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise cube root of the input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceiling&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Ceiling&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Ceiling&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Ceiling``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Ceiling(Of T As IFloatingPoint(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Ceiling : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Ceiling input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Ceiling(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceiling&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Ceiling&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Ceiling&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Ceiling``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Ceiling(Of T As IFloatingPoint(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Ceiling : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Ceiling (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Ceiling(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise ceiling of the input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concatenate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Concatenate&lt;T&gt; (scoped ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;T&gt;&gt; tensors, int axis = 0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Concatenate&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;class System.Numerics.Tensors.Tensor`1&lt;!!T&gt;&gt; tensors, int32 axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Concatenate``1(System.ReadOnlySpan{System.Numerics.Tensors.Tensor{``0}},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Concatenate(Of T) (tensors As ReadOnlySpan(Of Tensor(Of T)), Optional axis As Integer = 0) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Concatenate : ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;'T&gt;&gt; * int -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Concatenate (tensors, axis)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensors" Type="System.ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;T&gt;&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="axis" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensors">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertChecked&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;TTo&gt; ConvertChecked&lt;TFrom,TTo&gt; (System.Numerics.Tensors.Tensor&lt;TFrom&gt; source) where TFrom : IEquatable&lt;TFrom&gt;, System.Numerics.IEqualityOperators&lt;TFrom,TFrom,bool&gt;, System.Numerics.INumberBase&lt;TFrom&gt; where TTo : System.Numerics.INumberBase&lt;TTo&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!TTo&gt; ConvertChecked&lt;(class System.IEquatable`1&lt;!!TFrom&gt;, class System.Numerics.IEqualityOperators`3&lt;!!TFrom, !!TFrom, bool&gt;, class System.Numerics.INumberBase`1&lt;!!TFrom&gt;) TFrom, (class System.Numerics.INumberBase`1&lt;!!TTo&gt;) TTo&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!TFrom&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ConvertChecked``2(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertChecked(Of TFrom As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}, TTo As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}) (source As Tensor(Of TFrom)) As Tensor(Of TTo)" />
      <MemberSignature Language="F#" Value="static member ConvertChecked : System.Numerics.Tensors.Tensor&lt;'From (requires 'From :&gt; IEquatable&lt;'From&gt; and 'From :&gt; System.Numerics.IEqualityOperators&lt;'From, 'From, bool&gt; and 'From :&gt; System.Numerics.INumberBase&lt;'From&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'o (requires 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)&gt; (requires 'From :&gt; IEquatable&lt;'From&gt; and 'From :&gt; System.Numerics.IEqualityOperators&lt;'From, 'From, bool&gt; and 'From :&gt; System.Numerics.INumberBase&lt;'From&gt; and 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)" Usage="System.Numerics.Tensors.Tensor.ConvertChecked source" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; where TFrom : IEquatable&lt;TFrom&gt;, System::Numerics::IEqualityOperators&lt;TFrom, TFrom, bool&gt;, System::Numerics::INumberBase&lt;TFrom&gt; where TTo : System::Numerics::INumberBase&lt;TTo&gt; static System::Numerics::Tensors::Tensor&lt;TTo&gt; ^ ConvertChecked(System::Numerics::Tensors::Tensor&lt;TFrom&gt; ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;TTo&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;TFrom&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;TFrom,TFrom,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.INumberBase&lt;TFrom&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TTo&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Tensors.Tensor&lt;TFrom&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFrom">To be added.</typeparam>
        <typeparam name="TTo">To be added.</typeparam>
        <param name="source">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertChecked&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;TTo&gt; ConvertChecked&lt;TFrom,TTo&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;TFrom&gt; source, in System.Numerics.Tensors.TensorSpan&lt;TTo&gt; destination) where TFrom : IEquatable&lt;TFrom&gt;, System.Numerics.IEqualityOperators&lt;TFrom,TFrom,bool&gt;, System.Numerics.INumberBase&lt;TFrom&gt; where TTo : System.Numerics.INumberBase&lt;TTo&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!TTo&gt; ConvertChecked&lt;(class System.IEquatable`1&lt;!!TFrom&gt;, class System.Numerics.IEqualityOperators`3&lt;!!TFrom, !!TFrom, bool&gt;, class System.Numerics.INumberBase`1&lt;!!TFrom&gt;) TFrom, (class System.Numerics.INumberBase`1&lt;!!TTo&gt;) TTo&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!TFrom&gt;&amp; source, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!TTo&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ConvertChecked``2(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``1}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertChecked(Of TFrom As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}, TTo As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}) (ByRef source As ReadOnlyTensorSpan(Of TFrom), ByRef destination As TensorSpan(Of TTo)) As TensorSpan(Of TTo)" />
      <MemberSignature Language="F#" Value="static member ConvertChecked : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'From :&gt; IEquatable&lt;'From&gt; and 'From :&gt; System.Numerics.IEqualityOperators&lt;'From, 'From, bool&gt; and 'From :&gt; System.Numerics.INumberBase&lt;'From&gt; and 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)" Usage="System.Numerics.Tensors.Tensor.ConvertChecked (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; where TFrom : IEquatable&lt;TFrom&gt;, System::Numerics::IEqualityOperators&lt;TFrom, TFrom, bool&gt;, System::Numerics::INumberBase&lt;TFrom&gt; where TTo : System::Numerics::INumberBase&lt;TTo&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ ConvertChecked(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;TFrom&gt; % source, System::Numerics::Tensors::TensorSpan&lt;TTo&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;TTo&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;TFrom&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;TFrom,TFrom,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.INumberBase&lt;TFrom&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TTo&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;TFrom&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;TTo&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TFrom">To be added.</typeparam>
        <typeparam name="TTo">To be added.</typeparam>
        <param name="source">The input <see cref="T:System.Numerics.Tensors.TensorSpan`1" />.</param>
        <param name="destination">To be added.</param>
        <summary>Copies <paramref name="source" /> to a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> converting each <typeparamref name="TFrom" /> value to a <typeparamref name="TTo" /> value.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertSaturating&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;TTo&gt; ConvertSaturating&lt;TFrom,TTo&gt; (System.Numerics.Tensors.Tensor&lt;TFrom&gt; source) where TFrom : IEquatable&lt;TFrom&gt;, System.Numerics.IEqualityOperators&lt;TFrom,TFrom,bool&gt;, System.Numerics.INumberBase&lt;TFrom&gt; where TTo : System.Numerics.INumberBase&lt;TTo&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!TTo&gt; ConvertSaturating&lt;(class System.IEquatable`1&lt;!!TFrom&gt;, class System.Numerics.IEqualityOperators`3&lt;!!TFrom, !!TFrom, bool&gt;, class System.Numerics.INumberBase`1&lt;!!TFrom&gt;) TFrom, (class System.Numerics.INumberBase`1&lt;!!TTo&gt;) TTo&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!TFrom&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ConvertSaturating``2(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertSaturating(Of TFrom As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}, TTo As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}) (source As Tensor(Of TFrom)) As Tensor(Of TTo)" />
      <MemberSignature Language="F#" Value="static member ConvertSaturating : System.Numerics.Tensors.Tensor&lt;'From (requires 'From :&gt; IEquatable&lt;'From&gt; and 'From :&gt; System.Numerics.IEqualityOperators&lt;'From, 'From, bool&gt; and 'From :&gt; System.Numerics.INumberBase&lt;'From&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'o (requires 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)&gt; (requires 'From :&gt; IEquatable&lt;'From&gt; and 'From :&gt; System.Numerics.IEqualityOperators&lt;'From, 'From, bool&gt; and 'From :&gt; System.Numerics.INumberBase&lt;'From&gt; and 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)" Usage="System.Numerics.Tensors.Tensor.ConvertSaturating source" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; where TFrom : IEquatable&lt;TFrom&gt;, System::Numerics::IEqualityOperators&lt;TFrom, TFrom, bool&gt;, System::Numerics::INumberBase&lt;TFrom&gt; where TTo : System::Numerics::INumberBase&lt;TTo&gt; static System::Numerics::Tensors::Tensor&lt;TTo&gt; ^ ConvertSaturating(System::Numerics::Tensors::Tensor&lt;TFrom&gt; ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;TTo&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;TFrom&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;TFrom,TFrom,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.INumberBase&lt;TFrom&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TTo&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Tensors.Tensor&lt;TFrom&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFrom">To be added.</typeparam>
        <typeparam name="TTo">To be added.</typeparam>
        <param name="source">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertSaturating&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;TTo&gt; ConvertSaturating&lt;TFrom,TTo&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;TFrom&gt; source, in System.Numerics.Tensors.TensorSpan&lt;TTo&gt; destination) where TFrom : IEquatable&lt;TFrom&gt;, System.Numerics.IEqualityOperators&lt;TFrom,TFrom,bool&gt;, System.Numerics.INumberBase&lt;TFrom&gt; where TTo : System.Numerics.INumberBase&lt;TTo&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!TTo&gt; ConvertSaturating&lt;(class System.IEquatable`1&lt;!!TFrom&gt;, class System.Numerics.IEqualityOperators`3&lt;!!TFrom, !!TFrom, bool&gt;, class System.Numerics.INumberBase`1&lt;!!TFrom&gt;) TFrom, (class System.Numerics.INumberBase`1&lt;!!TTo&gt;) TTo&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!TFrom&gt;&amp; source, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!TTo&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ConvertSaturating``2(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``1}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertSaturating(Of TFrom As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}, TTo As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}) (ByRef source As ReadOnlyTensorSpan(Of TFrom), ByRef destination As TensorSpan(Of TTo)) As TensorSpan(Of TTo)" />
      <MemberSignature Language="F#" Value="static member ConvertSaturating : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'From :&gt; IEquatable&lt;'From&gt; and 'From :&gt; System.Numerics.IEqualityOperators&lt;'From, 'From, bool&gt; and 'From :&gt; System.Numerics.INumberBase&lt;'From&gt; and 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)" Usage="System.Numerics.Tensors.Tensor.ConvertSaturating (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; where TFrom : IEquatable&lt;TFrom&gt;, System::Numerics::IEqualityOperators&lt;TFrom, TFrom, bool&gt;, System::Numerics::INumberBase&lt;TFrom&gt; where TTo : System::Numerics::INumberBase&lt;TTo&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ ConvertSaturating(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;TFrom&gt; % source, System::Numerics::Tensors::TensorSpan&lt;TTo&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;TTo&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;TFrom&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;TFrom,TFrom,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.INumberBase&lt;TFrom&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TTo&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;TFrom&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;TTo&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TFrom">To be added.</typeparam>
        <typeparam name="TTo">To be added.</typeparam>
        <param name="source">The input <see cref="T:System.Numerics.Tensors.TensorSpan`1" />.</param>
        <param name="destination">To be added.</param>
        <summary>Copies <paramref name="source" /> to a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> converting each <typeparamref name="TFrom" /> value to a <typeparamref name="TTo" /> value.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertTruncating&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;TTo&gt; ConvertTruncating&lt;TFrom,TTo&gt; (System.Numerics.Tensors.Tensor&lt;TFrom&gt; source) where TFrom : IEquatable&lt;TFrom&gt;, System.Numerics.IEqualityOperators&lt;TFrom,TFrom,bool&gt;, System.Numerics.INumberBase&lt;TFrom&gt; where TTo : System.Numerics.INumberBase&lt;TTo&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!TTo&gt; ConvertTruncating&lt;(class System.IEquatable`1&lt;!!TFrom&gt;, class System.Numerics.IEqualityOperators`3&lt;!!TFrom, !!TFrom, bool&gt;, class System.Numerics.INumberBase`1&lt;!!TFrom&gt;) TFrom, (class System.Numerics.INumberBase`1&lt;!!TTo&gt;) TTo&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!TFrom&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ConvertTruncating``2(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertTruncating(Of TFrom As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}, TTo As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}) (source As Tensor(Of TFrom)) As Tensor(Of TTo)" />
      <MemberSignature Language="F#" Value="static member ConvertTruncating : System.Numerics.Tensors.Tensor&lt;'From (requires 'From :&gt; IEquatable&lt;'From&gt; and 'From :&gt; System.Numerics.IEqualityOperators&lt;'From, 'From, bool&gt; and 'From :&gt; System.Numerics.INumberBase&lt;'From&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'o (requires 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)&gt; (requires 'From :&gt; IEquatable&lt;'From&gt; and 'From :&gt; System.Numerics.IEqualityOperators&lt;'From, 'From, bool&gt; and 'From :&gt; System.Numerics.INumberBase&lt;'From&gt; and 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)" Usage="System.Numerics.Tensors.Tensor.ConvertTruncating source" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; where TFrom : IEquatable&lt;TFrom&gt;, System::Numerics::IEqualityOperators&lt;TFrom, TFrom, bool&gt;, System::Numerics::INumberBase&lt;TFrom&gt; where TTo : System::Numerics::INumberBase&lt;TTo&gt; static System::Numerics::Tensors::Tensor&lt;TTo&gt; ^ ConvertTruncating(System::Numerics::Tensors::Tensor&lt;TFrom&gt; ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;TTo&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;TFrom&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;TFrom,TFrom,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.INumberBase&lt;TFrom&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TTo&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Tensors.Tensor&lt;TFrom&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFrom">To be added.</typeparam>
        <typeparam name="TTo">To be added.</typeparam>
        <param name="source">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertTruncating&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;TTo&gt; ConvertTruncating&lt;TFrom,TTo&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;TFrom&gt; source, in System.Numerics.Tensors.TensorSpan&lt;TTo&gt; destination) where TFrom : IEquatable&lt;TFrom&gt;, System.Numerics.IEqualityOperators&lt;TFrom,TFrom,bool&gt;, System.Numerics.INumberBase&lt;TFrom&gt; where TTo : System.Numerics.INumberBase&lt;TTo&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!TTo&gt; ConvertTruncating&lt;(class System.IEquatable`1&lt;!!TFrom&gt;, class System.Numerics.IEqualityOperators`3&lt;!!TFrom, !!TFrom, bool&gt;, class System.Numerics.INumberBase`1&lt;!!TFrom&gt;) TFrom, (class System.Numerics.INumberBase`1&lt;!!TTo&gt;) TTo&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!TFrom&gt;&amp; source, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!TTo&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ConvertTruncating``2(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``1}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertTruncating(Of TFrom As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}, TTo As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}) (ByRef source As ReadOnlyTensorSpan(Of TFrom), ByRef destination As TensorSpan(Of TTo)) As TensorSpan(Of TTo)" />
      <MemberSignature Language="F#" Value="static member ConvertTruncating : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'From :&gt; IEquatable&lt;'From&gt; and 'From :&gt; System.Numerics.IEqualityOperators&lt;'From, 'From, bool&gt; and 'From :&gt; System.Numerics.INumberBase&lt;'From&gt; and 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)" Usage="System.Numerics.Tensors.Tensor.ConvertTruncating (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; where TFrom : IEquatable&lt;TFrom&gt;, System::Numerics::IEqualityOperators&lt;TFrom, TFrom, bool&gt;, System::Numerics::INumberBase&lt;TFrom&gt; where TTo : System::Numerics::INumberBase&lt;TTo&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ ConvertTruncating(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;TFrom&gt; % source, System::Numerics::Tensors::TensorSpan&lt;TTo&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;TTo&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;TFrom&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;TFrom,TFrom,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.INumberBase&lt;TFrom&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TTo&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;TFrom&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;TTo&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TFrom">To be added.</typeparam>
        <typeparam name="TTo">To be added.</typeparam>
        <param name="source">The input <see cref="T:System.Numerics.Tensors.TensorSpan`1" />.</param>
        <param name="destination">To be added.</param>
        <summary>Copies <paramref name="source" /> to a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> converting each <typeparamref name="TFrom" /> value to a <typeparamref name="TTo" /> value.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopySign&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CopySign&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input, System.Numerics.Tensors.Tensor&lt;T&gt; sign) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CopySign&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; sign) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CopySign``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function CopySign(Of T As INumber(Of T)) (input As Tensor(Of T), sign As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CopySign : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CopySign (input, sign)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ CopySign(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, System::Numerics::Tensors::Tensor&lt;T&gt; ^ sign);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="sign" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="sign">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopySign&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CopySign&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input, T sign) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CopySign&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, !!T sign) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CopySign``1(System.Numerics.Tensors.Tensor{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopySign(Of T As INumber(Of T)) (input As Tensor(Of T), sign As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CopySign : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CopySign (input, sign)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ CopySign(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, T sign);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="sign" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="sign">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopySign&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; CopySign&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; sign, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; CopySign&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; sign, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CopySign``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopySign(Of T As INumber(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef sign As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member CopySign : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CopySign (input, sign, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ CopySign(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % sign, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="sign" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="sign">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> with the associated signs.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise result of copying the sign from one number to another number in the specified tensors and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopySign&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; CopySign&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, T sign, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; CopySign&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, !!T sign, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CopySign``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopySign(Of T As INumber(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), sign As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member CopySign : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CopySign (input, sign, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ CopySign(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, T sign, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="sign" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="sign">The number with the associated sign.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise result of copying the sign from one number to another number in the specified tensors and returns a new tensor with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Cos&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Cos&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Cos``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Cos(Of T As ITrigonometricFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Cos : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Cos input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Cos(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Cos&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Cos&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Cos``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Cos(Of T As ITrigonometricFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Cos : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Cos (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Cos(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Takes the cosine of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cosh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Cosh&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Cosh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Cosh``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Cosh(Of T As IHyperbolicFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Cosh : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Cosh input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Cosh(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cosh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Cosh&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Cosh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Cosh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Cosh(Of T As IHyperbolicFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Cosh : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Cosh (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Cosh(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Takes the hyperbolic cosine of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CosineSimilarity&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CosineSimilarity&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CosineSimilarity&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CosineSimilarity``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function CosineSimilarity(Of T As IRootFunctions(Of T)) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CosineSimilarity : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CosineSimilarity (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ CosineSimilarity(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CosineSimilarity&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; CosineSimilarity&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; CosineSimilarity&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CosineSimilarity``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function CosineSimilarity(Of T As IRootFunctions(Of T)) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member CosineSimilarity : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CosineSimilarity (left, right, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ CosineSimilarity(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes cosine similarity between <paramref name="x" /> and <paramref name="y" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CosPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CosPi&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CosPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CosPi``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function CosPi(Of T As ITrigonometricFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CosPi : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CosPi input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ CosPi(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CosPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; CosPi&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; CosPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CosPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function CosPi(Of T As ITrigonometricFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member CosPi : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CosPi (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ CosPi(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise cosine of the value in the specified tensor that has been multiplied by Pi and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the results.</summary>
        <returns>To be added.</returns>
        <remarks>
          <para> This method effectively computes <c><typeparamref name="T" />.CosPi(<paramref name="x" />[i])</c>.
 </para>
          <para> The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians" /> or multiply by <typeparamref name="T" />.Pi/180 to convert degrees to radians.
 </para>
          <para> This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different operating systems or architectures.
 </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Create&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; data, scoped ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Create&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; data, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Create``1(System.Collections.Generic.IEnumerable{``0},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function Create(Of T) (data As IEnumerable(Of T), lengths As ReadOnlySpan(Of IntPtr)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Create : seq&lt;'T&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Create (data, lengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Create(System::Collections::Generic::IEnumerable&lt;T&gt; ^ data, ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="data">To be added.</param>
        <param name="lengths">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Create&lt;T&gt; (scoped ReadOnlySpan&lt;IntPtr&gt; lengths, bool pinned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Create&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Create``1(System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Create(Of T) (lengths As ReadOnlySpan(Of IntPtr), Optional pinned As Boolean = false) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Create : ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Create (lengths, pinned)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="lengths">A <see cref="T:System.ReadOnlySpan`1" /> indicating the lengths of each dimension.</param>
        <param name="pinned">
          <see langword="true" /> to pin the underlying data; otherwise <see langword="false" />.</param>
        <summary>Creates a <see cref="T:System.Numerics.Tensors.Tensor`1" /> and initializes it with the default value of T. If <paramref name="pinned" /> is <see langword="true" />, the memory will be pinned.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Create&lt;T&gt; (T[] values, scoped ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Create&lt;T&gt;(!!T[] values, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Create``1(``0[],System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function Create(Of T) (values As T(), lengths As ReadOnlySpan(Of IntPtr)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Create : 'T[] * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Create (values, lengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Create(cli::array &lt;T&gt; ^ values, ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="T[]" />
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="values">To be added.</param>
        <param name="lengths">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Create&lt;T&gt; (scoped ReadOnlySpan&lt;IntPtr&gt; lengths, scoped ReadOnlySpan&lt;IntPtr&gt; strides, bool pinned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Create&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Create``1(System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Create(Of T) (lengths As ReadOnlySpan(Of IntPtr), strides As ReadOnlySpan(Of IntPtr), Optional pinned As Boolean = false) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Create : ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Create (lengths, strides, pinned)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="lengths">A <see cref="T:System.ReadOnlySpan`1" /> indicating the lengths of each dimension.</param>
        <param name="strides">A <see cref="T:System.ReadOnlySpan`1" /> indicating the strides of each dimension.</param>
        <param name="pinned">
          <see langword="true" /> to pin the underlying data; otherwise <see langword="false" />.</param>
        <summary>Creates a <see cref="T:System.Numerics.Tensors.Tensor`1" /> and initializes it with the default value of T. If <paramref name="pinned" /> is <see langword="true" />, the memory will be pinned.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Create&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; data, scoped ReadOnlySpan&lt;IntPtr&gt; lengths, scoped ReadOnlySpan&lt;IntPtr&gt; strides, bool isPinned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Create&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; data, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides, bool isPinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Create``1(System.Collections.Generic.IEnumerable{``0},System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Create(Of T) (data As IEnumerable(Of T), lengths As ReadOnlySpan(Of IntPtr), strides As ReadOnlySpan(Of IntPtr), Optional isPinned As Boolean = false) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Create : seq&lt;'T&gt; * ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Create (data, lengths, strides, isPinned)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IEnumerable&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="isPinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="data">To be added.</param>
        <param name="lengths">A <see cref="T:System.ReadOnlySpan`1" /> indicating the lengths of each dimension.</param>
        <param name="strides">A <see cref="T:System.ReadOnlySpan`1" /> indicating the strides of each dimension.</param>
        <param name="isPinned">To be added.</param>
        <summary>Creates a <see cref="T:System.Numerics.Tensors.Tensor`1" /> and initializes it with the data from <paramref name="values" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Create&lt;T&gt; (T[] values, scoped ReadOnlySpan&lt;IntPtr&gt; lengths, scoped ReadOnlySpan&lt;IntPtr&gt; strides, bool isPinned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Create&lt;T&gt;(!!T[] values, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides, bool isPinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Create``1(``0[],System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Create(Of T) (values As T(), lengths As ReadOnlySpan(Of IntPtr), strides As ReadOnlySpan(Of IntPtr), Optional isPinned As Boolean = false) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Create : 'T[] * ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Create (values, lengths, strides, isPinned)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="T[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="isPinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="values">An array of the backing memory.</param>
        <param name="lengths">A <see cref="T:System.ReadOnlySpan`1" /> indicating the lengths of each dimension.</param>
        <param name="strides">A <see cref="T:System.ReadOnlySpan`1" /> indicating the strides of each dimension.</param>
        <param name="isPinned">To be added.</param>
        <summary>Creates a <see cref="T:System.Numerics.Tensors.Tensor`1" /> from the provided <paramref name="values" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The product of <paramref name="lengths" /> does not equal the length of the <paramref name="values" /> array.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateAndFillGaussianNormalDistribution&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CreateAndFillGaussianNormalDistribution&lt;T&gt; (scoped ReadOnlySpan&lt;IntPtr&gt; lengths) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CreateAndFillGaussianNormalDistribution&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CreateAndFillGaussianNormalDistribution``1(System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateAndFillGaussianNormalDistribution(Of T As IFloatingPoint(Of T)) (lengths As ReadOnlySpan(Of IntPtr)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CreateAndFillGaussianNormalDistribution : ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CreateAndFillGaussianNormalDistribution lengths" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ CreateAndFillGaussianNormalDistribution(ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="lengths">A <see cref="T:System.ReadOnlySpan`1" /> indicating the lengths of each dimension.</param>
        <summary>Creates a <see cref="T:System.Numerics.Tensors.Tensor`1" /> and initializes it with random data in a gaussian normal distribution.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAndFillUniformDistribution&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CreateAndFillUniformDistribution&lt;T&gt; (scoped ReadOnlySpan&lt;IntPtr&gt; lengths) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CreateAndFillUniformDistribution&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CreateAndFillUniformDistribution``1(System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateAndFillUniformDistribution(Of T As IFloatingPoint(Of T)) (lengths As ReadOnlySpan(Of IntPtr)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CreateAndFillUniformDistribution : ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CreateAndFillUniformDistribution lengths" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ CreateAndFillUniformDistribution(ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="lengths">A <see cref="T:System.ReadOnlySpan`1" /> indicating the lengths of each dimension.</param>
        <summary>Creates a <see cref="T:System.Numerics.Tensors.Tensor`1" /> and initializes it with random data uniformly distributed.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateUninitialized&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CreateUninitialized&lt;T&gt; (scoped ReadOnlySpan&lt;IntPtr&gt; lengths, bool pinned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CreateUninitialized&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CreateUninitialized``1(System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateUninitialized(Of T) (lengths As ReadOnlySpan(Of IntPtr), Optional pinned As Boolean = false) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CreateUninitialized : ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.CreateUninitialized (lengths, pinned)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="lengths">A <see cref="T:System.ReadOnlySpan`1" /> indicating the lengths of each dimension.</param>
        <param name="pinned">
          <see langword="true" /> to pin the underlying data; otherwise <see langword="false" />.</param>
        <summary>Creates a <see cref="T:System.Numerics.Tensors.Tensor`1" /> and does not initialize it. If <paramref name="pinned" /> is <see langword="true" />, the memory will be pinned.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateUninitialized&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CreateUninitialized&lt;T&gt; (scoped ReadOnlySpan&lt;IntPtr&gt; lengths, scoped ReadOnlySpan&lt;IntPtr&gt; strides, bool pinned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CreateUninitialized&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CreateUninitialized``1(System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateUninitialized(Of T) (lengths As ReadOnlySpan(Of IntPtr), strides As ReadOnlySpan(Of IntPtr), Optional pinned As Boolean = false) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CreateUninitialized : ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.CreateUninitialized (lengths, strides, pinned)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="lengths">A <see cref="T:System.ReadOnlySpan`1" /> indicating the lengths of each dimension.</param>
        <param name="strides">A <see cref="T:System.ReadOnlySpan`1" /> indicating the strides of each dimension.</param>
        <param name="pinned">
          <see langword="true" /> to pin the underlying data; otherwise <see langword="false" />.</param>
        <summary>Creates a <see cref="T:System.Numerics.Tensors.Tensor`1" /> and does not initialize it. If <paramref name="pinned" /> is <see langword="true" />, the memory will be pinned.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DegreesToRadians&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; DegreesToRadians&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; DegreesToRadians&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.DegreesToRadians``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function DegreesToRadians(Of T As ITrigonometricFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member DegreesToRadians : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.DegreesToRadians input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ DegreesToRadians(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DegreesToRadians&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; DegreesToRadians&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; DegreesToRadians&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.DegreesToRadians``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function DegreesToRadians(Of T As ITrigonometricFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member DegreesToRadians : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.DegreesToRadians (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ DegreesToRadians(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise conversion of each number of degrees in the specified tensor to radians and returns a new tensor with the results.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Distance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Distance&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Distance&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Distance``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Distance(Of T As IRootFunctions(Of T)) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Distance : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Distance (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static T Distance(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>Computes the distance between two points, specified as non-empty, equal-length tensors of numbers, in Euclidean space.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Distance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Distance&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Distance&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Distance``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Distance(Of T As IRootFunctions(Of T)) (left As Tensor(Of T), right As Tensor(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Distance : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Distance (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static T Distance(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Divide&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Divide&lt;(class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Divide``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Divide(Of T As IDivisionOperators(Of T, T, T)) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Divide (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IDivisionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Divide(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Divide&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input, T val) where T : System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Divide&lt;(class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, !!T val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Divide``1(System.Numerics.Tensors.Tensor{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Divide(Of T As IDivisionOperators(Of T, T, T)) (input As Tensor(Of T), val As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Divide (input, val)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IDivisionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Divide(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, T val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="val" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Divide&lt;T&gt; (T val, System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Divide&lt;(class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(!!T val, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Divide``1(``0,System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Divide(Of T As IDivisionOperators(Of T, T, T)) (val As T, input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Divide : 'T * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Divide (val, input)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IDivisionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Divide(T val, System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="val" Type="T" />
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="val">To be added.</param>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Divide&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Divide&lt;(class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Divide``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Divide(Of T As IDivisionOperators(Of T, T, T)) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Divide : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Divide (left, right, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IDivisionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Divide(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Divides each element of <paramref name="x" /> by its corresponding element in <paramref name="y" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Divide&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, T val, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Divide&lt;(class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, !!T val, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Divide``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Divide(Of T As IDivisionOperators(Of T, T, T)) (ByRef input As ReadOnlyTensorSpan(Of T), val As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Divide : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Divide (input, val, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IDivisionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Divide(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, T val, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="val" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Divides each element of <paramref name="x" /> by <paramref name="y" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Divide&lt;T&gt; (T val, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Divide&lt;(class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(!!T val, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Divide``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Divide(Of T As IDivisionOperators(Of T, T, T)) (val As T, ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Divide : 'T * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Divide (val, input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IDivisionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Divide(T val, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="val" Type="T" />
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="val">To be added.</param>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Divides <paramref name="x" /> by each element of <paramref name="y" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dot&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Dot&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Dot&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Dot``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dot(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T), IMultiplicativeIdentity(Of T, T), IMultiplyOperators(Of T, T, T)}) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Dot : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Dot (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt; static T Dot(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>Computes the dot product of two tensors containing numbers.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dot&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Dot&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Dot&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Dot``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Dot(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T), IMultiplicativeIdentity(Of T, T), IMultiplyOperators(Of T, T, T)}) (left As Tensor(Of T), right As Tensor(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Dot : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Dot (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt; static T Dot(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ElementwiseEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;bool&gt; ElementwiseEqual&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;bool&gt; ElementwiseEqual&lt;(class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ElementwiseEqual``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ElementwiseEqual(Of T As IEqualityOperators(Of T, T, Boolean)) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member ElementwiseEqual : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;bool&gt; (requires 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.ElementwiseEqual (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IEqualityOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;bool&gt; ^ ElementwiseEqual(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ElementwiseEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;bool&gt; ElementwiseEqual&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right, in System.Numerics.Tensors.TensorSpan&lt;bool&gt; destination) where T : System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt; ElementwiseEqual&lt;(class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ElementwiseEqual``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{System.Boolean}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ElementwiseEqual(Of T As IEqualityOperators(Of T, T, Boolean)) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of Boolean)) As TensorSpan(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member ElementwiseEqual : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.ElementwiseEqual (left, right, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IEqualityOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ ElementwiseEqual(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right, System::Numerics::Tensors::TensorSpan&lt;bool&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Exp&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Exp&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Exp``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Exp(Of T As IExponentialFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Exp : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Exp input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Exp(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Exp&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Exp&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Exp``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Exp(Of T As IExponentialFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Exp : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Exp (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Exp(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise result of raising <c>e</c> to the single-precision floating-point number powers in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp10&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Exp10&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Exp10&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Exp10``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Exp10(Of T As IExponentialFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Exp10 : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Exp10 input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Exp10(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp10&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Exp10&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Exp10&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Exp10``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Exp10(Of T As IExponentialFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Exp10 : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Exp10 (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Exp10(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise result of raising 10 to the number powers in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp10M1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Exp10M1&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Exp10M1&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Exp10M1``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Exp10M1(Of T As IExponentialFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Exp10M1 : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Exp10M1 input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Exp10M1(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp10M1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Exp10M1&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Exp10M1&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Exp10M1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Exp10M1(Of T As IExponentialFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Exp10M1 : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Exp10M1 (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Exp10M1(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise result of raising 10 to the number powers in the specified tensor, minus one.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Exp2&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Exp2&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Exp2``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Exp2(Of T As IExponentialFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Exp2 : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Exp2 input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Exp2(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Exp2&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Exp2&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Exp2``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Exp2(Of T As IExponentialFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Exp2 : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Exp2 (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Exp2(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise result of raising 2 to the number powers in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp2M1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Exp2M1&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Exp2M1&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Exp2M1``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Exp2M1(Of T As IExponentialFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Exp2M1 : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Exp2M1 input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Exp2M1(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp2M1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Exp2M1&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Exp2M1&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Exp2M1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Exp2M1(Of T As IExponentialFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Exp2M1 : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Exp2M1 (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Exp2M1(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise result of raising 2 to the number powers in the specified tensor, minus one.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpM1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; ExpM1&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; ExpM1&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ExpM1``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ExpM1(Of T As IExponentialFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member ExpM1 : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.ExpM1 input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ ExpM1(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpM1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; ExpM1&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; ExpM1&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ExpM1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExpM1(Of T As IExponentialFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member ExpM1 : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.ExpM1 (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ ExpM1(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise result of raising <c>e</c> to the number powers in the specified tensor, minus 1.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FillGaussianNormalDistribution&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; FillGaussianNormalDistribution&lt;T&gt; (in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; FillGaussianNormalDistribution&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.FillGaussianNormalDistribution``1(System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function FillGaussianNormalDistribution(Of T As IFloatingPoint(Of T)) (ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member FillGaussianNormalDistribution : TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.FillGaussianNormalDistribution destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ FillGaussianNormalDistribution(System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FillUniformDistribution&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; FillUniformDistribution&lt;T&gt; (in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; FillUniformDistribution&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.FillUniformDistribution``1(System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function FillUniformDistribution(Of T As IFloatingPoint(Of T)) (ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member FillUniformDistribution : TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.FillUniformDistribution destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ FillUniformDistribution(System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilteredUpdate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; FilteredUpdate&lt;T&gt; (this in System.Numerics.Tensors.TensorSpan&lt;T&gt; tensor, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;bool&gt; filter, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; FilteredUpdate&lt;T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; tensor, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;bool&gt;&amp; filter, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.FilteredUpdate``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{System.Boolean}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FilteredUpdate(Of T) (ByRef tensor As TensorSpan(Of T), ByRef filter As ReadOnlyTensorSpan(Of Boolean), ByRef values As ReadOnlyTensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member FilteredUpdate : TensorSpan * ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.FilteredUpdate (tensor, filter, values)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::TensorSpan&lt;T&gt; FilteredUpdate(System::Numerics::Tensors::TensorSpan&lt;T&gt; % tensor, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;bool&gt; % filter, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="filter" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;System.Boolean&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="values" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">Input <see cref="T:System.Numerics.Tensors.Tensor`1" />.</param>
        <param name="filter">Input filter where if the index is <see langword="true" /> then it will update the <paramref name="tensor" />.</param>
        <param name="values">Values to update in the <paramref name="tensor" />.</param>
        <summary>Updates the <paramref name="tensor" /> tensor with the <paramref name="values" /> where the <paramref name="filter" /> is <see langword="true" />.
 If dimensions are not the same an exception is thrown.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilteredUpdate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; FilteredUpdate&lt;T&gt; (this in System.Numerics.Tensors.TensorSpan&lt;T&gt; tensor, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;bool&gt; filter, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; FilteredUpdate&lt;T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; tensor, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;bool&gt;&amp; filter, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.FilteredUpdate``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{System.Boolean}@,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FilteredUpdate(Of T) (ByRef tensor As TensorSpan(Of T), ByRef filter As ReadOnlyTensorSpan(Of Boolean), value As T) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member FilteredUpdate : TensorSpan * ReadOnlyTensorSpan * 'T -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.FilteredUpdate (tensor, filter, value)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::TensorSpan&lt;T&gt; FilteredUpdate(System::Numerics::Tensors::TensorSpan&lt;T&gt; % tensor, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;bool&gt; % filter, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="filter" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;System.Boolean&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="value" Type="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">Input <see cref="T:System.Numerics.Tensors.Tensor`1" />.</param>
        <param name="filter">Input filter where if the index is <see langword="true" /> then it will update the <paramref name="tensor" />.</param>
        <param name="value">Value to update in the <paramref name="tensor" />.</param>
        <summary>Updates the <paramref name="tensor" /> tensor with the <paramref name="value" /> where the <paramref name="filter" /> is <see langword="true" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Floor&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Floor&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Floor&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Floor``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Floor(Of T As IFloatingPoint(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Floor : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Floor input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Floor(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Floor&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Floor&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Floor&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Floor``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Floor(Of T As IFloatingPoint(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Floor : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Floor (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Floor(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise floor of numbers in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSmallestBroadcastableLengths">
      <MemberSignature Language="C#" Value="public static IntPtr[] GetSmallestBroadcastableLengths (ReadOnlySpan&lt;IntPtr&gt; shape1, ReadOnlySpan&lt;IntPtr&gt; shape2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int[] GetSmallestBroadcastableLengths(valuetype System.ReadOnlySpan`1&lt;native int&gt; shape1, valuetype System.ReadOnlySpan`1&lt;native int&gt; shape2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GetSmallestBroadcastableLengths(System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSmallestBroadcastableLengths (shape1 As ReadOnlySpan(Of IntPtr), shape2 As ReadOnlySpan(Of IntPtr)) As IntPtr()" />
      <MemberSignature Language="F#" Value="static member GetSmallestBroadcastableLengths : ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; nativeint[]" Usage="System.Numerics.Tensors.Tensor.GetSmallestBroadcastableLengths (shape1, shape2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;IntPtr&gt; ^ GetSmallestBroadcastableLengths(ReadOnlySpan&lt;IntPtr&gt; shape1, ReadOnlySpan&lt;IntPtr&gt; shape2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr[]</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="shape1" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;" />
        <Parameter Name="shape2" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;" />
      </Parameters>
      <Docs>
        <param name="shape1">To be added.</param>
        <param name="shape2">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;bool&gt; GreaterThan&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;bool&gt; GreaterThan&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThan``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThan(Of T As IComparisonOperators(Of T, T, Boolean)) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member GreaterThan : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;bool&gt; (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThan (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;bool&gt; ^ GreaterThan(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;bool&gt; GreaterThan&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, T right) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;bool&gt; GreaterThan&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, !!T right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThan``1(System.Numerics.Tensors.Tensor{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThan(Of T As IComparisonOperators(Of T, T, Boolean)) (left As Tensor(Of T), right As T) As Tensor(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member GreaterThan : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.Tensor&lt;bool&gt; (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThan (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;bool&gt; ^ GreaterThan(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, T right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool GreaterThanAll&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GreaterThanAll&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThanAll``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThanAll(Of T As IComparisonOperators(Of T, T, Boolean)) (left As Tensor(Of T), right As Tensor(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member GreaterThanAll : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThanAll (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool GreaterThanAll(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool GreaterThanAny&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GreaterThanAny&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThanAny``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThanAny(Of T As IComparisonOperators(Of T, T, Boolean)) (left As Tensor(Of T), right As Tensor(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member GreaterThanAny : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThanAny (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool GreaterThanAny(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Hypot&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Hypot&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Hypot&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Hypot``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Hypot(Of T As IRootFunctions(Of T)) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Hypot : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Hypot (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Hypot(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Hypot&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Hypot&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Hypot&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Hypot``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Hypot(Of T As IRootFunctions(Of T)) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Hypot : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Hypot (left, right, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Hypot(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise hypotenuse given values from two tensors representing the lengths of the shorter sides in a right-angled triangle.
 If the shapes are not the same they are broadcast to the smallest compatible shape.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ieee754Remainder&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Ieee754Remainder&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Ieee754Remainder&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Ieee754Remainder``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Ieee754Remainder(Of T As IFloatingPointIeee754(Of T)) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Ieee754Remainder : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Ieee754Remainder (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Ieee754Remainder(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ieee754Remainder&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Ieee754Remainder&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Ieee754Remainder&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Ieee754Remainder``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Ieee754Remainder(Of T As IFloatingPointIeee754(Of T)) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Ieee754Remainder : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Ieee754Remainder (left, right, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Ieee754Remainder(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise remainder of the numbers in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ILogB&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;int&gt; ILogB&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;int32&gt; ILogB&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ILogB``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ILogB(Of T As IFloatingPointIeee754(Of T)) (input As Tensor(Of T)) As Tensor(Of Integer)" />
      <MemberSignature Language="F#" Value="static member ILogB : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;int&gt; (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.ILogB input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;int&gt; ^ ILogB(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ILogB&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;int&gt; ILogB&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;int&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;int32&gt; ILogB&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;int32&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ILogB``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{System.Int32}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ILogB(Of T As IFloatingPointIeee754(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of Integer)) As TensorSpan(Of Integer)" />
      <MemberSignature Language="F#" Value="static member ILogB : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.ILogB (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ ILogB(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;int&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;System.Int32&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;System.Int32&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise integer logarithm of numbers in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMax&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfMax&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMax&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.IndexOfMax``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfMax(Of T As INumber(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMax : ReadOnlyTensorSpan -&gt; int (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.IndexOfMax input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static int IndexOfMax(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>Searches for the index of the largest number in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMax&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfMax&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMax&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.IndexOfMax``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfMax(Of T As INumber(Of T)) (input As Tensor(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMax : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.IndexOfMax input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static int IndexOfMax(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMaxMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfMaxMagnitude&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMaxMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.IndexOfMaxMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfMaxMagnitude(Of T As INumber(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMaxMagnitude : ReadOnlyTensorSpan -&gt; int (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.IndexOfMaxMagnitude input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static int IndexOfMaxMagnitude(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>Searches for the index of the number with the largest magnitude in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMaxMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfMaxMagnitude&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMaxMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.IndexOfMaxMagnitude``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfMaxMagnitude(Of T As INumber(Of T)) (input As Tensor(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMaxMagnitude : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.IndexOfMaxMagnitude input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static int IndexOfMaxMagnitude(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfMin&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMin&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.IndexOfMin``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfMin(Of T As INumber(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMin : ReadOnlyTensorSpan -&gt; int (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.IndexOfMin input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static int IndexOfMin(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>Searches for the index of the smallest number in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfMin&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMin&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.IndexOfMin``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfMin(Of T As INumber(Of T)) (input As Tensor(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMin : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.IndexOfMin input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static int IndexOfMin(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMinMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfMinMagnitude&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMinMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.IndexOfMinMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfMinMagnitude(Of T As INumber(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMinMagnitude : ReadOnlyTensorSpan -&gt; int (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.IndexOfMinMagnitude input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static int IndexOfMinMagnitude(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>Searches for the index of the number with the smallest magnitude in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMinMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfMinMagnitude&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMinMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.IndexOfMinMagnitude``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfMinMagnitude(Of T As INumber(Of T)) (input As Tensor(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMinMagnitude : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.IndexOfMinMagnitude input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static int IndexOfMinMagnitude(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeadingZeroCount&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; LeadingZeroCount&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; LeadingZeroCount&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LeadingZeroCount``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function LeadingZeroCount(Of T As IBinaryInteger(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member LeadingZeroCount : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.LeadingZeroCount input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ LeadingZeroCount(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeadingZeroCount&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; LeadingZeroCount&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; LeadingZeroCount&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LeadingZeroCount``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function LeadingZeroCount(Of T As IBinaryInteger(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member LeadingZeroCount : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.LeadingZeroCount (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ LeadingZeroCount(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise leading zero count of numbers in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;bool&gt; LessThan&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;bool&gt; LessThan&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThan``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThan(Of T As IComparisonOperators(Of T, T, Boolean)) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member LessThan : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;bool&gt; (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThan (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;bool&gt; ^ LessThan(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;bool&gt; LessThan&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, T right) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;bool&gt; LessThan&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, !!T right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThan``1(System.Numerics.Tensors.Tensor{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThan(Of T As IComparisonOperators(Of T, T, Boolean)) (left As Tensor(Of T), right As T) As Tensor(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member LessThan : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.Tensor&lt;bool&gt; (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThan (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;bool&gt; ^ LessThan(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, T right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool LessThanAll&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool LessThanAll&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThanAll``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThanAll(Of T As IComparisonOperators(Of T, T, Boolean)) (left As Tensor(Of T), right As Tensor(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member LessThanAll : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThanAll (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool LessThanAll(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool LessThanAny&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool LessThanAny&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThanAny``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThanAny(Of T As IComparisonOperators(Of T, T, Boolean)) (left As Tensor(Of T), right As Tensor(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member LessThanAny : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThanAny (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool LessThanAny(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Log&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Log&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Log(Of T As ILogarithmicFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Log(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Log&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Log&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Log(Of T As ILogarithmicFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Log : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Log(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Takes the natural logarithm of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Log10&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Log10&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log10``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Log10(Of T As ILogarithmicFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log10 input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Log10(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Log10&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Log10&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log10``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Log10(Of T As ILogarithmicFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Log10 : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log10 (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Log10(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Takes the base 10 logarithm of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10P1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Log10P1&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Log10P1&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log10P1``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Log10P1(Of T As ILogarithmicFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Log10P1 : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log10P1 input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Log10P1(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10P1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Log10P1&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Log10P1&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log10P1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Log10P1(Of T As ILogarithmicFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Log10P1 : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log10P1 (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Log10P1(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Takes the base 10 logarithm plus 1 of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Log2&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Log2&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log2``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Log2(Of T As ILogarithmicFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Log2 : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log2 input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Log2(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Log2&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Log2&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log2``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Log2(Of T As ILogarithmicFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Log2 : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log2 (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Log2(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Takes the base 2 logarithm of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log2P1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Log2P1&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Log2P1&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log2P1``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Log2P1(Of T As ILogarithmicFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Log2P1 : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log2P1 input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Log2P1(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log2P1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Log2P1&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Log2P1&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log2P1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Log2P1(Of T As ILogarithmicFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Log2P1 : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log2P1 (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Log2P1(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Takes the base 2 logarithm plus 1 of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogP1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; LogP1&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; LogP1&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LogP1``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function LogP1(Of T As ILogarithmicFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member LogP1 : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.LogP1 input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ LogP1(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogP1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; LogP1&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; LogP1&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LogP1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function LogP1(Of T As ILogarithmicFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member LogP1 : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.LogP1 (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ LogP1(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Takes the natural logarithm plus 1 of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Max&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Max&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Max``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Max(Of T As INumber(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Max : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Max input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T Max(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>Searches for the largest number in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Max&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Max&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Max``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Max(Of T As INumber(Of T)) (input As Tensor(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Max : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Max input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T Max(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MaxMagnitude&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MaxMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MaxMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MaxMagnitude(Of T As INumber(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MaxMagnitude input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T MaxMagnitude(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>Searches for the number with the largest magnitude in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MaxMagnitude&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MaxMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MaxMagnitude``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function MaxMagnitude(Of T As INumber(Of T)) (input As Tensor(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MaxMagnitude input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T MaxMagnitude(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MaxNumber&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MaxNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MaxNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MaxNumber(Of T As INumber(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MaxNumber : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MaxNumber input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T MaxNumber(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>Searches for the largest number in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MaxNumber&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MaxNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MaxNumber``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function MaxNumber(Of T As INumber(Of T)) (input As Tensor(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MaxNumber : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MaxNumber input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T MaxNumber(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Mean&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Mean&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Mean&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Mean``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Mean(Of T As IFloatingPoint(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Mean : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Mean input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static T Mean(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Min&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Min&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Min``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Min(Of T As INumber(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Min : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Min input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T Min(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>Searches for the smallest number in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Min&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Min&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Min``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Min(Of T As INumber(Of T)) (input As Tensor(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Min : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Min input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T Min(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MinMagnitude&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MinMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MinMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MinMagnitude(Of T As INumber(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MinMagnitude input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T MinMagnitude(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>Searches for the number with the smallest magnitude in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MinMagnitude&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MinMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MinMagnitude``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function MinMagnitude(Of T As INumber(Of T)) (input As Tensor(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MinMagnitude input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T MinMagnitude(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MinNumber&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MinNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MinNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MinNumber(Of T As INumber(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MinNumber : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MinNumber input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T MinNumber(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>Searches for the smallest number in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MinNumber&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MinNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MinNumber``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function MinNumber(Of T As INumber(Of T)) (input As Tensor(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MinNumber : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MinNumber input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T MinNumber(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiply&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Multiply&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Multiply&lt;(class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Multiply``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Multiply(Of T As {IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Multiply (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Multiply(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiply&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Multiply&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input, T val) where T : System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Multiply&lt;(class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, !!T val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Multiply``1(System.Numerics.Tensors.Tensor{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Multiply(Of T As {IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (input As Tensor(Of T), val As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Multiply (input, val)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Multiply(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, T val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="val" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiply&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Multiply&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Multiply&lt;(class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Multiply``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Multiply(Of T As {IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Multiply : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Multiply (left, right, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Multiply(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Multiplies each element of <paramref name="x" /> with <paramref name="y" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
 If the shapes are not the same they are broadcast to the smallest compatible shape.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiply&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Multiply&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, T val, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Multiply&lt;(class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, !!T val, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Multiply``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Multiply(Of T As {IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (ByRef input As ReadOnlyTensorSpan(Of T), val As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Multiply : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Multiply (input, val, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Multiply(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, T val, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="val" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Multiplies each element of <paramref name="x" /> with <paramref name="y" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Negate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Negate&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IUnaryNegationOperators&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Negate&lt;(class System.Numerics.IUnaryNegationOperators`2&lt;!!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Negate``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Negate(Of T As IUnaryNegationOperators(Of T, T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IUnaryNegationOperators&lt;'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IUnaryNegationOperators&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IUnaryNegationOperators&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Negate input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IUnaryNegationOperators&lt;T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Negate(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IUnaryNegationOperators&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Negate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Negate&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IUnaryNegationOperators&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Negate&lt;(class System.Numerics.IUnaryNegationOperators`2&lt;!!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Negate``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Negate(Of T As IUnaryNegationOperators(Of T, T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Negate : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IUnaryNegationOperators&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Negate (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IUnaryNegationOperators&lt;T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Negate(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IUnaryNegationOperators&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise negation of each number in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Norm&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Norm&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Norm&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Norm``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Norm(Of T As IRootFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Norm : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Norm input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static T Norm(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>Takes the norm of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Norm&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Norm&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Norm&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Norm``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Norm(Of T As IRootFunctions(Of T)) (input As Tensor(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Norm : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Norm input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static T Norm(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnesComplement&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; OnesComplement&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; OnesComplement&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.OnesComplement``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function OnesComplement(Of T As IBitwiseOperators(Of T, T, T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member OnesComplement : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.OnesComplement input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ OnesComplement(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnesComplement&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; OnesComplement&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; OnesComplement&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.OnesComplement``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function OnesComplement(Of T As IBitwiseOperators(Of T, T, T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member OnesComplement : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.OnesComplement (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ OnesComplement(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise one's complement of numbers in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Permute&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Permute&lt;T&gt; (this System.Numerics.Tensors.Tensor&lt;T&gt; input, scoped ReadOnlySpan&lt;int&gt; axis);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Permute&lt;T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, valuetype System.ReadOnlySpan`1&lt;int32&gt; axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Permute``1(System.Numerics.Tensors.Tensor{``0},System.ReadOnlySpan{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Permute(Of T) (input As Tensor(Of T), axis As ReadOnlySpan(Of Integer)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Permute : System.Numerics.Tensors.Tensor&lt;'T&gt; * ReadOnlySpan&lt;int&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Permute (input, axis)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Permute(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, ReadOnlySpan&lt;int&gt; axis);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" RefType="this" />
        <Parameter Name="axis" Type="System.ReadOnlySpan&lt;System.Int32&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PopCount&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; PopCount&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; PopCount&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.PopCount``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function PopCount(Of T As IBinaryInteger(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member PopCount : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.PopCount input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ PopCount(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PopCount&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; PopCount&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; PopCount&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.PopCount``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function PopCount(Of T As IBinaryInteger(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member PopCount : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.PopCount (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ PopCount(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise population count of numbers in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Pow&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IPowerFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Pow&lt;(class System.Numerics.IPowerFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Pow``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Pow(Of T As IPowerFunctions(Of T)) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Pow (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IPowerFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Pow(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IPowerFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Pow&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IPowerFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Pow&lt;(class System.Numerics.IPowerFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Pow``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Pow(Of T As IPowerFunctions(Of T)) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Pow : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Pow (left, right, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IPowerFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Pow(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IPowerFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise power of a number in a specified tensor raised to a number in another specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Product&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Product&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input) where T : System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Product&lt;(class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Product``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Product(Of T As {IMultiplicativeIdentity(Of T, T), IMultiplyOperators(Of T, T, T)}) (ByRef input As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Product : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Product input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IMultiplicativeIdentity&lt;T, T&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt; static T Product(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>Computes the product of all elements in the specified non-empty tensor of numbers.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Product&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Product&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Product&lt;(class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Product``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Product(Of T As {IMultiplicativeIdentity(Of T, T), IMultiplyOperators(Of T, T, T)}) (input As Tensor(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Product : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Product input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IMultiplicativeIdentity&lt;T, T&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt; static T Product(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RadiansToDegrees&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; RadiansToDegrees&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; RadiansToDegrees&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.RadiansToDegrees``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RadiansToDegrees(Of T As ITrigonometricFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member RadiansToDegrees : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.RadiansToDegrees input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ RadiansToDegrees(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RadiansToDegrees&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; RadiansToDegrees&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; RadiansToDegrees&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.RadiansToDegrees``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function RadiansToDegrees(Of T As ITrigonometricFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member RadiansToDegrees : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.RadiansToDegrees (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ RadiansToDegrees(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise conversion of each number of radians in the specified tensor to degrees.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reciprocal&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Reciprocal&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Reciprocal&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Reciprocal``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Reciprocal(Of T As IFloatingPoint(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Reciprocal : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Reciprocal input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Reciprocal(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reciprocal&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Reciprocal&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Reciprocal&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Reciprocal``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Reciprocal(Of T As IFloatingPoint(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Reciprocal : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Reciprocal (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Reciprocal(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise reciprocal of numbers in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reshape&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; Reshape&lt;T&gt; (this in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, scoped ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt; Reshape&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Reshape``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Reshape(Of T) (ByRef input As ReadOnlyTensorSpan(Of T), lengths As ReadOnlySpan(Of IntPtr)) As ReadOnlyTensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Reshape : ReadOnlyTensorSpan * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Reshape (input, lengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; Reshape(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="lengths">
          <see cref="T:System.ReadOnlySpan`1" /> with the new dimensions.</param>
        <summary>Reshapes the <paramref name="tensor" /> tensor to the specified <paramref name="lengths" />. If one of the lengths is -1, it will be calculated automatically.
 Does not change the length of the underlying memory nor does it allocate new memory. If the new shape is not compatible with the old shape, an exception is thrown.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reshape&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Reshape&lt;T&gt; (this System.Numerics.Tensors.Tensor&lt;T&gt; input, scoped ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Reshape&lt;T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Reshape``1(System.Numerics.Tensors.Tensor{``0},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Reshape(Of T) (input As Tensor(Of T), lengths As ReadOnlySpan(Of IntPtr)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Reshape : System.Numerics.Tensors.Tensor&lt;'T&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Reshape (input, lengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Reshape(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" RefType="this" />
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="lengths">
          <see cref="T:System.ReadOnlySpan`1" /> with the new dimensions.</param>
        <summary>Reshapes the <paramref name="tensor" /> tensor to the specified <paramref name="lengths" />. If one of the lengths is -1, it will be calculated automatically.
 Does not change the length of the underlying memory nor does it allocate new memory. If the new shape is not compatible with the old shape, an exception is thrown.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reshape&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Reshape&lt;T&gt; (this in System.Numerics.Tensors.TensorSpan&lt;T&gt; input, scoped ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Reshape&lt;T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; input, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Reshape``1(System.Numerics.Tensors.TensorSpan{``0}@,System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Reshape(Of T) (ByRef input As TensorSpan(Of T), lengths As ReadOnlySpan(Of IntPtr)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Reshape : TensorSpan * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Reshape (input, lengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::TensorSpan&lt;T&gt; Reshape(System::Numerics::Tensors::TensorSpan&lt;T&gt; % input, ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="lengths">
          <see cref="T:System.ReadOnlySpan`1" /> with the new dimensions.</param>
        <summary>Reshapes the <paramref name="tensor" /> tensor to the specified <paramref name="lengths" />. If one of the lengths is -1, it will be calculated automatically.
 Does not change the length of the underlying memory nor does it allocate new memory. If the new shape is not compatible with the old shape, an exception is thrown.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Resize&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Resize&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Resize``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Resize(Of T) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Resize : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan" Usage="System.Numerics.Tensors.Tensor.Resize (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Resize(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Resize&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input, ReadOnlySpan&lt;IntPtr&gt; shape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Resize&lt;T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, valuetype System.ReadOnlySpan`1&lt;native int&gt; shape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Resize``1(System.Numerics.Tensors.Tensor{``0},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function Resize(Of T) (input As Tensor(Of T), shape As ReadOnlySpan(Of IntPtr)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Resize : System.Numerics.Tensors.Tensor&lt;'T&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Resize (input, shape)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Resize(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, ReadOnlySpan&lt;IntPtr&gt; shape);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="shape" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="shape">To be added.</param>
        <summary>Creates a new <see cref="T:System.Numerics.Tensors.Tensor`1" />, allocates new memory, and copies the data from <paramref name="tensor" />. If the final shape is smaller all data after that point is ignored.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Reverse&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, IntPtr axis = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Reverse&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, native int axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Reverse``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Function Reverse(Of T) (ByRef input As ReadOnlyTensorSpan(Of T), Optional axis As IntPtr = -1) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Reverse : ReadOnlyTensorSpan * nativeint -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Reverse (input, axis)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="axis" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Reverse&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination, IntPtr axis = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Reverse&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination, native int axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Reverse``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Function Reverse(Of T) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T), Optional axis As IntPtr = -1) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Reverse : ReadOnlyTensorSpan * TensorSpan * nativeint -&gt; TensorSpan" Usage="System.Numerics.Tensors.Tensor.Reverse (input, destination, axis)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="axis" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Round&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Round&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Round&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Round``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Round(Of T As IFloatingPoint(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Round : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Round input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Round(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Round&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Round&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Round&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Round``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Round(Of T As IFloatingPoint(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Round : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Round (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Round(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise rounding of the numbers in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;T&gt; (this scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; span, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; span, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SequenceEqual``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of T) (ByRef span As ReadOnlyTensorSpan(Of T), ByRef other As ReadOnlyTensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; bool" Usage="System.Numerics.Tensors.Tensor.SequenceEqual (span, other)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % span, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="other" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="span">To be added.</param>
        <param name="other">To be added.</param>
        <summary>Determines whether two sequences are equal by comparing the elements using IEquatable{T}.Equals(T).</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSlice&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; SetSlice&lt;T&gt; (this System.Numerics.Tensors.Tensor&lt;T&gt; tensor, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; values, scoped ReadOnlySpan&lt;System.Buffers.NRange&gt; ranges);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; SetSlice&lt;T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; tensor, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; values, valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NRange&gt; ranges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SetSlice``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.ReadOnlySpan{System.Buffers.NRange})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SetSlice(Of T) (tensor As Tensor(Of T), ByRef values As ReadOnlyTensorSpan(Of T), ranges As ReadOnlySpan(Of NRange)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member SetSlice : System.Numerics.Tensors.Tensor&lt;'T&gt; * ReadOnlyTensorSpan * ReadOnlySpan&lt;System.Buffers.NRange&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.SetSlice (tensor, values, ranges)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ SetSlice(System::Numerics::Tensors::Tensor&lt;T&gt; ^ tensor, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % values, ReadOnlySpan&lt;System::Buffers::NRange&gt; ranges);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" RefType="this" />
        <Parameter Name="values" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="ranges" Type="System.ReadOnlySpan&lt;System.Buffers.NRange&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">Input <see cref="T:System.Numerics.Tensors.Tensor`1" />.</param>
        <param name="values">The values you want to set in the <paramref name="tensor" />.</param>
        <param name="ranges">The ranges you want to set.</param>
        <summary>Sets a slice of the given <paramref name="tensor" /> with the provided <paramref name="values" /> for the given <paramref name="ranges" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSlice&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; SetSlice&lt;T&gt; (this in System.Numerics.Tensors.TensorSpan&lt;T&gt; tensor, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; values, scoped ReadOnlySpan&lt;System.Buffers.NRange&gt; ranges);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; SetSlice&lt;T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; tensor, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; values, valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NRange&gt; ranges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SetSlice``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.ReadOnlySpan{System.Buffers.NRange})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SetSlice(Of T) (ByRef tensor As TensorSpan(Of T), ByRef values As ReadOnlyTensorSpan(Of T), ranges As ReadOnlySpan(Of NRange)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member SetSlice : TensorSpan * ReadOnlyTensorSpan * ReadOnlySpan&lt;System.Buffers.NRange&gt; -&gt; TensorSpan" Usage="System.Numerics.Tensors.Tensor.SetSlice (tensor, values, ranges)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ SetSlice(System::Numerics::Tensors::TensorSpan&lt;T&gt; % tensor, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % values, ReadOnlySpan&lt;System::Buffers::NRange&gt; ranges);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="values" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="ranges" Type="System.ReadOnlySpan&lt;System.Buffers.NRange&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">Input <see cref="T:System.Numerics.Tensors.Tensor`1" />.</param>
        <param name="values">The values you want to set in the <paramref name="tensor" />.</param>
        <param name="ranges">The ranges you want to set.</param>
        <summary>Sets a slice of the given <paramref name="tensor" /> with the provided <paramref name="values" /> for the given <paramref name="ranges" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sigmoid&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Sigmoid&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Sigmoid&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sigmoid``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Sigmoid(Of T As IExponentialFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Sigmoid : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sigmoid input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Sigmoid(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sigmoid&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Sigmoid&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Sigmoid&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sigmoid``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Sigmoid(Of T As IExponentialFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Sigmoid : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sigmoid (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Sigmoid(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise sigmoid function on the specified non-empty tensor of numbers.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Sin&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Sin&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sin``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Sin(Of T As ITrigonometricFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Sin : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sin input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Sin(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Sin&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Sin&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sin``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Sin(Of T As ITrigonometricFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Sin : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sin (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Sin(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Takes the sin of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sinh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Sinh&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Sinh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sinh``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Sinh(Of T As IHyperbolicFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Sinh : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sinh input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Sinh(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sinh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Sinh&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Sinh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sinh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Sinh(Of T As IHyperbolicFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Sinh : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sinh (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Sinh(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise hyperbolic sine of each radian angle in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SinPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; SinPi&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; SinPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SinPi``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SinPi(Of T As ITrigonometricFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member SinPi : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.SinPi input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ SinPi(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SinPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; SinPi&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; SinPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SinPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function SinPi(Of T As ITrigonometricFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member SinPi : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.SinPi (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ SinPi(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise sine of the value in the specified tensor that has been multiplied by Pi.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SoftMax&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; SoftMax&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; SoftMax&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SoftMax``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SoftMax(Of T As IExponentialFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member SoftMax : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.SoftMax input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ SoftMax(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SoftMax&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; SoftMax&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; SoftMax&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SoftMax``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function SoftMax(Of T As IExponentialFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member SoftMax : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.SoftMax (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ SoftMax(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the softmax function over the specified non-empty tensor of numbers.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt;[] Split&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, IntPtr numSplits, IntPtr axis);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt;[] Split&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, native int numSplits, native int axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Split``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split(Of T) (ByRef input As ReadOnlyTensorSpan(Of T), numSplits As IntPtr, axis As IntPtr) As Tensor(Of T)()" />
      <MemberSignature Language="F#" Value="static member Split : ReadOnlyTensorSpan * nativeint * nativeint -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;[]" Usage="System.Numerics.Tensors.Tensor.Split (input, numSplits, axis)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;System::Numerics::Tensors::Tensor&lt;T&gt; ^&gt; ^ Split(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, IntPtr numSplits, IntPtr axis);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="numSplits" Type="System.IntPtr" />
        <Parameter Name="axis" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="numSplits">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sqrt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Sqrt&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Sqrt&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sqrt``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Sqrt(Of T As IRootFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Sqrt : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sqrt input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Sqrt(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sqrt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Sqrt&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Sqrt&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sqrt``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Sqrt(Of T As IRootFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Sqrt : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sqrt (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Sqrt(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Takes the square root of each element of the <paramref name="x" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Squeeze&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; Squeeze&lt;T&gt; (this in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, int axis = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt; Squeeze&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, int32 axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Squeeze``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Squeeze(Of T) (ByRef input As ReadOnlyTensorSpan(Of T), Optional axis As Integer = -1) As ReadOnlyTensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Squeeze : ReadOnlyTensorSpan * int -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Squeeze (input, axis)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="axis" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Squeeze&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Squeeze&lt;T&gt; (this System.Numerics.Tensors.Tensor&lt;T&gt; input, int axis = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Squeeze&lt;T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, int32 axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Squeeze``1(System.Numerics.Tensors.Tensor{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Squeeze(Of T) (input As Tensor(Of T), Optional axis As Integer = -1) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Squeeze : System.Numerics.Tensors.Tensor&lt;'T&gt; * int -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Squeeze (input, axis)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" RefType="this" />
        <Parameter Name="axis" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Squeeze&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Squeeze&lt;T&gt; (this in System.Numerics.Tensors.TensorSpan&lt;T&gt; input, int axis = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Squeeze&lt;T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; input, int32 axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Squeeze``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Squeeze(Of T) (ByRef input As TensorSpan(Of T), Optional axis As Integer = -1) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Squeeze : TensorSpan * int -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Squeeze (input, axis)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="axis" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Stack&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Stack&lt;T&gt; (ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;T&gt;&gt; input, int axis = 0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Stack&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;class System.Numerics.Tensors.Tensor`1&lt;!!T&gt;&gt; input, int32 axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Stack``1(System.ReadOnlySpan{System.Numerics.Tensors.Tensor{``0}},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Stack(Of T) (input As ReadOnlySpan(Of Tensor(Of T)), Optional axis As Integer = 0) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Stack : ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;'T&gt;&gt; * int -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Stack (input, axis)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;T&gt;&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="axis" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StdDev&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T StdDev&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input) where T : System.Numerics.IFloatingPoint&lt;T&gt;, System.Numerics.IPowerFunctions&lt;T&gt;, System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T StdDev&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;, class System.Numerics.IPowerFunctions`1&lt;!!T&gt;, class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.StdDev``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function StdDev(Of T As {IFloatingPoint(Of T), IPowerFunctions(Of T), IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (ByRef input As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member StdDev : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt; and 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.StdDev input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt;, System::Numerics::IPowerFunctions&lt;T&gt;, System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static T StdDev(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IPowerFunctions&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>Returns the standard deviation of the elements in the <paramref name="x" /> tensor.</summary>
        <returns>
          <typeparamref name="T" /> representing the standard deviation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Subtract&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Subtract&lt;(class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Subtract``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract(Of T As ISubtractionOperators(Of T, T, T)) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Subtract (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Subtract(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Subtract&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input, T val) where T : System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Subtract&lt;(class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, !!T val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Subtract``1(System.Numerics.Tensors.Tensor{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract(Of T As ISubtractionOperators(Of T, T, T)) (input As Tensor(Of T), val As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Subtract (input, val)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Subtract(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, T val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="val" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Subtract&lt;T&gt; (T val, System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Subtract&lt;(class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(!!T val, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Subtract``1(``0,System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract(Of T As ISubtractionOperators(Of T, T, T)) (val As T, input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Subtract : 'T * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Subtract (val, input)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Subtract(T val, System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="val" Type="T" />
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="val">To be added.</param>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Subtract&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Subtract&lt;(class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Subtract``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract(Of T As ISubtractionOperators(Of T, T, T)) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Subtract : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Subtract (left, right, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Subtract(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Subtracts each element of <paramref name="x" /> from <paramref name="y" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Subtract&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, T val, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Subtract&lt;(class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, !!T val, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Subtract``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract(Of T As ISubtractionOperators(Of T, T, T)) (ByRef input As ReadOnlyTensorSpan(Of T), val As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Subtract : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Subtract (input, val, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Subtract(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, T val, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="val" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Subtracts <paramref name="y" /> from each element of <paramref name="x" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Subtract&lt;T&gt; (T val, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Subtract&lt;(class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(!!T val, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Subtract``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract(Of T As ISubtractionOperators(Of T, T, T)) (val As T, ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Subtract : 'T * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Subtract (val, input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Subtract(T val, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="val" Type="T" />
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="val">To be added.</param>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Subtracts each element of <paramref name="y" /> from <paramref name="x" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Sum&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Sum&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sum``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Sum(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (ByRef input As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Sum : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sum input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static T Sum(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>Sums the elements of the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Sum&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Sum&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sum``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Sum(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (input As Tensor(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Sum : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sum input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static T Sum(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Tan&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Tan&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Tan``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Tan(Of T As ITrigonometricFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Tan : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Tan input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Tan(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Tan&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Tan&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Tan``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Tan(Of T As ITrigonometricFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Tan : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Tan (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Tan(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise tangent of the value in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tanh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Tanh&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Tanh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Tanh``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Tanh(Of T As IHyperbolicFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Tanh : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Tanh input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Tanh(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tanh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Tanh&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Tanh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Tanh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Tanh(Of T As IHyperbolicFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Tanh : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Tanh (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Tanh(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise hyperbolic tangent of each radian angle in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TanPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; TanPi&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; TanPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.TanPi``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TanPi(Of T As ITrigonometricFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member TanPi : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.TanPi input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ TanPi(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TanPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; TanPi&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; TanPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.TanPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TanPi(Of T As ITrigonometricFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member TanPi : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.TanPi (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ TanPi(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise tangent of the value in the specified tensor that has been multiplied by Pi.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string ToString&lt;T&gt; (this in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; span, scoped ReadOnlySpan&lt;IntPtr&gt; maximumLengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; span, valuetype System.ReadOnlySpan`1&lt;native int&gt; maximumLengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ToString``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToString(Of T) (ByRef span As ReadOnlyTensorSpan(Of T), maximumLengths As ReadOnlySpan(Of IntPtr)) As String" />
      <MemberSignature Language="F#" Value="static member ToString : ReadOnlyTensorSpan * ReadOnlySpan&lt;nativeint&gt; -&gt; string" Usage="System.Numerics.Tensors.Tensor.ToString (span, maximumLengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::String ^ ToString(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % span, ReadOnlySpan&lt;IntPtr&gt; maximumLengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="maximumLengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="span">To be added.</param>
        <param name="maximumLengths">The maximum length of each dimension.</param>
        <summary>Creates a <see cref="T:System.String" /> representation of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string ToString&lt;T&gt; (this in System.Numerics.Tensors.TensorSpan&lt;T&gt; span, scoped ReadOnlySpan&lt;IntPtr&gt; maximumLengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString&lt;T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; span, valuetype System.ReadOnlySpan`1&lt;native int&gt; maximumLengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ToString``1(System.Numerics.Tensors.TensorSpan{``0}@,System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToString(Of T) (ByRef span As TensorSpan(Of T), maximumLengths As ReadOnlySpan(Of IntPtr)) As String" />
      <MemberSignature Language="F#" Value="static member ToString : TensorSpan * ReadOnlySpan&lt;nativeint&gt; -&gt; string" Usage="System.Numerics.Tensors.Tensor.ToString (span, maximumLengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::String ^ ToString(System::Numerics::Tensors::TensorSpan&lt;T&gt; % span, ReadOnlySpan&lt;IntPtr&gt; maximumLengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="maximumLengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="span">To be added.</param>
        <param name="maximumLengths">To be added.</param>
        <summary>Creates a <see cref="T:System.String" /> representation of the <see cref="T:System.Numerics.Tensors.TensorSpan`1" />.</summary>
        <returns>A <see cref="T:System.String" /> representation of the <paramref name="tensor" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrailingZeroCount&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; TrailingZeroCount&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; TrailingZeroCount&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.TrailingZeroCount``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TrailingZeroCount(Of T As IBinaryInteger(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member TrailingZeroCount : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.TrailingZeroCount input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ TrailingZeroCount(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrailingZeroCount&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; TrailingZeroCount&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; TrailingZeroCount&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.TrailingZeroCount``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrailingZeroCount(Of T As IBinaryInteger(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member TrailingZeroCount : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.TrailingZeroCount (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ TrailingZeroCount(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise trailing zero count of numbers in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Transpose&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Transpose&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Transpose&lt;T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Transpose``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Transpose(Of T) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Transpose : System.Numerics.Tensors.Tensor&lt;'T&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Transpose input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Transpose(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>Swaps the last two dimensions of the <paramref name="tensor" /> tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Truncate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Truncate&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Truncate&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Truncate``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Truncate(Of T As IFloatingPoint(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Truncate : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Truncate input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Truncate(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Truncate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Truncate&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Truncate&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Truncate``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Truncate(Of T As IFloatingPoint(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Truncate : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Truncate (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Truncate(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise truncation of numbers in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryBroadcastTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryBroadcastTo&lt;T&gt; (this in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryBroadcastTo&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.TryBroadcastTo``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TryBroadcastTo(Of T) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryBroadcastTo : ReadOnlyTensorSpan * TensorSpan -&gt; bool" Usage="System.Numerics.Tensors.Tensor.TryBroadcastTo (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryBroadcastTo(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">Destination <see cref="T:System.Numerics.Tensors.TensorSpan`1" />.</param>
        <summary>Broadcasts the data from <paramref name="tensor" /> to the smallest broadcastable shape compatible with <paramref name="destination" /> and stores it in <paramref name="destination" />.</summary>
        <returns>
          <see langword="false" /> if the shapes are not compatible, otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryBroadcastTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryBroadcastTo&lt;T&gt; (this System.Numerics.Tensors.Tensor&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryBroadcastTo&lt;T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.TryBroadcastTo``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TryBroadcastTo(Of T) (input As Tensor(Of T), ByRef destination As TensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryBroadcastTo : System.Numerics.Tensors.Tensor&lt;'T&gt; * TensorSpan -&gt; bool" Usage="System.Numerics.Tensors.Tensor.TryBroadcastTo (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryBroadcastTo(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" RefType="this" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">Destination <see cref="T:System.Numerics.Tensors.TensorSpan`1" />.</param>
        <summary>Broadcasts the data from <paramref name="tensor" /> to the smallest broadcastable shape compatible with <paramref name="destination" /> and stores it in <paramref name="destination" />.</summary>
        <returns>
          <see langword="false" /> if the shapes are not compatible, otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryBroadcastTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryBroadcastTo&lt;T&gt; (this in System.Numerics.Tensors.TensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryBroadcastTo&lt;T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.TryBroadcastTo``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TryBroadcastTo(Of T) (ByRef input As TensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryBroadcastTo : TensorSpan * TensorSpan -&gt; bool" Usage="System.Numerics.Tensors.Tensor.TryBroadcastTo (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryBroadcastTo(System::Numerics::Tensors::TensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">Destination <see cref="T:System.Numerics.Tensors.TensorSpan`1" />.</param>
        <summary>Broadcasts the data from <paramref name="tensor" /> to the smallest broadcastable shape compatible with <paramref name="destination" /> and stores it in <paramref name="destination" />.</summary>
        <returns>
          <see langword="false" /> if the shapes are not compatible, otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unsqueeze&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; Unsqueeze&lt;T&gt; (this in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, int axis);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt; Unsqueeze&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, int32 axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Unsqueeze``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Unsqueeze(Of T) (ByRef input As ReadOnlyTensorSpan(Of T), axis As Integer) As ReadOnlyTensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Unsqueeze : ReadOnlyTensorSpan * int -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Unsqueeze (input, axis)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; Unsqueeze(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, int axis);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="axis" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>Inserts a new dimension of length 1 that will appear at the dimension position.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unsqueeze&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Unsqueeze&lt;T&gt; (this System.Numerics.Tensors.Tensor&lt;T&gt; input, int axis);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Unsqueeze&lt;T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, int32 axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Unsqueeze``1(System.Numerics.Tensors.Tensor{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Unsqueeze(Of T) (input As Tensor(Of T), axis As Integer) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Unsqueeze : System.Numerics.Tensors.Tensor&lt;'T&gt; * int -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Unsqueeze (input, axis)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Unsqueeze(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, int axis);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" RefType="this" />
        <Parameter Name="axis" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>Inserts a new dimension of length 1 that will appear at the dimension position.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unsqueeze&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Unsqueeze&lt;T&gt; (this in System.Numerics.Tensors.TensorSpan&lt;T&gt; input, int axis);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Unsqueeze&lt;T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; input, int32 axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Unsqueeze``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Unsqueeze(Of T) (ByRef input As TensorSpan(Of T), axis As Integer) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Unsqueeze : TensorSpan * int -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Unsqueeze (input, axis)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::TensorSpan&lt;T&gt; Unsqueeze(System::Numerics::Tensors::TensorSpan&lt;T&gt; % input, int axis);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="axis" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>Inserts a new dimension of length 1 that will appear at the dimension position.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Xor&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Xor&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Xor``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Xor(Of T As IBitwiseOperators(Of T, T, T)) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Xor : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Xor (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Xor(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Xor&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Xor&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Xor``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Xor(Of T As IBitwiseOperators(Of T, T, T)) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Xor : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Xor (left, right, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Xor(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>Computes the element-wise XOR of numbers in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
