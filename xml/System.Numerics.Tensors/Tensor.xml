<Type Name="Tensor" FullName="System.Numerics.Tensors.Tensor">
  <TypeSignature Language="C#" Value="public static class Tensor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Tensor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Tensors.Tensor" />
  <TypeSignature Language="VB.NET" Value="Public Module Tensor" />
  <TypeSignature Language="F#" Value="type Tensor = class" />
  <TypeSignature Language="C++ CLI" Value="public ref class Tensor abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Numerics.Tensors</AssemblyName>
    <AssemblyVersion>9.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>To be added.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Abs&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Abs&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Abs&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Abs``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Abs(Of T As INumberBase(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Abs input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Abs(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Abs&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Abs&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Abs``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Abs(Of T As INumberBase(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Abs : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Abs (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Abs(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Acos&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Acos&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Acos&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Acos``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Acos(Of T As ITrigonometricFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Acos : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Acos input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Acos(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Acos&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Acos&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Acos&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Acos``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Acos(Of T As ITrigonometricFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Acos : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Acos (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Acos(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Acosh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Acosh&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Acosh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Acosh``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Acosh(Of T As IHyperbolicFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Acosh : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Acosh input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Acosh(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Acosh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Acosh&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Acosh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Acosh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Acosh(Of T As IHyperbolicFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Acosh : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Acosh (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Acosh(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcosPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; AcosPi&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; AcosPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.AcosPi``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AcosPi(Of T As ITrigonometricFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member AcosPi : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.AcosPi input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ AcosPi(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcosPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; AcosPi&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; AcosPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.AcosPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcosPi(Of T As ITrigonometricFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member AcosPi : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.AcosPi (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ AcosPi(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Add&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Add&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Add``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Add(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Add (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Add(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Add&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input, T val) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Add&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, !!T val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Add``1(System.Numerics.Tensors.Tensor{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (input As Tensor(Of T), val As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Add (input, val)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Add(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, T val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="val" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Add&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Add&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Add``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Add : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Add (left, right, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Add(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Add&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, T val, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Add&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, !!T val, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Add``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (ByRef input As ReadOnlyTensorSpan(Of T), val As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Add : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Add (input, val, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Add(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, T val, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="val" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Asin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Asin&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Asin&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Asin``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Asin(Of T As ITrigonometricFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Asin : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Asin input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Asin(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Asin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Asin&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Asin&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Asin``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Asin(Of T As ITrigonometricFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Asin : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Asin (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Asin(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Asinh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Asinh&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Asinh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Asinh``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Asinh(Of T As IHyperbolicFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Asinh : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Asinh input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Asinh(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Asinh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Asinh&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Asinh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Asinh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Asinh(Of T As IHyperbolicFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Asinh : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Asinh (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Asinh(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsinPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; AsinPi&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; AsinPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.AsinPi``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AsinPi(Of T As ITrigonometricFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member AsinPi : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.AsinPi input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ AsinPi(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsinPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; AsinPi&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; AsinPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.AsinPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function AsinPi(Of T As ITrigonometricFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member AsinPi : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.AsinPi (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ AsinPi(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsReadOnlyTensorSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; AsReadOnlyTensorSpan&lt;T&gt; (this T[]? array, scoped ReadOnlySpan&lt;IntPtr&gt; shape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt; AsReadOnlyTensorSpan&lt;T&gt;(!!T[] array, valuetype System.ReadOnlySpan`1&lt;native int&gt; shape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.AsReadOnlyTensorSpan``1(``0[],System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsReadOnlyTensorSpan(Of T) (array As T(), shape As ReadOnlySpan(Of IntPtr)) As ReadOnlyTensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member AsReadOnlyTensorSpan : 'T[] * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.AsReadOnlyTensorSpan (array, shape)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; AsReadOnlyTensorSpan(cli::array &lt;T&gt; ^ array, ReadOnlySpan&lt;IntPtr&gt; shape);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="shape" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="shape">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsTensorSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; AsTensorSpan&lt;T&gt; (this T[]? array, scoped ReadOnlySpan&lt;IntPtr&gt; shape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; AsTensorSpan&lt;T&gt;(!!T[] array, valuetype System.ReadOnlySpan`1&lt;native int&gt; shape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.AsTensorSpan``1(``0[],System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsTensorSpan(Of T) (array As T(), shape As ReadOnlySpan(Of IntPtr)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member AsTensorSpan : 'T[] * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.AsTensorSpan (array, shape)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::TensorSpan&lt;T&gt; AsTensorSpan(cli::array &lt;T&gt; ^ array, ReadOnlySpan&lt;IntPtr&gt; shape);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="shape" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="shape">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Atan&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Atan&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atan``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Atan(Of T As ITrigonometricFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Atan : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atan input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Atan(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Atan&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Atan&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atan``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Atan(Of T As ITrigonometricFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Atan : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atan (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Atan(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Atan2&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Atan2&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atan2``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Atan2(Of T As IFloatingPointIeee754(Of T)) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Atan2 : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atan2 (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Atan2(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Atan2&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Atan2&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atan2``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Atan2(Of T As IFloatingPointIeee754(Of T)) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Atan2 : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atan2 (left, right, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Atan2(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2Pi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Atan2Pi&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Atan2Pi&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atan2Pi``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Atan2Pi(Of T As IFloatingPointIeee754(Of T)) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Atan2Pi : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atan2Pi (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Atan2Pi(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2Pi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Atan2Pi&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Atan2Pi&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atan2Pi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Atan2Pi(Of T As IFloatingPointIeee754(Of T)) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Atan2Pi : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atan2Pi (left, right, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Atan2Pi(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atanh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Atanh&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Atanh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atanh``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Atanh(Of T As IHyperbolicFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Atanh : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atanh input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Atanh(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atanh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Atanh&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Atanh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atanh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Atanh(Of T As IHyperbolicFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Atanh : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atanh (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Atanh(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AtanPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; AtanPi&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; AtanPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.AtanPi``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AtanPi(Of T As ITrigonometricFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member AtanPi : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.AtanPi input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ AtanPi(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AtanPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; AtanPi&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; AtanPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.AtanPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function AtanPi(Of T As ITrigonometricFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member AtanPi : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.AtanPi (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ AtanPi(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BitwiseAnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; BitwiseAnd&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; BitwiseAnd&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.BitwiseAnd``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BitwiseAnd(Of T As IBitwiseOperators(Of T, T, T)) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member BitwiseAnd : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.BitwiseAnd (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ BitwiseAnd(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BitwiseAnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; BitwiseAnd&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; BitwiseAnd&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.BitwiseAnd``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function BitwiseAnd(Of T As IBitwiseOperators(Of T, T, T)) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member BitwiseAnd : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.BitwiseAnd (left, right, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ BitwiseAnd(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BitwiseOr&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; BitwiseOr&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; BitwiseOr&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.BitwiseOr``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function BitwiseOr(Of T As IBitwiseOperators(Of T, T, T)) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member BitwiseOr : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.BitwiseOr (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ BitwiseOr(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BitwiseOr&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; BitwiseOr&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; BitwiseOr&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.BitwiseOr``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function BitwiseOr(Of T As IBitwiseOperators(Of T, T, T)) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member BitwiseOr : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.BitwiseOr (left, right, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ BitwiseOr(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Broadcast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Broadcast&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; lengthsSource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Broadcast&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; lengthsSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Broadcast``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Broadcast(Of T) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef lengthsSource As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Broadcast : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Broadcast (input, lengthsSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Broadcast(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % lengthsSource);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="lengthsSource" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="lengthsSource">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Broadcast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Broadcast&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, scoped ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Broadcast&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Broadcast``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function Broadcast(Of T) (ByRef input As ReadOnlyTensorSpan(Of T), lengths As ReadOnlySpan(Of IntPtr)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Broadcast : ReadOnlyTensorSpan * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Broadcast (input, lengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Broadcast(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="lengths">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BroadcastTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void BroadcastTo&lt;T&gt; (this in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; source, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BroadcastTo&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; source, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.BroadcastTo``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub BroadcastTo(Of T) (ByRef source As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T))" />
      <MemberSignature Language="F#" Value="static member BroadcastTo : ReadOnlyTensorSpan * TensorSpan -&gt; unit" Usage="System.Numerics.Tensors.Tensor.BroadcastTo (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void BroadcastTo(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % source, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BroadcastTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void BroadcastTo&lt;T&gt; (this System.Numerics.Tensors.Tensor&lt;T&gt; source, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BroadcastTo&lt;T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; source, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.BroadcastTo``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub BroadcastTo(Of T) (source As Tensor(Of T), ByRef destination As TensorSpan(Of T))" />
      <MemberSignature Language="F#" Value="static member BroadcastTo : System.Numerics.Tensors.Tensor&lt;'T&gt; * TensorSpan -&gt; unit" Usage="System.Numerics.Tensors.Tensor.BroadcastTo (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void BroadcastTo(System::Numerics::Tensors::Tensor&lt;T&gt; ^ source, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" RefType="this" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BroadcastTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void BroadcastTo&lt;T&gt; (this in System.Numerics.Tensors.TensorSpan&lt;T&gt; source, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BroadcastTo&lt;T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; source, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.BroadcastTo``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub BroadcastTo(Of T) (ByRef source As TensorSpan(Of T), ByRef destination As TensorSpan(Of T))" />
      <MemberSignature Language="F#" Value="static member BroadcastTo : TensorSpan * TensorSpan -&gt; unit" Usage="System.Numerics.Tensors.Tensor.BroadcastTo (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void BroadcastTo(System::Numerics::Tensors::TensorSpan&lt;T&gt; % source, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cbrt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Cbrt&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Cbrt&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Cbrt``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Cbrt(Of T As IRootFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Cbrt : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Cbrt input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Cbrt(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cbrt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Cbrt&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Cbrt&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Cbrt``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Cbrt(Of T As IRootFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Cbrt : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Cbrt (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Cbrt(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceiling&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Ceiling&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Ceiling&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Ceiling``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Ceiling(Of T As IFloatingPoint(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Ceiling : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Ceiling input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Ceiling(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceiling&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Ceiling&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Ceiling&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Ceiling``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Ceiling(Of T As IFloatingPoint(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Ceiling : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Ceiling (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Ceiling(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concatenate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Concatenate&lt;T&gt; (scoped ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;T&gt;&gt; tensors, int axis = 0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Concatenate&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;class System.Numerics.Tensors.Tensor`1&lt;!!T&gt;&gt; tensors, int32 axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Concatenate``1(System.ReadOnlySpan{System.Numerics.Tensors.Tensor{``0}},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Concatenate(Of T) (tensors As ReadOnlySpan(Of Tensor(Of T)), Optional axis As Integer = 0) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Concatenate : ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;'T&gt;&gt; * int -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Concatenate (tensors, axis)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensors" Type="System.ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;T&gt;&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="axis" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensors">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertChecked&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;TTo&gt; ConvertChecked&lt;TFrom,TTo&gt; (System.Numerics.Tensors.Tensor&lt;TFrom&gt; source) where TFrom : IEquatable&lt;TFrom&gt;, System.Numerics.IEqualityOperators&lt;TFrom,TFrom,bool&gt;, System.Numerics.INumberBase&lt;TFrom&gt; where TTo : System.Numerics.INumberBase&lt;TTo&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!TTo&gt; ConvertChecked&lt;(class System.IEquatable`1&lt;!!TFrom&gt;, class System.Numerics.IEqualityOperators`3&lt;!!TFrom, !!TFrom, bool&gt;, class System.Numerics.INumberBase`1&lt;!!TFrom&gt;) TFrom, (class System.Numerics.INumberBase`1&lt;!!TTo&gt;) TTo&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!TFrom&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ConvertChecked``2(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertChecked(Of TFrom As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}, TTo As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}) (source As Tensor(Of TFrom)) As Tensor(Of TTo)" />
      <MemberSignature Language="F#" Value="static member ConvertChecked : System.Numerics.Tensors.Tensor&lt;'From (requires 'From :&gt; IEquatable&lt;'From&gt; and 'From :&gt; System.Numerics.IEqualityOperators&lt;'From, 'From, bool&gt; and 'From :&gt; System.Numerics.INumberBase&lt;'From&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'o (requires 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)&gt; (requires 'From :&gt; IEquatable&lt;'From&gt; and 'From :&gt; System.Numerics.IEqualityOperators&lt;'From, 'From, bool&gt; and 'From :&gt; System.Numerics.INumberBase&lt;'From&gt; and 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)" Usage="System.Numerics.Tensors.Tensor.ConvertChecked source" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; where TFrom : IEquatable&lt;TFrom&gt;, System::Numerics::IEqualityOperators&lt;TFrom, TFrom, bool&gt;, System::Numerics::INumberBase&lt;TFrom&gt; where TTo : System::Numerics::INumberBase&lt;TTo&gt; static System::Numerics::Tensors::Tensor&lt;TTo&gt; ^ ConvertChecked(System::Numerics::Tensors::Tensor&lt;TFrom&gt; ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;TTo&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;TFrom&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;TFrom,TFrom,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.INumberBase&lt;TFrom&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TTo&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Tensors.Tensor&lt;TFrom&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFrom">To be added.</typeparam>
        <typeparam name="TTo">To be added.</typeparam>
        <param name="source">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertChecked&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;TTo&gt; ConvertChecked&lt;TFrom,TTo&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;TFrom&gt; source, in System.Numerics.Tensors.TensorSpan&lt;TTo&gt; destination) where TFrom : IEquatable&lt;TFrom&gt;, System.Numerics.IEqualityOperators&lt;TFrom,TFrom,bool&gt;, System.Numerics.INumberBase&lt;TFrom&gt; where TTo : System.Numerics.INumberBase&lt;TTo&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!TTo&gt; ConvertChecked&lt;(class System.IEquatable`1&lt;!!TFrom&gt;, class System.Numerics.IEqualityOperators`3&lt;!!TFrom, !!TFrom, bool&gt;, class System.Numerics.INumberBase`1&lt;!!TFrom&gt;) TFrom, (class System.Numerics.INumberBase`1&lt;!!TTo&gt;) TTo&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!TFrom&gt;&amp; source, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!TTo&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ConvertChecked``2(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``1}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertChecked(Of TFrom As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}, TTo As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}) (ByRef source As ReadOnlyTensorSpan(Of TFrom), ByRef destination As TensorSpan(Of TTo)) As TensorSpan(Of TTo)" />
      <MemberSignature Language="F#" Value="static member ConvertChecked : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'From :&gt; IEquatable&lt;'From&gt; and 'From :&gt; System.Numerics.IEqualityOperators&lt;'From, 'From, bool&gt; and 'From :&gt; System.Numerics.INumberBase&lt;'From&gt; and 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)" Usage="System.Numerics.Tensors.Tensor.ConvertChecked (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; where TFrom : IEquatable&lt;TFrom&gt;, System::Numerics::IEqualityOperators&lt;TFrom, TFrom, bool&gt;, System::Numerics::INumberBase&lt;TFrom&gt; where TTo : System::Numerics::INumberBase&lt;TTo&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ ConvertChecked(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;TFrom&gt; % source, System::Numerics::Tensors::TensorSpan&lt;TTo&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;TTo&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;TFrom&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;TFrom,TFrom,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.INumberBase&lt;TFrom&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TTo&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;TFrom&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;TTo&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TFrom">To be added.</typeparam>
        <typeparam name="TTo">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertSaturating&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;TTo&gt; ConvertSaturating&lt;TFrom,TTo&gt; (System.Numerics.Tensors.Tensor&lt;TFrom&gt; source) where TFrom : IEquatable&lt;TFrom&gt;, System.Numerics.IEqualityOperators&lt;TFrom,TFrom,bool&gt;, System.Numerics.INumberBase&lt;TFrom&gt; where TTo : System.Numerics.INumberBase&lt;TTo&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!TTo&gt; ConvertSaturating&lt;(class System.IEquatable`1&lt;!!TFrom&gt;, class System.Numerics.IEqualityOperators`3&lt;!!TFrom, !!TFrom, bool&gt;, class System.Numerics.INumberBase`1&lt;!!TFrom&gt;) TFrom, (class System.Numerics.INumberBase`1&lt;!!TTo&gt;) TTo&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!TFrom&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ConvertSaturating``2(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertSaturating(Of TFrom As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}, TTo As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}) (source As Tensor(Of TFrom)) As Tensor(Of TTo)" />
      <MemberSignature Language="F#" Value="static member ConvertSaturating : System.Numerics.Tensors.Tensor&lt;'From (requires 'From :&gt; IEquatable&lt;'From&gt; and 'From :&gt; System.Numerics.IEqualityOperators&lt;'From, 'From, bool&gt; and 'From :&gt; System.Numerics.INumberBase&lt;'From&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'o (requires 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)&gt; (requires 'From :&gt; IEquatable&lt;'From&gt; and 'From :&gt; System.Numerics.IEqualityOperators&lt;'From, 'From, bool&gt; and 'From :&gt; System.Numerics.INumberBase&lt;'From&gt; and 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)" Usage="System.Numerics.Tensors.Tensor.ConvertSaturating source" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; where TFrom : IEquatable&lt;TFrom&gt;, System::Numerics::IEqualityOperators&lt;TFrom, TFrom, bool&gt;, System::Numerics::INumberBase&lt;TFrom&gt; where TTo : System::Numerics::INumberBase&lt;TTo&gt; static System::Numerics::Tensors::Tensor&lt;TTo&gt; ^ ConvertSaturating(System::Numerics::Tensors::Tensor&lt;TFrom&gt; ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;TTo&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;TFrom&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;TFrom,TFrom,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.INumberBase&lt;TFrom&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TTo&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Tensors.Tensor&lt;TFrom&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFrom">To be added.</typeparam>
        <typeparam name="TTo">To be added.</typeparam>
        <param name="source">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertSaturating&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;TTo&gt; ConvertSaturating&lt;TFrom,TTo&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;TFrom&gt; source, in System.Numerics.Tensors.TensorSpan&lt;TTo&gt; destination) where TFrom : IEquatable&lt;TFrom&gt;, System.Numerics.IEqualityOperators&lt;TFrom,TFrom,bool&gt;, System.Numerics.INumberBase&lt;TFrom&gt; where TTo : System.Numerics.INumberBase&lt;TTo&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!TTo&gt; ConvertSaturating&lt;(class System.IEquatable`1&lt;!!TFrom&gt;, class System.Numerics.IEqualityOperators`3&lt;!!TFrom, !!TFrom, bool&gt;, class System.Numerics.INumberBase`1&lt;!!TFrom&gt;) TFrom, (class System.Numerics.INumberBase`1&lt;!!TTo&gt;) TTo&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!TFrom&gt;&amp; source, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!TTo&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ConvertSaturating``2(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``1}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertSaturating(Of TFrom As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}, TTo As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}) (ByRef source As ReadOnlyTensorSpan(Of TFrom), ByRef destination As TensorSpan(Of TTo)) As TensorSpan(Of TTo)" />
      <MemberSignature Language="F#" Value="static member ConvertSaturating : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'From :&gt; IEquatable&lt;'From&gt; and 'From :&gt; System.Numerics.IEqualityOperators&lt;'From, 'From, bool&gt; and 'From :&gt; System.Numerics.INumberBase&lt;'From&gt; and 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)" Usage="System.Numerics.Tensors.Tensor.ConvertSaturating (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; where TFrom : IEquatable&lt;TFrom&gt;, System::Numerics::IEqualityOperators&lt;TFrom, TFrom, bool&gt;, System::Numerics::INumberBase&lt;TFrom&gt; where TTo : System::Numerics::INumberBase&lt;TTo&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ ConvertSaturating(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;TFrom&gt; % source, System::Numerics::Tensors::TensorSpan&lt;TTo&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;TTo&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;TFrom&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;TFrom,TFrom,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.INumberBase&lt;TFrom&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TTo&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;TFrom&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;TTo&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TFrom">To be added.</typeparam>
        <typeparam name="TTo">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertTruncating&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;TTo&gt; ConvertTruncating&lt;TFrom,TTo&gt; (System.Numerics.Tensors.Tensor&lt;TFrom&gt; source) where TFrom : IEquatable&lt;TFrom&gt;, System.Numerics.IEqualityOperators&lt;TFrom,TFrom,bool&gt;, System.Numerics.INumberBase&lt;TFrom&gt; where TTo : System.Numerics.INumberBase&lt;TTo&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!TTo&gt; ConvertTruncating&lt;(class System.IEquatable`1&lt;!!TFrom&gt;, class System.Numerics.IEqualityOperators`3&lt;!!TFrom, !!TFrom, bool&gt;, class System.Numerics.INumberBase`1&lt;!!TFrom&gt;) TFrom, (class System.Numerics.INumberBase`1&lt;!!TTo&gt;) TTo&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!TFrom&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ConvertTruncating``2(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertTruncating(Of TFrom As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}, TTo As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}) (source As Tensor(Of TFrom)) As Tensor(Of TTo)" />
      <MemberSignature Language="F#" Value="static member ConvertTruncating : System.Numerics.Tensors.Tensor&lt;'From (requires 'From :&gt; IEquatable&lt;'From&gt; and 'From :&gt; System.Numerics.IEqualityOperators&lt;'From, 'From, bool&gt; and 'From :&gt; System.Numerics.INumberBase&lt;'From&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'o (requires 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)&gt; (requires 'From :&gt; IEquatable&lt;'From&gt; and 'From :&gt; System.Numerics.IEqualityOperators&lt;'From, 'From, bool&gt; and 'From :&gt; System.Numerics.INumberBase&lt;'From&gt; and 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)" Usage="System.Numerics.Tensors.Tensor.ConvertTruncating source" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; where TFrom : IEquatable&lt;TFrom&gt;, System::Numerics::IEqualityOperators&lt;TFrom, TFrom, bool&gt;, System::Numerics::INumberBase&lt;TFrom&gt; where TTo : System::Numerics::INumberBase&lt;TTo&gt; static System::Numerics::Tensors::Tensor&lt;TTo&gt; ^ ConvertTruncating(System::Numerics::Tensors::Tensor&lt;TFrom&gt; ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;TTo&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;TFrom&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;TFrom,TFrom,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.INumberBase&lt;TFrom&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TTo&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Tensors.Tensor&lt;TFrom&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFrom">To be added.</typeparam>
        <typeparam name="TTo">To be added.</typeparam>
        <param name="source">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertTruncating&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;TTo&gt; ConvertTruncating&lt;TFrom,TTo&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;TFrom&gt; source, in System.Numerics.Tensors.TensorSpan&lt;TTo&gt; destination) where TFrom : IEquatable&lt;TFrom&gt;, System.Numerics.IEqualityOperators&lt;TFrom,TFrom,bool&gt;, System.Numerics.INumberBase&lt;TFrom&gt; where TTo : System.Numerics.INumberBase&lt;TTo&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!TTo&gt; ConvertTruncating&lt;(class System.IEquatable`1&lt;!!TFrom&gt;, class System.Numerics.IEqualityOperators`3&lt;!!TFrom, !!TFrom, bool&gt;, class System.Numerics.INumberBase`1&lt;!!TFrom&gt;) TFrom, (class System.Numerics.INumberBase`1&lt;!!TTo&gt;) TTo&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!TFrom&gt;&amp; source, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!TTo&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ConvertTruncating``2(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``1}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertTruncating(Of TFrom As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}, TTo As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}) (ByRef source As ReadOnlyTensorSpan(Of TFrom), ByRef destination As TensorSpan(Of TTo)) As TensorSpan(Of TTo)" />
      <MemberSignature Language="F#" Value="static member ConvertTruncating : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'From :&gt; IEquatable&lt;'From&gt; and 'From :&gt; System.Numerics.IEqualityOperators&lt;'From, 'From, bool&gt; and 'From :&gt; System.Numerics.INumberBase&lt;'From&gt; and 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)" Usage="System.Numerics.Tensors.Tensor.ConvertTruncating (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; where TFrom : IEquatable&lt;TFrom&gt;, System::Numerics::IEqualityOperators&lt;TFrom, TFrom, bool&gt;, System::Numerics::INumberBase&lt;TFrom&gt; where TTo : System::Numerics::INumberBase&lt;TTo&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ ConvertTruncating(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;TFrom&gt; % source, System::Numerics::Tensors::TensorSpan&lt;TTo&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;TTo&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;TFrom&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;TFrom,TFrom,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.INumberBase&lt;TFrom&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TTo&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;TFrom&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;TTo&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TFrom">To be added.</typeparam>
        <typeparam name="TTo">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopySign&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CopySign&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input, System.Numerics.Tensors.Tensor&lt;T&gt; sign) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CopySign&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; sign) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CopySign``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function CopySign(Of T As INumber(Of T)) (input As Tensor(Of T), sign As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CopySign : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CopySign (input, sign)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ CopySign(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, System::Numerics::Tensors::Tensor&lt;T&gt; ^ sign);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="sign" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="sign">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopySign&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CopySign&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input, T sign) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CopySign&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, !!T sign) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CopySign``1(System.Numerics.Tensors.Tensor{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopySign(Of T As INumber(Of T)) (input As Tensor(Of T), sign As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CopySign : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CopySign (input, sign)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ CopySign(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, T sign);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="sign" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="sign">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopySign&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; CopySign&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; sign, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; CopySign&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; sign, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CopySign``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopySign(Of T As INumber(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef sign As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member CopySign : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CopySign (input, sign, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ CopySign(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % sign, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="sign" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="sign">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopySign&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; CopySign&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, T sign, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; CopySign&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, !!T sign, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CopySign``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopySign(Of T As INumber(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), sign As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member CopySign : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CopySign (input, sign, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ CopySign(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, T sign, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="sign" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="sign">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Cos&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Cos&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Cos``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Cos(Of T As ITrigonometricFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Cos : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Cos input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Cos(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Cos&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Cos&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Cos``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Cos(Of T As ITrigonometricFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Cos : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Cos (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Cos(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cosh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Cosh&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Cosh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Cosh``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Cosh(Of T As IHyperbolicFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Cosh : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Cosh input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Cosh(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cosh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Cosh&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Cosh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Cosh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Cosh(Of T As IHyperbolicFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Cosh : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Cosh (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Cosh(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CosineSimilarity&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CosineSimilarity&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CosineSimilarity&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CosineSimilarity``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function CosineSimilarity(Of T As IRootFunctions(Of T)) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CosineSimilarity : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CosineSimilarity (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ CosineSimilarity(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CosineSimilarity&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; CosineSimilarity&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; CosineSimilarity&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CosineSimilarity``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function CosineSimilarity(Of T As IRootFunctions(Of T)) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member CosineSimilarity : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CosineSimilarity (left, right, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ CosineSimilarity(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CosPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CosPi&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CosPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CosPi``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function CosPi(Of T As ITrigonometricFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CosPi : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CosPi input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ CosPi(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CosPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; CosPi&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; CosPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CosPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function CosPi(Of T As ITrigonometricFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member CosPi : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CosPi (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ CosPi(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Create&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; data, scoped ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Create&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; data, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Create``1(System.Collections.Generic.IEnumerable{``0},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function Create(Of T) (data As IEnumerable(Of T), lengths As ReadOnlySpan(Of IntPtr)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Create : seq&lt;'T&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Create (data, lengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Create(System::Collections::Generic::IEnumerable&lt;T&gt; ^ data, ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="data">To be added.</param>
        <param name="lengths">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Create&lt;T&gt; (scoped ReadOnlySpan&lt;IntPtr&gt; lengths, bool pinned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Create&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Create``1(System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Create(Of T) (lengths As ReadOnlySpan(Of IntPtr), Optional pinned As Boolean = false) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Create : ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Create (lengths, pinned)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="lengths">To be added.</param>
        <param name="pinned">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Create&lt;T&gt; (T[] values, scoped ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Create&lt;T&gt;(!!T[] values, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Create``1(``0[],System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function Create(Of T) (values As T(), lengths As ReadOnlySpan(Of IntPtr)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Create : 'T[] * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Create (values, lengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Create(cli::array &lt;T&gt; ^ values, ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="T[]" />
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="values">To be added.</param>
        <param name="lengths">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Create&lt;T&gt; (scoped ReadOnlySpan&lt;IntPtr&gt; lengths, scoped ReadOnlySpan&lt;IntPtr&gt; strides, bool pinned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Create&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Create``1(System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Create(Of T) (lengths As ReadOnlySpan(Of IntPtr), strides As ReadOnlySpan(Of IntPtr), Optional pinned As Boolean = false) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Create : ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Create (lengths, strides, pinned)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="lengths">To be added.</param>
        <param name="strides">To be added.</param>
        <param name="pinned">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Create&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; data, scoped ReadOnlySpan&lt;IntPtr&gt; lengths, scoped ReadOnlySpan&lt;IntPtr&gt; strides, bool isPinned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Create&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; data, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides, bool isPinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Create``1(System.Collections.Generic.IEnumerable{``0},System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Create(Of T) (data As IEnumerable(Of T), lengths As ReadOnlySpan(Of IntPtr), strides As ReadOnlySpan(Of IntPtr), Optional isPinned As Boolean = false) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Create : seq&lt;'T&gt; * ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Create (data, lengths, strides, isPinned)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IEnumerable&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="isPinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="data">To be added.</param>
        <param name="lengths">To be added.</param>
        <param name="strides">To be added.</param>
        <param name="isPinned">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Create&lt;T&gt; (T[] values, scoped ReadOnlySpan&lt;IntPtr&gt; lengths, scoped ReadOnlySpan&lt;IntPtr&gt; strides, bool isPinned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Create&lt;T&gt;(!!T[] values, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides, bool isPinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Create``1(``0[],System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Create(Of T) (values As T(), lengths As ReadOnlySpan(Of IntPtr), strides As ReadOnlySpan(Of IntPtr), Optional isPinned As Boolean = false) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Create : 'T[] * ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Create (values, lengths, strides, isPinned)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="T[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="isPinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="values">To be added.</param>
        <param name="lengths">To be added.</param>
        <param name="strides">To be added.</param>
        <param name="isPinned">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAndFillGaussianNormalDistribution&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CreateAndFillGaussianNormalDistribution&lt;T&gt; (scoped ReadOnlySpan&lt;IntPtr&gt; lengths) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CreateAndFillGaussianNormalDistribution&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CreateAndFillGaussianNormalDistribution``1(System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateAndFillGaussianNormalDistribution(Of T As IFloatingPoint(Of T)) (lengths As ReadOnlySpan(Of IntPtr)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CreateAndFillGaussianNormalDistribution : ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CreateAndFillGaussianNormalDistribution lengths" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ CreateAndFillGaussianNormalDistribution(ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="lengths">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAndFillUniformDistribution&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CreateAndFillUniformDistribution&lt;T&gt; (scoped ReadOnlySpan&lt;IntPtr&gt; lengths) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CreateAndFillUniformDistribution&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CreateAndFillUniformDistribution``1(System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateAndFillUniformDistribution(Of T As IFloatingPoint(Of T)) (lengths As ReadOnlySpan(Of IntPtr)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CreateAndFillUniformDistribution : ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CreateAndFillUniformDistribution lengths" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ CreateAndFillUniformDistribution(ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="lengths">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateUninitialized&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CreateUninitialized&lt;T&gt; (scoped ReadOnlySpan&lt;IntPtr&gt; lengths, bool pinned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CreateUninitialized&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CreateUninitialized``1(System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateUninitialized(Of T) (lengths As ReadOnlySpan(Of IntPtr), Optional pinned As Boolean = false) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CreateUninitialized : ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.CreateUninitialized (lengths, pinned)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="lengths">To be added.</param>
        <param name="pinned">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateUninitialized&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CreateUninitialized&lt;T&gt; (scoped ReadOnlySpan&lt;IntPtr&gt; lengths, scoped ReadOnlySpan&lt;IntPtr&gt; strides, bool pinned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CreateUninitialized&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CreateUninitialized``1(System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateUninitialized(Of T) (lengths As ReadOnlySpan(Of IntPtr), strides As ReadOnlySpan(Of IntPtr), Optional pinned As Boolean = false) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CreateUninitialized : ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.CreateUninitialized (lengths, strides, pinned)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="lengths">To be added.</param>
        <param name="strides">To be added.</param>
        <param name="pinned">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DegreesToRadians&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; DegreesToRadians&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; DegreesToRadians&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.DegreesToRadians``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function DegreesToRadians(Of T As ITrigonometricFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member DegreesToRadians : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.DegreesToRadians input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ DegreesToRadians(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DegreesToRadians&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; DegreesToRadians&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; DegreesToRadians&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.DegreesToRadians``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function DegreesToRadians(Of T As ITrigonometricFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member DegreesToRadians : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.DegreesToRadians (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ DegreesToRadians(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Distance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Distance&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Distance&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Distance``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Distance(Of T As IRootFunctions(Of T)) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Distance : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Distance (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static T Distance(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Distance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Distance&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Distance&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Distance``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Distance(Of T As IRootFunctions(Of T)) (left As Tensor(Of T), right As Tensor(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Distance : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Distance (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static T Distance(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Divide&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Divide&lt;(class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Divide``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Divide(Of T As IDivisionOperators(Of T, T, T)) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Divide (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IDivisionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Divide(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Divide&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input, T val) where T : System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Divide&lt;(class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, !!T val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Divide``1(System.Numerics.Tensors.Tensor{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Divide(Of T As IDivisionOperators(Of T, T, T)) (input As Tensor(Of T), val As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Divide (input, val)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IDivisionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Divide(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, T val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="val" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Divide&lt;T&gt; (T val, System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Divide&lt;(class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(!!T val, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Divide``1(``0,System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Divide(Of T As IDivisionOperators(Of T, T, T)) (val As T, input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Divide : 'T * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Divide (val, input)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IDivisionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Divide(T val, System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="val" Type="T" />
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="val">To be added.</param>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Divide&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Divide&lt;(class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Divide``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Divide(Of T As IDivisionOperators(Of T, T, T)) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Divide : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Divide (left, right, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IDivisionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Divide(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Divide&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, T val, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Divide&lt;(class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, !!T val, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Divide``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Divide(Of T As IDivisionOperators(Of T, T, T)) (ByRef input As ReadOnlyTensorSpan(Of T), val As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Divide : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Divide (input, val, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IDivisionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Divide(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, T val, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="val" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Divide&lt;T&gt; (T val, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Divide&lt;(class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(!!T val, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Divide``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Divide(Of T As IDivisionOperators(Of T, T, T)) (val As T, ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Divide : 'T * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Divide (val, input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IDivisionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Divide(T val, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="val" Type="T" />
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="val">To be added.</param>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dot&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Dot&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Dot&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Dot``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dot(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T), IMultiplicativeIdentity(Of T, T), IMultiplyOperators(Of T, T, T)}) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Dot : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Dot (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt; static T Dot(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dot&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Dot&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Dot&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Dot``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Dot(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T), IMultiplicativeIdentity(Of T, T), IMultiplyOperators(Of T, T, T)}) (left As Tensor(Of T), right As Tensor(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Dot : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Dot (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt; static T Dot(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ElementwiseEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;bool&gt; ElementwiseEqual&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;bool&gt; ElementwiseEqual&lt;(class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ElementwiseEqual``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ElementwiseEqual(Of T As IEqualityOperators(Of T, T, Boolean)) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member ElementwiseEqual : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;bool&gt; (requires 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.ElementwiseEqual (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IEqualityOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;bool&gt; ^ ElementwiseEqual(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ElementwiseEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;bool&gt; ElementwiseEqual&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right, in System.Numerics.Tensors.TensorSpan&lt;bool&gt; destination) where T : System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt; ElementwiseEqual&lt;(class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ElementwiseEqual``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{System.Boolean}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ElementwiseEqual(Of T As IEqualityOperators(Of T, T, Boolean)) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of Boolean)) As TensorSpan(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member ElementwiseEqual : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.ElementwiseEqual (left, right, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IEqualityOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ ElementwiseEqual(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right, System::Numerics::Tensors::TensorSpan&lt;bool&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Exp&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Exp&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Exp``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Exp(Of T As IExponentialFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Exp : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Exp input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Exp(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Exp&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Exp&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Exp``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Exp(Of T As IExponentialFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Exp : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Exp (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Exp(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp10&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Exp10&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Exp10&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Exp10``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Exp10(Of T As IExponentialFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Exp10 : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Exp10 input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Exp10(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp10&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Exp10&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Exp10&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Exp10``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Exp10(Of T As IExponentialFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Exp10 : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Exp10 (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Exp10(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp10M1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Exp10M1&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Exp10M1&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Exp10M1``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Exp10M1(Of T As IExponentialFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Exp10M1 : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Exp10M1 input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Exp10M1(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp10M1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Exp10M1&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Exp10M1&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Exp10M1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Exp10M1(Of T As IExponentialFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Exp10M1 : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Exp10M1 (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Exp10M1(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Exp2&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Exp2&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Exp2``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Exp2(Of T As IExponentialFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Exp2 : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Exp2 input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Exp2(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Exp2&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Exp2&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Exp2``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Exp2(Of T As IExponentialFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Exp2 : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Exp2 (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Exp2(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp2M1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Exp2M1&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Exp2M1&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Exp2M1``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Exp2M1(Of T As IExponentialFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Exp2M1 : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Exp2M1 input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Exp2M1(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp2M1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Exp2M1&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Exp2M1&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Exp2M1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Exp2M1(Of T As IExponentialFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Exp2M1 : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Exp2M1 (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Exp2M1(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpM1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; ExpM1&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; ExpM1&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ExpM1``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ExpM1(Of T As IExponentialFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member ExpM1 : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.ExpM1 input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ ExpM1(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpM1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; ExpM1&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; ExpM1&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ExpM1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExpM1(Of T As IExponentialFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member ExpM1 : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.ExpM1 (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ ExpM1(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FillGaussianNormalDistribution&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; FillGaussianNormalDistribution&lt;T&gt; (in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; FillGaussianNormalDistribution&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.FillGaussianNormalDistribution``1(System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function FillGaussianNormalDistribution(Of T As IFloatingPoint(Of T)) (ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member FillGaussianNormalDistribution : TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.FillGaussianNormalDistribution destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ FillGaussianNormalDistribution(System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FillUniformDistribution&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; FillUniformDistribution&lt;T&gt; (in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; FillUniformDistribution&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.FillUniformDistribution``1(System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function FillUniformDistribution(Of T As IFloatingPoint(Of T)) (ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member FillUniformDistribution : TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.FillUniformDistribution destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ FillUniformDistribution(System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilteredUpdate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; FilteredUpdate&lt;T&gt; (this in System.Numerics.Tensors.TensorSpan&lt;T&gt; tensor, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;bool&gt; filter, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; FilteredUpdate&lt;T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; tensor, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;bool&gt;&amp; filter, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.FilteredUpdate``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{System.Boolean}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FilteredUpdate(Of T) (ByRef tensor As TensorSpan(Of T), ByRef filter As ReadOnlyTensorSpan(Of Boolean), ByRef values As ReadOnlyTensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member FilteredUpdate : TensorSpan * ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.FilteredUpdate (tensor, filter, values)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::TensorSpan&lt;T&gt; FilteredUpdate(System::Numerics::Tensors::TensorSpan&lt;T&gt; % tensor, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;bool&gt; % filter, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="filter" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;System.Boolean&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="values" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">To be added.</param>
        <param name="filter">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilteredUpdate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; FilteredUpdate&lt;T&gt; (this in System.Numerics.Tensors.TensorSpan&lt;T&gt; tensor, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;bool&gt; filter, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; FilteredUpdate&lt;T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; tensor, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;bool&gt;&amp; filter, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.FilteredUpdate``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{System.Boolean}@,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FilteredUpdate(Of T) (ByRef tensor As TensorSpan(Of T), ByRef filter As ReadOnlyTensorSpan(Of Boolean), value As T) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member FilteredUpdate : TensorSpan * ReadOnlyTensorSpan * 'T -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.FilteredUpdate (tensor, filter, value)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::TensorSpan&lt;T&gt; FilteredUpdate(System::Numerics::Tensors::TensorSpan&lt;T&gt; % tensor, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;bool&gt; % filter, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="filter" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;System.Boolean&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="value" Type="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">To be added.</param>
        <param name="filter">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Floor&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Floor&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Floor&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Floor``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Floor(Of T As IFloatingPoint(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Floor : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Floor input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Floor(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Floor&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Floor&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Floor&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Floor``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Floor(Of T As IFloatingPoint(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Floor : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Floor (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Floor(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSmallestBroadcastableLengths">
      <MemberSignature Language="C#" Value="public static IntPtr[] GetSmallestBroadcastableLengths (ReadOnlySpan&lt;IntPtr&gt; shape1, ReadOnlySpan&lt;IntPtr&gt; shape2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int[] GetSmallestBroadcastableLengths(valuetype System.ReadOnlySpan`1&lt;native int&gt; shape1, valuetype System.ReadOnlySpan`1&lt;native int&gt; shape2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GetSmallestBroadcastableLengths(System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSmallestBroadcastableLengths (shape1 As ReadOnlySpan(Of IntPtr), shape2 As ReadOnlySpan(Of IntPtr)) As IntPtr()" />
      <MemberSignature Language="F#" Value="static member GetSmallestBroadcastableLengths : ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; nativeint[]" Usage="System.Numerics.Tensors.Tensor.GetSmallestBroadcastableLengths (shape1, shape2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;IntPtr&gt; ^ GetSmallestBroadcastableLengths(ReadOnlySpan&lt;IntPtr&gt; shape1, ReadOnlySpan&lt;IntPtr&gt; shape2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr[]</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="shape1" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;" />
        <Parameter Name="shape2" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;" />
      </Parameters>
      <Docs>
        <param name="shape1">To be added.</param>
        <param name="shape2">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;bool&gt; GreaterThan&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;bool&gt; GreaterThan&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThan``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThan(Of T As IComparisonOperators(Of T, T, Boolean)) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member GreaterThan : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;bool&gt; (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThan (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;bool&gt; ^ GreaterThan(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;bool&gt; GreaterThan&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, T right) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;bool&gt; GreaterThan&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, !!T right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThan``1(System.Numerics.Tensors.Tensor{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThan(Of T As IComparisonOperators(Of T, T, Boolean)) (left As Tensor(Of T), right As T) As Tensor(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member GreaterThan : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.Tensor&lt;bool&gt; (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThan (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;bool&gt; ^ GreaterThan(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, T right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool GreaterThanAll&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GreaterThanAll&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThanAll``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThanAll(Of T As IComparisonOperators(Of T, T, Boolean)) (left As Tensor(Of T), right As Tensor(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member GreaterThanAll : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThanAll (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool GreaterThanAll(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool GreaterThanAny&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GreaterThanAny&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThanAny``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThanAny(Of T As IComparisonOperators(Of T, T, Boolean)) (left As Tensor(Of T), right As Tensor(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member GreaterThanAny : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThanAny (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool GreaterThanAny(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Hypot&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Hypot&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Hypot&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Hypot``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Hypot(Of T As IRootFunctions(Of T)) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Hypot : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Hypot (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Hypot(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Hypot&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Hypot&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Hypot&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Hypot``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Hypot(Of T As IRootFunctions(Of T)) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Hypot : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Hypot (left, right, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Hypot(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ieee754Remainder&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Ieee754Remainder&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Ieee754Remainder&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Ieee754Remainder``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Ieee754Remainder(Of T As IFloatingPointIeee754(Of T)) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Ieee754Remainder : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Ieee754Remainder (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Ieee754Remainder(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ieee754Remainder&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Ieee754Remainder&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Ieee754Remainder&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Ieee754Remainder``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Ieee754Remainder(Of T As IFloatingPointIeee754(Of T)) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Ieee754Remainder : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Ieee754Remainder (left, right, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Ieee754Remainder(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ILogB&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;int&gt; ILogB&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;int32&gt; ILogB&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ILogB``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ILogB(Of T As IFloatingPointIeee754(Of T)) (input As Tensor(Of T)) As Tensor(Of Integer)" />
      <MemberSignature Language="F#" Value="static member ILogB : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;int&gt; (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.ILogB input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;int&gt; ^ ILogB(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ILogB&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;int&gt; ILogB&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;int&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;int32&gt; ILogB&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;int32&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ILogB``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{System.Int32}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ILogB(Of T As IFloatingPointIeee754(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of Integer)) As TensorSpan(Of Integer)" />
      <MemberSignature Language="F#" Value="static member ILogB : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.ILogB (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ ILogB(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;int&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;System.Int32&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;System.Int32&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMax&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfMax&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMax&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.IndexOfMax``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfMax(Of T As INumber(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMax : ReadOnlyTensorSpan -&gt; int (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.IndexOfMax input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static int IndexOfMax(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMax&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfMax&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMax&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.IndexOfMax``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfMax(Of T As INumber(Of T)) (input As Tensor(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMax : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.IndexOfMax input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static int IndexOfMax(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMaxMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfMaxMagnitude&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMaxMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.IndexOfMaxMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfMaxMagnitude(Of T As INumber(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMaxMagnitude : ReadOnlyTensorSpan -&gt; int (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.IndexOfMaxMagnitude input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static int IndexOfMaxMagnitude(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMaxMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfMaxMagnitude&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMaxMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.IndexOfMaxMagnitude``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfMaxMagnitude(Of T As INumber(Of T)) (input As Tensor(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMaxMagnitude : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.IndexOfMaxMagnitude input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static int IndexOfMaxMagnitude(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfMin&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMin&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.IndexOfMin``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfMin(Of T As INumber(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMin : ReadOnlyTensorSpan -&gt; int (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.IndexOfMin input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static int IndexOfMin(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfMin&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMin&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.IndexOfMin``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfMin(Of T As INumber(Of T)) (input As Tensor(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMin : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.IndexOfMin input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static int IndexOfMin(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMinMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfMinMagnitude&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMinMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.IndexOfMinMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfMinMagnitude(Of T As INumber(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMinMagnitude : ReadOnlyTensorSpan -&gt; int (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.IndexOfMinMagnitude input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static int IndexOfMinMagnitude(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMinMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfMinMagnitude&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMinMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.IndexOfMinMagnitude``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfMinMagnitude(Of T As INumber(Of T)) (input As Tensor(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMinMagnitude : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.IndexOfMinMagnitude input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static int IndexOfMinMagnitude(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeadingZeroCount&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; LeadingZeroCount&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; LeadingZeroCount&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LeadingZeroCount``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function LeadingZeroCount(Of T As IBinaryInteger(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member LeadingZeroCount : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.LeadingZeroCount input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ LeadingZeroCount(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeadingZeroCount&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; LeadingZeroCount&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; LeadingZeroCount&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LeadingZeroCount``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function LeadingZeroCount(Of T As IBinaryInteger(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member LeadingZeroCount : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.LeadingZeroCount (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ LeadingZeroCount(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;bool&gt; LessThan&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;bool&gt; LessThan&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThan``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThan(Of T As IComparisonOperators(Of T, T, Boolean)) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member LessThan : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;bool&gt; (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThan (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;bool&gt; ^ LessThan(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;bool&gt; LessThan&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, T right) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;bool&gt; LessThan&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, !!T right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThan``1(System.Numerics.Tensors.Tensor{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThan(Of T As IComparisonOperators(Of T, T, Boolean)) (left As Tensor(Of T), right As T) As Tensor(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member LessThan : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.Tensor&lt;bool&gt; (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThan (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;bool&gt; ^ LessThan(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, T right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool LessThanAll&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool LessThanAll&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThanAll``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThanAll(Of T As IComparisonOperators(Of T, T, Boolean)) (left As Tensor(Of T), right As Tensor(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member LessThanAll : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThanAll (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool LessThanAll(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool LessThanAny&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool LessThanAny&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThanAny``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThanAny(Of T As IComparisonOperators(Of T, T, Boolean)) (left As Tensor(Of T), right As Tensor(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member LessThanAny : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThanAny (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool LessThanAny(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Log&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Log&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Log(Of T As ILogarithmicFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Log(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Log&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Log&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Log(Of T As ILogarithmicFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Log : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Log(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Log10&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Log10&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log10``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Log10(Of T As ILogarithmicFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log10 input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Log10(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Log10&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Log10&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log10``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Log10(Of T As ILogarithmicFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Log10 : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log10 (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Log10(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10P1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Log10P1&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Log10P1&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log10P1``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Log10P1(Of T As ILogarithmicFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Log10P1 : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log10P1 input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Log10P1(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10P1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Log10P1&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Log10P1&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log10P1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Log10P1(Of T As ILogarithmicFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Log10P1 : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log10P1 (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Log10P1(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Log2&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Log2&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log2``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Log2(Of T As ILogarithmicFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Log2 : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log2 input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Log2(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Log2&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Log2&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log2``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Log2(Of T As ILogarithmicFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Log2 : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log2 (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Log2(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log2P1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Log2P1&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Log2P1&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log2P1``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Log2P1(Of T As ILogarithmicFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Log2P1 : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log2P1 input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Log2P1(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log2P1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Log2P1&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Log2P1&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log2P1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Log2P1(Of T As ILogarithmicFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Log2P1 : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log2P1 (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Log2P1(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogP1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; LogP1&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; LogP1&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LogP1``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function LogP1(Of T As ILogarithmicFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member LogP1 : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.LogP1 input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ LogP1(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogP1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; LogP1&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; LogP1&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LogP1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function LogP1(Of T As ILogarithmicFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member LogP1 : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.LogP1 (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ LogP1(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Max&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Max&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Max``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Max(Of T As INumber(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Max : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Max input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T Max(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Max&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Max&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Max``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Max(Of T As INumber(Of T)) (input As Tensor(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Max : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Max input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T Max(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MaxMagnitude&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MaxMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MaxMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MaxMagnitude(Of T As INumber(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MaxMagnitude input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T MaxMagnitude(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MaxMagnitude&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MaxMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MaxMagnitude``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function MaxMagnitude(Of T As INumber(Of T)) (input As Tensor(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MaxMagnitude input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T MaxMagnitude(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MaxNumber&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MaxNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MaxNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MaxNumber(Of T As INumber(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MaxNumber : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MaxNumber input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T MaxNumber(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MaxNumber&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MaxNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MaxNumber``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function MaxNumber(Of T As INumber(Of T)) (input As Tensor(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MaxNumber : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MaxNumber input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T MaxNumber(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Mean&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Mean&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Mean&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Mean``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Mean(Of T As IFloatingPoint(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Mean : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Mean input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static T Mean(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Min&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Min&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Min``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Min(Of T As INumber(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Min : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Min input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T Min(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Min&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Min&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Min``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Min(Of T As INumber(Of T)) (input As Tensor(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Min : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Min input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T Min(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MinMagnitude&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MinMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MinMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MinMagnitude(Of T As INumber(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MinMagnitude input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T MinMagnitude(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MinMagnitude&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MinMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MinMagnitude``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function MinMagnitude(Of T As INumber(Of T)) (input As Tensor(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MinMagnitude input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T MinMagnitude(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MinNumber&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MinNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MinNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MinNumber(Of T As INumber(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MinNumber : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MinNumber input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T MinNumber(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MinNumber&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MinNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MinNumber``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function MinNumber(Of T As INumber(Of T)) (input As Tensor(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MinNumber : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MinNumber input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T MinNumber(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiply&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Multiply&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Multiply&lt;(class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Multiply``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Multiply(Of T As {IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Multiply (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Multiply(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiply&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Multiply&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input, T val) where T : System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Multiply&lt;(class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, !!T val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Multiply``1(System.Numerics.Tensors.Tensor{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Multiply(Of T As {IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (input As Tensor(Of T), val As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Multiply (input, val)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Multiply(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, T val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="val" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiply&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Multiply&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Multiply&lt;(class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Multiply``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Multiply(Of T As {IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Multiply : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Multiply (left, right, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Multiply(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiply&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Multiply&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, T val, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Multiply&lt;(class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, !!T val, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Multiply``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Multiply(Of T As {IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (ByRef input As ReadOnlyTensorSpan(Of T), val As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Multiply : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Multiply (input, val, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Multiply(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, T val, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="val" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Negate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Negate&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IUnaryNegationOperators&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Negate&lt;(class System.Numerics.IUnaryNegationOperators`2&lt;!!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Negate``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Negate(Of T As IUnaryNegationOperators(Of T, T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IUnaryNegationOperators&lt;'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IUnaryNegationOperators&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IUnaryNegationOperators&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Negate input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IUnaryNegationOperators&lt;T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Negate(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IUnaryNegationOperators&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Negate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Negate&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IUnaryNegationOperators&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Negate&lt;(class System.Numerics.IUnaryNegationOperators`2&lt;!!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Negate``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Negate(Of T As IUnaryNegationOperators(Of T, T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Negate : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IUnaryNegationOperators&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Negate (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IUnaryNegationOperators&lt;T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Negate(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IUnaryNegationOperators&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Norm&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Norm&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Norm&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Norm``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Norm(Of T As IRootFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Norm : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Norm input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static T Norm(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Norm&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Norm&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Norm&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Norm``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Norm(Of T As IRootFunctions(Of T)) (input As Tensor(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Norm : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Norm input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static T Norm(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnesComplement&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; OnesComplement&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; OnesComplement&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.OnesComplement``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function OnesComplement(Of T As IBitwiseOperators(Of T, T, T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member OnesComplement : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.OnesComplement input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ OnesComplement(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnesComplement&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; OnesComplement&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; OnesComplement&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.OnesComplement``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function OnesComplement(Of T As IBitwiseOperators(Of T, T, T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member OnesComplement : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.OnesComplement (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ OnesComplement(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Permute&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Permute&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input, scoped ReadOnlySpan&lt;int&gt; axis) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Permute&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, valuetype System.ReadOnlySpan`1&lt;int32&gt; axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Permute``1(System.Numerics.Tensors.Tensor{``0},System.ReadOnlySpan{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Function Permute(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean)}) (input As Tensor(Of T), axis As ReadOnlySpan(Of Integer)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Permute : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; * ReadOnlySpan&lt;int&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.Permute (input, axis)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Permute(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, ReadOnlySpan&lt;int&gt; axis);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="axis" Type="System.ReadOnlySpan&lt;System.Int32&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PopCount&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; PopCount&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; PopCount&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.PopCount``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function PopCount(Of T As IBinaryInteger(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member PopCount : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.PopCount input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ PopCount(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PopCount&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; PopCount&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; PopCount&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.PopCount``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function PopCount(Of T As IBinaryInteger(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member PopCount : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.PopCount (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ PopCount(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Pow&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IPowerFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Pow&lt;(class System.Numerics.IPowerFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Pow``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Pow(Of T As IPowerFunctions(Of T)) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Pow (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IPowerFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Pow(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IPowerFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Pow&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IPowerFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Pow&lt;(class System.Numerics.IPowerFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Pow``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Pow(Of T As IPowerFunctions(Of T)) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Pow : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Pow (left, right, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IPowerFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Pow(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IPowerFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Product&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Product&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input) where T : System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Product&lt;(class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Product``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Product(Of T As {IMultiplicativeIdentity(Of T, T), IMultiplyOperators(Of T, T, T)}) (ByRef input As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Product : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Product input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IMultiplicativeIdentity&lt;T, T&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt; static T Product(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Product&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Product&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Product&lt;(class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Product``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Product(Of T As {IMultiplicativeIdentity(Of T, T), IMultiplyOperators(Of T, T, T)}) (input As Tensor(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Product : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Product input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IMultiplicativeIdentity&lt;T, T&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt; static T Product(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RadiansToDegrees&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; RadiansToDegrees&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; RadiansToDegrees&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.RadiansToDegrees``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RadiansToDegrees(Of T As ITrigonometricFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member RadiansToDegrees : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.RadiansToDegrees input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ RadiansToDegrees(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RadiansToDegrees&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; RadiansToDegrees&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; RadiansToDegrees&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.RadiansToDegrees``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function RadiansToDegrees(Of T As ITrigonometricFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member RadiansToDegrees : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.RadiansToDegrees (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ RadiansToDegrees(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reciprocal&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Reciprocal&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Reciprocal&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Reciprocal``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Reciprocal(Of T As IFloatingPoint(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Reciprocal : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Reciprocal input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Reciprocal(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reciprocal&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Reciprocal&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Reciprocal&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Reciprocal``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Reciprocal(Of T As IFloatingPoint(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Reciprocal : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Reciprocal (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Reciprocal(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reshape&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; Reshape&lt;T&gt; (this in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, scoped ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt; Reshape&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Reshape``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Reshape(Of T) (ByRef input As ReadOnlyTensorSpan(Of T), lengths As ReadOnlySpan(Of IntPtr)) As ReadOnlyTensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Reshape : ReadOnlyTensorSpan * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Reshape (input, lengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; Reshape(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="lengths">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reshape&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Reshape&lt;T&gt; (this System.Numerics.Tensors.Tensor&lt;T&gt; input, scoped ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Reshape&lt;T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Reshape``1(System.Numerics.Tensors.Tensor{``0},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Reshape(Of T) (input As Tensor(Of T), lengths As ReadOnlySpan(Of IntPtr)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Reshape : System.Numerics.Tensors.Tensor&lt;'T&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Reshape (input, lengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Reshape(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" RefType="this" />
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="lengths">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reshape&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Reshape&lt;T&gt; (this in System.Numerics.Tensors.TensorSpan&lt;T&gt; input, scoped ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Reshape&lt;T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; input, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Reshape``1(System.Numerics.Tensors.TensorSpan{``0}@,System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Reshape(Of T) (ByRef input As TensorSpan(Of T), lengths As ReadOnlySpan(Of IntPtr)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Reshape : TensorSpan * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Reshape (input, lengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::TensorSpan&lt;T&gt; Reshape(System::Numerics::Tensors::TensorSpan&lt;T&gt; % input, ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="lengths">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Resize&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Resize&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Resize``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Resize(Of T) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Resize : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan" Usage="System.Numerics.Tensors.Tensor.Resize (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Resize(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Resize&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input, ReadOnlySpan&lt;IntPtr&gt; shape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Resize&lt;T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, valuetype System.ReadOnlySpan`1&lt;native int&gt; shape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Resize``1(System.Numerics.Tensors.Tensor{``0},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function Resize(Of T) (input As Tensor(Of T), shape As ReadOnlySpan(Of IntPtr)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Resize : System.Numerics.Tensors.Tensor&lt;'T&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Resize (input, shape)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Resize(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, ReadOnlySpan&lt;IntPtr&gt; shape);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="shape" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="shape">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Reverse&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, IntPtr axis = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Reverse&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, native int axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Reverse``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Function Reverse(Of T) (ByRef input As ReadOnlyTensorSpan(Of T), Optional axis As IntPtr = -1) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Reverse : ReadOnlyTensorSpan * nativeint -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Reverse (input, axis)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="axis" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Reverse&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination, IntPtr axis = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Reverse&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination, native int axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Reverse``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Function Reverse(Of T) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T), Optional axis As IntPtr = -1) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Reverse : ReadOnlyTensorSpan * TensorSpan * nativeint -&gt; TensorSpan" Usage="System.Numerics.Tensors.Tensor.Reverse (input, destination, axis)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="axis" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Round&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Round&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Round&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Round``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Round(Of T As IFloatingPoint(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Round : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Round input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Round(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Round&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Round&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Round&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Round``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Round(Of T As IFloatingPoint(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Round : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Round (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Round(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;T&gt; (this scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; span, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; span, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SequenceEqual``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of T) (ByRef span As ReadOnlyTensorSpan(Of T), ByRef other As ReadOnlyTensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; bool" Usage="System.Numerics.Tensors.Tensor.SequenceEqual (span, other)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % span, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="other" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="span">To be added.</param>
        <param name="other">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSlice&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; SetSlice&lt;T&gt; (this System.Numerics.Tensors.Tensor&lt;T&gt; tensor, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; values, scoped ReadOnlySpan&lt;System.Buffers.NRange&gt; ranges);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; SetSlice&lt;T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; tensor, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; values, valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NRange&gt; ranges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SetSlice``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.ReadOnlySpan{System.Buffers.NRange})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SetSlice(Of T) (tensor As Tensor(Of T), ByRef values As ReadOnlyTensorSpan(Of T), ranges As ReadOnlySpan(Of NRange)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member SetSlice : System.Numerics.Tensors.Tensor&lt;'T&gt; * ReadOnlyTensorSpan * ReadOnlySpan&lt;System.Buffers.NRange&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.SetSlice (tensor, values, ranges)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ SetSlice(System::Numerics::Tensors::Tensor&lt;T&gt; ^ tensor, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % values, ReadOnlySpan&lt;System::Buffers::NRange&gt; ranges);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" RefType="this" />
        <Parameter Name="values" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="ranges" Type="System.ReadOnlySpan&lt;System.Buffers.NRange&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">To be added.</param>
        <param name="values">To be added.</param>
        <param name="ranges">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSlice&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; SetSlice&lt;T&gt; (this in System.Numerics.Tensors.TensorSpan&lt;T&gt; tensor, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; values, scoped ReadOnlySpan&lt;System.Buffers.NRange&gt; ranges);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; SetSlice&lt;T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; tensor, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; values, valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NRange&gt; ranges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SetSlice``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.ReadOnlySpan{System.Buffers.NRange})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SetSlice(Of T) (ByRef tensor As TensorSpan(Of T), ByRef values As ReadOnlyTensorSpan(Of T), ranges As ReadOnlySpan(Of NRange)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member SetSlice : TensorSpan * ReadOnlyTensorSpan * ReadOnlySpan&lt;System.Buffers.NRange&gt; -&gt; TensorSpan" Usage="System.Numerics.Tensors.Tensor.SetSlice (tensor, values, ranges)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ SetSlice(System::Numerics::Tensors::TensorSpan&lt;T&gt; % tensor, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % values, ReadOnlySpan&lt;System::Buffers::NRange&gt; ranges);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="values" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="ranges" Type="System.ReadOnlySpan&lt;System.Buffers.NRange&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">To be added.</param>
        <param name="values">To be added.</param>
        <param name="ranges">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sigmoid&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Sigmoid&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Sigmoid&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sigmoid``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Sigmoid(Of T As IExponentialFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Sigmoid : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sigmoid input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Sigmoid(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sigmoid&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Sigmoid&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Sigmoid&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sigmoid``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Sigmoid(Of T As IExponentialFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Sigmoid : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sigmoid (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Sigmoid(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Sin&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Sin&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sin``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Sin(Of T As ITrigonometricFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Sin : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sin input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Sin(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Sin&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Sin&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sin``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Sin(Of T As ITrigonometricFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Sin : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sin (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Sin(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sinh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Sinh&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Sinh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sinh``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Sinh(Of T As IHyperbolicFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Sinh : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sinh input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Sinh(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sinh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Sinh&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Sinh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sinh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Sinh(Of T As IHyperbolicFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Sinh : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sinh (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Sinh(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SinPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; SinPi&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; SinPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SinPi``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SinPi(Of T As ITrigonometricFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member SinPi : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.SinPi input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ SinPi(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SinPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; SinPi&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; SinPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SinPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function SinPi(Of T As ITrigonometricFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member SinPi : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.SinPi (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ SinPi(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SoftMax&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; SoftMax&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; SoftMax&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SoftMax``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SoftMax(Of T As IExponentialFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member SoftMax : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.SoftMax input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ SoftMax(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SoftMax&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; SoftMax&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; SoftMax&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SoftMax``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function SoftMax(Of T As IExponentialFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member SoftMax : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.SoftMax (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ SoftMax(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt;[] Split&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, IntPtr numSplits, IntPtr axis);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt;[] Split&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, native int numSplits, native int axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Split``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split(Of T) (ByRef input As ReadOnlyTensorSpan(Of T), numSplits As IntPtr, axis As IntPtr) As Tensor(Of T)()" />
      <MemberSignature Language="F#" Value="static member Split : ReadOnlyTensorSpan * nativeint * nativeint -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;[]" Usage="System.Numerics.Tensors.Tensor.Split (input, numSplits, axis)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;System::Numerics::Tensors::Tensor&lt;T&gt; ^&gt; ^ Split(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, IntPtr numSplits, IntPtr axis);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="numSplits" Type="System.IntPtr" />
        <Parameter Name="axis" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="numSplits">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sqrt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Sqrt&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Sqrt&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sqrt``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Sqrt(Of T As IRootFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Sqrt : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sqrt input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Sqrt(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sqrt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Sqrt&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Sqrt&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sqrt``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Sqrt(Of T As IRootFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Sqrt : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sqrt (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Sqrt(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Squeeze&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; Squeeze&lt;T&gt; (this in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, int axis = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt; Squeeze&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, int32 axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Squeeze``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Squeeze(Of T) (ByRef input As ReadOnlyTensorSpan(Of T), Optional axis As Integer = -1) As ReadOnlyTensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Squeeze : ReadOnlyTensorSpan * int -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Squeeze (input, axis)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="axis" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Squeeze&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Squeeze&lt;T&gt; (this System.Numerics.Tensors.Tensor&lt;T&gt; input, int axis = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Squeeze&lt;T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, int32 axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Squeeze``1(System.Numerics.Tensors.Tensor{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Squeeze(Of T) (input As Tensor(Of T), Optional axis As Integer = -1) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Squeeze : System.Numerics.Tensors.Tensor&lt;'T&gt; * int -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Squeeze (input, axis)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" RefType="this" />
        <Parameter Name="axis" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Squeeze&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Squeeze&lt;T&gt; (this in System.Numerics.Tensors.TensorSpan&lt;T&gt; input, int axis = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Squeeze&lt;T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; input, int32 axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Squeeze``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Squeeze(Of T) (ByRef input As TensorSpan(Of T), Optional axis As Integer = -1) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Squeeze : TensorSpan * int -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Squeeze (input, axis)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="axis" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Stack&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Stack&lt;T&gt; (ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;T&gt;&gt; input, int axis = 0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Stack&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;class System.Numerics.Tensors.Tensor`1&lt;!!T&gt;&gt; input, int32 axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Stack``1(System.ReadOnlySpan{System.Numerics.Tensors.Tensor{``0}},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Stack(Of T) (input As ReadOnlySpan(Of Tensor(Of T)), Optional axis As Integer = 0) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Stack : ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;'T&gt;&gt; * int -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Stack (input, axis)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;T&gt;&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="axis" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StdDev&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T StdDev&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input) where T : System.Numerics.IFloatingPoint&lt;T&gt;, System.Numerics.IPowerFunctions&lt;T&gt;, System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T StdDev&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;, class System.Numerics.IPowerFunctions`1&lt;!!T&gt;, class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.StdDev``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function StdDev(Of T As {IFloatingPoint(Of T), IPowerFunctions(Of T), IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (ByRef input As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member StdDev : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt; and 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.StdDev input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt;, System::Numerics::IPowerFunctions&lt;T&gt;, System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static T StdDev(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IPowerFunctions&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Subtract&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Subtract&lt;(class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Subtract``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract(Of T As ISubtractionOperators(Of T, T, T)) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Subtract (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Subtract(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Subtract&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input, T val) where T : System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Subtract&lt;(class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, !!T val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Subtract``1(System.Numerics.Tensors.Tensor{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract(Of T As ISubtractionOperators(Of T, T, T)) (input As Tensor(Of T), val As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Subtract (input, val)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Subtract(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, T val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="val" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Subtract&lt;T&gt; (T val, System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Subtract&lt;(class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(!!T val, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Subtract``1(``0,System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract(Of T As ISubtractionOperators(Of T, T, T)) (val As T, input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Subtract : 'T * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Subtract (val, input)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Subtract(T val, System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="val" Type="T" />
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="val">To be added.</param>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Subtract&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Subtract&lt;(class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Subtract``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract(Of T As ISubtractionOperators(Of T, T, T)) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Subtract : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Subtract (left, right, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Subtract(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Subtract&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, T val, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Subtract&lt;(class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, !!T val, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Subtract``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract(Of T As ISubtractionOperators(Of T, T, T)) (ByRef input As ReadOnlyTensorSpan(Of T), val As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Subtract : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Subtract (input, val, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Subtract(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, T val, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="val" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Subtract&lt;T&gt; (T val, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Subtract&lt;(class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(!!T val, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Subtract``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract(Of T As ISubtractionOperators(Of T, T, T)) (val As T, ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Subtract : 'T * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Subtract (val, input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Subtract(T val, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="val" Type="T" />
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="val">To be added.</param>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Sum&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Sum&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sum``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Sum(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (ByRef input As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Sum : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sum input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static T Sum(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Sum&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Sum&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sum``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Sum(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (input As Tensor(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Sum : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sum input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static T Sum(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Tan&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Tan&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Tan``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Tan(Of T As ITrigonometricFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Tan : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Tan input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Tan(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Tan&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Tan&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Tan``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Tan(Of T As ITrigonometricFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Tan : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Tan (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Tan(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tanh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Tanh&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Tanh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Tanh``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Tanh(Of T As IHyperbolicFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Tanh : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Tanh input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Tanh(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tanh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Tanh&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Tanh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Tanh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Tanh(Of T As IHyperbolicFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Tanh : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Tanh (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Tanh(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TanPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; TanPi&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; TanPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.TanPi``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TanPi(Of T As ITrigonometricFunctions(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member TanPi : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.TanPi input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ TanPi(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TanPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; TanPi&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; TanPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.TanPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TanPi(Of T As ITrigonometricFunctions(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member TanPi : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.TanPi (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ TanPi(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string ToString&lt;T&gt; (this in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; span, scoped ReadOnlySpan&lt;IntPtr&gt; maximumLengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; span, valuetype System.ReadOnlySpan`1&lt;native int&gt; maximumLengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ToString``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToString(Of T) (ByRef span As ReadOnlyTensorSpan(Of T), maximumLengths As ReadOnlySpan(Of IntPtr)) As String" />
      <MemberSignature Language="F#" Value="static member ToString : ReadOnlyTensorSpan * ReadOnlySpan&lt;nativeint&gt; -&gt; string" Usage="System.Numerics.Tensors.Tensor.ToString (span, maximumLengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::String ^ ToString(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % span, ReadOnlySpan&lt;IntPtr&gt; maximumLengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="maximumLengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="span">To be added.</param>
        <param name="maximumLengths">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string ToString&lt;T&gt; (this in System.Numerics.Tensors.TensorSpan&lt;T&gt; span, scoped ReadOnlySpan&lt;IntPtr&gt; maximumLengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString&lt;T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; span, valuetype System.ReadOnlySpan`1&lt;native int&gt; maximumLengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ToString``1(System.Numerics.Tensors.TensorSpan{``0}@,System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToString(Of T) (ByRef span As TensorSpan(Of T), maximumLengths As ReadOnlySpan(Of IntPtr)) As String" />
      <MemberSignature Language="F#" Value="static member ToString : TensorSpan * ReadOnlySpan&lt;nativeint&gt; -&gt; string" Usage="System.Numerics.Tensors.Tensor.ToString (span, maximumLengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::String ^ ToString(System::Numerics::Tensors::TensorSpan&lt;T&gt; % span, ReadOnlySpan&lt;IntPtr&gt; maximumLengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="maximumLengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="span">To be added.</param>
        <param name="maximumLengths">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrailingZeroCount&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; TrailingZeroCount&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; TrailingZeroCount&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.TrailingZeroCount``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TrailingZeroCount(Of T As IBinaryInteger(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member TrailingZeroCount : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.TrailingZeroCount input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ TrailingZeroCount(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrailingZeroCount&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; TrailingZeroCount&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; TrailingZeroCount&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.TrailingZeroCount``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrailingZeroCount(Of T As IBinaryInteger(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member TrailingZeroCount : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.TrailingZeroCount (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ TrailingZeroCount(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Transpose&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Transpose&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Transpose&lt;T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Transpose``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Transpose(Of T) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Transpose : System.Numerics.Tensors.Tensor&lt;'T&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Transpose input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Transpose(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Truncate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Truncate&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Truncate&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Truncate``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Truncate(Of T As IFloatingPoint(Of T)) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Truncate : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Truncate input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Truncate(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Truncate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Truncate&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Truncate&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Truncate``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Truncate(Of T As IFloatingPoint(Of T)) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Truncate : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Truncate (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Truncate(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryBroadcastTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryBroadcastTo&lt;T&gt; (this in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryBroadcastTo&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.TryBroadcastTo``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TryBroadcastTo(Of T) (ByRef input As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryBroadcastTo : ReadOnlyTensorSpan * TensorSpan -&gt; bool" Usage="System.Numerics.Tensors.Tensor.TryBroadcastTo (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryBroadcastTo(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryBroadcastTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryBroadcastTo&lt;T&gt; (this System.Numerics.Tensors.Tensor&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryBroadcastTo&lt;T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.TryBroadcastTo``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TryBroadcastTo(Of T) (input As Tensor(Of T), ByRef destination As TensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryBroadcastTo : System.Numerics.Tensors.Tensor&lt;'T&gt; * TensorSpan -&gt; bool" Usage="System.Numerics.Tensors.Tensor.TryBroadcastTo (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryBroadcastTo(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" RefType="this" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryBroadcastTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryBroadcastTo&lt;T&gt; (this in System.Numerics.Tensors.TensorSpan&lt;T&gt; input, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryBroadcastTo&lt;T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; input, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.TryBroadcastTo``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TryBroadcastTo(Of T) (ByRef input As TensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryBroadcastTo : TensorSpan * TensorSpan -&gt; bool" Usage="System.Numerics.Tensors.Tensor.TryBroadcastTo (input, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryBroadcastTo(System::Numerics::Tensors::TensorSpan&lt;T&gt; % input, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unsqueeze&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; Unsqueeze&lt;T&gt; (this in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; input, int axis);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt; Unsqueeze&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; input, int32 axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Unsqueeze``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Unsqueeze(Of T) (ByRef input As ReadOnlyTensorSpan(Of T), axis As Integer) As ReadOnlyTensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Unsqueeze : ReadOnlyTensorSpan * int -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Unsqueeze (input, axis)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; Unsqueeze(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % input, int axis);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="axis" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unsqueeze&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Unsqueeze&lt;T&gt; (this System.Numerics.Tensors.Tensor&lt;T&gt; input, int axis);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Unsqueeze&lt;T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, int32 axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Unsqueeze``1(System.Numerics.Tensors.Tensor{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Unsqueeze(Of T) (input As Tensor(Of T), axis As Integer) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Unsqueeze : System.Numerics.Tensors.Tensor&lt;'T&gt; * int -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Unsqueeze (input, axis)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Unsqueeze(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, int axis);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" RefType="this" />
        <Parameter Name="axis" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unsqueeze&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Unsqueeze&lt;T&gt; (this in System.Numerics.Tensors.TensorSpan&lt;T&gt; input, int axis);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Unsqueeze&lt;T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; input, int32 axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Unsqueeze``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Unsqueeze(Of T) (ByRef input As TensorSpan(Of T), axis As Integer) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Unsqueeze : TensorSpan * int -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Unsqueeze (input, axis)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::TensorSpan&lt;T&gt; Unsqueeze(System::Numerics::Tensors::TensorSpan&lt;T&gt; % input, int axis);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="axis" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Xor&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Xor&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Xor``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Xor(Of T As IBitwiseOperators(Of T, T, T)) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Xor : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Xor (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Xor(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Xor&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; left, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; right, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Xor&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; left, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; right, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Xor``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Xor(Of T As IBitwiseOperators(Of T, T, T)) (ByRef left As ReadOnlyTensorSpan(Of T), ByRef right As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Xor : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Xor (left, right, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Xor(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % left, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % right, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <param name="destination">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
