<Type Name="Tensor" FullName="System.Numerics.Tensors.Tensor">
  <TypeSignature Language="C#" Value="public static class Tensor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Tensor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Tensors.Tensor" />
  <TypeSignature Language="VB.NET" Value="Public Module Tensor" />
  <TypeSignature Language="F#" Value="type Tensor = class" />
  <TypeSignature Language="C++ CLI" Value="public ref class Tensor abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Numerics.Tensors</AssemblyName>
    <AssemblyVersion>9.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>To be added.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Add&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Add&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Add&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Add``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Add(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Add (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Add(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Add&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input, T val) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Add&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, !!T val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Add``1(System.Numerics.Tensors.Tensor{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (input As Tensor(Of T), val As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Add (input, val)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Add(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, T val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="val" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Add&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; left, System.Numerics.Tensors.TensorSpan&lt;T&gt; right) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Add&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; left, valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Add``1(System.Numerics.Tensors.TensorSpan{``0},System.Numerics.Tensors.TensorSpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Add(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (left As TensorSpan(Of T), right As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; * System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Add (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; Add(System::Numerics::Tensors::TensorSpan&lt;T&gt; left, System::Numerics::Tensors::TensorSpan&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Add&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; input, T val) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Add&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; input, !!T val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Add``1(System.Numerics.Tensors.TensorSpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (input As TensorSpan(Of T), val As T) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Add (input, val)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; Add(System::Numerics::Tensors::TensorSpan&lt;T&gt; input, T val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="val" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddInPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; AddInPlace&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; AddInPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.AddInPlace``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddInPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member AddInPlace : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.AddInPlace (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ AddInPlace(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddInPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; AddInPlace&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input, T val) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; AddInPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, !!T val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.AddInPlace``1(System.Numerics.Tensors.Tensor{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddInPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (input As Tensor(Of T), val As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member AddInPlace : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.AddInPlace (input, val)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ AddInPlace(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, T val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="val" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddInPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; AddInPlace&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; left, System.Numerics.Tensors.TensorSpan&lt;T&gt; right) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; AddInPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; left, valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.AddInPlace``1(System.Numerics.Tensors.TensorSpan{``0},System.Numerics.Tensors.TensorSpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddInPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (left As TensorSpan(Of T), right As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member AddInPlace : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; * System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.AddInPlace (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; AddInPlace(System::Numerics::Tensors::TensorSpan&lt;T&gt; left, System::Numerics::Tensors::TensorSpan&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddInPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; AddInPlace&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; input, T val) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; AddInPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; input, !!T val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.AddInPlace``1(System.Numerics.Tensors.TensorSpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddInPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (input As TensorSpan(Of T), val As T) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member AddInPlace : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.AddInPlace (input, val)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; AddInPlace(System::Numerics::Tensors::TensorSpan&lt;T&gt; input, T val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="val" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Broadcast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Broadcast&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input, scoped ReadOnlySpan&lt;IntPtr&gt; shape) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Broadcast&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, valuetype System.ReadOnlySpan`1&lt;native int&gt; shape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Broadcast``1(System.Numerics.Tensors.Tensor{``0},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function Broadcast(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean)}) (input As Tensor(Of T), shape As ReadOnlySpan(Of IntPtr)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Broadcast : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.Broadcast (input, shape)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Broadcast(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, ReadOnlySpan&lt;IntPtr&gt; shape);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="shape" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="shape">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concatenate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Concatenate&lt;T&gt; (ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;T&gt;&gt; tensors, int axis = 0) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Concatenate&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;class System.Numerics.Tensors.Tensor`1&lt;!!T&gt;&gt; tensors, int32 axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Concatenate``1(System.ReadOnlySpan{System.Numerics.Tensors.Tensor{``0}},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Concatenate(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean)}) (tensors As ReadOnlySpan(Of Tensor(Of T)), Optional axis As Integer = 0) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Concatenate : ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;'T&gt;&gt; * int -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.Concatenate (tensors, axis)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensors" Type="System.ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;T&gt;&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="axis" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensors">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Cos&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Cos&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Cos``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Cos(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ITrigonometricFunctions(Of T)}) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Cos : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Cos input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Cos(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Cos&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Cos&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Cos``1(System.Numerics.Tensors.TensorSpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Cos(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ITrigonometricFunctions(Of T)}) (input As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Cos : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Cos input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; Cos(System::Numerics::Tensors::TensorSpan&lt;T&gt; input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CosInPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CosInPlace&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CosInPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CosInPlace``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function CosInPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ITrigonometricFunctions(Of T)}) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CosInPlace : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CosInPlace input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ CosInPlace(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CosInPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; CosInPlace&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; CosInPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CosInPlace``1(System.Numerics.Tensors.TensorSpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function CosInPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ITrigonometricFunctions(Of T)}) (input As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member CosInPlace : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CosInPlace input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; CosInPlace(System::Numerics::Tensors::TensorSpan&lt;T&gt; input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Create&lt;T&gt; (scoped ReadOnlySpan&lt;IntPtr&gt; lengths, bool pinned = false) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Create&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Create``1(System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Create(Of T As IEquatable(Of T)) (lengths As ReadOnlySpan(Of IntPtr), Optional pinned As Boolean = false) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Create : ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Create (lengths, pinned)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="lengths">To be added.</param>
        <param name="pinned">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Create&lt;T&gt; (T[] values, scoped ReadOnlySpan&lt;IntPtr&gt; lengths) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Create&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(!!T[] values, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Create``1(``0[],System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function Create(Of T As IEquatable(Of T)) (values As T(), lengths As ReadOnlySpan(Of IntPtr)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Create : 'T[] * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Create (values, lengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Create(cli::array &lt;T&gt; ^ values, ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="T[]" />
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="values">To be added.</param>
        <param name="lengths">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Create&lt;T&gt; (scoped ReadOnlySpan&lt;IntPtr&gt; lengths, scoped ReadOnlySpan&lt;IntPtr&gt; strides, bool pinned = false) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Create&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Create``1(System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Create(Of T As IEquatable(Of T)) (lengths As ReadOnlySpan(Of IntPtr), strides As ReadOnlySpan(Of IntPtr), Optional pinned As Boolean = false) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Create : ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Create (lengths, strides, pinned)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="lengths">To be added.</param>
        <param name="strides">To be added.</param>
        <param name="pinned">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Create&lt;T&gt; (T[] values, scoped ReadOnlySpan&lt;IntPtr&gt; lengths, scoped ReadOnlySpan&lt;IntPtr&gt; strides) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Create&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(!!T[] values, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Create``1(``0[],System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function Create(Of T As IEquatable(Of T)) (values As T(), lengths As ReadOnlySpan(Of IntPtr), strides As ReadOnlySpan(Of IntPtr)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Create : 'T[] * ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Create (values, lengths, strides)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Create(cli::array &lt;T&gt; ^ values, ReadOnlySpan&lt;IntPtr&gt; lengths, ReadOnlySpan&lt;IntPtr&gt; strides);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="T[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="values">To be added.</param>
        <param name="lengths">To be added.</param>
        <param name="strides">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAndFillGaussianNormalDistribution&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CreateAndFillGaussianNormalDistribution&lt;T&gt; (scoped ReadOnlySpan&lt;IntPtr&gt; lengths) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CreateAndFillGaussianNormalDistribution&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CreateAndFillGaussianNormalDistribution``1(System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateAndFillGaussianNormalDistribution(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IFloatingPoint(Of T)}) (lengths As ReadOnlySpan(Of IntPtr)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CreateAndFillGaussianNormalDistribution : ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CreateAndFillGaussianNormalDistribution lengths" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ CreateAndFillGaussianNormalDistribution(ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="lengths">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAndFillUniformDistribution&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CreateAndFillUniformDistribution&lt;T&gt; (scoped ReadOnlySpan&lt;IntPtr&gt; lengths) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CreateAndFillUniformDistribution&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CreateAndFillUniformDistribution``1(System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateAndFillUniformDistribution(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IFloatingPoint(Of T)}) (lengths As ReadOnlySpan(Of IntPtr)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CreateAndFillUniformDistribution : ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CreateAndFillUniformDistribution lengths" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ CreateAndFillUniformDistribution(ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="lengths">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateFromEnumerable&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CreateFromEnumerable&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; data) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CreateFromEnumerable&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CreateFromEnumerable``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateFromEnumerable(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean)}) (data As IEnumerable(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CreateFromEnumerable : seq&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.CreateFromEnumerable data" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ CreateFromEnumerable(System::Collections::Generic::IEnumerable&lt;T&gt; ^ data);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="data">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateUninitialized&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CreateUninitialized&lt;T&gt; (scoped ReadOnlySpan&lt;IntPtr&gt; lengths, bool pinned = false) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CreateUninitialized&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CreateUninitialized``1(System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateUninitialized(Of T As IEquatable(Of T)) (lengths As ReadOnlySpan(Of IntPtr), Optional pinned As Boolean = false) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CreateUninitialized : ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CreateUninitialized (lengths, pinned)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="lengths">To be added.</param>
        <param name="pinned">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateUninitialized&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CreateUninitialized&lt;T&gt; (scoped ReadOnlySpan&lt;IntPtr&gt; lengths, scoped ReadOnlySpan&lt;IntPtr&gt; strides, bool pinned = false) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CreateUninitialized&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CreateUninitialized``1(System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateUninitialized(Of T As IEquatable(Of T)) (lengths As ReadOnlySpan(Of IntPtr), strides As ReadOnlySpan(Of IntPtr), Optional pinned As Boolean = false) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CreateUninitialized : ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CreateUninitialized (lengths, strides, pinned)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="lengths">To be added.</param>
        <param name="strides">To be added.</param>
        <param name="pinned">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Divide&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Divide&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Divide``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Divide(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IDivisionOperators(Of T, T, T)}) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Divide (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IDivisionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Divide(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Divide&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input, T val) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Divide&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, !!T val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Divide``1(System.Numerics.Tensors.Tensor{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Divide(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IDivisionOperators(Of T, T, T)}) (input As Tensor(Of T), val As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Divide (input, val)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IDivisionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Divide(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, T val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="val" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Divide&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; left, System.Numerics.Tensors.TensorSpan&lt;T&gt; right) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Divide&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; left, valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Divide``1(System.Numerics.Tensors.TensorSpan{``0},System.Numerics.Tensors.TensorSpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Divide(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IDivisionOperators(Of T, T, T)}) (left As TensorSpan(Of T), right As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; * System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Divide (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IDivisionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; Divide(System::Numerics::Tensors::TensorSpan&lt;T&gt; left, System::Numerics::Tensors::TensorSpan&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Divide&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; input, T val) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Divide&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; input, !!T val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Divide``1(System.Numerics.Tensors.TensorSpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Divide(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IDivisionOperators(Of T, T, T)}) (input As TensorSpan(Of T), val As T) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Divide (input, val)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IDivisionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; Divide(System::Numerics::Tensors::TensorSpan&lt;T&gt; input, T val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="val" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Divide&lt;T&gt; (T val, System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Divide&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(!!T val, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Divide``1(``0,System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Divide(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IDivisionOperators(Of T, T, T)}) (val As T, input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Divide : 'T * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Divide (val, input)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IDivisionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Divide(T val, System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="val" Type="T" />
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="val">To be added.</param>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Divide&lt;T&gt; (T val, System.Numerics.Tensors.TensorSpan&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Divide&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(!!T val, valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Divide``1(``0,System.Numerics.Tensors.TensorSpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Divide(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IDivisionOperators(Of T, T, T)}) (val As T, input As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Divide : 'T * System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Divide (val, input)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IDivisionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; Divide(T val, System::Numerics::Tensors::TensorSpan&lt;T&gt; input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="val" Type="T" />
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="val">To be added.</param>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideInPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; DivideInPlace&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; DivideInPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.DivideInPlace``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function DivideInPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IDivisionOperators(Of T, T, T)}) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member DivideInPlace : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.DivideInPlace (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IDivisionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ DivideInPlace(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideInPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; DivideInPlace&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input, T val) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; DivideInPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, !!T val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.DivideInPlace``1(System.Numerics.Tensors.Tensor{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function DivideInPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IDivisionOperators(Of T, T, T)}) (input As Tensor(Of T), val As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member DivideInPlace : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.DivideInPlace (input, val)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IDivisionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ DivideInPlace(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, T val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="val" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideInPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; DivideInPlace&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; left, System.Numerics.Tensors.TensorSpan&lt;T&gt; right) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; DivideInPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; left, valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.DivideInPlace``1(System.Numerics.Tensors.TensorSpan{``0},System.Numerics.Tensors.TensorSpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function DivideInPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IDivisionOperators(Of T, T, T)}) (left As TensorSpan(Of T), right As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member DivideInPlace : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; * System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.DivideInPlace (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IDivisionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; DivideInPlace(System::Numerics::Tensors::TensorSpan&lt;T&gt; left, System::Numerics::Tensors::TensorSpan&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideInPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; DivideInPlace&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; input, T val) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; DivideInPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; input, !!T val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.DivideInPlace``1(System.Numerics.Tensors.TensorSpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function DivideInPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IDivisionOperators(Of T, T, T)}) (input As TensorSpan(Of T), val As T) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member DivideInPlace : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.DivideInPlace (input, val)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IDivisionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; DivideInPlace(System::Numerics::Tensors::TensorSpan&lt;T&gt; input, T val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="val" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideInPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; DivideInPlace&lt;T&gt; (T val, System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; DivideInPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(!!T val, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.DivideInPlace``1(``0,System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function DivideInPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IDivisionOperators(Of T, T, T)}) (val As T, input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member DivideInPlace : 'T * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.DivideInPlace (val, input)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IDivisionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ DivideInPlace(T val, System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="val" Type="T" />
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="val">To be added.</param>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DivideInPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; DivideInPlace&lt;T&gt; (T val, System.Numerics.Tensors.TensorSpan&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; DivideInPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(!!T val, valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.DivideInPlace``1(``0,System.Numerics.Tensors.TensorSpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function DivideInPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IDivisionOperators(Of T, T, T)}) (val As T, input As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member DivideInPlace : 'T * System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.DivideInPlace (val, input)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IDivisionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; DivideInPlace(T val, System::Numerics::Tensors::TensorSpan&lt;T&gt; input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="val" Type="T" />
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="val">To be added.</param>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilteredUpdate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; FilteredUpdate&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; tensor, System.Numerics.Tensors.Tensor&lt;bool&gt; filter, System.Numerics.Tensors.Tensor&lt;T&gt; values) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; FilteredUpdate&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; tensor, class System.Numerics.Tensors.Tensor`1&lt;bool&gt; filter, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.FilteredUpdate``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{System.Boolean},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function FilteredUpdate(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean)}) (tensor As Tensor(Of T), filter As Tensor(Of Boolean), values As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member FilteredUpdate : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;bool&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.FilteredUpdate (tensor, filter, values)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ FilteredUpdate(System::Numerics::Tensors::Tensor&lt;T&gt; ^ tensor, System::Numerics::Tensors::Tensor&lt;bool&gt; ^ filter, System::Numerics::Tensors::Tensor&lt;T&gt; ^ values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="filter" Type="System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;" />
        <Parameter Name="values" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">To be added.</param>
        <param name="filter">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilteredUpdate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; FilteredUpdate&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; tensor, System.Numerics.Tensors.Tensor&lt;bool&gt; filter, T value) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; FilteredUpdate&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; tensor, class System.Numerics.Tensors.Tensor`1&lt;bool&gt; filter, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.FilteredUpdate``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{System.Boolean},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function FilteredUpdate(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean)}) (tensor As Tensor(Of T), filter As Tensor(Of Boolean), value As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member FilteredUpdate : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;bool&gt; * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.FilteredUpdate (tensor, filter, value)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ FilteredUpdate(System::Numerics::Tensors::Tensor&lt;T&gt; ^ tensor, System::Numerics::Tensors::Tensor&lt;bool&gt; ^ filter, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="filter" Type="System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">To be added.</param>
        <param name="filter">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;bool&gt; GreaterThan&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;bool&gt; GreaterThan&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThan``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThan(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IComparisonOperators(Of T, T, Boolean)}) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member GreaterThan : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;bool&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThan (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;bool&gt; ^ GreaterThan(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;bool&gt; GreaterThan&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, T right) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;bool&gt; GreaterThan&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, !!T right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThan``1(System.Numerics.Tensors.Tensor{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThan(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IComparisonOperators(Of T, T, Boolean)}) (left As Tensor(Of T), right As T) As Tensor(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member GreaterThan : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.Tensor&lt;bool&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThan (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;bool&gt; ^ GreaterThan(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, T right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool GreaterThanAll&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GreaterThanAll&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThanAll``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThanAll(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IComparisonOperators(Of T, T, Boolean)}) (left As Tensor(Of T), right As Tensor(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member GreaterThanAll : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThanAll (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool GreaterThanAll(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool GreaterThanAny&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GreaterThanAny&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThanAny``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThanAny(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IComparisonOperators(Of T, T, Boolean)}) (left As Tensor(Of T), right As Tensor(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member GreaterThanAny : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThanAny (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool GreaterThanAny(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;bool&gt; LessThan&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;bool&gt; LessThan&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThan``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThan(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IComparisonOperators(Of T, T, Boolean)}) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member LessThan : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;bool&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThan (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;bool&gt; ^ LessThan(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;bool&gt; LessThan&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, T right) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;bool&gt; LessThan&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, !!T right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThan``1(System.Numerics.Tensors.Tensor{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThan(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IComparisonOperators(Of T, T, Boolean)}) (left As Tensor(Of T), right As T) As Tensor(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member LessThan : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.Tensor&lt;bool&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThan (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;bool&gt; ^ LessThan(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, T right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool LessThanAll&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool LessThanAll&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThanAll``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThanAll(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IComparisonOperators(Of T, T, Boolean)}) (left As Tensor(Of T), right As Tensor(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member LessThanAll : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThanAll (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool LessThanAll(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool LessThanAny&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool LessThanAny&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThanAny``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThanAny(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IComparisonOperators(Of T, T, Boolean)}) (left As Tensor(Of T), right As Tensor(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member LessThanAny : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)&gt; -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThanAny (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool LessThanAny(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Log&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Log&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Log(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ILogarithmicFunctions(Of T)}) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Log(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Log&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Log&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log``1(System.Numerics.Tensors.TensorSpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Log(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ILogarithmicFunctions(Of T)}) (input As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; Log(System::Numerics::Tensors::TensorSpan&lt;T&gt; input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Log10&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Log10&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log10``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Log10(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ILogarithmicFunctions(Of T)}) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log10 input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Log10(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Log10&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Log10&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log10``1(System.Numerics.Tensors.TensorSpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Log10(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ILogarithmicFunctions(Of T)}) (input As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log10 input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; Log10(System::Numerics::Tensors::TensorSpan&lt;T&gt; input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10InPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Log10InPlace&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Log10InPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log10InPlace``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Log10InPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ILogarithmicFunctions(Of T)}) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Log10InPlace : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log10InPlace input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Log10InPlace(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10InPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Log10InPlace&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Log10InPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log10InPlace``1(System.Numerics.Tensors.TensorSpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Log10InPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ILogarithmicFunctions(Of T)}) (input As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Log10InPlace : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log10InPlace input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; Log10InPlace(System::Numerics::Tensors::TensorSpan&lt;T&gt; input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Log2&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Log2&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log2``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Log2(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ILogarithmicFunctions(Of T)}) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Log2 : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log2 input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Log2(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Log2&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Log2&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log2``1(System.Numerics.Tensors.TensorSpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Log2(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ILogarithmicFunctions(Of T)}) (input As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Log2 : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log2 input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; Log2(System::Numerics::Tensors::TensorSpan&lt;T&gt; input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log2InPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Log2InPlace&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Log2InPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log2InPlace``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Log2InPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ILogarithmicFunctions(Of T)}) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Log2InPlace : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log2InPlace input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Log2InPlace(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log2InPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Log2InPlace&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Log2InPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log2InPlace``1(System.Numerics.Tensors.TensorSpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Log2InPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ILogarithmicFunctions(Of T)}) (input As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Log2InPlace : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log2InPlace input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; Log2InPlace(System::Numerics::Tensors::TensorSpan&lt;T&gt; input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogInPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; LogInPlace&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; LogInPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LogInPlace``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function LogInPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ILogarithmicFunctions(Of T)}) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member LogInPlace : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.LogInPlace input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ LogInPlace(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogInPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; LogInPlace&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; LogInPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LogInPlace``1(System.Numerics.Tensors.TensorSpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function LogInPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ILogarithmicFunctions(Of T)}) (input As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member LogInPlace : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.LogInPlace input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; LogInPlace(System::Numerics::Tensors::TensorSpan&lt;T&gt; input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Mean&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Mean&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Mean&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Mean``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Mean(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IFloatingPoint(Of T)}) (input As Tensor(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Mean : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Mean input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IFloatingPoint&lt;T&gt; static T Mean(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Mean&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Mean&lt;T,TResult&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.INumber&lt;T&gt; where TResult : IEquatable&lt;TResult&gt;, System.Numerics.IEqualityOperators&lt;TResult,TResult,bool&gt;, System.Numerics.IFloatingPoint&lt;TResult&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Mean&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.INumber`1&lt;!!T&gt;) T, (class System.IEquatable`1&lt;!!TResult&gt;, class System.Numerics.IEqualityOperators`3&lt;!!TResult, !!TResult, bool&gt;, class System.Numerics.IFloatingPoint`1&lt;!!TResult&gt;) TResult&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Mean``2(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Mean(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), INumber(Of T)}, TResult As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), INumber(Of T)}) (input As Tensor(Of T)) As TResult" />
      <MemberSignature Language="F#" Value="static member Mean : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; 'Result (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.INumber&lt;'T&gt; and 'Result :&gt; IEquatable&lt;'Result&gt; and 'Result :&gt; System.Numerics.IEqualityOperators&lt;'Result, 'Result, bool&gt; and 'Result :&gt; System.Numerics.IFloatingPoint&lt;'Result&gt;)" Usage="System.Numerics.Tensors.Tensor.Mean input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TResult&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::INumber&lt;T&gt; where TResult : IEquatable&lt;TResult&gt;, System::Numerics::IEqualityOperators&lt;TResult, TResult, bool&gt;, System::Numerics::IFloatingPoint&lt;TResult&gt; static TResult Mean(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TResult">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;TResult&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;TResult,TResult,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;TResult&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiply&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Multiply&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Multiply&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Multiply``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Multiply(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Multiply (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Multiply(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiply&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Multiply&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input, T val) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Multiply&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, !!T val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Multiply``1(System.Numerics.Tensors.Tensor{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Multiply(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (input As Tensor(Of T), val As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Multiply (input, val)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Multiply(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, T val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="val" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiply&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Multiply&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; left, System.Numerics.Tensors.TensorSpan&lt;T&gt; right) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Multiply&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; left, valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Multiply``1(System.Numerics.Tensors.TensorSpan{``0},System.Numerics.Tensors.TensorSpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Multiply(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (left As TensorSpan(Of T), right As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; * System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Multiply (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; Multiply(System::Numerics::Tensors::TensorSpan&lt;T&gt; left, System::Numerics::Tensors::TensorSpan&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiply&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Multiply&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; input, T val) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Multiply&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; input, !!T val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Multiply``1(System.Numerics.Tensors.TensorSpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Multiply(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (input As TensorSpan(Of T), val As T) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Multiply (input, val)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; Multiply(System::Numerics::Tensors::TensorSpan&lt;T&gt; input, T val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="val" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyInPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; MultiplyInPlace&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; MultiplyInPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MultiplyInPlace``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function MultiplyInPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member MultiplyInPlace : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MultiplyInPlace (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ MultiplyInPlace(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyInPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; MultiplyInPlace&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input, T val) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; MultiplyInPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, !!T val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MultiplyInPlace``1(System.Numerics.Tensors.Tensor{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function MultiplyInPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (input As Tensor(Of T), val As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member MultiplyInPlace : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MultiplyInPlace (input, val)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ MultiplyInPlace(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, T val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="val" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyInPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; MultiplyInPlace&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; left, System.Numerics.Tensors.TensorSpan&lt;T&gt; right) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; MultiplyInPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; left, valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MultiplyInPlace``1(System.Numerics.Tensors.TensorSpan{``0},System.Numerics.Tensors.TensorSpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function MultiplyInPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (left As TensorSpan(Of T), right As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member MultiplyInPlace : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; * System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MultiplyInPlace (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; MultiplyInPlace(System::Numerics::Tensors::TensorSpan&lt;T&gt; left, System::Numerics::Tensors::TensorSpan&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MultiplyInPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; MultiplyInPlace&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; input, T val) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; MultiplyInPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; input, !!T val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MultiplyInPlace``1(System.Numerics.Tensors.TensorSpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function MultiplyInPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (input As TensorSpan(Of T), val As T) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member MultiplyInPlace : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MultiplyInPlace (input, val)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; MultiplyInPlace(System::Numerics::Tensors::TensorSpan&lt;T&gt; input, T val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="val" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Norm&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Norm&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Norm&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Norm``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Norm(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IRootFunctions(Of T)}) (input As Tensor(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Norm : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Norm input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IRootFunctions&lt;T&gt; static T Norm(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Norm&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Norm&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Norm&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Norm``1(System.Numerics.Tensors.TensorSpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Norm(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IRootFunctions(Of T)}) (input As TensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Norm : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Norm input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IRootFunctions&lt;T&gt; static T Norm(System::Numerics::Tensors::TensorSpan&lt;T&gt; input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Permute&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Permute&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input, scoped ReadOnlySpan&lt;int&gt; axis) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Permute&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, valuetype System.ReadOnlySpan`1&lt;int32&gt; axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Permute``1(System.Numerics.Tensors.Tensor{``0},System.ReadOnlySpan{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Function Permute(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean)}) (input As Tensor(Of T), axis As ReadOnlySpan(Of Integer)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Permute : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; * ReadOnlySpan&lt;int&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.Permute (input, axis)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Permute(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, ReadOnlySpan&lt;int&gt; axis);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="axis" Type="System.ReadOnlySpan&lt;System.Int32&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reshape&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Reshape&lt;T&gt; (this System.Numerics.Tensors.Tensor&lt;T&gt; input, scoped ReadOnlySpan&lt;IntPtr&gt; lengths) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Reshape&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Reshape``1(System.Numerics.Tensors.Tensor{``0},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Reshape(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean)}) (input As Tensor(Of T), lengths As ReadOnlySpan(Of IntPtr)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Reshape : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.Reshape (input, lengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Reshape(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" RefType="this" />
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="lengths">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reshape&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Reshape&lt;T&gt; (this System.Numerics.Tensors.TensorSpan&lt;T&gt; input, scoped ReadOnlySpan&lt;IntPtr&gt; lengths) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Reshape&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; input, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Reshape``1(System.Numerics.Tensors.TensorSpan{``0},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Reshape(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean)}) (input As TensorSpan(Of T), lengths As ReadOnlySpan(Of IntPtr)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Reshape : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.Reshape (input, lengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::TensorSpan&lt;T&gt; Reshape(System::Numerics::Tensors::TensorSpan&lt;T&gt; input, ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="lengths">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Resize&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input, scoped ReadOnlySpan&lt;IntPtr&gt; shape) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Resize&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, valuetype System.ReadOnlySpan`1&lt;native int&gt; shape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Resize``1(System.Numerics.Tensors.Tensor{``0},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function Resize(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean)}) (input As Tensor(Of T), shape As ReadOnlySpan(Of IntPtr)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Resize : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.Resize (input, shape)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Resize(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, ReadOnlySpan&lt;IntPtr&gt; shape);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="shape" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="shape">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Resize&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; input, scoped ReadOnlySpan&lt;IntPtr&gt; shape) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Resize&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; input, valuetype System.ReadOnlySpan`1&lt;native int&gt; shape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Resize``1(System.Numerics.Tensors.TensorSpan{``0},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function Resize(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean)}) (input As TensorSpan(Of T), shape As ReadOnlySpan(Of IntPtr)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Resize : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.Resize (input, shape)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; Resize(System::Numerics::Tensors::TensorSpan&lt;T&gt; input, ReadOnlySpan&lt;IntPtr&gt; shape);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="shape" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="shape">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Reverse&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input, IntPtr axis = -1) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Reverse&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, native int axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Reverse``1(System.Numerics.Tensors.Tensor{``0},System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Function Reverse(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean)}) (input As Tensor(Of T), Optional axis As IntPtr = -1) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Reverse : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; * nativeint -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.Reverse (input, axis)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="axis" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Reverse&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; input, IntPtr axis = -1) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Reverse&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; input, native int axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Reverse``1(System.Numerics.Tensors.TensorSpan{``0},System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Function Reverse(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean)}) (input As TensorSpan(Of T), Optional axis As IntPtr = -1) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Reverse : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; * nativeint -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.Reverse (input, axis)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="axis" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;bool&gt; SequenceEqual&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;bool&gt; SequenceEqual&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SequenceEqual``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SequenceEqual(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean)}) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;bool&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.SequenceEqual (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;bool&gt; ^ SequenceEqual(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSlice&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; SetSlice&lt;T&gt; (this System.Numerics.Tensors.Tensor&lt;T&gt; tensor, System.Numerics.Tensors.Tensor&lt;T&gt; values, scoped ReadOnlySpan&lt;System.Buffers.NRange&gt; ranges) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; SetSlice&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; tensor, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; values, valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NRange&gt; ranges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SetSlice``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0},System.ReadOnlySpan{System.Buffers.NRange})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SetSlice(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean)}) (tensor As Tensor(Of T), values As Tensor(Of T), ranges As ReadOnlySpan(Of NRange)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member SetSlice : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; * ReadOnlySpan&lt;System.Buffers.NRange&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.SetSlice (tensor, values, ranges)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ SetSlice(System::Numerics::Tensors::Tensor&lt;T&gt; ^ tensor, System::Numerics::Tensors::Tensor&lt;T&gt; ^ values, ReadOnlySpan&lt;System::Buffers::NRange&gt; ranges);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" RefType="this" />
        <Parameter Name="values" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="ranges" Type="System.ReadOnlySpan&lt;System.Buffers.NRange&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">To be added.</param>
        <param name="values">To be added.</param>
        <param name="ranges">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Sin&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Sin&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sin``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Sin(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ITrigonometricFunctions(Of T)}) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Sin : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sin input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Sin(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Sin&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Sin&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sin``1(System.Numerics.Tensors.TensorSpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Sin(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ITrigonometricFunctions(Of T)}) (input As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Sin : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sin input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; Sin(System::Numerics::Tensors::TensorSpan&lt;T&gt; input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SinInPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; SinInPlace&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; SinInPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SinInPlace``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SinInPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ITrigonometricFunctions(Of T)}) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member SinInPlace : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.SinInPlace input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ SinInPlace(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SinInPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; SinInPlace&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; SinInPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SinInPlace``1(System.Numerics.Tensors.TensorSpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SinInPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ITrigonometricFunctions(Of T)}) (input As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member SinInPlace : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.SinInPlace input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; SinInPlace(System::Numerics::Tensors::TensorSpan&lt;T&gt; input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt;[] Split&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input, IntPtr numSplits, IntPtr axis) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt;[] Split&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, native int numSplits, native int axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Split``1(System.Numerics.Tensors.Tensor{``0},System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean)}) (input As Tensor(Of T), numSplits As IntPtr, axis As IntPtr) As Tensor(Of T)()" />
      <MemberSignature Language="F#" Value="static member Split : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; * nativeint * nativeint -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt;[] (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.Split (input, numSplits, axis)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt; static cli::array &lt;System::Numerics::Tensors::Tensor&lt;T&gt; ^&gt; ^ Split(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, IntPtr numSplits, IntPtr axis);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="numSplits" Type="System.IntPtr" />
        <Parameter Name="axis" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="numSplits">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sqrt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Sqrt&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Sqrt&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sqrt``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Sqrt(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IRootFunctions(Of T)}) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Sqrt : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sqrt input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IRootFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Sqrt(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sqrt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Sqrt&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Sqrt&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sqrt``1(System.Numerics.Tensors.TensorSpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Sqrt(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IRootFunctions(Of T)}) (input As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Sqrt : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sqrt input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IRootFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; Sqrt(System::Numerics::Tensors::TensorSpan&lt;T&gt; input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SqrtInPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; SqrtInPlace&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; SqrtInPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SqrtInPlace``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SqrtInPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IRootFunctions(Of T)}) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member SqrtInPlace : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.SqrtInPlace input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IRootFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ SqrtInPlace(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SqrtInPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; SqrtInPlace&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; SqrtInPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SqrtInPlace``1(System.Numerics.Tensors.TensorSpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SqrtInPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IRootFunctions(Of T)}) (input As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member SqrtInPlace : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.SqrtInPlace input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IRootFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; SqrtInPlace(System::Numerics::Tensors::TensorSpan&lt;T&gt; input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Squeeze&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Squeeze&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input, int axis = -1) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Squeeze&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, int32 axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Squeeze``1(System.Numerics.Tensors.Tensor{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Squeeze(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean)}) (input As Tensor(Of T), Optional axis As Integer = -1) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Squeeze : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; * int -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.Squeeze (input, axis)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="axis" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Stack&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Stack&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt;[] input, int axis = 0) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Stack&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt;[] input, int32 axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Stack``1(System.Numerics.Tensors.Tensor{``0}[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Stack(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean)}) (input As Tensor(Of T)(), Optional axis As Integer = 0) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Stack : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt;[] * int -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.Stack (input, axis)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;[]" />
        <Parameter Name="axis" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StdDev&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T StdDev&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IFloatingPoint&lt;T&gt;, System.Numerics.IPowerFunctions&lt;T&gt;, System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T StdDev&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IFloatingPoint`1&lt;!!T&gt;, class System.Numerics.IPowerFunctions`1&lt;!!T&gt;, class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.StdDev``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function StdDev(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IFloatingPoint(Of T), IPowerFunctions(Of T), IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (input As Tensor(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member StdDev : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt; and 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt; and 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.StdDev input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IFloatingPoint&lt;T&gt;, System::Numerics::IPowerFunctions&lt;T&gt;, System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static T StdDev(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IPowerFunctions&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StdDev&lt;T,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult StdDev&lt;T,TResult&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.INumber&lt;T&gt; where TResult : IEquatable&lt;TResult&gt;, System.Numerics.IEqualityOperators&lt;TResult,TResult,bool&gt;, System.Numerics.IFloatingPoint&lt;TResult&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult StdDev&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.INumber`1&lt;!!T&gt;) T, (class System.IEquatable`1&lt;!!TResult&gt;, class System.Numerics.IEqualityOperators`3&lt;!!TResult, !!TResult, bool&gt;, class System.Numerics.IFloatingPoint`1&lt;!!TResult&gt;) TResult&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.StdDev``2(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function StdDev(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), INumber(Of T)}, TResult As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), INumber(Of T)}) (input As Tensor(Of T)) As TResult" />
      <MemberSignature Language="F#" Value="static member StdDev : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; 'Result (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.INumber&lt;'T&gt; and 'Result :&gt; IEquatable&lt;'Result&gt; and 'Result :&gt; System.Numerics.IEqualityOperators&lt;'Result, 'Result, bool&gt; and 'Result :&gt; System.Numerics.IFloatingPoint&lt;'Result&gt;)" Usage="System.Numerics.Tensors.Tensor.StdDev input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T, typename TResult&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::INumber&lt;T&gt; where TResult : IEquatable&lt;TResult&gt;, System::Numerics::IEqualityOperators&lt;TResult, TResult, bool&gt;, System::Numerics::IFloatingPoint&lt;TResult&gt; static TResult StdDev(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TResult">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;TResult&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;TResult,TResult,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;TResult&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <typeparam name="TResult">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Subtract&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Subtract&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Subtract``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ISubtractionOperators(Of T, T, T)}) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Subtract (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Subtract(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Subtract&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input, T val) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Subtract&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, !!T val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Subtract``1(System.Numerics.Tensors.Tensor{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ISubtractionOperators(Of T, T, T)}) (input As Tensor(Of T), val As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Subtract (input, val)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Subtract(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, T val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="val" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Subtract&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; left, System.Numerics.Tensors.TensorSpan&lt;T&gt; right) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Subtract&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; left, valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Subtract``1(System.Numerics.Tensors.TensorSpan{``0},System.Numerics.Tensors.TensorSpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ISubtractionOperators(Of T, T, T)}) (left As TensorSpan(Of T), right As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; * System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Subtract (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; Subtract(System::Numerics::Tensors::TensorSpan&lt;T&gt; left, System::Numerics::Tensors::TensorSpan&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Subtract&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; input, T val) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Subtract&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; input, !!T val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Subtract``1(System.Numerics.Tensors.TensorSpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ISubtractionOperators(Of T, T, T)}) (input As TensorSpan(Of T), val As T) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Subtract (input, val)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; Subtract(System::Numerics::Tensors::TensorSpan&lt;T&gt; input, T val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="val" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Subtract&lt;T&gt; (T val, System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Subtract&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(!!T val, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Subtract``1(``0,System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ISubtractionOperators(Of T, T, T)}) (val As T, input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Subtract : 'T * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Subtract (val, input)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Subtract(T val, System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="val" Type="T" />
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="val">To be added.</param>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Subtract&lt;T&gt; (T val, System.Numerics.Tensors.TensorSpan&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Subtract&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(!!T val, valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Subtract``1(``0,System.Numerics.Tensors.TensorSpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ISubtractionOperators(Of T, T, T)}) (val As T, input As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Subtract : 'T * System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Subtract (val, input)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; Subtract(T val, System::Numerics::Tensors::TensorSpan&lt;T&gt; input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="val" Type="T" />
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="val">To be added.</param>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractInPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; SubtractInPlace&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; left, System.Numerics.Tensors.Tensor&lt;T&gt; right) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; SubtractInPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; left, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SubtractInPlace``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SubtractInPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ISubtractionOperators(Of T, T, T)}) (left As Tensor(Of T), right As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member SubtractInPlace : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.SubtractInPlace (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ SubtractInPlace(System::Numerics::Tensors::Tensor&lt;T&gt; ^ left, System::Numerics::Tensors::Tensor&lt;T&gt; ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="right" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractInPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; SubtractInPlace&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input, T val) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; SubtractInPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, !!T val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SubtractInPlace``1(System.Numerics.Tensors.Tensor{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function SubtractInPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ISubtractionOperators(Of T, T, T)}) (input As Tensor(Of T), val As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member SubtractInPlace : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.SubtractInPlace (input, val)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ SubtractInPlace(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, T val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="val" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractInPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; SubtractInPlace&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; left, System.Numerics.Tensors.TensorSpan&lt;T&gt; right) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; SubtractInPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; left, valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SubtractInPlace``1(System.Numerics.Tensors.TensorSpan{``0},System.Numerics.Tensors.TensorSpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SubtractInPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ISubtractionOperators(Of T, T, T)}) (left As TensorSpan(Of T), right As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member SubtractInPlace : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; * System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.SubtractInPlace (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; SubtractInPlace(System::Numerics::Tensors::TensorSpan&lt;T&gt; left, System::Numerics::Tensors::TensorSpan&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractInPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; SubtractInPlace&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; input, T val) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; SubtractInPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; input, !!T val) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SubtractInPlace``1(System.Numerics.Tensors.TensorSpan{``0},``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function SubtractInPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ISubtractionOperators(Of T, T, T)}) (input As TensorSpan(Of T), val As T) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member SubtractInPlace : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.SubtractInPlace (input, val)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; SubtractInPlace(System::Numerics::Tensors::TensorSpan&lt;T&gt; input, T val);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="val" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="val">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractInPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; SubtractInPlace&lt;T&gt; (T val, System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; SubtractInPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(!!T val, class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SubtractInPlace``1(``0,System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SubtractInPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ISubtractionOperators(Of T, T, T)}) (val As T, input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member SubtractInPlace : 'T * System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.SubtractInPlace (val, input)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ SubtractInPlace(T val, System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="val" Type="T" />
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="val">To be added.</param>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SubtractInPlace&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; SubtractInPlace&lt;T&gt; (T val, System.Numerics.Tensors.TensorSpan&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; SubtractInPlace&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(!!T val, valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SubtractInPlace``1(``0,System.Numerics.Tensors.TensorSpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SubtractInPlace(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), ISubtractionOperators(Of T, T, T)}) (val As T, input As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member SubtractInPlace : 'T * System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.SubtractInPlace (val, input)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; SubtractInPlace(T val, System::Numerics::Tensors::TensorSpan&lt;T&gt; input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="val" Type="T" />
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="val">To be added.</param>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Sum&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Sum&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sum``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Sum(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (input As Tensor(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Sum : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sum input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static T Sum(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Sum&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;, System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Sum&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;, class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sum``1(System.Numerics.Tensors.TensorSpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Sum(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean), IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (input As TensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Sum : System.Numerics.Tensors.TensorSpan&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sum input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt;, System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static T Sum(System::Numerics::Tensors::TensorSpan&lt;T&gt; input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string ToString&lt;T&gt; (this System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; span, scoped ReadOnlySpan&lt;IntPtr&gt; maximumLengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString&lt;T&gt;(valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;native int&gt; maximumLengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ToString``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToString(Of T) (span As ReadOnlyTensorSpan(Of T), maximumLengths As ReadOnlySpan(Of IntPtr)) As String" />
      <MemberSignature Language="F#" Value="static member ToString : System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; string" Usage="System.Numerics.Tensors.Tensor.ToString (span, maximumLengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::String ^ ToString(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; span, ReadOnlySpan&lt;IntPtr&gt; maximumLengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="maximumLengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="span">To be added.</param>
        <param name="maximumLengths">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string ToString&lt;T&gt; (this System.Numerics.Tensors.TensorSpan&lt;T&gt; span, scoped ReadOnlySpan&lt;IntPtr&gt; maximumLengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString&lt;T&gt;(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; span, valuetype System.ReadOnlySpan`1&lt;native int&gt; maximumLengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ToString``1(System.Numerics.Tensors.TensorSpan{``0},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToString(Of T) (span As TensorSpan(Of T), maximumLengths As ReadOnlySpan(Of IntPtr)) As String" />
      <MemberSignature Language="F#" Value="static member ToString : System.Numerics.Tensors.TensorSpan&lt;'T&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; string" Usage="System.Numerics.Tensors.Tensor.ToString (span, maximumLengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::String ^ ToString(System::Numerics::Tensors::TensorSpan&lt;T&gt; span, ReadOnlySpan&lt;IntPtr&gt; maximumLengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="span" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="maximumLengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="span">To be added.</param>
        <param name="maximumLengths">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Transpose&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Transpose&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Transpose&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Transpose``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Transpose(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean)}) (input As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Transpose : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.Transpose input" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Transpose(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unsqueeze&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Unsqueeze&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; input, int axis) where T : IEquatable&lt;T&gt;, System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Unsqueeze&lt;(class System.IEquatable`1&lt;!!T&gt;, class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; input, int32 axis) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Unsqueeze``1(System.Numerics.Tensors.Tensor{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Unsqueeze(Of T As {IEquatable(Of T), IEqualityOperators(Of T, T, Boolean)}) (input As Tensor(Of T), axis As Integer) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Unsqueeze : System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; * int -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)&gt; (requires 'T :&gt; IEquatable&lt;'T&gt; and 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.Unsqueeze (input, axis)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;, System::Numerics::IEqualityOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Unsqueeze(System::Numerics::Tensors::Tensor&lt;T&gt; ^ input, int axis);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="input" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="axis" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="input">To be added.</param>
        <param name="axis">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
