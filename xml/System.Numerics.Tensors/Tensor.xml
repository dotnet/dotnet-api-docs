<Type Name="Tensor" FullName="System.Numerics.Tensors.Tensor">
  <TypeSignature Language="C#" Value="public static class Tensor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Tensor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Tensors.Tensor" />
  <TypeSignature Language="VB.NET" Value="Public Module Tensor" />
  <TypeSignature Language="F#" Value="type Tensor = class" />
  <TypeSignature Language="C++ CLI" Value="public ref class Tensor abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Numerics.Tensors</AssemblyName>
    <AssemblyVersion>9.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.Experimental("SYSLIB5001", UrlFormat="https://aka.ms/dotnet-warnings/{0}")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.Experimental("SYSLIB5001", UrlFormat="https://aka.ms/dotnet-warnings/{0}")&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
            Provides methods for tensor operations.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Abs&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Abs&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Abs&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Abs``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Abs(Of T As INumberBase(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Abs : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Abs x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Abs(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the abs of.</param>
        <summary>
            Takes the absolute value of each element of the <see cref="T:System.Numerics.Tensors.Tensor`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Abs&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Abs&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Abs``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Abs(Of T As INumberBase(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Abs : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Abs (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Abs(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> to take the abs of.</param>
        <param name="destination">The <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> destination.</param>
        <summary>
            Takes the absolute value of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Acos&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Acos&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Acos&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Acos``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Acos(Of T As ITrigonometricFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Acos : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Acos x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Acos(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the sin of.</param>
        <summary>
            Takes the inverse cosine of each element of the <see cref="T:System.Numerics.Tensors.Tensor`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Acos&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Acos&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Acos&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Acos``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Acos(Of T As ITrigonometricFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Acos : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Acos (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Acos(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> to take the sin of.</param>
        <param name="destination" />
        <summary>
            Takes the inverse cosine of each element of the <see cref="T:System.Numerics.Tensors.Tensor`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Acosh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Acosh&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Acosh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Acosh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Acosh(Of T As IHyperbolicFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Acosh : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Acosh x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Acosh(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the sin of.</param>
        <summary>
            Takes the inverse hyperbolic cosine of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Acosh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Acosh&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Acosh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Acosh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Acosh(Of T As IHyperbolicFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Acosh : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Acosh (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Acosh(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> to take the sin of.</param>
        <param name="destination" />
        <summary>
            Takes the inverse hyperbolic cosine of each element of the <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcosPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; AcosPi&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; AcosPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.AcosPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcosPi(Of T As ITrigonometricFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member AcosPi : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.AcosPi x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ AcosPi(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the sin of.</param>
        <summary>
            Takes the inverse hyperbolic cosine divided by pi of each element of the <see cref="T:System.Numerics.Tensors.Tensor`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AcosPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; AcosPi&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; AcosPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.AcosPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcosPi(Of T As ITrigonometricFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member AcosPi : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.AcosPi (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ AcosPi(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the sin of.</param>
        <param name="destination" />
        <summary>
            Takes the inverse hyperbolic cosine divided by pi of each element of the <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Add&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Add&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Add``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Add : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Add (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Add(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> of values to add.</param>
        <param name="y">The second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> of values to add.</param>
        <summary>
            Adds each element of <paramref name="x" /> to each element of <paramref name="y" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Add&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Add&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Add``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Add : ReadOnlyTensorSpan * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Add (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Add(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> of values to add.</param>
        <param name="y">The <typeparamref name="T" /> to add to each element of <paramref name="x" />.</param>
        <summary>
            Adds <paramref name="y" /> to each element of <paramref name="x" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Add&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Add&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Add``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Add : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Add (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Add(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> of values to add.</param>
        <param name="y">The second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> of values to add.</param>
        <param name="destination" />
        <summary>
            Adds each element of <paramref name="x" /> to each element of <paramref name="y" /> and returns a new <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Add&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Add&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Add``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (ByRef x As ReadOnlyTensorSpan(Of T), y As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Add : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Add (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Add(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> of values to add.</param>
        <param name="y">The <typeparamref name="T" /> to add to each element of <paramref name="x" />.</param>
        <param name="destination" />
        <summary>
            Adds <paramref name="y" /> to each element of <paramref name="x" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Asin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Asin&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Asin&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Asin``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Asin(Of T As ITrigonometricFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Asin : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Asin x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Asin(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the sin of.</param>
        <summary>
            Takes the inverse sin of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Asin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Asin&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Asin&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Asin``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Asin(Of T As ITrigonometricFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Asin : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Asin (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Asin(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the sin of.</param>
        <param name="destination" />
        <summary>
            Takes the inverse sin of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Asinh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Asinh&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Asinh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Asinh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Asinh(Of T As IHyperbolicFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Asinh : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Asinh x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Asinh(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the sin of.</param>
        <summary>
            Takes the inverse hyperbolic sine of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Asinh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Asinh&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Asinh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Asinh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Asinh(Of T As IHyperbolicFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Asinh : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Asinh (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Asinh(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the sin of.</param>
        <param name="destination" />
        <summary>
            Takes the inverse hyperbolic sine of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsinPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; AsinPi&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; AsinPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.AsinPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function AsinPi(Of T As ITrigonometricFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member AsinPi : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.AsinPi x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ AsinPi(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the sin of.</param>
        <summary>
            Takes the inverse hyperbolic sine divided by pi of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsinPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; AsinPi&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; AsinPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.AsinPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function AsinPi(Of T As ITrigonometricFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member AsinPi : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.AsinPi (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ AsinPi(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the sin of.</param>
        <param name="destination" />
        <summary>
            Takes the inverse hyperbolic sine divided by pi of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsReadOnlyTensorSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; AsReadOnlyTensorSpan&lt;T&gt; (this T[]? array, scoped ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt; AsReadOnlyTensorSpan&lt;T&gt;(!!T[] array, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.AsReadOnlyTensorSpan``1(``0[],System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsReadOnlyTensorSpan(Of T) (array As T(), lengths As ReadOnlySpan(Of IntPtr)) As ReadOnlyTensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member AsReadOnlyTensorSpan : 'T[] * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.AsReadOnlyTensorSpan (array, lengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; AsReadOnlyTensorSpan(cli::array &lt;T&gt; ^ array, ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The type of the elements in the array</typeparam>
        <param name="array">The <see cref="T:System.Array" /> with the data</param>
        <param name="lengths">The shape for the <see cref="T:System.Numerics.Tensors.TensorSpan`1" /></param>
        <summary>
            Extension method to more easily create a TensorSpan from an array.
            </summary>
        <returns />
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsTensorSpan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; AsTensorSpan&lt;T&gt; (this T[]? array, scoped ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; AsTensorSpan&lt;T&gt;(!!T[] array, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.AsTensorSpan``1(``0[],System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function AsTensorSpan(Of T) (array As T(), lengths As ReadOnlySpan(Of IntPtr)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member AsTensorSpan : 'T[] * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.AsTensorSpan (array, lengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::TensorSpan&lt;T&gt; AsTensorSpan(cli::array &lt;T&gt; ^ array, ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The type of the elements in the array</typeparam>
        <param name="array">The <see cref="T:System.Array" /> with the data</param>
        <param name="lengths">The shape for the <see cref="T:System.Numerics.Tensors.TensorSpan`1" /></param>
        <summary>
            Extension method to more easily create a TensorSpan from an array.
            </summary>
        <returns />
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Atan&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Atan&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atan``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Atan(Of T As ITrigonometricFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Atan : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atan x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Atan(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /></param>
        <summary>
            Takes the arc tangent of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Atan&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Atan&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atan``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Atan(Of T As ITrigonometricFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Atan : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atan (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Atan(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /></param>
        <param name="destination" />
        <summary>
            Takes the arc tangent of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Atan2&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Atan2&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atan2``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Atan2(Of T As IFloatingPointIeee754(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Atan2 : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atan2 (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Atan2(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>
            Takes the arc tangent of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Atan2&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Atan2&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atan2``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Atan2(Of T As IFloatingPointIeee754(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Atan2 : ReadOnlyTensorSpan * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atan2 (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Atan2(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>
            Takes the arc tangent of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Atan2&lt;T&gt; (T x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Atan2&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(!!T x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atan2``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Atan2(Of T As IFloatingPointIeee754(Of T)) (x As T, ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Atan2 : 'T * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atan2 (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Atan2(T x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>
            Takes the arc tangent of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Atan2&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Atan2&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atan2``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Atan2(Of T As IFloatingPointIeee754(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Atan2 : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atan2 (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Atan2(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>
            Takes the arc tangent of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Atan2&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Atan2&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atan2``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Atan2(Of T As IFloatingPointIeee754(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Atan2 : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atan2 (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Atan2(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>
            Takes the arc tangent of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Atan2&lt;T&gt; (T x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Atan2&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(!!T x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atan2``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Atan2(Of T As IFloatingPointIeee754(Of T)) (x As T, ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Atan2 : 'T * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atan2 (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Atan2(T x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>
            Takes the arc tangent of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2Pi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Atan2Pi&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Atan2Pi&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atan2Pi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Atan2Pi(Of T As IFloatingPointIeee754(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Atan2Pi : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atan2Pi (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Atan2Pi(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>
            Takes the arc tangent of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />, divides each element by pi, and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2Pi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Atan2Pi&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Atan2Pi&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atan2Pi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Atan2Pi(Of T As IFloatingPointIeee754(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Atan2Pi : ReadOnlyTensorSpan * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atan2Pi (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Atan2Pi(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>
            Takes the arc tangent of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />, divides each element by pi, and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2Pi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Atan2Pi&lt;T&gt; (T x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Atan2Pi&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(!!T x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atan2Pi``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Atan2Pi(Of T As IFloatingPointIeee754(Of T)) (x As T, ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Atan2Pi : 'T * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atan2Pi (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Atan2Pi(T x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>
            Takes the arc tangent of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />, divides each element by pi, and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2Pi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Atan2Pi&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Atan2Pi&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atan2Pi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Atan2Pi(Of T As IFloatingPointIeee754(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Atan2Pi : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atan2Pi (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Atan2Pi(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>
            Takes the arc tangent of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />, divides each element by pi, and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2Pi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Atan2Pi&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Atan2Pi&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atan2Pi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Atan2Pi(Of T As IFloatingPointIeee754(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Atan2Pi : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atan2Pi (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Atan2Pi(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>
            Takes the arc tangent of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />, divides each element by pi, and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2Pi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Atan2Pi&lt;T&gt; (T x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Atan2Pi&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(!!T x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atan2Pi``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Atan2Pi(Of T As IFloatingPointIeee754(Of T)) (x As T, ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Atan2Pi : 'T * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atan2Pi (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Atan2Pi(T x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>
            Takes the arc tangent of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />, divides each element by pi, and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atanh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Atanh&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Atanh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atanh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Atanh(Of T As IHyperbolicFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Atanh : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atanh x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Atanh(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>
            Takes the inverse hyperbolic tangent of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atanh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Atanh&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Atanh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Atanh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Atanh(Of T As IHyperbolicFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Atanh : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Atanh (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Atanh(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>
            Takes the inverse hyperbolic tangent of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AtanPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; AtanPi&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; AtanPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.AtanPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function AtanPi(Of T As ITrigonometricFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member AtanPi : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.AtanPi x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ AtanPi(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input<see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>
            Takes the inverse hyperbolic tangent divided by pi of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AtanPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; AtanPi&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; AtanPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.AtanPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function AtanPi(Of T As ITrigonometricFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member AtanPi : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.AtanPi (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ AtanPi(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input<see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>
            Takes the inverse hyperbolic tangent divided by pi of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Average&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Average&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Average``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Average(Of T As IFloatingPoint(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Average : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Average x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static T Average(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> to take the mean of.</param>
        <summary>
            Returns the average of the elements in the <paramref name="x" /> tensor.
            </summary>
        <returns>
          <typeparamref name="T" /> representing the mean.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BitwiseAnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; BitwiseAnd&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; BitwiseAnd&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.BitwiseAnd``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function BitwiseAnd(Of T As IBitwiseOperators(Of T, T, T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member BitwiseAnd : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.BitwiseAnd (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ BitwiseAnd(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>
            Computes the element-wise bitwise and of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BitwiseAnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; BitwiseAnd&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; BitwiseAnd&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.BitwiseAnd``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function BitwiseAnd(Of T As IBitwiseOperators(Of T, T, T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member BitwiseAnd : ReadOnlyTensorSpan * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.BitwiseAnd (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ BitwiseAnd(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The second value.</param>
        <summary>
            Computes the element-wise bitwise and of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BitwiseAnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; BitwiseAnd&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; BitwiseAnd&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.BitwiseAnd``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function BitwiseAnd(Of T As IBitwiseOperators(Of T, T, T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member BitwiseAnd : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.BitwiseAnd (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ BitwiseAnd(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>
            Computes the element-wise bitwise and of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BitwiseAnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; BitwiseAnd&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; BitwiseAnd&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.BitwiseAnd``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function BitwiseAnd(Of T As IBitwiseOperators(Of T, T, T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member BitwiseAnd : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.BitwiseAnd (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ BitwiseAnd(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The second value.</param>
        <param name="destination" />
        <summary>
            Computes the element-wise bitwise and of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BitwiseOr&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; BitwiseOr&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; BitwiseOr&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.BitwiseOr``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function BitwiseOr(Of T As IBitwiseOperators(Of T, T, T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member BitwiseOr : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.BitwiseOr (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ BitwiseOr(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>
            Computes the element-wise bitwise of of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BitwiseOr&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; BitwiseOr&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; BitwiseOr&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.BitwiseOr``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function BitwiseOr(Of T As IBitwiseOperators(Of T, T, T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member BitwiseOr : ReadOnlyTensorSpan * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.BitwiseOr (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ BitwiseOr(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The second value.</param>
        <summary>
            Computes the element-wise bitwise or of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BitwiseOr&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; BitwiseOr&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; BitwiseOr&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.BitwiseOr``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function BitwiseOr(Of T As IBitwiseOperators(Of T, T, T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member BitwiseOr : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.BitwiseOr (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ BitwiseOr(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>
            Computes the element-wise bitwise of of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BitwiseOr&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; BitwiseOr&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; BitwiseOr&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.BitwiseOr``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function BitwiseOr(Of T As IBitwiseOperators(Of T, T, T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member BitwiseOr : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.BitwiseOr (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ BitwiseOr(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The second value.</param>
        <param name="destination" />
        <summary>
            Computes the element-wise bitwise or of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Broadcast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Broadcast&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; source, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; lengthsSource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Broadcast&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; source, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; lengthsSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Broadcast``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Broadcast(Of T) (ByRef source As ReadOnlyTensorSpan(Of T), ByRef lengthsSource As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Broadcast : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Broadcast (source, lengthsSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Broadcast(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % source, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % lengthsSource);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="lengthsSource" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">Input <see cref="T:System.Numerics.Tensors.Tensor`1" />.</param>
        <param name="lengthsSource">Other <see cref="T:System.Numerics.Tensors.Tensor`1" /> to make shapes broadcastable.</param>
        <summary>
            Broadcast the data from <paramref name="source" /> to the smallest broadcastable shape compatible with <paramref name="lengthsSource" />. Creates a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> and allocates new memory.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Broadcast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Broadcast&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; source, scoped ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Broadcast&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; source, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Broadcast``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function Broadcast(Of T) (ByRef source As ReadOnlyTensorSpan(Of T), lengths As ReadOnlySpan(Of IntPtr)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Broadcast : ReadOnlyTensorSpan * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Broadcast (source, lengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Broadcast(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % source, ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">Input <see cref="T:System.Numerics.Tensors.Tensor`1" />.</param>
        <param name="lengths">
          <see cref="T:System.ReadOnlySpan`1" /> of the desired new shape.</param>
        <summary>
            Broadcast the data from <paramref name="source" /> to the new shape <paramref name="lengths" />. Creates a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> and allocates new memory.
            If the shape of the <paramref name="source" /> is not compatible with the new shape, an exception is thrown.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Thrown when the shapes are not broadcast compatible.</exception>
      </Docs>
    </Member>
    <Member MemberName="BroadcastTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void BroadcastTo&lt;T&gt; (this in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; source, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BroadcastTo&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; source, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.BroadcastTo``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub BroadcastTo(Of T) (ByRef source As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T))" />
      <MemberSignature Language="F#" Value="static member BroadcastTo : ReadOnlyTensorSpan * TensorSpan -&gt; unit" Usage="System.Numerics.Tensors.Tensor.BroadcastTo (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void BroadcastTo(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % source, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">Input <see cref="T:System.Numerics.Tensors.TensorSpan`1" />.</param>
        <param name="destination" />
        <summary>
            Broadcast the data from <paramref name="source" /> to <paramref name="destination" />.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BroadcastTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void BroadcastTo&lt;T&gt; (this System.Numerics.Tensors.Tensor&lt;T&gt; source, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BroadcastTo&lt;T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; source, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.BroadcastTo``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub BroadcastTo(Of T) (source As Tensor(Of T), ByRef destination As TensorSpan(Of T))" />
      <MemberSignature Language="F#" Value="static member BroadcastTo : System.Numerics.Tensors.Tensor&lt;'T&gt; * TensorSpan -&gt; unit" Usage="System.Numerics.Tensors.Tensor.BroadcastTo (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void BroadcastTo(System::Numerics::Tensors::Tensor&lt;T&gt; ^ source, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" RefType="this" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">Input <see cref="T:System.Numerics.Tensors.TensorSpan`1" />.</param>
        <param name="destination" />
        <summary>
            Broadcast the data from <paramref name="source" /> to <paramref name="destination" />.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BroadcastTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void BroadcastTo&lt;T&gt; (this in System.Numerics.Tensors.TensorSpan&lt;T&gt; source, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BroadcastTo&lt;T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; source, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.BroadcastTo``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Sub BroadcastTo(Of T) (ByRef source As TensorSpan(Of T), ByRef destination As TensorSpan(Of T))" />
      <MemberSignature Language="F#" Value="static member BroadcastTo : TensorSpan * TensorSpan -&gt; unit" Usage="System.Numerics.Tensors.Tensor.BroadcastTo (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static void BroadcastTo(System::Numerics::Tensors::TensorSpan&lt;T&gt; % source, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="source">Input <see cref="T:System.Numerics.Tensors.TensorSpan`1" />.</param>
        <param name="destination">Other <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> to make shapes broadcastable.</param>
        <summary>
            Broadcast the data from <paramref name="source" /> to <paramref name="destination" />.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cbrt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Cbrt&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Cbrt&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Cbrt``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Cbrt(Of T As IRootFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Cbrt : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Cbrt x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Cbrt(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>
            Computes the element-wise cube root of the input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cbrt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Cbrt&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Cbrt&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Cbrt``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Cbrt(Of T As IRootFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Cbrt : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Cbrt (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Cbrt(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>
            Computes the element-wise cube root of the input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceiling&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Ceiling&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Ceiling&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Ceiling``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Ceiling(Of T As IFloatingPoint(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Ceiling : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Ceiling x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Ceiling(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>
            Computes the element-wise ceiling of the input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceiling&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Ceiling&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Ceiling&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Ceiling``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Ceiling(Of T As IFloatingPoint(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Ceiling : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Ceiling (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Ceiling(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>
            Computes the element-wise ceiling of the input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concatenate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Concatenate&lt;T&gt; (scoped ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;T&gt;&gt; tensors);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Concatenate&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;class System.Numerics.Tensors.Tensor`1&lt;!!T&gt;&gt; tensors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Concatenate``1(System.ReadOnlySpan{System.Numerics.Tensors.Tensor{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Concatenate(Of T) (tensors As ReadOnlySpan(Of Tensor(Of T))) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Concatenate : ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;'T&gt;&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Concatenate tensors" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Concatenate(ReadOnlySpan&lt;System::Numerics::Tensors::Tensor&lt;T&gt; ^&gt; tensors);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensors" Type="System.ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;T&gt;&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensors">The tensors must have the same shape, except in the dimension corresponding to axis (the first, by default).</param>
        <summary>
            Join a sequence of tensors along an existing axis.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concatenate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Concatenate&lt;T&gt; (scoped ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;T&gt;&gt; tensors, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Concatenate&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;class System.Numerics.Tensors.Tensor`1&lt;!!T&gt;&gt; tensors, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Concatenate``1(System.ReadOnlySpan{System.Numerics.Tensors.Tensor{``0}},System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Concatenate(Of T) (tensors As ReadOnlySpan(Of Tensor(Of T)), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Concatenate : ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;'T&gt;&gt; * TensorSpan -&gt; TensorSpan" Usage="System.Numerics.Tensors.Tensor.Concatenate (tensors, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Concatenate(ReadOnlySpan&lt;System::Numerics::Tensors::Tensor&lt;T&gt; ^&gt; tensors, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensors" Type="System.ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;T&gt;&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensors">The tensors must have the same shape, except in the dimension corresponding to axis (the first, by default).</param>
        <param name="destination" />
        <summary>
            Join a sequence of tensors along an existing axis.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConcatenateOnDimension&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; ConcatenateOnDimension&lt;T&gt; (int dimension, scoped ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;T&gt;&gt; tensors);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; ConcatenateOnDimension&lt;T&gt;(int32 dimension, valuetype System.ReadOnlySpan`1&lt;class System.Numerics.Tensors.Tensor`1&lt;!!T&gt;&gt; tensors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ConcatenateOnDimension``1(System.Int32,System.ReadOnlySpan{System.Numerics.Tensors.Tensor{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Function ConcatenateOnDimension(Of T) (dimension As Integer, tensors As ReadOnlySpan(Of Tensor(Of T))) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member ConcatenateOnDimension : int * ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;'T&gt;&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.ConcatenateOnDimension (dimension, tensors)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ ConcatenateOnDimension(int dimension, ReadOnlySpan&lt;System::Numerics::Tensors::Tensor&lt;T&gt; ^&gt; tensors);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
        <Parameter Name="tensors" Type="System.ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;T&gt;&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensors">The tensors must have the same shape, except in the dimension corresponding to axis (the first, by default).</param>
        <param name="dimension">The axis along which the tensors will be joined. If axis is -1, arrays are flattened before use. Default is 0.</param>
        <summary>
            Join a sequence of tensors along an existing axis.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConcatenateOnDimension&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; ConcatenateOnDimension&lt;T&gt; (int dimension, scoped ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;T&gt;&gt; tensors, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; ConcatenateOnDimension&lt;T&gt;(int32 dimension, valuetype System.ReadOnlySpan`1&lt;class System.Numerics.Tensors.Tensor`1&lt;!!T&gt;&gt; tensors, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ConcatenateOnDimension``1(System.Int32,System.ReadOnlySpan{System.Numerics.Tensors.Tensor{``0}},System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConcatenateOnDimension(Of T) (dimension As Integer, tensors As ReadOnlySpan(Of Tensor(Of T)), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member ConcatenateOnDimension : int * ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;'T&gt;&gt; * TensorSpan -&gt; TensorSpan" Usage="System.Numerics.Tensors.Tensor.ConcatenateOnDimension (dimension, tensors, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ ConcatenateOnDimension(int dimension, ReadOnlySpan&lt;System::Numerics::Tensors::Tensor&lt;T&gt; ^&gt; tensors, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
        <Parameter Name="tensors" Type="System.ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;T&gt;&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensors">The tensors must have the same shape, except in the dimension corresponding to axis (the first, by default).</param>
        <param name="dimension">The axis along which the tensors will be joined. If axis is -1, arrays are flattened before use. Default is 0.</param>
        <param name="destination" />
        <summary>
            Join a sequence of tensors along an existing axis.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertChecked&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;TTo&gt; ConvertChecked&lt;TFrom,TTo&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;TFrom&gt; source) where TFrom : IEquatable&lt;TFrom&gt;, System.Numerics.IEqualityOperators&lt;TFrom,TFrom,bool&gt;, System.Numerics.INumberBase&lt;TFrom&gt; where TTo : System.Numerics.INumberBase&lt;TTo&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!TTo&gt; ConvertChecked&lt;(class System.IEquatable`1&lt;!!TFrom&gt;, class System.Numerics.IEqualityOperators`3&lt;!!TFrom, !!TFrom, bool&gt;, class System.Numerics.INumberBase`1&lt;!!TFrom&gt;) TFrom, (class System.Numerics.INumberBase`1&lt;!!TTo&gt;) TTo&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!TFrom&gt;&amp; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ConvertChecked``2(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertChecked(Of TFrom As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}, TTo As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}) (ByRef source As ReadOnlyTensorSpan(Of TFrom)) As Tensor(Of TTo)" />
      <MemberSignature Language="F#" Value="static member ConvertChecked : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'o (requires 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)&gt; (requires 'From :&gt; IEquatable&lt;'From&gt; and 'From :&gt; System.Numerics.IEqualityOperators&lt;'From, 'From, bool&gt; and 'From :&gt; System.Numerics.INumberBase&lt;'From&gt; and 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)" Usage="System.Numerics.Tensors.Tensor.ConvertChecked source" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; where TFrom : IEquatable&lt;TFrom&gt;, System::Numerics::IEqualityOperators&lt;TFrom, TFrom, bool&gt;, System::Numerics::INumberBase&lt;TFrom&gt; where TTo : System::Numerics::INumberBase&lt;TTo&gt; static System::Numerics::Tensors::Tensor&lt;TTo&gt; ^ ConvertChecked(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;TFrom&gt; % source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;TTo&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;TFrom&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;TFrom,TFrom,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.INumberBase&lt;TFrom&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TTo&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;TFrom&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TFrom">To be added.</typeparam>
        <typeparam name="TTo">To be added.</typeparam>
        <param name="source">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>
            Copies <paramref name="source" /> to a new <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> converting each <typeparamref name="TFrom" />
            value to a <typeparamref name="TTo" /> value.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertChecked&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;TTo&gt; ConvertChecked&lt;TFrom,TTo&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;TFrom&gt; source, in System.Numerics.Tensors.TensorSpan&lt;TTo&gt; destination) where TFrom : IEquatable&lt;TFrom&gt;, System.Numerics.IEqualityOperators&lt;TFrom,TFrom,bool&gt;, System.Numerics.INumberBase&lt;TFrom&gt; where TTo : System.Numerics.INumberBase&lt;TTo&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!TTo&gt; ConvertChecked&lt;(class System.IEquatable`1&lt;!!TFrom&gt;, class System.Numerics.IEqualityOperators`3&lt;!!TFrom, !!TFrom, bool&gt;, class System.Numerics.INumberBase`1&lt;!!TFrom&gt;) TFrom, (class System.Numerics.INumberBase`1&lt;!!TTo&gt;) TTo&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!TFrom&gt;&amp; source, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!TTo&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ConvertChecked``2(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``1}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertChecked(Of TFrom As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}, TTo As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}) (ByRef source As ReadOnlyTensorSpan(Of TFrom), ByRef destination As TensorSpan(Of TTo)) As TensorSpan(Of TTo)" />
      <MemberSignature Language="F#" Value="static member ConvertChecked : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'From :&gt; IEquatable&lt;'From&gt; and 'From :&gt; System.Numerics.IEqualityOperators&lt;'From, 'From, bool&gt; and 'From :&gt; System.Numerics.INumberBase&lt;'From&gt; and 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)" Usage="System.Numerics.Tensors.Tensor.ConvertChecked (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; where TFrom : IEquatable&lt;TFrom&gt;, System::Numerics::IEqualityOperators&lt;TFrom, TFrom, bool&gt;, System::Numerics::INumberBase&lt;TFrom&gt; where TTo : System::Numerics::INumberBase&lt;TTo&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ ConvertChecked(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;TFrom&gt; % source, System::Numerics::Tensors::TensorSpan&lt;TTo&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;TTo&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;TFrom&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;TFrom,TFrom,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.INumberBase&lt;TFrom&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TTo&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;TFrom&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;TTo&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TFrom">To be added.</typeparam>
        <typeparam name="TTo">To be added.</typeparam>
        <param name="source">The input <see cref="T:System.Numerics.Tensors.TensorSpan`1" />.</param>
        <param name="destination" />
        <summary>
            Copies <paramref name="source" /> to a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> converting each <typeparamref name="TFrom" />
            value to a <typeparamref name="TTo" /> value.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertSaturating&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;TTo&gt; ConvertSaturating&lt;TFrom,TTo&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;TFrom&gt; source) where TFrom : IEquatable&lt;TFrom&gt;, System.Numerics.IEqualityOperators&lt;TFrom,TFrom,bool&gt;, System.Numerics.INumberBase&lt;TFrom&gt; where TTo : System.Numerics.INumberBase&lt;TTo&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!TTo&gt; ConvertSaturating&lt;(class System.IEquatable`1&lt;!!TFrom&gt;, class System.Numerics.IEqualityOperators`3&lt;!!TFrom, !!TFrom, bool&gt;, class System.Numerics.INumberBase`1&lt;!!TFrom&gt;) TFrom, (class System.Numerics.INumberBase`1&lt;!!TTo&gt;) TTo&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!TFrom&gt;&amp; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ConvertSaturating``2(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertSaturating(Of TFrom As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}, TTo As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}) (ByRef source As ReadOnlyTensorSpan(Of TFrom)) As Tensor(Of TTo)" />
      <MemberSignature Language="F#" Value="static member ConvertSaturating : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'o (requires 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)&gt; (requires 'From :&gt; IEquatable&lt;'From&gt; and 'From :&gt; System.Numerics.IEqualityOperators&lt;'From, 'From, bool&gt; and 'From :&gt; System.Numerics.INumberBase&lt;'From&gt; and 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)" Usage="System.Numerics.Tensors.Tensor.ConvertSaturating source" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; where TFrom : IEquatable&lt;TFrom&gt;, System::Numerics::IEqualityOperators&lt;TFrom, TFrom, bool&gt;, System::Numerics::INumberBase&lt;TFrom&gt; where TTo : System::Numerics::INumberBase&lt;TTo&gt; static System::Numerics::Tensors::Tensor&lt;TTo&gt; ^ ConvertSaturating(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;TFrom&gt; % source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;TTo&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;TFrom&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;TFrom,TFrom,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.INumberBase&lt;TFrom&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TTo&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;TFrom&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TFrom">To be added.</typeparam>
        <typeparam name="TTo">To be added.</typeparam>
        <param name="source">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>
            Copies <paramref name="source" /> to a new <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> converting each <typeparamref name="TFrom" />
            value to a <typeparamref name="TTo" /> value.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertSaturating&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;TTo&gt; ConvertSaturating&lt;TFrom,TTo&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;TFrom&gt; source, in System.Numerics.Tensors.TensorSpan&lt;TTo&gt; destination) where TFrom : IEquatable&lt;TFrom&gt;, System.Numerics.IEqualityOperators&lt;TFrom,TFrom,bool&gt;, System.Numerics.INumberBase&lt;TFrom&gt; where TTo : System.Numerics.INumberBase&lt;TTo&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!TTo&gt; ConvertSaturating&lt;(class System.IEquatable`1&lt;!!TFrom&gt;, class System.Numerics.IEqualityOperators`3&lt;!!TFrom, !!TFrom, bool&gt;, class System.Numerics.INumberBase`1&lt;!!TFrom&gt;) TFrom, (class System.Numerics.INumberBase`1&lt;!!TTo&gt;) TTo&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!TFrom&gt;&amp; source, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!TTo&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ConvertSaturating``2(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``1}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertSaturating(Of TFrom As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}, TTo As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}) (ByRef source As ReadOnlyTensorSpan(Of TFrom), ByRef destination As TensorSpan(Of TTo)) As TensorSpan(Of TTo)" />
      <MemberSignature Language="F#" Value="static member ConvertSaturating : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'From :&gt; IEquatable&lt;'From&gt; and 'From :&gt; System.Numerics.IEqualityOperators&lt;'From, 'From, bool&gt; and 'From :&gt; System.Numerics.INumberBase&lt;'From&gt; and 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)" Usage="System.Numerics.Tensors.Tensor.ConvertSaturating (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; where TFrom : IEquatable&lt;TFrom&gt;, System::Numerics::IEqualityOperators&lt;TFrom, TFrom, bool&gt;, System::Numerics::INumberBase&lt;TFrom&gt; where TTo : System::Numerics::INumberBase&lt;TTo&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ ConvertSaturating(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;TFrom&gt; % source, System::Numerics::Tensors::TensorSpan&lt;TTo&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;TTo&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;TFrom&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;TFrom,TFrom,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.INumberBase&lt;TFrom&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TTo&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;TFrom&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;TTo&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TFrom">To be added.</typeparam>
        <typeparam name="TTo">To be added.</typeparam>
        <param name="source">The input <see cref="T:System.Numerics.Tensors.TensorSpan`1" />.</param>
        <param name="destination" />
        <summary>
            Copies <paramref name="source" /> to a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> converting each <typeparamref name="TFrom" />
            value to a <typeparamref name="TTo" /> value.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertTruncating&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;TTo&gt; ConvertTruncating&lt;TFrom,TTo&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;TFrom&gt; source) where TFrom : IEquatable&lt;TFrom&gt;, System.Numerics.IEqualityOperators&lt;TFrom,TFrom,bool&gt;, System.Numerics.INumberBase&lt;TFrom&gt; where TTo : System.Numerics.INumberBase&lt;TTo&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!TTo&gt; ConvertTruncating&lt;(class System.IEquatable`1&lt;!!TFrom&gt;, class System.Numerics.IEqualityOperators`3&lt;!!TFrom, !!TFrom, bool&gt;, class System.Numerics.INumberBase`1&lt;!!TFrom&gt;) TFrom, (class System.Numerics.INumberBase`1&lt;!!TTo&gt;) TTo&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!TFrom&gt;&amp; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ConvertTruncating``2(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertTruncating(Of TFrom As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}, TTo As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}) (ByRef source As ReadOnlyTensorSpan(Of TFrom)) As Tensor(Of TTo)" />
      <MemberSignature Language="F#" Value="static member ConvertTruncating : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'o (requires 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)&gt; (requires 'From :&gt; IEquatable&lt;'From&gt; and 'From :&gt; System.Numerics.IEqualityOperators&lt;'From, 'From, bool&gt; and 'From :&gt; System.Numerics.INumberBase&lt;'From&gt; and 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)" Usage="System.Numerics.Tensors.Tensor.ConvertTruncating source" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; where TFrom : IEquatable&lt;TFrom&gt;, System::Numerics::IEqualityOperators&lt;TFrom, TFrom, bool&gt;, System::Numerics::INumberBase&lt;TFrom&gt; where TTo : System::Numerics::INumberBase&lt;TTo&gt; static System::Numerics::Tensors::Tensor&lt;TTo&gt; ^ ConvertTruncating(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;TFrom&gt; % source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;TTo&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;TFrom&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;TFrom,TFrom,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.INumberBase&lt;TFrom&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TTo&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;TFrom&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TFrom">To be added.</typeparam>
        <typeparam name="TTo">To be added.</typeparam>
        <param name="source">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>
            Copies <paramref name="source" /> to a new <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> converting each <typeparamref name="TFrom" />
            value to a <typeparamref name="TTo" /> value.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertTruncating&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;TTo&gt; ConvertTruncating&lt;TFrom,TTo&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;TFrom&gt; source, in System.Numerics.Tensors.TensorSpan&lt;TTo&gt; destination) where TFrom : IEquatable&lt;TFrom&gt;, System.Numerics.IEqualityOperators&lt;TFrom,TFrom,bool&gt;, System.Numerics.INumberBase&lt;TFrom&gt; where TTo : System.Numerics.INumberBase&lt;TTo&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!TTo&gt; ConvertTruncating&lt;(class System.IEquatable`1&lt;!!TFrom&gt;, class System.Numerics.IEqualityOperators`3&lt;!!TFrom, !!TFrom, bool&gt;, class System.Numerics.INumberBase`1&lt;!!TFrom&gt;) TFrom, (class System.Numerics.INumberBase`1&lt;!!TTo&gt;) TTo&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!TFrom&gt;&amp; source, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!TTo&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ConvertTruncating``2(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``1}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConvertTruncating(Of TFrom As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}, TTo As {IEquatable(Of TFrom), IEqualityOperators(Of TFrom, TFrom, Boolean), INumberBase(Of TFrom)}) (ByRef source As ReadOnlyTensorSpan(Of TFrom), ByRef destination As TensorSpan(Of TTo)) As TensorSpan(Of TTo)" />
      <MemberSignature Language="F#" Value="static member ConvertTruncating : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'From :&gt; IEquatable&lt;'From&gt; and 'From :&gt; System.Numerics.IEqualityOperators&lt;'From, 'From, bool&gt; and 'From :&gt; System.Numerics.INumberBase&lt;'From&gt; and 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)" Usage="System.Numerics.Tensors.Tensor.ConvertTruncating (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; where TFrom : IEquatable&lt;TFrom&gt;, System::Numerics::IEqualityOperators&lt;TFrom, TFrom, bool&gt;, System::Numerics::INumberBase&lt;TFrom&gt; where TTo : System::Numerics::INumberBase&lt;TTo&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ ConvertTruncating(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;TFrom&gt; % source, System::Numerics::Tensors::TensorSpan&lt;TTo&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;TTo&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.IEquatable&lt;TFrom&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;TFrom,TFrom,System.Boolean&gt;</InterfaceName>
            <InterfaceName>System.Numerics.INumberBase&lt;TFrom&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TTo&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;TFrom&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;TTo&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TFrom">To be added.</typeparam>
        <typeparam name="TTo">To be added.</typeparam>
        <param name="source">The input <see cref="T:System.Numerics.Tensors.TensorSpan`1" />.</param>
        <param name="destination" />
        <summary>
            Copies <paramref name="source" /> to a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> converting each <typeparamref name="TFrom" />
            value to a <typeparamref name="TTo" /> value.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopySign&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CopySign&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; sign) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CopySign&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; sign) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CopySign``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopySign(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef sign As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CopySign : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CopySign (x, sign)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ CopySign(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % sign);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="sign" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">Input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="sign">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> with the associated signs.</param>
        <summary>
            Computes the element-wise result of copying the sign from one number to another number in the specified tensors and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopySign&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CopySign&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T sign) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CopySign&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T sign) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CopySign``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopySign(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), sign As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CopySign : ReadOnlyTensorSpan * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CopySign (x, sign)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ CopySign(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T sign);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="sign" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">Input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="sign">The number with the associated sign.</param>
        <summary>
            Computes the element-wise result of copying the sign from one number to another number in the specified tensors and returns a new tensor with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopySign&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; CopySign&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; sign, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; CopySign&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; sign, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CopySign``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopySign(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef sign As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member CopySign : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CopySign (x, sign, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ CopySign(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % sign, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="sign" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">Input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="sign">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> with the associated signs.</param>
        <param name="destination" />
        <summary>
            Computes the element-wise result of copying the sign from one number to another number in the specified tensors and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopySign&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; CopySign&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T sign, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; CopySign&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T sign, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CopySign``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function CopySign(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), sign As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member CopySign : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CopySign (x, sign, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ CopySign(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T sign, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="sign" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">Input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="sign">The number with the associated sign.</param>
        <param name="destination" />
        <summary>
            Computes the element-wise result of copying the sign from one number to another number in the specified tensors and returns a new tensor with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Cos&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Cos&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Cos``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Cos(Of T As ITrigonometricFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Cos : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Cos x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Cos(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the cosine of.</param>
        <summary>
            Takes the cosine of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Cos&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Cos&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Cos``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Cos(Of T As ITrigonometricFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Cos : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Cos (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Cos(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the cosine of.</param>
        <param name="destination" />
        <summary>
            Takes the cosine of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cosh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Cosh&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Cosh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Cosh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Cosh(Of T As IHyperbolicFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Cosh : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Cosh x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Cosh(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the cosine of.</param>
        <summary>
            Takes the hyperbolic cosine of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cosh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Cosh&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Cosh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Cosh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Cosh(Of T As IHyperbolicFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Cosh : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Cosh (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Cosh(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the cosine of.</param>
        <param name="destination" />
        <summary>
            Takes the hyperbolic cosine of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CosineSimilarity&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CosineSimilarity&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CosineSimilarity&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CosineSimilarity``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function CosineSimilarity(Of T As IRootFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CosineSimilarity : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CosineSimilarity (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ CosineSimilarity(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /></param>
        <param name="y">The second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /></param>
        <summary>
            Compute cosine similarity between <paramref name="x" /> and <paramref name="y" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CosineSimilarity&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; CosineSimilarity&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; CosineSimilarity&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CosineSimilarity``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function CosineSimilarity(Of T As IRootFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member CosineSimilarity : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CosineSimilarity (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ CosineSimilarity(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /></param>
        <param name="y">The second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /></param>
        <param name="destination" />
        <summary>
            Compute cosine similarity between <paramref name="x" /> and <paramref name="y" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CosPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CosPi&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CosPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CosPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function CosPi(Of T As ITrigonometricFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CosPi : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CosPi x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ CosPi(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /></param>
        <summary>Computes the element-wise cosine of the value in the specified tensor that has been multiplied by Pi and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the results.</summary>
        <returns>To be added.</returns>
        <remarks>
          <para>
            This method effectively computes <c><typeparamref name="T" />.CosPi(<paramref name="x" />[i])</c>.
            </para>
          <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians" /> or multiply by <typeparamref name="T" />.Pi/180 to convert degrees to radians.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CosPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; CosPi&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; CosPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CosPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function CosPi(Of T As ITrigonometricFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member CosPi : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CosPi (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ CosPi(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /></param>
        <param name="destination" />
        <summary>Computes the element-wise cosine of the value in the specified tensor that has been multiplied by Pi and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the results.</summary>
        <returns>To be added.</returns>
        <remarks>
          <para>
            This method effectively computes <c><typeparamref name="T" />.CosPi(<paramref name="x" />[i])</c>.
            </para>
          <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians" /> or multiply by <typeparamref name="T" />.Pi/180 to convert degrees to radians.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Create&lt;T&gt; (scoped ReadOnlySpan&lt;IntPtr&gt; lengths, bool pinned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Create&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Create``1(System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Create(Of T) (lengths As ReadOnlySpan(Of IntPtr), Optional pinned As Boolean = false) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Create : ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Create (lengths, pinned)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="lengths">A <see cref="T:System.ReadOnlySpan`1" /> indicating the lengths of each dimension.</param>
        <param name="pinned">A <see cref="T:System.Boolean" /> whether the underlying data should be pinned or not.</param>
        <summary>
            Creates a <see cref="T:System.Numerics.Tensors.Tensor`1" /> and initializes it with the default value of T. If <paramref name="pinned" /> is true, the memory will be pinned.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Create&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values, scoped ReadOnlySpan&lt;IntPtr&gt; lengths, bool pinned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Create&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Create``1(System.Collections.Generic.IEnumerable{``0},System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Create(Of T) (values As IEnumerable(Of T), lengths As ReadOnlySpan(Of IntPtr), Optional pinned As Boolean = false) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Create : seq&lt;'T&gt; * ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Create (values, lengths, pinned)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="values">A <see cref="T:System.Collections.Generic.IEnumerable`1" /> with the data to use for the initialization.</param>
        <param name="lengths">A <see cref="T:System.ReadOnlySpan`1" /> indicating the lengths of each dimension.</param>
        <param name="pinned">A <see cref="T:System.Boolean" /> indicating whether the <paramref name="values" /> were pinned or not.</param>
        <summary>
            Creates a <see cref="T:System.Numerics.Tensors.Tensor`1" /> and initializes it with the data from <paramref name="values" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Create&lt;T&gt; (scoped ReadOnlySpan&lt;IntPtr&gt; lengths, scoped ReadOnlySpan&lt;IntPtr&gt; strides, bool pinned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Create&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Create``1(System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Create(Of T) (lengths As ReadOnlySpan(Of IntPtr), strides As ReadOnlySpan(Of IntPtr), Optional pinned As Boolean = false) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Create : ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Create (lengths, strides, pinned)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="lengths">A <see cref="T:System.ReadOnlySpan`1" /> indicating the lengths of each dimension.</param>
        <param name="strides">A <see cref="T:System.ReadOnlySpan`1" /> indicating the strides of each dimension.</param>
        <param name="pinned">A <see cref="T:System.Boolean" /> whether the underlying data should be pinned or not.</param>
        <summary>
            Creates a <see cref="T:System.Numerics.Tensors.Tensor`1" /> and initializes it with the default value of T. If <paramref name="pinned" /> is true, the memory will be pinned.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Create&lt;T&gt; (T[] values, scoped ReadOnlySpan&lt;IntPtr&gt; lengths, bool pinned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Create&lt;T&gt;(!!T[] values, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Create``1(``0[],System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Create(Of T) (values As T(), lengths As ReadOnlySpan(Of IntPtr), Optional pinned As Boolean = false) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Create : 'T[] * ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Create (values, lengths, pinned)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="T[]" />
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="values">An array of the backing memory.</param>
        <param name="lengths">A <see cref="T:System.ReadOnlySpan`1" /> indicating the lengths of each dimension.</param>
        <param name="pinned">A <see cref="T:System.Boolean" /> indicating whether the <paramref name="values" /> were pinned or not.</param>
        <summary>
            Creates a <see cref="T:System.Numerics.Tensors.Tensor`1" /> from the provided <paramref name="values" />. If the product of the
            <paramref name="lengths" /> does not equal the length of the <paramref name="values" /> array, an exception will be thrown.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException" />
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Create&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values, scoped ReadOnlySpan&lt;IntPtr&gt; lengths, scoped ReadOnlySpan&lt;IntPtr&gt; strides, bool pinned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Create&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Create``1(System.Collections.Generic.IEnumerable{``0},System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Create(Of T) (values As IEnumerable(Of T), lengths As ReadOnlySpan(Of IntPtr), strides As ReadOnlySpan(Of IntPtr), Optional pinned As Boolean = false) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Create : seq&lt;'T&gt; * ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Create (values, lengths, strides, pinned)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="values">A <see cref="T:System.Collections.Generic.IEnumerable`1" /> with the data to use for the initialization.</param>
        <param name="lengths">A <see cref="T:System.ReadOnlySpan`1" /> indicating the lengths of each dimension.</param>
        <param name="strides">A <see cref="T:System.ReadOnlySpan`1" /> indicating the strides of each dimension.</param>
        <param name="pinned">A <see cref="T:System.Boolean" /> indicating whether the <paramref name="values" /> were pinned or not.</param>
        <summary>
            Creates a <see cref="T:System.Numerics.Tensors.Tensor`1" /> and initializes it with the data from <paramref name="values" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Create&lt;T&gt; (T[] values, scoped ReadOnlySpan&lt;IntPtr&gt; lengths, scoped ReadOnlySpan&lt;IntPtr&gt; strides, bool pinned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Create&lt;T&gt;(!!T[] values, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Create``1(``0[],System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function Create(Of T) (values As T(), lengths As ReadOnlySpan(Of IntPtr), strides As ReadOnlySpan(Of IntPtr), Optional pinned As Boolean = false) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Create : 'T[] * ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Create (values, lengths, strides, pinned)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="T[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="values">An array of the backing memory.</param>
        <param name="lengths">A <see cref="T:System.ReadOnlySpan`1" /> indicating the lengths of each dimension.</param>
        <param name="strides">A <see cref="T:System.ReadOnlySpan`1" /> indicating the strides of each dimension.</param>
        <param name="pinned">A <see cref="T:System.Boolean" /> indicating whether the <paramref name="values" /> were pinned or not.</param>
        <summary>
            Creates a <see cref="T:System.Numerics.Tensors.Tensor`1" /> from the provided <paramref name="values" />. If the product of the
            <paramref name="lengths" /> does not equal the length of the <paramref name="values" /> array, an exception will be thrown.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException" />
      </Docs>
    </Member>
    <Member MemberName="CreateAndFillGaussianNormalDistribution&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CreateAndFillGaussianNormalDistribution&lt;T&gt; (scoped ReadOnlySpan&lt;IntPtr&gt; lengths) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CreateAndFillGaussianNormalDistribution&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CreateAndFillGaussianNormalDistribution``1(System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateAndFillGaussianNormalDistribution(Of T As IFloatingPoint(Of T)) (lengths As ReadOnlySpan(Of IntPtr)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CreateAndFillGaussianNormalDistribution : ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CreateAndFillGaussianNormalDistribution lengths" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ CreateAndFillGaussianNormalDistribution(ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="lengths">A <see cref="T:System.ReadOnlySpan`1" /> indicating the lengths of each dimension.</param>
        <summary>
            Creates a <see cref="T:System.Numerics.Tensors.Tensor`1" /> and initializes it with random data in a gaussian normal distribution.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAndFillGaussianNormalDistribution&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CreateAndFillGaussianNormalDistribution&lt;T&gt; (Random random, scoped ReadOnlySpan&lt;IntPtr&gt; lengths) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CreateAndFillGaussianNormalDistribution&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(class System.Random random, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CreateAndFillGaussianNormalDistribution``1(System.Random,System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateAndFillGaussianNormalDistribution(Of T As IFloatingPoint(Of T)) (random As Random, lengths As ReadOnlySpan(Of IntPtr)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CreateAndFillGaussianNormalDistribution : Random * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CreateAndFillGaussianNormalDistribution (random, lengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ CreateAndFillGaussianNormalDistribution(Random ^ random, ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="random" Type="System.Random" />
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="random" />
        <param name="lengths">A <see cref="T:System.ReadOnlySpan`1" /> indicating the lengths of each dimension.</param>
        <summary>
            Creates a <see cref="T:System.Numerics.Tensors.Tensor`1" /> and initializes it with random data in a gaussian normal distribution.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAndFillUniformDistribution&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CreateAndFillUniformDistribution&lt;T&gt; (scoped ReadOnlySpan&lt;IntPtr&gt; lengths) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CreateAndFillUniformDistribution&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CreateAndFillUniformDistribution``1(System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateAndFillUniformDistribution(Of T As IFloatingPoint(Of T)) (lengths As ReadOnlySpan(Of IntPtr)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CreateAndFillUniformDistribution : ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CreateAndFillUniformDistribution lengths" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ CreateAndFillUniformDistribution(ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="lengths">A <see cref="T:System.ReadOnlySpan`1" /> indicating the lengths of each dimension.</param>
        <summary>
            Creates a <see cref="T:System.Numerics.Tensors.Tensor`1" /> and initializes it with random data uniformly distributed.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAndFillUniformDistribution&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CreateAndFillUniformDistribution&lt;T&gt; (Random random, scoped ReadOnlySpan&lt;IntPtr&gt; lengths) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CreateAndFillUniformDistribution&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(class System.Random random, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CreateAndFillUniformDistribution``1(System.Random,System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateAndFillUniformDistribution(Of T As IFloatingPoint(Of T)) (random As Random, lengths As ReadOnlySpan(Of IntPtr)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CreateAndFillUniformDistribution : Random * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.CreateAndFillUniformDistribution (random, lengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ CreateAndFillUniformDistribution(Random ^ random, ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="random" Type="System.Random" />
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="random" />
        <param name="lengths">A <see cref="T:System.ReadOnlySpan`1" /> indicating the lengths of each dimension.</param>
        <summary>
            Creates a <see cref="T:System.Numerics.Tensors.Tensor`1" /> and initializes it with random data uniformly distributed.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateUninitialized&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CreateUninitialized&lt;T&gt; (scoped ReadOnlySpan&lt;IntPtr&gt; lengths, bool pinned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CreateUninitialized&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CreateUninitialized``1(System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateUninitialized(Of T) (lengths As ReadOnlySpan(Of IntPtr), Optional pinned As Boolean = false) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CreateUninitialized : ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.CreateUninitialized (lengths, pinned)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="lengths">A <see cref="T:System.ReadOnlySpan`1" /> indicating the lengths of each dimension.</param>
        <param name="pinned">A <see cref="T:System.Boolean" /> whether the underlying data should be pinned or not.</param>
        <summary>
            Creates a <see cref="T:System.Numerics.Tensors.Tensor`1" /> and does not initialize it. If <paramref name="pinned" /> is true, the memory will be pinned.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateUninitialized&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; CreateUninitialized&lt;T&gt; (scoped ReadOnlySpan&lt;IntPtr&gt; lengths, scoped ReadOnlySpan&lt;IntPtr&gt; strides, bool pinned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; CreateUninitialized&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides, bool pinned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.CreateUninitialized``1(System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateUninitialized(Of T) (lengths As ReadOnlySpan(Of IntPtr), strides As ReadOnlySpan(Of IntPtr), Optional pinned As Boolean = false) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member CreateUninitialized : ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; * bool -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.CreateUninitialized (lengths, strides, pinned)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="pinned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="lengths">A <see cref="T:System.ReadOnlySpan`1" /> indicating the lengths of each dimension.</param>
        <param name="strides">A <see cref="T:System.ReadOnlySpan`1" /> indicating the strides of each dimension.</param>
        <param name="pinned">A <see cref="T:System.Boolean" /> whether the underlying data should be pinned or not.</param>
        <summary>
            Creates a <see cref="T:System.Numerics.Tensors.Tensor`1" /> and does not initialize it. If <paramref name="pinned" /> is true, the memory will be pinned.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DegreesToRadians&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; DegreesToRadians&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; DegreesToRadians&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.DegreesToRadians``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function DegreesToRadians(Of T As ITrigonometricFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member DegreesToRadians : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.DegreesToRadians x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ DegreesToRadians(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>
            Computes the element-wise conversion of each number of degrees in the specified tensor to radians and returns a new tensor with the results.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DegreesToRadians&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; DegreesToRadians&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; DegreesToRadians&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.DegreesToRadians``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function DegreesToRadians(Of T As ITrigonometricFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member DegreesToRadians : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.DegreesToRadians (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ DegreesToRadians(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>
            Computes the element-wise conversion of each number of degrees in the specified tensor to radians and returns a new tensor with the results.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Distance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Distance&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Distance&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Distance``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Distance(Of T As IRootFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Distance : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Distance (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static T Distance(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>
            Computes the distance between two points, specified as non-empty, equal-length tensors of numbers, in Euclidean space.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Divide&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Divide&lt;(class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Divide``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Divide(Of T As IDivisionOperators(Of T, T, T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Divide : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Divide (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IDivisionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Divide(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to be divided.</param>
        <param name="y">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> divisor.</param>
        <summary>
            Divides each element of <paramref name="x" /> by its corresponding element in <paramref name="y" /> and returns
            a new <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Divide&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Divide&lt;(class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Divide``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Divide(Of T As IDivisionOperators(Of T, T, T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Divide : ReadOnlyTensorSpan * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Divide (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IDivisionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Divide(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">Input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The divisor</param>
        <summary>
            Divides each element of <paramref name="x" /> by <paramref name="y" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Divide&lt;T&gt; (T x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Divide&lt;(class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(!!T x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Divide``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Divide(Of T As IDivisionOperators(Of T, T, T)) (x As T, ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Divide : 'T * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Divide (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IDivisionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Divide(T x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The value to be divided.</param>
        <param name="y">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> divisor.</param>
        <summary>
            Divides <paramref name="x" /> by each element of <paramref name="y" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result."/&gt;
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Divide&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Divide&lt;(class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Divide``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Divide(Of T As IDivisionOperators(Of T, T, T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Divide : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Divide (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IDivisionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Divide(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to be divided.</param>
        <param name="y">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> divisor.</param>
        <param name="destination" />
        <summary>
            Divides each element of <paramref name="x" /> by its corresponding element in <paramref name="y" /> and returns
            a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Divide&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Divide&lt;(class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Divide``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Divide(Of T As IDivisionOperators(Of T, T, T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Divide : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Divide (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IDivisionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Divide(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">Input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The divisor</param>
        <param name="destination" />
        <summary>
            Divides each element of <paramref name="x" /> by <paramref name="y" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Divide&lt;T&gt; (T x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Divide&lt;(class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(!!T x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Divide``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Divide(Of T As IDivisionOperators(Of T, T, T)) (x As T, ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Divide : 'T * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Divide (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IDivisionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Divide(T x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The value to be divided.</param>
        <param name="y">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> divisor.</param>
        <param name="destination" />
        <summary>
            Divides <paramref name="x" /> by each element of <paramref name="y" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result."/&gt;
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dot&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Dot&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Dot&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Dot``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dot(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T), IMultiplicativeIdentity(Of T, T), IMultiplyOperators(Of T, T, T)}) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Dot : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Dot (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt; static T Dot(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>
            Computes the dot product of two tensors containing numbers.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;bool&gt; Equals&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;bool&gt; Equals&lt;(class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Equals``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals(Of T As IEqualityOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member Equals : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;bool&gt; (requires 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.Equals (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IEqualityOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;bool&gt; ^ Equals(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> for equality. If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size
            before they are compared. It returns a <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> where the value is true if the elements are equal and false if they are not."/&gt;
            </summary>
        <returns>A <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> where the value is true if the elements are equal and false if they are not.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;bool&gt; Equals&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;bool&gt; Equals&lt;(class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Equals``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals(Of T As IEqualityOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Tensor(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member Equals : ReadOnlyTensorSpan * 'T -&gt; System.Numerics.Tensors.Tensor&lt;bool&gt; (requires 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.Equals (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IEqualityOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;bool&gt; ^ Equals(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second value to compare.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> for equality. If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size
            before they are compared. It returns a <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> where the value is true if the elements are equal and false if they are not."/&gt;
            </summary>
        <returns>A <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> where the value is true if the elements are equal and false if they are not.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;bool&gt; Equals&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;bool&gt; destination) where T : System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt; Equals&lt;(class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Equals``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{System.Boolean}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals(Of T As IEqualityOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of Boolean)) As TensorSpan(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member Equals : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.Equals (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IEqualityOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Equals(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;bool&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="destination" />
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> for equality. If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size
            before they are compared. It returns a <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> where the value is true if the elements are equal and false if they are not."/&gt;
            </summary>
        <returns>A <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> where the value is true if the elements are equal and false if they are not.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;bool&gt; Equals&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y, in System.Numerics.Tensors.TensorSpan&lt;bool&gt; destination) where T : System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt; Equals&lt;(class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Equals``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{System.Boolean}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals(Of T As IEqualityOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T, ByRef destination As TensorSpan(Of Boolean)) As TensorSpan(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member Equals : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.Equals (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IEqualityOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Equals(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y, System::Numerics::Tensors::TensorSpan&lt;bool&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second value to compare.</param>
        <param name="destination" />
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> for equality. If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size
            before they are compared. It returns a <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> where the value is true if the elements are equal and false if they are not."/&gt;
            </summary>
        <returns>A <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> where the value is true if the elements are equal and false if they are not.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EqualsAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool EqualsAll&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EqualsAll&lt;(class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.EqualsAll``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EqualsAll(Of T As IEqualityOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member EqualsAll : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; bool (requires 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.EqualsAll (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IEqualityOperators&lt;T, T, bool&gt; static bool EqualsAll(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare against.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see if all elements of <paramref name="x" /> are equal to <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean" /> where the value is true if all elements in <paramref name="x" /> are eqaul to <paramref name="y" />.
            </summary>
        <returns>
          <see cref="T:System.Boolean" /> where the value is true if all elements in <paramref name="x" /> are equal to <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EqualsAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool EqualsAll&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EqualsAll&lt;(class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.EqualsAll``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function EqualsAll(Of T As IEqualityOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Boolean" />
      <MemberSignature Language="F#" Value="static member EqualsAll : ReadOnlyTensorSpan * 'T -&gt; bool (requires 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.EqualsAll (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IEqualityOperators&lt;T, T, bool&gt; static bool EqualsAll(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare against.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see if all elements of <paramref name="x" /> are equal to <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean" /> where the value is true if all elements in <paramref name="x" /> are eqaul to <paramref name="y" />.
            </summary>
        <returns>
          <see cref="T:System.Boolean" /> where the value is true if all elements in <paramref name="x" /> are equal to <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EqualsAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool EqualsAny&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EqualsAny&lt;(class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.EqualsAny``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EqualsAny(Of T As IEqualityOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member EqualsAny : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; bool (requires 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.EqualsAny (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IEqualityOperators&lt;T, T, bool&gt; static bool EqualsAny(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare against.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see if any elements of <paramref name="x" /> are equal to <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean" /> where the value is true if any elements in <paramref name="x" /> are equal to <paramref name="y" />.
            </summary>
        <returns>
          <see cref="T:System.Boolean" /> where the value is true if any elements in <paramref name="x" /> are equal to <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EqualsAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool EqualsAny&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.IEqualityOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool EqualsAny&lt;(class System.Numerics.IEqualityOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.EqualsAny``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function EqualsAny(Of T As IEqualityOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Boolean" />
      <MemberSignature Language="F#" Value="static member EqualsAny : ReadOnlyTensorSpan * 'T -&gt; bool (requires 'T :&gt; System.Numerics.IEqualityOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.EqualsAny (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IEqualityOperators&lt;T, T, bool&gt; static bool EqualsAny(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IEqualityOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Value to compare against.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see if any elements of <paramref name="x" /> are equal to <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean" /> where the value is true if any elements in <paramref name="x" /> are equal to <paramref name="y" />.
            </summary>
        <returns>
          <see cref="T:System.Boolean" /> where the value is true if any elements in <paramref name="x" /> are equal to <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Exp&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Exp&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Exp``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Exp(Of T As IExponentialFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Exp : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Exp x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Exp(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>
            Computes the element-wise result of raising <c>e</c> to the single-precision floating-point number powers in the specified tensor.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Exp&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Exp&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Exp``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Exp(Of T As IExponentialFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Exp : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Exp (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Exp(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>
            Computes the element-wise result of raising <c>e</c> to the single-precision floating-point number powers in the specified tensor.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp10&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Exp10&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Exp10&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Exp10``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Exp10(Of T As IExponentialFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Exp10 : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Exp10 x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Exp10(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>
            Computes the element-wise result of raising 10 to the number powers in the specified tensor.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp10&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Exp10&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Exp10&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Exp10``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Exp10(Of T As IExponentialFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Exp10 : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Exp10 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Exp10(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>
            Computes the element-wise result of raising 10 to the number powers in the specified tensor.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp10M1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Exp10M1&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Exp10M1&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Exp10M1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Exp10M1(Of T As IExponentialFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Exp10M1 : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Exp10M1 x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Exp10M1(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>Computes the element-wise result of raising 10 to the number powers in the specified tensor, minus one.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp10M1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Exp10M1&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Exp10M1&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Exp10M1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Exp10M1(Of T As IExponentialFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Exp10M1 : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Exp10M1 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Exp10M1(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>Computes the element-wise result of raising 10 to the number powers in the specified tensor, minus one.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Exp2&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Exp2&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Exp2``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Exp2(Of T As IExponentialFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Exp2 : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Exp2 x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Exp2(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>Computes the element-wise result of raising 2 to the number powers in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Exp2&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Exp2&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Exp2``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Exp2(Of T As IExponentialFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Exp2 : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Exp2 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Exp2(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>Computes the element-wise result of raising 2 to the number powers in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp2M1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Exp2M1&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Exp2M1&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Exp2M1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Exp2M1(Of T As IExponentialFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Exp2M1 : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Exp2M1 x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Exp2M1(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>Computes the element-wise result of raising 2 to the number powers in the specified tensor, minus one.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp2M1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Exp2M1&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Exp2M1&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Exp2M1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Exp2M1(Of T As IExponentialFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Exp2M1 : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Exp2M1 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Exp2M1(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>Computes the element-wise result of raising 2 to the number powers in the specified tensor, minus one.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpM1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; ExpM1&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; ExpM1&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ExpM1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExpM1(Of T As IExponentialFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member ExpM1 : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.ExpM1 x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ ExpM1(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>Computes the element-wise result of raising <c>e</c> to the number powers in the specified tensor, minus 1.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpM1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; ExpM1&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; ExpM1&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ExpM1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExpM1(Of T As IExponentialFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member ExpM1 : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.ExpM1 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ ExpM1(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>Computes the element-wise result of raising <c>e</c> to the number powers in the specified tensor, minus 1.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FillGaussianNormalDistribution&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; FillGaussianNormalDistribution&lt;T&gt; (in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination, Random? random = default) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; FillGaussianNormalDistribution&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination, class System.Random random) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.FillGaussianNormalDistribution``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Random)" />
      <MemberSignature Language="VB.NET" Value="Public Function FillGaussianNormalDistribution(Of T As IFloatingPoint(Of T)) (ByRef destination As TensorSpan(Of T), Optional random As Random = Nothing) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member FillGaussianNormalDistribution : TensorSpan * Random -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.FillGaussianNormalDistribution (destination, random)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="random" Type="System.Random">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The element type.</typeparam>
        <param name="destination">The destination <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> where the data will be stored.</param>
        <param name="random">
          <see cref="T:System.Random" /> to provide random seeding. Defaults to <see cref="P:System.Random.Shared" /> if not provided.</param>
        <summary>
            Fills the given <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with random data in a Gaussian normal distribution. <see cref="T:System.Random" />
            can optionally be provided for seeding.
            </summary>
        <returns />
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FillUniformDistribution&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; FillUniformDistribution&lt;T&gt; (in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination, Random? random = default) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; FillUniformDistribution&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination, class System.Random random) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.FillUniformDistribution``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Random)" />
      <MemberSignature Language="VB.NET" Value="Public Function FillUniformDistribution(Of T As IFloatingPoint(Of T)) (ByRef destination As TensorSpan(Of T), Optional random As Random = Nothing) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member FillUniformDistribution : TensorSpan * Random -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.FillUniformDistribution (destination, random)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="random" Type="System.Random">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The element type.</typeparam>
        <param name="destination">The destination <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> where the data will be stored.</param>
        <param name="random">
          <see cref="T:System.Random" /> to provide random seeding. Defaults to <see cref="P:System.Random.Shared" /> if not provided.</param>
        <summary>
            Fills the given <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with random data in a uniform distribution. <see cref="T:System.Random" />
            can optionally be provided for seeding.
            </summary>
        <returns />
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilteredUpdate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; FilteredUpdate&lt;T&gt; (this in System.Numerics.Tensors.TensorSpan&lt;T&gt; tensor, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;bool&gt; filter, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; FilteredUpdate&lt;T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; tensor, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;bool&gt;&amp; filter, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.FilteredUpdate``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{System.Boolean}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FilteredUpdate(Of T) (ByRef tensor As TensorSpan(Of T), ByRef filter As ReadOnlyTensorSpan(Of Boolean), ByRef values As ReadOnlyTensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member FilteredUpdate : TensorSpan * ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; TensorSpan" Usage="System.Numerics.Tensors.Tensor.FilteredUpdate (tensor, filter, values)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ FilteredUpdate(System::Numerics::Tensors::TensorSpan&lt;T&gt; % tensor, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;bool&gt; % filter, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % values);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="filter" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;System.Boolean&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="values" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">Input <see cref="T:System.Numerics.Tensors.Tensor`1" />.</param>
        <param name="filter">Input filter where if the index is true then it will update the <paramref name="tensor" />.</param>
        <param name="values">Values to update in the <paramref name="tensor" />.</param>
        <summary>
            Updates the <paramref name="tensor" /> tensor with the <paramref name="values" /> where the <paramref name="filter" /> is true.
            If dimensions are not the same an exception is thrown.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilteredUpdate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; FilteredUpdate&lt;T&gt; (this in System.Numerics.Tensors.TensorSpan&lt;T&gt; tensor, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;bool&gt; filter, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; FilteredUpdate&lt;T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; tensor, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;bool&gt;&amp; filter, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.FilteredUpdate``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{System.Boolean}@,``0)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function FilteredUpdate(Of T) (ByRef tensor As TensorSpan(Of T), ByRef filter As ReadOnlyTensorSpan(Of Boolean), value As T) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member FilteredUpdate : TensorSpan * ReadOnlyTensorSpan * 'T -&gt; TensorSpan" Usage="System.Numerics.Tensors.Tensor.FilteredUpdate (tensor, filter, value)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ FilteredUpdate(System::Numerics::Tensors::TensorSpan&lt;T&gt; % tensor, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;bool&gt; % filter, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="filter" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;System.Boolean&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="value" Type="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">Input <see cref="T:System.Numerics.Tensors.Tensor`1" />.</param>
        <param name="filter">Input filter where if the index is true then it will update the <paramref name="tensor" />.</param>
        <param name="value">Value to update in the <paramref name="tensor" />.</param>
        <summary>
            Updates the <paramref name="tensor" /> tensor with the <paramref name="value" /> where the <paramref name="filter" /> is true.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Floor&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Floor&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Floor&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Floor``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Floor(Of T As IFloatingPoint(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Floor : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Floor x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Floor(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>Computes the element-wise floor of numbers in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Floor&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Floor&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Floor&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Floor``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Floor(Of T As IFloatingPoint(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Floor : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Floor (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Floor(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>Computes the element-wise floor of numbers in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSmallestBroadcastableLengths">
      <MemberSignature Language="C#" Value="public static IntPtr[] GetSmallestBroadcastableLengths (ReadOnlySpan&lt;IntPtr&gt; shape1, ReadOnlySpan&lt;IntPtr&gt; shape2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int[] GetSmallestBroadcastableLengths(valuetype System.ReadOnlySpan`1&lt;native int&gt; shape1, valuetype System.ReadOnlySpan`1&lt;native int&gt; shape2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GetSmallestBroadcastableLengths(System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSmallestBroadcastableLengths (shape1 As ReadOnlySpan(Of IntPtr), shape2 As ReadOnlySpan(Of IntPtr)) As IntPtr()" />
      <MemberSignature Language="F#" Value="static member GetSmallestBroadcastableLengths : ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; nativeint[]" Usage="System.Numerics.Tensors.Tensor.GetSmallestBroadcastableLengths (shape1, shape2)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;IntPtr&gt; ^ GetSmallestBroadcastableLengths(ReadOnlySpan&lt;IntPtr&gt; shape1, ReadOnlySpan&lt;IntPtr&gt; shape2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr[]</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="shape1" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;" />
        <Parameter Name="shape2" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;" />
      </Parameters>
      <Docs>
        <param name="shape1">The first shape to broadcast.</param>
        <param name="shape2">The second shape to broadcast.</param>
        <summary>
            Gets the smallest broadcastable lengths for two shapes.
            </summary>
        <returns>The smallest lengths these shapes can be broadcast to.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">The lengths of <paramref name="shape1" /> and  <paramref name="shape2" /> are not broadcast compatible.</exception>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;bool&gt; GreaterThan&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;bool&gt; GreaterThan&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThan``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThan(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member GreaterThan : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;bool&gt; (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThan (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;bool&gt; ^ GreaterThan(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see which elements of <paramref name="x" /> are greater than <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are greater than <paramref name="y" />
            and false if they are not."/&gt;
            </summary>
        <returns>A <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are greater than <paramref name="y" /> and
            false if they are not.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;bool&gt; GreaterThan&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;bool&gt; GreaterThan&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThan``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThan(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Tensor(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member GreaterThan : ReadOnlyTensorSpan * 'T -&gt; System.Numerics.Tensors.Tensor&lt;bool&gt; (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThan (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;bool&gt; ^ GreaterThan(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">
          <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">
          <typeparamref name="T" /> to compare against <paramref name="x" />.</param>
        <summary>
            Compares the elements of a <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see which elements are greater than <paramref name="y" />.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are greater than <paramref name="y" />
            and false if they are not."/&gt;
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are greater than <paramref name="y" />
            and false if they are not.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;bool&gt; GreaterThan&lt;T&gt; (T x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;bool&gt; GreaterThan&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(!!T x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThan``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThan(Of T As IComparisonOperators(Of T, T, Boolean)) (x As T, ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member GreaterThan : 'T * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;bool&gt; (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThan (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;bool&gt; ^ GreaterThan(T x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">
          <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">
          <typeparamref name="T" /> to compare against <paramref name="x" />.</param>
        <summary>
            Compares <paramref name="x" /> to see which elements are greater than <paramref name="y" />.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are greater than <paramref name="y" />
            and false if they are not."/&gt;
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are greater than <paramref name="y" />
            and false if they are not.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;bool&gt; GreaterThan&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;bool&gt; destination) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt; GreaterThan&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThan``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{System.Boolean}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThan(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of Boolean)) As TensorSpan(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member GreaterThan : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThan (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ GreaterThan(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;bool&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="destination" />
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see which elements of <paramref name="x" /> are greater than <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are greater than <paramref name="y" />
            and false if they are not."/&gt;
            </summary>
        <returns>A <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are greater than <paramref name="y" /> and
            false if they are not.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;bool&gt; GreaterThan&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y, in System.Numerics.Tensors.TensorSpan&lt;bool&gt; destination) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt; GreaterThan&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThan``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{System.Boolean}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThan(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T, ByRef destination As TensorSpan(Of Boolean)) As TensorSpan(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member GreaterThan : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThan (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ GreaterThan(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y, System::Numerics::Tensors::TensorSpan&lt;bool&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">
          <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">
          <typeparamref name="T" /> to compare against <paramref name="x" />.</param>
        <param name="destination" />
        <summary>
            Compares the elements of a <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see which elements are greater than <paramref name="y" />.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are greater than <paramref name="y" />
            and false if they are not."/&gt;
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are greater than <paramref name="y" />
            and false if they are not.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;bool&gt; GreaterThan&lt;T&gt; (T x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;bool&gt; destination) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt; GreaterThan&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(!!T x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThan``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{System.Boolean}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThan(Of T As IComparisonOperators(Of T, T, Boolean)) (x As T, ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of Boolean)) As TensorSpan(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member GreaterThan : 'T * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThan (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ GreaterThan(T x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;bool&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">
          <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">
          <typeparamref name="T" /> to compare against <paramref name="x" />.</param>
        <param name="destination" />
        <summary>
            Compares <paramref name="x" /> to see which elements are greater than <paramref name="y" />.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are greater than <paramref name="y" />
            and false if they are not."/&gt;
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are greater than <paramref name="y" />
            and false if they are not.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool GreaterThanAll&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GreaterThanAll&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThanAll``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThanAll(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member GreaterThanAll : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThanAll (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool GreaterThanAll(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare against.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see if all elements of <paramref name="x" /> are greater than <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean" /> where the value is true if all elements in <paramref name="x" /> are greater than <paramref name="y" />.
            </summary>
        <returns>
          <see cref="T:System.Boolean" /> where the value is true if all elements in <paramref name="x" /> are greater than <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool GreaterThanAll&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GreaterThanAll&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThanAll``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThanAll(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Boolean" />
      <MemberSignature Language="F#" Value="static member GreaterThanAll : ReadOnlyTensorSpan * 'T -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThanAll (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool GreaterThanAll(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare against.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see if all elements of <paramref name="x" /> are greater than <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean" /> where the value is true if all elements in <paramref name="x" /> are greater than <paramref name="y" />.
            </summary>
        <returns>
          <see cref="T:System.Boolean" /> where the value is true if all elements in <paramref name="x" /> are greater than <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool GreaterThanAll&lt;T&gt; (T x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GreaterThanAll&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(!!T x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThanAll``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThanAll(Of T As IComparisonOperators(Of T, T, Boolean)) (x As T, ByRef y As ReadOnlyTensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member GreaterThanAll : 'T * ReadOnlyTensorSpan -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThanAll (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool GreaterThanAll(T x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare against.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see if all elements of <paramref name="y" /> are greater than <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean" /> where the value is true if all elements in <paramref name="y" /> are greater than <paramref name="y" />.
            </summary>
        <returns>
          <see cref="T:System.Boolean" /> where the value is true if all elements in <paramref name="y" /> are greater than <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool GreaterThanAny&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GreaterThanAny&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThanAny``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThanAny(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member GreaterThanAny : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThanAny (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool GreaterThanAny(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare against.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see if any elements of <paramref name="x" /> are greater than <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean" /> where the value is true if any elements in <paramref name="x" /> are greater than <paramref name="y" />.
            </summary>
        <returns>
          <see cref="T:System.Boolean" /> where the value is true if any elements in <paramref name="x" /> are greater than <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool GreaterThanAny&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GreaterThanAny&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThanAny``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThanAny(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Boolean" />
      <MemberSignature Language="F#" Value="static member GreaterThanAny : ReadOnlyTensorSpan * 'T -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThanAny (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool GreaterThanAny(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Value to compare against.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see if any elements of <paramref name="x" /> are greater than <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean" /> where the value is true if any elements in <paramref name="x" /> are greater than <paramref name="y" />.
            </summary>
        <returns>
          <see cref="T:System.Boolean" /> where the value is true if any elements in <paramref name="x" /> are greater than <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool GreaterThanAny&lt;T&gt; (T x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GreaterThanAny&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(!!T x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThanAny``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThanAny(Of T As IComparisonOperators(Of T, T, Boolean)) (x As T, ByRef y As ReadOnlyTensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member GreaterThanAny : 'T * ReadOnlyTensorSpan -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThanAny (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool GreaterThanAny(T x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="y">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="x">Value to compare against.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see if any elements of <paramref name="y" /> are greater than <paramref name="x" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean" /> where the value is true if any elements in <paramref name="y" /> are greater than <paramref name="x" />.
            </summary>
        <returns>
          <see cref="T:System.Boolean" /> where the value is true if any elements in <paramref name="y" /> are greater than <paramref name="x" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;bool&gt; GreaterThanOrEqual&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;bool&gt; GreaterThanOrEqual&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThanOrEqual``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThanOrEqual(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqual : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;bool&gt; (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThanOrEqual (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;bool&gt; ^ GreaterThanOrEqual(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see which elements of <paramref name="x" /> are greater than or equal to <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are greater than <paramref name="y" />
            and false if they are not."/&gt;
            </summary>
        <returns>A <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are greater than <paramref name="y" /> and
            false if they are not.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;bool&gt; GreaterThanOrEqual&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;bool&gt; GreaterThanOrEqual&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThanOrEqual``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThanOrEqual(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Tensor(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqual : ReadOnlyTensorSpan * 'T -&gt; System.Numerics.Tensors.Tensor&lt;bool&gt; (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThanOrEqual (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;bool&gt; ^ GreaterThanOrEqual(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">
          <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">
          <typeparamref name="T" /> to compare against <paramref name="x" />.</param>
        <summary>
            Compares the elements of a <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see which elements are greater than or equal to <paramref name="y" />.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are greater than <paramref name="y" />
            and false if they are not."/&gt;
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are greater than <paramref name="y" />
            and false if they are not.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;bool&gt; GreaterThanOrEqual&lt;T&gt; (T x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;bool&gt; GreaterThanOrEqual&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(!!T x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThanOrEqual``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThanOrEqual(Of T As IComparisonOperators(Of T, T, Boolean)) (x As T, ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqual : 'T * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;bool&gt; (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThanOrEqual (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;bool&gt; ^ GreaterThanOrEqual(T x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">
          <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">
          <typeparamref name="T" /> to compare against <paramref name="x" />.</param>
        <summary>
            Compares <paramref name="x" /> to see which elements are greater than or equal to <paramref name="y" />.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are greater than <paramref name="y" />
            and false if they are not."/&gt;
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are greater than <paramref name="y" />
            and false if they are not.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;bool&gt; GreaterThanOrEqual&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;bool&gt; destination) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt; GreaterThanOrEqual&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThanOrEqual``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{System.Boolean}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThanOrEqual(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of Boolean)) As TensorSpan(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqual : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThanOrEqual (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ GreaterThanOrEqual(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;bool&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="destination" />
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see which elements of <paramref name="x" /> are greater than or equal to <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are greater than <paramref name="y" />
            and false if they are not."/&gt;
            </summary>
        <returns>A <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are greater than <paramref name="y" /> and
            false if they are not.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;bool&gt; GreaterThanOrEqual&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y, in System.Numerics.Tensors.TensorSpan&lt;bool&gt; destination) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt; GreaterThanOrEqual&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThanOrEqual``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{System.Boolean}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThanOrEqual(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T, ByRef destination As TensorSpan(Of Boolean)) As TensorSpan(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqual : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThanOrEqual (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ GreaterThanOrEqual(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y, System::Numerics::Tensors::TensorSpan&lt;bool&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">
          <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">
          <typeparamref name="T" /> to compare against <paramref name="x" />.</param>
        <param name="destination" />
        <summary>
            Compares the elements of a <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see which elements are greater than or equal to <paramref name="y" />.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are greater than <paramref name="y" />
            and false if they are not."/&gt;
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are greater than <paramref name="y" />
            and false if they are not.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;bool&gt; GreaterThanOrEqual&lt;T&gt; (T x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;bool&gt; destination) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt; GreaterThanOrEqual&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(!!T x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThanOrEqual``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{System.Boolean}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThanOrEqual(Of T As IComparisonOperators(Of T, T, Boolean)) (x As T, ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of Boolean)) As TensorSpan(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqual : 'T * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThanOrEqual (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ GreaterThanOrEqual(T x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;bool&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">
          <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">
          <typeparamref name="T" /> to compare against <paramref name="x" />.</param>
        <param name="destination" />
        <summary>
            Compares <paramref name="x" /> to see which elements are greater than or equal to <paramref name="y" />.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are greater than <paramref name="y" />
            and false if they are not."/&gt;
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are greater than <paramref name="y" />
            and false if they are not.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqualAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool GreaterThanOrEqualAll&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GreaterThanOrEqualAll&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThanOrEqualAll``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThanOrEqualAll(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqualAll : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThanOrEqualAll (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool GreaterThanOrEqualAll(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare against.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see if all elements of <paramref name="x" /> are greater than <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean" /> where the value is true if all elements in <paramref name="x" /> are greater than <paramref name="y" />.
            </summary>
        <returns>
          <see cref="T:System.Boolean" /> where the value is true if all elements in <paramref name="x" /> are greater than <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqualAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool GreaterThanOrEqualAll&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GreaterThanOrEqualAll&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThanOrEqualAll``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThanOrEqualAll(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Boolean" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqualAll : ReadOnlyTensorSpan * 'T -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThanOrEqualAll (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool GreaterThanOrEqualAll(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare against.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see if all elements of <paramref name="x" /> are greater than <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean" /> where the value is true if all elements in <paramref name="x" /> are greater than <paramref name="y" />.
            </summary>
        <returns>
          <see cref="T:System.Boolean" /> where the value is true if all elements in <paramref name="x" /> are greater than <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqualAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool GreaterThanOrEqualAll&lt;T&gt; (T x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GreaterThanOrEqualAll&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(!!T x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThanOrEqualAll``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThanOrEqualAll(Of T As IComparisonOperators(Of T, T, Boolean)) (x As T, ByRef y As ReadOnlyTensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqualAll : 'T * ReadOnlyTensorSpan -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThanOrEqualAll (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool GreaterThanOrEqualAll(T x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare against.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see if all elements of <paramref name="y" /> are greater than <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean" /> where the value is true if all elements in <paramref name="y" /> are greater than <paramref name="y" />.
            </summary>
        <returns>
          <see cref="T:System.Boolean" /> where the value is true if all elements in <paramref name="y" /> are greater than <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqualAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool GreaterThanOrEqualAny&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GreaterThanOrEqualAny&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThanOrEqualAny``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThanOrEqualAny(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqualAny : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThanOrEqualAny (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool GreaterThanOrEqualAny(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare against.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see if any elements of <paramref name="x" /> are greater than <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean" /> where the value is true if any elements in <paramref name="x" /> are greater than <paramref name="y" />.
            </summary>
        <returns>
          <see cref="T:System.Boolean" /> where the value is true if any elements in <paramref name="x" /> are greater than <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqualAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool GreaterThanOrEqualAny&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GreaterThanOrEqualAny&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThanOrEqualAny``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThanOrEqualAny(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Boolean" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqualAny : ReadOnlyTensorSpan * 'T -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThanOrEqualAny (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool GreaterThanOrEqualAny(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Value to compare against.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see if any elements of <paramref name="x" /> are greater than <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean" /> where the value is true if any elements in <paramref name="x" /> are greater than <paramref name="y" />.
            </summary>
        <returns>
          <see cref="T:System.Boolean" /> where the value is true if any elements in <paramref name="x" /> are greater than <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreaterThanOrEqualAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool GreaterThanOrEqualAny&lt;T&gt; (T x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool GreaterThanOrEqualAny&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(!!T x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.GreaterThanOrEqualAny``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GreaterThanOrEqualAny(Of T As IComparisonOperators(Of T, T, Boolean)) (x As T, ByRef y As ReadOnlyTensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member GreaterThanOrEqualAny : 'T * ReadOnlyTensorSpan -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.GreaterThanOrEqualAny (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool GreaterThanOrEqualAny(T x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="y">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="x">Value to compare against.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see if any elements of <paramref name="y" /> are greater than <paramref name="x" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean" /> where the value is true if any elements in <paramref name="y" /> are greater than <paramref name="x" />.
            </summary>
        <returns>
          <see cref="T:System.Boolean" /> where the value is true if any elements in <paramref name="y" /> are greater than <paramref name="x" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Hypot&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Hypot&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Hypot&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Hypot``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Hypot(Of T As IRootFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Hypot : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Hypot (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Hypot(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">Left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">Right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>
            Computes the element-wise hypotenuse given values from two tensors representing the lengths of the shorter sides in a right-angled triangle.
            If the shapes are not the same they are broadcast to the smallest compatible shape.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Hypot&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Hypot&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Hypot&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Hypot``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Hypot(Of T As IRootFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Hypot : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Hypot (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Hypot(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">Left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">Right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>
            Computes the element-wise hypotenuse given values from two tensors representing the lengths of the shorter sides in a right-angled triangle.
            If the shapes are not the same they are broadcast to the smallest compatible shape.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ieee754Remainder&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Ieee754Remainder&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Ieee754Remainder&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Ieee754Remainder``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Ieee754Remainder(Of T As IFloatingPointIeee754(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Ieee754Remainder : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Ieee754Remainder (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Ieee754Remainder(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">Left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">Right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>Computes the element-wise remainder of the numbers in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ieee754Remainder&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Ieee754Remainder&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Ieee754Remainder&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Ieee754Remainder``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Ieee754Remainder(Of T As IFloatingPointIeee754(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Ieee754Remainder : ReadOnlyTensorSpan * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Ieee754Remainder (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Ieee754Remainder(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>Computes the element-wise remainder of the numbers in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ieee754Remainder&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Ieee754Remainder&lt;T&gt; (T x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Ieee754Remainder&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(!!T x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Ieee754Remainder``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Ieee754Remainder(Of T As IFloatingPointIeee754(Of T)) (x As T, ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Ieee754Remainder : 'T * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Ieee754Remainder (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Ieee754Remainder(T x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>Computes the element-wise remainder of the numbers in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ieee754Remainder&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Ieee754Remainder&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Ieee754Remainder&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Ieee754Remainder``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Ieee754Remainder(Of T As IFloatingPointIeee754(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Ieee754Remainder : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Ieee754Remainder (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Ieee754Remainder(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">Left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">Right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>Computes the element-wise remainder of the numbers in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ieee754Remainder&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Ieee754Remainder&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Ieee754Remainder&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Ieee754Remainder``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Ieee754Remainder(Of T As IFloatingPointIeee754(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Ieee754Remainder : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Ieee754Remainder (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Ieee754Remainder(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>Computes the element-wise remainder of the numbers in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Ieee754Remainder&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Ieee754Remainder&lt;T&gt; (T x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Ieee754Remainder&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(!!T x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Ieee754Remainder``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Ieee754Remainder(Of T As IFloatingPointIeee754(Of T)) (x As T, ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Ieee754Remainder : 'T * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Ieee754Remainder (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Ieee754Remainder(T x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>Computes the element-wise remainder of the numbers in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ILogB&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;int&gt; ILogB&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;int32&gt; ILogB&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ILogB``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ILogB(Of T As IFloatingPointIeee754(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of Integer)" />
      <MemberSignature Language="F#" Value="static member ILogB : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;int&gt; (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.ILogB x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;int&gt; ^ ILogB(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>Computes the element-wise integer logarithm of numbers in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ILogB&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;int&gt; ILogB&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;int&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;int32&gt; ILogB&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;int32&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ILogB``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{System.Int32}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ILogB(Of T As IFloatingPointIeee754(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of Integer)) As TensorSpan(Of Integer)" />
      <MemberSignature Language="F#" Value="static member ILogB : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.ILogB (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ ILogB(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;int&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;System.Int32&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;System.Int32&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>Computes the element-wise integer logarithm of numbers in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMax&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfMax&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMax&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.IndexOfMax``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfMax(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMax : ReadOnlyTensorSpan -&gt; int (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.IndexOfMax x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static int IndexOfMax(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>Searches for the index of the largest number in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMaxMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfMaxMagnitude&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMaxMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.IndexOfMaxMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfMaxMagnitude(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMaxMagnitude : ReadOnlyTensorSpan -&gt; int (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.IndexOfMaxMagnitude x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static int IndexOfMaxMagnitude(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>Searches for the index of the number with the largest magnitude in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfMin&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMin&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.IndexOfMin``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfMin(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMin : ReadOnlyTensorSpan -&gt; int (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.IndexOfMin x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static int IndexOfMin(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>Searches for the index of the smallest number in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMinMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfMinMagnitude&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMinMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.IndexOfMinMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfMinMagnitude(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMinMagnitude : ReadOnlyTensorSpan -&gt; int (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.IndexOfMinMagnitude x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static int IndexOfMinMagnitude(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>
            Searches for the index of the number with the smallest magnitude in the specified tensor.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeadingZeroCount&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; LeadingZeroCount&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; LeadingZeroCount&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LeadingZeroCount``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function LeadingZeroCount(Of T As IBinaryInteger(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member LeadingZeroCount : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.LeadingZeroCount x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ LeadingZeroCount(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>
            Computes the element-wise leading zero count of numbers in the specified tensor.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeadingZeroCount&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; LeadingZeroCount&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; LeadingZeroCount&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LeadingZeroCount``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function LeadingZeroCount(Of T As IBinaryInteger(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member LeadingZeroCount : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.LeadingZeroCount (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ LeadingZeroCount(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>
            Computes the element-wise leading zero count of numbers in the specified tensor.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;bool&gt; LessThan&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;bool&gt; LessThan&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThan``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThan(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member LessThan : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;bool&gt; (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThan (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;bool&gt; ^ LessThan(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see which elements of <paramref name="x" /> are less than <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are less than <paramref name="y" />
            and false if they are not."/&gt;
            </summary>
        <returns>A <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are less than <paramref name="y" /> and
            false if they are not.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;bool&gt; LessThan&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;bool&gt; LessThan&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThan``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThan(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Tensor(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member LessThan : ReadOnlyTensorSpan * 'T -&gt; System.Numerics.Tensors.Tensor&lt;bool&gt; (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThan (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;bool&gt; ^ LessThan(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> to compare.</param>
        <param name="y">
          <typeparamref name="T" /> to compare against <paramref name="x" />.</param>
        <summary>
            Compares the elements of a <see cref="T:System.Numerics.Tensors.Tensor`1" /> to see which elements are less than <paramref name="y" />.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are less than <paramref name="y" />
            and false if they are not."/&gt;
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are less than <paramref name="y" />
            and false if they are not.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;bool&gt; LessThan&lt;T&gt; (T x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;bool&gt; LessThan&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(!!T x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThan``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThan(Of T As IComparisonOperators(Of T, T, Boolean)) (x As T, ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member LessThan : 'T * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;bool&gt; (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThan (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;bool&gt; ^ LessThan(T x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> to compare.</param>
        <param name="y">
          <typeparamref name="T" /> to compare against <paramref name="x" />.</param>
        <summary>
            Compares the elements of a <see cref="T:System.Numerics.Tensors.Tensor`1" /> to see which elements are less than <paramref name="y" />.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are less than <paramref name="y" />
            and false if they are not."/&gt;
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are less than <paramref name="y" />
            and false if they are not.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;bool&gt; LessThan&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;bool&gt; destination) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt; LessThan&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThan``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{System.Boolean}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThan(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of Boolean)) As TensorSpan(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member LessThan : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThan (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ LessThan(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;bool&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="destination" />
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see which elements of <paramref name="x" /> are less than <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are less than <paramref name="y" />
            and false if they are not."/&gt;
            </summary>
        <returns>A <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are less than <paramref name="y" /> and
            false if they are not.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;bool&gt; LessThan&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y, in System.Numerics.Tensors.TensorSpan&lt;bool&gt; destination) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt; LessThan&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThan``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{System.Boolean}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThan(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T, ByRef destination As TensorSpan(Of Boolean)) As TensorSpan(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member LessThan : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThan (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ LessThan(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y, System::Numerics::Tensors::TensorSpan&lt;bool&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> to compare.</param>
        <param name="y">
          <typeparamref name="T" /> to compare against <paramref name="x" />.</param>
        <param name="destination" />
        <summary>
            Compares the elements of a <see cref="T:System.Numerics.Tensors.Tensor`1" /> to see which elements are less than <paramref name="y" />.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are less than <paramref name="y" />
            and false if they are not."/&gt;
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are less than <paramref name="y" />
            and false if they are not.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;bool&gt; LessThan&lt;T&gt; (T x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;bool&gt; destination) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt; LessThan&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(!!T x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThan``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{System.Boolean}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThan(Of T As IComparisonOperators(Of T, T, Boolean)) (x As T, ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of Boolean)) As TensorSpan(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member LessThan : 'T * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThan (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ LessThan(T x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;bool&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> to compare.</param>
        <param name="y">
          <typeparamref name="T" /> to compare against <paramref name="x" />.</param>
        <param name="destination" />
        <summary>
            Compares the elements of a <see cref="T:System.Numerics.Tensors.Tensor`1" /> to see which elements are less than <paramref name="y" />.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are less than <paramref name="y" />
            and false if they are not."/&gt;
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are less than <paramref name="y" />
            and false if they are not.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool LessThanAll&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool LessThanAll&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThanAll``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThanAll(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member LessThanAll : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThanAll (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool LessThanAll(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare against.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see if all elements of <paramref name="x" /> are less than <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean" /> where the value is true if all elements in <paramref name="x" /> are less than <paramref name="y" />.
            </summary>
        <returns>
          <see cref="T:System.Boolean" /> where the value is true if all elements in <paramref name="x" /> are less than <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool LessThanAll&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool LessThanAll&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThanAll``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThanAll(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Boolean" />
      <MemberSignature Language="F#" Value="static member LessThanAll : ReadOnlyTensorSpan * 'T -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThanAll (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool LessThanAll(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second value to compare against.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see if all elements of <paramref name="x" /> are less than <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean" /> where the value is true if all elements in <paramref name="x" /> are less than <paramref name="y" />.
            </summary>
        <returns>
          <see cref="T:System.Boolean" /> where the value is true if all elements in <paramref name="x" /> are less than <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool LessThanAll&lt;T&gt; (T x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool LessThanAll&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(!!T x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThanAll``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThanAll(Of T As IComparisonOperators(Of T, T, Boolean)) (x As T, ByRef y As ReadOnlyTensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member LessThanAll : 'T * ReadOnlyTensorSpan -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThanAll (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool LessThanAll(T x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="y">First value to compare.</param>
        <param name="x">Second value to compare against.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see if all elements of <paramref name="y" /> are less than <paramref name="x" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean" /> where the value is true if all elements in <paramref name="y" /> are less than <paramref name="x" />.
            </summary>
        <returns>
          <see cref="T:System.Boolean" /> where the value is true if all elements in <paramref name="y" /> are less than <paramref name="x" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool LessThanAny&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool LessThanAny&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThanAny``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThanAny(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member LessThanAny : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThanAny (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool LessThanAny(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare against.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see if any elements of <paramref name="x" /> are less than <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean" /> where the value is true if any elements in <paramref name="x" /> are less than <paramref name="y" />.
            </summary>
        <returns>
          <see cref="T:System.Boolean" /> where the value is true if any elements in <paramref name="x" /> are less than <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool LessThanAny&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool LessThanAny&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThanAny``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThanAny(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Boolean" />
      <MemberSignature Language="F#" Value="static member LessThanAny : ReadOnlyTensorSpan * 'T -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThanAny (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool LessThanAny(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second value to compare against.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see if any elements of <paramref name="x" /> are less than <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean" /> where the value is true if any elements in <paramref name="x" /> are less than <paramref name="y" />.
            </summary>
        <returns>
          <see cref="T:System.Boolean" /> where the value is true if any elements in <paramref name="x" /> are less than <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool LessThanAny&lt;T&gt; (T x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool LessThanAny&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(!!T x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThanAny``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThanAny(Of T As IComparisonOperators(Of T, T, Boolean)) (x As T, ByRef y As ReadOnlyTensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member LessThanAny : 'T * ReadOnlyTensorSpan -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThanAny (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool LessThanAny(T x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First value to compare.</param>
        <param name="y">Second value to compare against.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see if any elements of <paramref name="y" /> are less than <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean" /> where the value is true if any elements in <paramref name="y" /> are less than <paramref name="y" />.
            </summary>
        <returns>
          <see cref="T:System.Boolean" /> where the value is true if any elements in <paramref name="y" /> are less than <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;bool&gt; LessThanOrEqual&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;bool&gt; LessThanOrEqual&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThanOrEqual``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThanOrEqual(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqual : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;bool&gt; (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThanOrEqual (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;bool&gt; ^ LessThanOrEqual(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see which elements of <paramref name="x" /> are less than <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are less than <paramref name="y" />
            and false if they are not."/&gt;
            </summary>
        <returns>A <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are less than <paramref name="y" /> and
            false if they are not.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;bool&gt; LessThanOrEqual&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;bool&gt; LessThanOrEqual&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThanOrEqual``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThanOrEqual(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Tensor(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqual : ReadOnlyTensorSpan * 'T -&gt; System.Numerics.Tensors.Tensor&lt;bool&gt; (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThanOrEqual (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;bool&gt; ^ LessThanOrEqual(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> to compare.</param>
        <param name="y">
          <typeparamref name="T" /> to compare against <paramref name="x" />.</param>
        <summary>
            Compares the elements of a <see cref="T:System.Numerics.Tensors.Tensor`1" /> to see which elements are less than <paramref name="y" />.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are less than <paramref name="y" />
            and false if they are not."/&gt;
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are less than <paramref name="y" />
            and false if they are not.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;bool&gt; LessThanOrEqual&lt;T&gt; (T x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;bool&gt; LessThanOrEqual&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(!!T x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThanOrEqual``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThanOrEqual(Of T As IComparisonOperators(Of T, T, Boolean)) (x As T, ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqual : 'T * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;bool&gt; (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThanOrEqual (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::Tensor&lt;bool&gt; ^ LessThanOrEqual(T x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> to compare.</param>
        <param name="y">
          <typeparamref name="T" /> to compare against <paramref name="x" />.</param>
        <summary>
            Compares the elements of a <see cref="T:System.Numerics.Tensors.Tensor`1" /> to see which elements are less than <paramref name="y" />.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are less than <paramref name="y" />
            and false if they are not."/&gt;
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are less than <paramref name="y" />
            and false if they are not.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;bool&gt; LessThanOrEqual&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;bool&gt; destination) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt; LessThanOrEqual&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThanOrEqual``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{System.Boolean}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThanOrEqual(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of Boolean)) As TensorSpan(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqual : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThanOrEqual (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ LessThanOrEqual(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;bool&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="destination" />
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see which elements of <paramref name="x" /> are less than <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are less than <paramref name="y" />
            and false if they are not."/&gt;
            </summary>
        <returns>A <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are less than <paramref name="y" /> and
            false if they are not.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;bool&gt; LessThanOrEqual&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y, in System.Numerics.Tensors.TensorSpan&lt;bool&gt; destination) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt; LessThanOrEqual&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThanOrEqual``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{System.Boolean}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThanOrEqual(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T, ByRef destination As TensorSpan(Of Boolean)) As TensorSpan(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqual : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThanOrEqual (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ LessThanOrEqual(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y, System::Numerics::Tensors::TensorSpan&lt;bool&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> to compare.</param>
        <param name="y">
          <typeparamref name="T" /> to compare against <paramref name="x" />.</param>
        <param name="destination" />
        <summary>
            Compares the elements of a <see cref="T:System.Numerics.Tensors.Tensor`1" /> to see which elements are less than <paramref name="y" />.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are less than <paramref name="y" />
            and false if they are not."/&gt;
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are less than <paramref name="y" />
            and false if they are not.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;bool&gt; LessThanOrEqual&lt;T&gt; (T x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;bool&gt; destination) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt; LessThanOrEqual&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(!!T x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;bool&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThanOrEqual``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{System.Boolean}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThanOrEqual(Of T As IComparisonOperators(Of T, T, Boolean)) (x As T, ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of Boolean)) As TensorSpan(Of Boolean)" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqual : 'T * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThanOrEqual (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ LessThanOrEqual(T x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;bool&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;System.Boolean&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> to compare.</param>
        <param name="y">
          <typeparamref name="T" /> to compare against <paramref name="x" />.</param>
        <param name="destination" />
        <summary>
            Compares the elements of a <see cref="T:System.Numerics.Tensors.Tensor`1" /> to see which elements are less than <paramref name="y" />.
            It returns a <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are less than <paramref name="y" />
            and false if they are not."/&gt;
            </summary>
        <returns>
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> where the value is true if the elements in <paramref name="x" /> are less than <paramref name="y" />
            and false if they are not.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqualAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool LessThanOrEqualAll&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool LessThanOrEqualAll&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThanOrEqualAll``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThanOrEqualAll(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqualAll : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThanOrEqualAll (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool LessThanOrEqualAll(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare against.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see if all elements of <paramref name="x" /> are less than <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean" /> where the value is true if all elements in <paramref name="x" /> are less than <paramref name="y" />.
            </summary>
        <returns>
          <see cref="T:System.Boolean" /> where the value is true if all elements in <paramref name="x" /> are less than <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqualAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool LessThanOrEqualAll&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool LessThanOrEqualAll&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThanOrEqualAll``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThanOrEqualAll(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Boolean" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqualAll : ReadOnlyTensorSpan * 'T -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThanOrEqualAll (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool LessThanOrEqualAll(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second value to compare against.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see if all elements of <paramref name="x" /> are less than <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean" /> where the value is true if all elements in <paramref name="x" /> are less than <paramref name="y" />.
            </summary>
        <returns>
          <see cref="T:System.Boolean" /> where the value is true if all elements in <paramref name="x" /> are less than <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqualAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool LessThanOrEqualAll&lt;T&gt; (T x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool LessThanOrEqualAll&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(!!T x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThanOrEqualAll``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThanOrEqualAll(Of T As IComparisonOperators(Of T, T, Boolean)) (x As T, ByRef y As ReadOnlyTensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqualAll : 'T * ReadOnlyTensorSpan -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThanOrEqualAll (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool LessThanOrEqualAll(T x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="y">First value to compare.</param>
        <param name="x">Second value to compare against.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see if all elements of <paramref name="y" /> are less than <paramref name="x" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean" /> where the value is true if all elements in <paramref name="y" /> are less than <paramref name="x" />.
            </summary>
        <returns>
          <see cref="T:System.Boolean" /> where the value is true if all elements in <paramref name="y" /> are less than <paramref name="x" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqualAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool LessThanOrEqualAny&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool LessThanOrEqualAny&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThanOrEqualAny``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThanOrEqualAny(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqualAny : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThanOrEqualAny (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool LessThanOrEqualAny(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare against.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see if any elements of <paramref name="x" /> are less than <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean" /> where the value is true if any elements in <paramref name="x" /> are less than <paramref name="y" />.
            </summary>
        <returns>
          <see cref="T:System.Boolean" /> where the value is true if any elements in <paramref name="x" /> are less than <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqualAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool LessThanOrEqualAny&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool LessThanOrEqualAny&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThanOrEqualAny``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThanOrEqualAny(Of T As IComparisonOperators(Of T, T, Boolean)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Boolean" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqualAny : ReadOnlyTensorSpan * 'T -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThanOrEqualAny (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool LessThanOrEqualAny(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to compare.</param>
        <param name="y">Second value to compare against.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see if any elements of <paramref name="x" /> are less than <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean" /> where the value is true if any elements in <paramref name="x" /> are less than <paramref name="y" />.
            </summary>
        <returns>
          <see cref="T:System.Boolean" /> where the value is true if any elements in <paramref name="x" /> are less than <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LessThanOrEqualAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool LessThanOrEqualAny&lt;T&gt; (T x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IComparisonOperators&lt;T,T,bool&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool LessThanOrEqualAny&lt;(class System.Numerics.IComparisonOperators`3&lt;!!T, !!T, bool&gt;) T&gt;(!!T x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LessThanOrEqualAny``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function LessThanOrEqualAny(Of T As IComparisonOperators(Of T, T, Boolean)) (x As T, ByRef y As ReadOnlyTensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member LessThanOrEqualAny : 'T * ReadOnlyTensorSpan -&gt; bool (requires 'T :&gt; System.Numerics.IComparisonOperators&lt;'T, 'T, bool&gt;)" Usage="System.Numerics.Tensors.Tensor.LessThanOrEqualAny (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IComparisonOperators&lt;T, T, bool&gt; static bool LessThanOrEqualAny(T x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IComparisonOperators&lt;T,T,System.Boolean&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">First value to compare.</param>
        <param name="y">Second value to compare against.</param>
        <summary>
            Compares the elements of two <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to see if any elements of <paramref name="y" /> are less than <paramref name="y" />.
            If the shapes are not the same, the tensors are broadcasted to the smallest broadcastable size before they are compared.
            It returns a <see cref="T:System.Boolean" /> where the value is true if any elements in <paramref name="y" /> are less than <paramref name="y" />.
            </summary>
        <returns>
          <see cref="T:System.Boolean" /> where the value is true if any elements in <paramref name="y" /> are less than <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Log&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Log&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Log(Of T As ILogarithmicFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Log : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Log(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the natural logarithm of.</param>
        <summary>
            Takes the natural logarithm of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Log&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Log&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Log(Of T As ILogarithmicFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Log : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Log(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor</param>
        <param name="y">The second tensor</param>
        <summary>Computes the element-wise logarithm of the numbers in a specified tensor to the specified base in another specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Log&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Log&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Log(Of T As ILogarithmicFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Log : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Log(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the natural logarithm of.</param>
        <param name="destination" />
        <summary>
            Takes the natural logarithm of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Log&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Log&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Log(Of T As ILogarithmicFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Log : ReadOnlyTensorSpan * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Log(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor</param>
        <param name="y">The second tensor</param>
        <summary>Computes the element-wise logarithm of the numbers in a specified tensor to the specified base in another specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Log&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Log&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Log(Of T As ILogarithmicFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Log : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Log(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor</param>
        <param name="y">The second tensor</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise logarithm of the numbers in a specified tensor to the specified base in another specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Log&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Log&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Log(Of T As ILogarithmicFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Log : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Log(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor</param>
        <param name="y">The second tensor</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise logarithm of the numbers in a specified tensor to the specified base in another specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Log10&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Log10&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log10``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Log10(Of T As ILogarithmicFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Log10 : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log10 x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Log10(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the base 10 logarithm of.</param>
        <summary>
            Takes the base 10 logarithm of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Log10&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Log10&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log10``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Log10(Of T As ILogarithmicFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Log10 : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log10 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Log10(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the base 10 logarithm of.</param>
        <param name="destination" />
        <summary>
            Takes the base 10 logarithm of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10P1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Log10P1&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Log10P1&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log10P1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Log10P1(Of T As ILogarithmicFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Log10P1 : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log10P1 x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Log10P1(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the base 10 logarithm of.</param>
        <summary>
            Takes the base 10 logarithm plus 1 of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10P1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Log10P1&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Log10P1&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log10P1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Log10P1(Of T As ILogarithmicFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Log10P1 : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log10P1 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Log10P1(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the base 10 logarithm of.</param>
        <param name="destination" />
        <summary>
            Takes the base 10 logarithm plus 1 of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Log2&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Log2&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log2``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Log2(Of T As ILogarithmicFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Log2 : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log2 x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Log2(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the base 2 logarithm of.</param>
        <summary>
            Takes the base 2 logarithm of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Log2&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Log2&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log2``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Log2(Of T As ILogarithmicFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Log2 : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log2 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Log2(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the base 2 logarithm of.</param>
        <param name="destination" />
        <summary>
            Takes the base 2 logarithm of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log2P1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Log2P1&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Log2P1&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log2P1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Log2P1(Of T As ILogarithmicFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Log2P1 : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log2P1 x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Log2P1(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the base 2 logarithm of.</param>
        <summary>
            Takes the base 2 logarithm plus 1 of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Log2P1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Log2P1&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Log2P1&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Log2P1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Log2P1(Of T As ILogarithmicFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Log2P1 : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Log2P1 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Log2P1(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the base 2 logarithm of.</param>
        <param name="destination" />
        <summary>
            Takes the base 2 logarithm plus 1 of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogP1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; LogP1&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; LogP1&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LogP1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function LogP1(Of T As ILogarithmicFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member LogP1 : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.LogP1 x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ LogP1(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the natural logarithm of.</param>
        <summary>
            Takes the natural logarithm plus 1 of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogP1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; LogP1&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; LogP1&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.LogP1``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function LogP1(Of T As ILogarithmicFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member LogP1 : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.LogP1 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ LogP1(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the natural logarithm of.</param>
        <param name="destination" />
        <summary>
            Takes the natural logarithm plus 1 of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Max&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Max&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Max``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Max(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Max : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Max x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T Max(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />..</param>
        <summary>Searches for the largest number in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Max&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Max&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Max``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Max(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Max : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Max (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Max(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Max&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Max&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Max``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Max(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Max : ReadOnlyTensorSpan * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Max (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Max(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Max&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Max&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Max``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Max(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Max : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Max (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Max(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Max&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Max&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Max``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Max(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Max : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Max (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Max(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MaxMagnitude&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MaxMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MaxMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MaxMagnitude(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MaxMagnitude x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T MaxMagnitude(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />..</param>
        <summary>Searches for the number with the largest magnitude in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; MaxMagnitude&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; MaxMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MaxMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MaxMagnitude(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MaxMagnitude (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ MaxMagnitude(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the largest magnitude in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; MaxMagnitude&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; MaxMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MaxMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function MaxMagnitude(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : ReadOnlyTensorSpan * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MaxMagnitude (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ MaxMagnitude(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the largest magnitude in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; MaxMagnitude&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; MaxMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MaxMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MaxMagnitude(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MaxMagnitude (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ MaxMagnitude(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the largest magnitude in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; MaxMagnitude&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; MaxMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MaxMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MaxMagnitude(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MaxMagnitude (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ MaxMagnitude(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the largest magnitude in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitudeNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MaxMagnitudeNumber&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MaxMagnitudeNumber&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MaxMagnitudeNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MaxMagnitudeNumber(Of T As INumberBase(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MaxMagnitudeNumber : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MaxMagnitudeNumber x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static T MaxMagnitudeNumber(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />..</param>
        <summary>Searches for the number with the largest magnitude in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitudeNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; MaxMagnitudeNumber&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; MaxMagnitudeNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MaxMagnitudeNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MaxMagnitudeNumber(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member MaxMagnitudeNumber : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MaxMagnitudeNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ MaxMagnitudeNumber(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the largest magnitude in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitudeNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; MaxMagnitudeNumber&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; MaxMagnitudeNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MaxMagnitudeNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function MaxMagnitudeNumber(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member MaxMagnitudeNumber : ReadOnlyTensorSpan * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MaxMagnitudeNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ MaxMagnitudeNumber(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the largest magnitude in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitudeNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; MaxMagnitudeNumber&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; MaxMagnitudeNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MaxMagnitudeNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MaxMagnitudeNumber(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member MaxMagnitudeNumber : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MaxMagnitudeNumber (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ MaxMagnitudeNumber(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the largest magnitude in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitudeNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; MaxMagnitudeNumber&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; MaxMagnitudeNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MaxMagnitudeNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MaxMagnitudeNumber(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member MaxMagnitudeNumber : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MaxMagnitudeNumber (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ MaxMagnitudeNumber(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the largest magnitude in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MaxNumber&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MaxNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MaxNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MaxNumber(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MaxNumber : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MaxNumber x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T MaxNumber(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />..</param>
        <summary>Searches for the largest number in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; MaxNumber&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; MaxNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MaxNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MaxNumber(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member MaxNumber : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MaxNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ MaxNumber(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; MaxNumber&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; MaxNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MaxNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function MaxNumber(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member MaxNumber : ReadOnlyTensorSpan * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MaxNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ MaxNumber(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; MaxNumber&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; MaxNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MaxNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MaxNumber(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member MaxNumber : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MaxNumber (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ MaxNumber(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; MaxNumber&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; MaxNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MaxNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MaxNumber(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member MaxNumber : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MaxNumber (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ MaxNumber(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Min&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Min&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Min``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Min(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Min : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Min x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T Min(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>Searches for the smallest number in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Min&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Min&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Min``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Min(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Min : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Min (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Min(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the element-wise minimum of the numbers in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Min&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Min&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Min``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Min(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Min : ReadOnlyTensorSpan * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Min (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Min(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the element-wise minimum of the numbers in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Min&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Min&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Min``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Min(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Min : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Min (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Min(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise minimum of the numbers in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Min&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Min&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Min``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Min(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Min : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Min (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Min(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise minimum of the numbers in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MinMagnitude&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MinMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MinMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MinMagnitude(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MinMagnitude x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T MinMagnitude(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>Searches for the number with the smallest magnitude in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; MinMagnitude&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; MinMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MinMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MinMagnitude(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MinMagnitude (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ MinMagnitude(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the smallest magnitude in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; MinMagnitude&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; MinMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MinMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function MinMagnitude(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : ReadOnlyTensorSpan * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MinMagnitude (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ MinMagnitude(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the smallest magnitude in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; MinMagnitude&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; MinMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MinMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MinMagnitude(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MinMagnitude (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ MinMagnitude(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the smallest magnitude in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; MinMagnitude&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; MinMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MinMagnitude``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MinMagnitude(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MinMagnitude (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ MinMagnitude(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the smallest magnitude in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitudeNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MinMagnitudeNumber&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MinMagnitudeNumber&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MinMagnitudeNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MinMagnitudeNumber(Of T As INumberBase(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MinMagnitudeNumber : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MinMagnitudeNumber x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static T MinMagnitudeNumber(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />..</param>
        <summary>Searches for the number with the smallest magnitude in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitudeNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; MinMagnitudeNumber&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; MinMagnitudeNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MinMagnitudeNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MinMagnitudeNumber(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member MinMagnitudeNumber : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MinMagnitudeNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ MinMagnitudeNumber(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the smallest magnitude in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitudeNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; MinMagnitudeNumber&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; MinMagnitudeNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MinMagnitudeNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function MinMagnitudeNumber(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member MinMagnitudeNumber : ReadOnlyTensorSpan * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MinMagnitudeNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ MinMagnitudeNumber(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the smallest magnitude in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitudeNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; MinMagnitudeNumber&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; MinMagnitudeNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MinMagnitudeNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MinMagnitudeNumber(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member MinMagnitudeNumber : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MinMagnitudeNumber (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ MinMagnitudeNumber(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the smallest magnitude in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitudeNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; MinMagnitudeNumber&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; MinMagnitudeNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MinMagnitudeNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MinMagnitudeNumber(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member MinMagnitudeNumber : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MinMagnitudeNumber (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ MinMagnitudeNumber(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the smallest magnitude in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MinNumber&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MinNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MinNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MinNumber(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MinNumber : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MinNumber x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T MinNumber(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.TensorSpan`1" />..</param>
        <summary>Searches for the smallest number in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; MinNumber&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; MinNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MinNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MinNumber(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member MinNumber : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MinNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ MinNumber(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the element-wise minimum of the numbers in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; MinNumber&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; MinNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MinNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function MinNumber(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member MinNumber : ReadOnlyTensorSpan * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MinNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ MinNumber(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the element-wise minimum of the numbers in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; MinNumber&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; MinNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MinNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MinNumber(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member MinNumber : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MinNumber (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ MinNumber(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise minimum of the numbers in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; MinNumber&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; MinNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.MinNumber``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function MinNumber(Of T As INumber(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member MinNumber : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.MinNumber (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ MinNumber(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise minimum of the numbers in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiply&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Multiply&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Multiply&lt;(class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Multiply``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Multiply(Of T As {IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Multiply : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Multiply (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Multiply(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">Left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> for multiplication.</param>
        <param name="y">Right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> for multiplication.</param>
        <summary>
            Multiplies each element of <paramref name="x" /> with <paramref name="y" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            If the shapes are not the same they are broadcast to the smallest compatible shape.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiply&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Multiply&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Multiply&lt;(class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Multiply``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Multiply(Of T As {IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Multiply : ReadOnlyTensorSpan * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Multiply (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Multiply(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">Input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /></param>
        <param name="y">
          <typeparamref name="T" /> value to multiply by.</param>
        <summary>
            Multiplies each element of <paramref name="x" /> with <paramref name="y" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiply&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Multiply&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Multiply&lt;(class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Multiply``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Multiply(Of T As {IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Multiply : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Multiply (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Multiply(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">Left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> for multiplication.</param>
        <param name="y">Right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> for multiplication.</param>
        <param name="destination" />
        <summary>
            Multiplies each element of <paramref name="x" /> with <paramref name="y" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            If the shapes are not the same they are broadcast to the smallest compatible shape.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Multiply&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Multiply&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Multiply&lt;(class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Multiply``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Multiply(Of T As {IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (ByRef x As ReadOnlyTensorSpan(Of T), y As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Multiply : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Multiply (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Multiply(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">Input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /></param>
        <param name="y">
          <typeparamref name="T" /> value to multiply by.</param>
        <param name="destination" />
        <summary>
            Multiplies each element of <paramref name="x" /> with <paramref name="y" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Negate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Negate&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IUnaryNegationOperators&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Negate&lt;(class System.Numerics.IUnaryNegationOperators`2&lt;!!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Negate``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Negate(Of T As IUnaryNegationOperators(Of T, T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Negate : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IUnaryNegationOperators&lt;'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IUnaryNegationOperators&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Negate x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IUnaryNegationOperators&lt;T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Negate(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IUnaryNegationOperators&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /></param>
        <summary>Computes the element-wise negation of each number in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Negate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Negate&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IUnaryNegationOperators&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Negate&lt;(class System.Numerics.IUnaryNegationOperators`2&lt;!!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Negate``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Negate(Of T As IUnaryNegationOperators(Of T, T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Negate : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IUnaryNegationOperators&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Negate (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IUnaryNegationOperators&lt;T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Negate(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IUnaryNegationOperators&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /></param>
        <param name="destination" />
        <summary>Computes the element-wise negation of each number in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Norm&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Norm&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Norm&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Norm``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Norm(Of T As IRootFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Norm : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Norm x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static T Norm(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the norm of.</param>
        <summary>
             Takes the norm of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnesComplement&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; OnesComplement&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; OnesComplement&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.OnesComplement``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function OnesComplement(Of T As IBitwiseOperators(Of T, T, T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member OnesComplement : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.OnesComplement x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ OnesComplement(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /></param>
        <summary>Computes the element-wise one's complement of numbers in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnesComplement&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; OnesComplement&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; OnesComplement&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.OnesComplement``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function OnesComplement(Of T As IBitwiseOperators(Of T, T, T)) (ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member OnesComplement : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.OnesComplement (y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ OnesComplement(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="y">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /></param>
        <param name="destination" />
        <summary>Computes the element-wise one's complement of numbers in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PermuteDimensions&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; PermuteDimensions&lt;T&gt; (this System.Numerics.Tensors.Tensor&lt;T&gt; tensor, scoped ReadOnlySpan&lt;int&gt; dimensions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; PermuteDimensions&lt;T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; tensor, valuetype System.ReadOnlySpan`1&lt;int32&gt; dimensions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.PermuteDimensions``1(System.Numerics.Tensors.Tensor{``0},System.ReadOnlySpan{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function PermuteDimensions(Of T) (tensor As Tensor(Of T), dimensions As ReadOnlySpan(Of Integer)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member PermuteDimensions : System.Numerics.Tensors.Tensor&lt;'T&gt; * ReadOnlySpan&lt;int&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.PermuteDimensions (tensor, dimensions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ PermuteDimensions(System::Numerics::Tensors::Tensor&lt;T&gt; ^ tensor, ReadOnlySpan&lt;int&gt; dimensions);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" RefType="this" />
        <Parameter Name="dimensions" Type="System.ReadOnlySpan&lt;System.Int32&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">Input <see cref="T:System.Numerics.Tensors.Tensor`1" /></param>
        <param name="dimensions">
          <see cref="T:System.ReadOnlySpan`1" /> with the new axis ordering.</param>
        <summary>
            Swaps the dimensions of the <paramref name="tensor" /> tensor according to the <paramref name="dimensions" /> parameter.
            If <paramref name="tensor" /> is a 1D tensor, it will return <paramref name="tensor" />. Otherwise it creates a new <see cref="T:System.Numerics.Tensors.Tensor`1" />
            with the new axis ordering by allocating new memory.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PopCount&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; PopCount&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; PopCount&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.PopCount``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function PopCount(Of T As IBinaryInteger(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member PopCount : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.PopCount x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ PopCount(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /></param>
        <summary>Computes the element-wise population count of numbers in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PopCount&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; PopCount&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; PopCount&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.PopCount``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function PopCount(Of T As IBinaryInteger(Of T)) (ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member PopCount : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.PopCount (y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ PopCount(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="y">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /></param>
        <param name="destination" />
        <summary>Computes the element-wise population count of numbers in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Pow&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IPowerFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Pow&lt;(class System.Numerics.IPowerFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Pow``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Pow(Of T As IPowerFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Pow : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Pow (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IPowerFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Pow(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IPowerFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The second input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /></param>
        <summary>Computes the element-wise power of a number in a specified tensor raised to a number in another specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Pow&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.IPowerFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Pow&lt;(class System.Numerics.IPowerFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Pow``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Pow(Of T As IPowerFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Pow : ReadOnlyTensorSpan * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Pow (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IPowerFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Pow(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IPowerFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The second input</param>
        <summary>Computes the element-wise power of a number in a specified tensor raised to a number in another specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Pow&lt;T&gt; (T x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IPowerFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Pow&lt;(class System.Numerics.IPowerFunctions`1&lt;!!T&gt;) T&gt;(!!T x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Pow``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Pow(Of T As IPowerFunctions(Of T)) (x As T, ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Pow : 'T * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Pow (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IPowerFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Pow(T x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IPowerFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The second input</param>
        <summary>Computes the element-wise power of a number in a specified tensor raised to a number in another specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Pow&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IPowerFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Pow&lt;(class System.Numerics.IPowerFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Pow``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Pow(Of T As IPowerFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Pow : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Pow (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IPowerFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Pow(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IPowerFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The second input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /></param>
        <param name="destination" />
        <summary>Computes the element-wise power of a number in a specified tensor raised to a number in another specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Pow&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IPowerFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Pow&lt;(class System.Numerics.IPowerFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Pow``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Pow(Of T As IPowerFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Pow : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Pow (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IPowerFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Pow(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IPowerFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The second input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /></param>
        <param name="destination" />
        <summary>Computes the element-wise power of a number in a specified tensor raised to a number in another specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Pow&lt;T&gt; (T x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IPowerFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Pow&lt;(class System.Numerics.IPowerFunctions`1&lt;!!T&gt;) T&gt;(!!T x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Pow``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Pow(Of T As IPowerFunctions(Of T)) (x As T, ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Pow : 'T * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Pow (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IPowerFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Pow(T x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IPowerFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The second input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /></param>
        <param name="destination" />
        <summary>Computes the element-wise power of a number in a specified tensor raised to a number in another specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Product&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Product&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Product&lt;(class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Product``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Product(Of T As {IMultiplicativeIdentity(Of T, T), IMultiplyOperators(Of T, T, T)}) (ByRef x As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Product : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Product x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IMultiplicativeIdentity&lt;T, T&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt; static T Product(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>Computes the product of all elements in the specified non-empty tensor of numbers.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RadiansToDegrees&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; RadiansToDegrees&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; RadiansToDegrees&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.RadiansToDegrees``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function RadiansToDegrees(Of T As ITrigonometricFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member RadiansToDegrees : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.RadiansToDegrees x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ RadiansToDegrees(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>Computes the element-wise conversion of each number of radians in the specified tensor to degrees.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RadiansToDegrees&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; RadiansToDegrees&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; RadiansToDegrees&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.RadiansToDegrees``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function RadiansToDegrees(Of T As ITrigonometricFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member RadiansToDegrees : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.RadiansToDegrees (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ RadiansToDegrees(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>Computes the element-wise conversion of each number of radians in the specified tensor to degrees.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reciprocal&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Reciprocal&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Reciprocal&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Reciprocal``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Reciprocal(Of T As IFloatingPoint(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Reciprocal : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Reciprocal x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Reciprocal(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>Computes the element-wise reciprocal of numbers in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reciprocal&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Reciprocal&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Reciprocal&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Reciprocal``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Reciprocal(Of T As IFloatingPoint(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Reciprocal : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Reciprocal (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Reciprocal(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>Computes the element-wise reciprocal of numbers in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reshape&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; Reshape&lt;T&gt; (this in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; tensor, scoped ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt; Reshape&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; tensor, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Reshape``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Reshape(Of T) (ByRef tensor As ReadOnlyTensorSpan(Of T), lengths As ReadOnlySpan(Of IntPtr)) As ReadOnlyTensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Reshape : ReadOnlyTensorSpan * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Reshape (tensor, lengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; Reshape(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % tensor, ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">
          <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> you want to reshape.</param>
        <param name="lengths">
          <see cref="T:System.ReadOnlySpan`1" /> with the new dimensions.</param>
        <summary>
            Reshapes the <paramref name="tensor" /> tensor to the specified <paramref name="lengths" />. If one of the lengths is -1, it will be calculated automatically.
            Does not change the length of the underlying memory nor does it allocate new memory. If the new shape is not compatible with the old shape,
            an exception is thrown.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reshape&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Reshape&lt;T&gt; (this System.Numerics.Tensors.Tensor&lt;T&gt; tensor, scoped ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Reshape&lt;T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; tensor, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Reshape``1(System.Numerics.Tensors.Tensor{``0},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Reshape(Of T) (tensor As Tensor(Of T), lengths As ReadOnlySpan(Of IntPtr)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Reshape : System.Numerics.Tensors.Tensor&lt;'T&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Reshape (tensor, lengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Reshape(System::Numerics::Tensors::Tensor&lt;T&gt; ^ tensor, ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" RefType="this" />
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">
          <see cref="T:System.Numerics.Tensors.Tensor`1" /> you want to reshape.</param>
        <param name="lengths">
          <see cref="T:System.ReadOnlySpan`1" /> with the new dimensions.</param>
        <summary>
            Reshapes the <paramref name="tensor" /> tensor to the specified <paramref name="lengths" />. If one of the lengths is -1, it will be calculated automatically.
            Does not change the length of the underlying memory nor does it allocate new memory. If the new shape is not compatible with the old shape,
            an exception is thrown.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reshape&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Reshape&lt;T&gt; (this in System.Numerics.Tensors.TensorSpan&lt;T&gt; tensor, scoped ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Reshape&lt;T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; tensor, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Reshape``1(System.Numerics.Tensors.TensorSpan{``0}@,System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Reshape(Of T) (ByRef tensor As TensorSpan(Of T), lengths As ReadOnlySpan(Of IntPtr)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Reshape : TensorSpan * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Reshape (tensor, lengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::TensorSpan&lt;T&gt; Reshape(System::Numerics::Tensors::TensorSpan&lt;T&gt; % tensor, ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">
          <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> you want to reshape.</param>
        <param name="lengths">
          <see cref="T:System.ReadOnlySpan`1" /> with the new dimensions.</param>
        <summary>
            Reshapes the <paramref name="tensor" /> tensor to the specified <paramref name="lengths" />. If one of the lengths is -1, it will be calculated automatically.
            Does not change the length of the underlying memory nor does it allocate new memory. If the new shape is not compatible with the old shape,
            an exception is thrown.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Resize&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; tensor, ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Resize&lt;T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; tensor, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Resize``1(System.Numerics.Tensors.Tensor{``0},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Function Resize(Of T) (tensor As Tensor(Of T), lengths As ReadOnlySpan(Of IntPtr)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Resize : System.Numerics.Tensors.Tensor&lt;'T&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Resize (tensor, lengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Resize(System::Numerics::Tensors::Tensor&lt;T&gt; ^ tensor, ReadOnlySpan&lt;IntPtr&gt; lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">Input <see cref="T:System.Numerics.Tensors.Tensor`1" />.</param>
        <param name="lengths">
          <see cref="T:System.ReadOnlySpan`1" /> of the desired new shape.</param>
        <summary>
            Creates a new <see cref="T:System.Numerics.Tensors.Tensor`1" />, allocates new memory, and copies the data from <paramref name="tensor" />. If the final shape is smaller all data after
            that point is ignored.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResizeTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ResizeTo&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; tensor, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResizeTo&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; tensor, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ResizeTo``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResizeTo(Of T) (ByRef tensor As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T))" />
      <MemberSignature Language="F#" Value="static member ResizeTo : ReadOnlyTensorSpan * TensorSpan -&gt; unit" Usage="System.Numerics.Tensors.Tensor.ResizeTo (tensor, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void ResizeTo(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % tensor, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">Input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination">Destination <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the desired new shape.</param>
        <summary>
            Copies the data from <paramref name="tensor" />. If the final shape is smaller all data after that point is ignored.
            If the final shape is bigger it is filled with 0s.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResizeTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ResizeTo&lt;T&gt; (scoped in System.Numerics.Tensors.Tensor&lt;T&gt; tensor, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResizeTo&lt;T&gt;([in]class System.Numerics.Tensors.Tensor`1&lt;!!T&gt;&amp; tensor, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ResizeTo``1(System.Numerics.Tensors.Tensor{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResizeTo(Of T) (ByRef tensor As Tensor(Of T), ByRef destination As TensorSpan(Of T))" />
      <MemberSignature Language="F#" Value="static member ResizeTo : Tensor * TensorSpan -&gt; unit" Usage="System.Numerics.Tensors.Tensor.ResizeTo (tensor, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void ResizeTo(System::Numerics::Tensors::Tensor&lt;T&gt; ^ % tensor, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">Input <see cref="T:System.Numerics.Tensors.Tensor`1" />.</param>
        <param name="destination">Destination <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the desired new shape.</param>
        <summary>
            Copies the data from <paramref name="tensor" />. If the final shape is smaller all data after that point is ignored.
            If the final shape is bigger it is filled with 0s.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResizeTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ResizeTo&lt;T&gt; (scoped in System.Numerics.Tensors.TensorSpan&lt;T&gt; tensor, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResizeTo&lt;T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; tensor, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ResizeTo``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResizeTo(Of T) (ByRef tensor As TensorSpan(Of T), ByRef destination As TensorSpan(Of T))" />
      <MemberSignature Language="F#" Value="static member ResizeTo : TensorSpan * TensorSpan -&gt; unit" Usage="System.Numerics.Tensors.Tensor.ResizeTo (tensor, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void ResizeTo(System::Numerics::Tensors::TensorSpan&lt;T&gt; % tensor, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">Input <see cref="T:System.Numerics.Tensors.TensorSpan`1" />.</param>
        <param name="destination">Destination <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the desired new shape.</param>
        <summary>
            Copies the data from <paramref name="tensor" />. If the final shape is smaller all data after that point is ignored.
            If the final shape is bigger it is filled with 0s.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Reverse&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; tensor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Reverse&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; tensor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Reverse``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Reverse(Of T) (ByRef tensor As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Reverse : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Reverse tensor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Reverse(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % tensor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">Input <see cref="T:System.Numerics.Tensors.Tensor`1" />.</param>
        <summary>
            Reverse the order of elements in the <paramref name="tensor" />. The shape of the tensor is preserved, but the elements are reordered.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Reverse&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; tensor, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Reverse&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; tensor, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Reverse``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Reverse(Of T) (ByRef tensor As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Reverse : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan" Usage="System.Numerics.Tensors.Tensor.Reverse (tensor, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Reverse(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % tensor, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">Input <see cref="T:System.Numerics.Tensors.TensorSpan`1" />.</param>
        <param name="destination" />
        <summary>
            Reverse the order of elements in the <paramref name="tensor" />. The shape of the tensor is preserved, but the elements are reordered.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseDimension&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; ReverseDimension&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; tensor, int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; ReverseDimension&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; tensor, int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ReverseDimension``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReverseDimension(Of T) (ByRef tensor As ReadOnlyTensorSpan(Of T), dimension As Integer) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member ReverseDimension : ReadOnlyTensorSpan * int -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.ReverseDimension (tensor, dimension)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ ReverseDimension(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % tensor, int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">Input <see cref="T:System.Numerics.Tensors.Tensor`1" />.</param>
        <param name="dimension">dimension along which to reverse over. -1 will reverse over all of the dimensions of the left tensor.</param>
        <summary>
            Reverse the order of elements in the <paramref name="tensor" /> along the given dimension. The shape of the tensor is preserved, but the elements are reordered.
            <paramref name="dimension" /> defaults to -1 when not provided, which reverses the entire tensor.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseDimension&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; ReverseDimension&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; tensor, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination, int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; ReverseDimension&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; tensor, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination, int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ReverseDimension``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReverseDimension(Of T) (ByRef tensor As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T), dimension As Integer) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member ReverseDimension : ReadOnlyTensorSpan * TensorSpan * int -&gt; TensorSpan" Usage="System.Numerics.Tensors.Tensor.ReverseDimension (tensor, destination, dimension)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ ReverseDimension(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % tensor, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination, int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">Input <see cref="T:System.Numerics.Tensors.TensorSpan`1" />.</param>
        <param name="destination" />
        <param name="dimension">dimension along which to reverse over. -1 will reverse over all of the dimensions of the left tensor.</param>
        <summary>
            Reverse the order of elements in the <paramref name="tensor" /> along the given axis. The shape of the tensor is preserved, but the elements are reordered.
            <paramref name="dimension" /> defaults to -1 when not provided, which reverses the entire span.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RootN&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; RootN&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, int n) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; RootN&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, int32 n) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.RootN``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function RootN(Of T As IRootFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), n As Integer) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member RootN : ReadOnlyTensorSpan * int -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.RootN (x, n)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ RootN(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, int n);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="n" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="n">The degree of the root to be computed, represented as a scalar.</param>
        <summary>Computes the element-wise n-th root of the values in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RootN&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; RootN&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, int n, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; RootN&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, int32 n, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.RootN``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function RootN(Of T As IRootFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), n As Integer, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member RootN : ReadOnlyTensorSpan * int * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.RootN (x, n, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ RootN(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, int n, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="n" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <param name="n">The degree of the root to be computed, represented as a scalar.</param>
        <summary>Computes the element-wise n-th root of the values in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RotateLeft&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; RotateLeft&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, int rotateAmount) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; RotateLeft&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, int32 rotateAmount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.RotateLeft``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function RotateLeft(Of T As IBinaryInteger(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), rotateAmount As Integer) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member RotateLeft : ReadOnlyTensorSpan * int -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.RotateLeft (x, rotateAmount)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ RotateLeft(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, int rotateAmount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="rotateAmount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor</param>
        <param name="rotateAmount">The number of bits to rotate, represented as a scalar.</param>
        <summary>Computes the element-wise rotation left of numbers in the specified tensor by the specified rotation amount.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Destination is too short.</exception>
      </Docs>
    </Member>
    <Member MemberName="RotateLeft&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; RotateLeft&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, int rotateAmount, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; RotateLeft&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, int32 rotateAmount, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.RotateLeft``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function RotateLeft(Of T As IBinaryInteger(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), rotateAmount As Integer, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member RotateLeft : ReadOnlyTensorSpan * int * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.RotateLeft (x, rotateAmount, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ RotateLeft(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, int rotateAmount, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="rotateAmount" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor</param>
        <param name="rotateAmount">The number of bits to rotate, represented as a scalar.</param>
        <param name="destination" />
        <summary>Computes the element-wise rotation left of numbers in the specified tensor by the specified rotation amount.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Destination is too short.</exception>
      </Docs>
    </Member>
    <Member MemberName="RotateRight&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; RotateRight&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, int rotateAmount) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; RotateRight&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, int32 rotateAmount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.RotateRight``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function RotateRight(Of T As IBinaryInteger(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), rotateAmount As Integer) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member RotateRight : ReadOnlyTensorSpan * int -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.RotateRight (x, rotateAmount)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ RotateRight(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, int rotateAmount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="rotateAmount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor</param>
        <param name="rotateAmount">The number of bits to rotate, represented as a scalar.</param>
        <summary>Computes the element-wise rotation right of numbers in the specified tensor by the specified rotation amount.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Destination is too short.</exception>
      </Docs>
    </Member>
    <Member MemberName="RotateRight&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; RotateRight&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, int rotateAmount, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; RotateRight&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, int32 rotateAmount, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.RotateRight``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function RotateRight(Of T As IBinaryInteger(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), rotateAmount As Integer, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member RotateRight : ReadOnlyTensorSpan * int * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.RotateRight (x, rotateAmount, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ RotateRight(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, int rotateAmount, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="rotateAmount" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor</param>
        <param name="rotateAmount">The number of bits to rotate, represented as a scalar.</param>
        <param name="destination" />
        <summary>Computes the element-wise rotation right of numbers in the specified tensor by the specified rotation amount.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Destination is too short.</exception>
      </Docs>
    </Member>
    <Member MemberName="Round&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Round&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Round&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Round``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Round(Of T As IFloatingPoint(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Round : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Round x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Round(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Round&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Round&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, int digits) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Round&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, int32 digits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Round``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Round(Of T As IFloatingPoint(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), digits As Integer) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Round : ReadOnlyTensorSpan * int -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Round (x, digits)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Round(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, int digits);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="digits" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="digits" />
        <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Round&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Round&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, MidpointRounding mode) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Round&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Round``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Function Round(Of T As IFloatingPoint(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), mode As MidpointRounding) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Round : ReadOnlyTensorSpan * MidpointRounding -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Round (x, mode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Round(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, MidpointRounding mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="mode" />
        <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Round&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Round&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Round&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Round``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Round(Of T As IFloatingPoint(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Round : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Round (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Round(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Round&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Round&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, int digits, MidpointRounding mode) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Round&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, int32 digits, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Round``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Function Round(Of T As IFloatingPoint(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), digits As Integer, mode As MidpointRounding) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Round : ReadOnlyTensorSpan * int * MidpointRounding -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Round (x, digits, mode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Round(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, int digits, MidpointRounding mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="digits" Type="System.Int32" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="digits" />
        <param name="mode" />
        <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Round&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Round&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, int digits, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Round&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, int32 digits, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Round``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Round(Of T As IFloatingPoint(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), digits As Integer, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Round : ReadOnlyTensorSpan * int * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Round (x, digits, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Round(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, int digits, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="digits" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="digits" />
        <param name="destination" />
        <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Round&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Round&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, MidpointRounding mode, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Round&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, valuetype System.MidpointRounding mode, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Round``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.MidpointRounding,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Round(Of T As IFloatingPoint(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), mode As MidpointRounding, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Round : ReadOnlyTensorSpan * MidpointRounding * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Round (x, mode, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Round(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, MidpointRounding mode, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="mode" Type="System.MidpointRounding" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="mode" />
        <param name="destination" />
        <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Round&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Round&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, int digits, MidpointRounding mode, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Round&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, int32 digits, valuetype System.MidpointRounding mode, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Round``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32,System.MidpointRounding,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Round(Of T As IFloatingPoint(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), digits As Integer, mode As MidpointRounding, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Round : ReadOnlyTensorSpan * int * MidpointRounding * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Round (x, digits, mode, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Round(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, int digits, MidpointRounding mode, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="digits" Type="System.Int32" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="digits" />
        <param name="mode" />
        <param name="destination" />
        <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;T&gt; (this scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; tensor, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; other) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; tensor, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SequenceEqual``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of T As IEquatable(Of T)) (ByRef tensor As ReadOnlyTensorSpan(Of T), ByRef other As ReadOnlyTensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.SequenceEqual (tensor, other)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % tensor, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="other" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">To be added.</param>
        <param name="other">To be added.</param>
        <summary>
            Determines whether two sequences are equal by comparing the elements using IEquatable{T}.Equals(T).
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;T&gt; (this scoped in System.Numerics.Tensors.TensorSpan&lt;T&gt; tensor, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; other) where T : IEquatable&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;(class System.IEquatable`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; tensor, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SequenceEqual``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SequenceEqual(Of T As IEquatable(Of T)) (ByRef tensor As TensorSpan(Of T), ByRef other As ReadOnlyTensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member SequenceEqual : TensorSpan * ReadOnlyTensorSpan -&gt; bool (requires 'T :&gt; IEquatable&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.SequenceEqual (tensor, other)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : IEquatable&lt;T&gt;[System::Runtime::CompilerServices::Extension]&#xA; static bool SequenceEqual(System::Numerics::Tensors::TensorSpan&lt;T&gt; % tensor, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.IEquatable&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="other" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">To be added.</param>
        <param name="other">To be added.</param>
        <summary>
            Determines whether two sequences are equal by comparing the elements using IEquatable{T}.Equals(T).
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSlice&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; SetSlice&lt;T&gt; (this System.Numerics.Tensors.Tensor&lt;T&gt; tensor, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; values, scoped ReadOnlySpan&lt;System.Buffers.NRange&gt; ranges);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; SetSlice&lt;T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; tensor, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; values, valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NRange&gt; ranges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SetSlice``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.ReadOnlySpan{System.Buffers.NRange})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SetSlice(Of T) (tensor As Tensor(Of T), ByRef values As ReadOnlyTensorSpan(Of T), ranges As ReadOnlySpan(Of NRange)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member SetSlice : System.Numerics.Tensors.Tensor&lt;'T&gt; * ReadOnlyTensorSpan * ReadOnlySpan&lt;System.Buffers.NRange&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.SetSlice (tensor, values, ranges)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ SetSlice(System::Numerics::Tensors::Tensor&lt;T&gt; ^ tensor, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % values, ReadOnlySpan&lt;System::Buffers::NRange&gt; ranges);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" RefType="this" />
        <Parameter Name="values" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="ranges" Type="System.ReadOnlySpan&lt;System.Buffers.NRange&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">Input <see cref="T:System.Numerics.Tensors.Tensor`1" />.</param>
        <param name="values">The values you want to set in the <paramref name="tensor" />.</param>
        <param name="ranges">The ranges you want to set.</param>
        <summary>
            Sets a slice of the given <paramref name="tensor" /> with the provided <paramref name="values" /> for the given <paramref name="ranges" /></summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSlice&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; SetSlice&lt;T&gt; (this in System.Numerics.Tensors.TensorSpan&lt;T&gt; tensor, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; values, scoped ReadOnlySpan&lt;System.Buffers.NRange&gt; ranges);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; SetSlice&lt;T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; tensor, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; values, valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NRange&gt; ranges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SetSlice``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.ReadOnlySpan{System.Buffers.NRange})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SetSlice(Of T) (ByRef tensor As TensorSpan(Of T), ByRef values As ReadOnlyTensorSpan(Of T), ranges As ReadOnlySpan(Of NRange)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member SetSlice : TensorSpan * ReadOnlyTensorSpan * ReadOnlySpan&lt;System.Buffers.NRange&gt; -&gt; TensorSpan" Usage="System.Numerics.Tensors.Tensor.SetSlice (tensor, values, ranges)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ SetSlice(System::Numerics::Tensors::TensorSpan&lt;T&gt; % tensor, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % values, ReadOnlySpan&lt;System::Buffers::NRange&gt; ranges);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="values" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="ranges" Type="System.ReadOnlySpan&lt;System.Buffers.NRange&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">Input <see cref="T:System.Numerics.Tensors.Tensor`1" />.</param>
        <param name="values">The values you want to set in the <paramref name="tensor" />.</param>
        <param name="ranges">The ranges you want to set.</param>
        <summary>
            Sets a slice of the given <paramref name="tensor" /> with the provided <paramref name="values" /> for the given <paramref name="ranges" /></summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sigmoid&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Sigmoid&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Sigmoid&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sigmoid``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Sigmoid(Of T As IExponentialFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Sigmoid : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sigmoid x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Sigmoid(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>Computes the element-wise sigmoid function on the specified non-empty tensor of numbers.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sigmoid&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Sigmoid&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Sigmoid&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sigmoid``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Sigmoid(Of T As IExponentialFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Sigmoid : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sigmoid (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Sigmoid(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>Computes the element-wise sigmoid function on the specified non-empty tensor of numbers.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Sin&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Sin&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sin``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Sin(Of T As ITrigonometricFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Sin : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sin x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Sin(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the sin of.</param>
        <summary>
            Takes the sin of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Sin&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Sin&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sin``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Sin(Of T As ITrigonometricFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Sin : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sin (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Sin(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the sin of.</param>
        <param name="destination" />
        <summary>
            Takes the sin of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sinh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Sinh&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Sinh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sinh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Sinh(Of T As IHyperbolicFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Sinh : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sinh x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Sinh(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the sin of.</param>
        <summary>Computes the element-wise hyperbolic sine of each radian angle in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sinh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Sinh&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Sinh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sinh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Sinh(Of T As IHyperbolicFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Sinh : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sinh (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Sinh(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the sin of.</param>
        <param name="destination" />
        <summary>Computes the element-wise hyperbolic sine of each radian angle in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SinPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; SinPi&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; SinPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SinPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function SinPi(Of T As ITrigonometricFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member SinPi : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.SinPi x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ SinPi(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the sin of.</param>
        <summary>Computes the element-wise sine of the value in the specified tensor that has been multiplied by Pi.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SinPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; SinPi&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; SinPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SinPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function SinPi(Of T As ITrigonometricFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member SinPi : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.SinPi (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ SinPi(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the sin of.</param>
        <param name="destination" />
        <summary>Computes the element-wise sine of the value in the specified tensor that has been multiplied by Pi.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SoftMax&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; SoftMax&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; SoftMax&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SoftMax``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function SoftMax(Of T As IExponentialFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member SoftMax : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.SoftMax x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ SoftMax(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the sin of.</param>
        <summary>Computes the softmax function over the specified non-empty tensor of numbers.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SoftMax&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; SoftMax&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; SoftMax&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SoftMax``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function SoftMax(Of T As IExponentialFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member SoftMax : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.SoftMax (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ SoftMax(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the sin of.</param>
        <param name="destination" />
        <summary>Computes the softmax function over the specified non-empty tensor of numbers.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt;[] Split&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; tensor, int splitCount, IntPtr dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt;[] Split&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; tensor, int32 splitCount, native int dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Split``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split(Of T) (ByRef tensor As ReadOnlyTensorSpan(Of T), splitCount As Integer, dimension As IntPtr) As Tensor(Of T)()" />
      <MemberSignature Language="F#" Value="static member Split : ReadOnlyTensorSpan * int * nativeint -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;[]" Usage="System.Numerics.Tensors.Tensor.Split (tensor, splitCount, dimension)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;System::Numerics::Tensors::Tensor&lt;T&gt; ^&gt; ^ Split(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % tensor, int splitCount, IntPtr dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="splitCount" Type="System.Int32" />
        <Parameter Name="dimension" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">Input <see cref="T:System.Numerics.Tensors.Tensor`1" />.</param>
        <param name="splitCount">How many times to split the <paramref name="tensor" /></param>
        <param name="dimension">The axis to split on.</param>
        <summary>
            Split a <see cref="T:System.Numerics.Tensors.Tensor`1" /> into <paramref name="splitCount" /> along the given <paramref name="dimension" />. If the tensor cannot be split
            evenly on the given <paramref name="dimension" /> an exception is thrown.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sqrt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Sqrt&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Sqrt&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sqrt``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Sqrt(Of T As IRootFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Sqrt : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sqrt x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Sqrt(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the square root of.</param>
        <summary>
            Takes the square root of each element of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sqrt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Sqrt&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Sqrt&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sqrt``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Sqrt(Of T As IRootFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Sqrt : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sqrt (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Sqrt(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the square root of.</param>
        <param name="destination" />
        <summary>
            Takes the square root of each element of the <paramref name="x" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Squeeze&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; Squeeze&lt;T&gt; (this in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; tensor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt; Squeeze&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; tensor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Squeeze``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Squeeze(Of T) (ByRef tensor As ReadOnlyTensorSpan(Of T)) As ReadOnlyTensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Squeeze : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Squeeze tensor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; Squeeze(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % tensor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to remove all dimensions of length 1.</param>
        <summary>
            Removes all dimensions of length one from the <paramref name="tensor" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Squeeze&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Squeeze&lt;T&gt; (this System.Numerics.Tensors.Tensor&lt;T&gt; tensor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Squeeze&lt;T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; tensor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Squeeze``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Squeeze(Of T) (tensor As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Squeeze : System.Numerics.Tensors.Tensor&lt;'T&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Squeeze tensor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Squeeze(System::Numerics::Tensors::Tensor&lt;T&gt; ^ tensor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">The <see cref="T:System.Numerics.Tensors.Tensor`1" /> to remove all dimensions of length 1.</param>
        <summary>
            Removes all dimensions of length one from the <paramref name="tensor" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Squeeze&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Squeeze&lt;T&gt; (this in System.Numerics.Tensors.TensorSpan&lt;T&gt; tensor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Squeeze&lt;T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; tensor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Squeeze``1(System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Squeeze(Of T) (ByRef tensor As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Squeeze : TensorSpan -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Squeeze tensor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::TensorSpan&lt;T&gt; Squeeze(System::Numerics::Tensors::TensorSpan&lt;T&gt; % tensor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">The <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> to remove all dimensions of length 1.</param>
        <summary>
            Removes all dimensions of length one from the <paramref name="tensor" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SqueezeDimension&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; SqueezeDimension&lt;T&gt; (this in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; tensor, int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt; SqueezeDimension&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; tensor, int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SqueezeDimension``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SqueezeDimension(Of T) (ByRef tensor As ReadOnlyTensorSpan(Of T), dimension As Integer) As ReadOnlyTensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member SqueezeDimension : ReadOnlyTensorSpan * int -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.SqueezeDimension (tensor, dimension)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; SqueezeDimension(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % tensor, int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to remove dimension of length 1.</param>
        <param name="dimension">The dimension to remove.</param>
        <summary>
            Removes axis of length one from the <paramref name="tensor" /> for the given <paramref name="dimension" />.
            If the dimension is not of length one it will throw an exception.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SqueezeDimension&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; SqueezeDimension&lt;T&gt; (this System.Numerics.Tensors.Tensor&lt;T&gt; tensor, int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; SqueezeDimension&lt;T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; tensor, int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SqueezeDimension``1(System.Numerics.Tensors.Tensor{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SqueezeDimension(Of T) (tensor As Tensor(Of T), dimension As Integer) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member SqueezeDimension : System.Numerics.Tensors.Tensor&lt;'T&gt; * int -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.SqueezeDimension (tensor, dimension)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ SqueezeDimension(System::Numerics::Tensors::Tensor&lt;T&gt; ^ tensor, int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" RefType="this" />
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">The <see cref="T:System.Numerics.Tensors.Tensor`1" /> to remove dimension of length 1.</param>
        <param name="dimension">The dimension to remove.</param>
        <summary>
            Removes axis of length one from the <paramref name="tensor" /> for the given <paramref name="dimension" />.
            If the dimension is not of length one it will throw an exception.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SqueezeDimension&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; SqueezeDimension&lt;T&gt; (this in System.Numerics.Tensors.TensorSpan&lt;T&gt; tensor, int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; SqueezeDimension&lt;T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; tensor, int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.SqueezeDimension``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function SqueezeDimension(Of T) (ByRef tensor As TensorSpan(Of T), dimension As Integer) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member SqueezeDimension : TensorSpan * int -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.SqueezeDimension (tensor, dimension)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::TensorSpan&lt;T&gt; SqueezeDimension(System::Numerics::Tensors::TensorSpan&lt;T&gt; % tensor, int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">The <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> to remove dimension of length 1.</param>
        <param name="dimension">The dimension to remove.</param>
        <summary>
            Removes axis of length one from the <paramref name="tensor" /> for the given <paramref name="dimension" />.
            If the dimension is not of length one it will throw an exception.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Stack&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Stack&lt;T&gt; (scoped ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;T&gt;&gt; tensors);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Stack&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;class System.Numerics.Tensors.Tensor`1&lt;!!T&gt;&gt; tensors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Stack``1(System.ReadOnlySpan{System.Numerics.Tensors.Tensor{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Stack(Of T) (tensors As ReadOnlySpan(Of Tensor(Of T))) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Stack : ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;'T&gt;&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Stack tensors" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Stack(ReadOnlySpan&lt;System::Numerics::Tensors::Tensor&lt;T&gt; ^&gt; tensors);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensors" Type="System.ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;T&gt;&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensors">Input <see cref="T:System.Numerics.Tensors.Tensor`1" />.</param>
        <summary>
            Join multiple <see cref="T:System.Numerics.Tensors.Tensor`1" /> along a new dimension that is added at position 0. All tensors must have the same shape.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Stack&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Stack&lt;T&gt; (scoped in ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;T&gt;&gt; tensors, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Stack&lt;T&gt;([in]valuetype System.ReadOnlySpan`1&lt;class System.Numerics.Tensors.Tensor`1&lt;!!T&gt;&gt;&amp; tensors, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Stack``1(System.ReadOnlySpan{System.Numerics.Tensors.Tensor{``0}}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Stack(Of T) (ByRef tensors As ReadOnlySpan(Of Tensor(Of T)), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Stack : ReadOnlySpan * TensorSpan -&gt; TensorSpan" Usage="System.Numerics.Tensors.Tensor.Stack (tensors, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Stack(ReadOnlySpan&lt;System::Numerics::Tensors::Tensor&lt;T&gt; ^&gt; % tensors, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensors" Type="System.ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;T&gt;&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensors">Input <see cref="T:System.Numerics.Tensors.Tensor`1" />.</param>
        <param name="destination" />
        <summary>
            Join multiple <see cref="T:System.Numerics.Tensors.Tensor`1" /> along a new dimension that is added at position 0. All tensors must have the same shape.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StackAlongDimension&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; StackAlongDimension&lt;T&gt; (int dimension, scoped ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;T&gt;&gt; tensors);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; StackAlongDimension&lt;T&gt;(int32 dimension, valuetype System.ReadOnlySpan`1&lt;class System.Numerics.Tensors.Tensor`1&lt;!!T&gt;&gt; tensors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.StackAlongDimension``1(System.Int32,System.ReadOnlySpan{System.Numerics.Tensors.Tensor{``0}})" />
      <MemberSignature Language="VB.NET" Value="Public Function StackAlongDimension(Of T) (dimension As Integer, tensors As ReadOnlySpan(Of Tensor(Of T))) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member StackAlongDimension : int * ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;'T&gt;&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.StackAlongDimension (dimension, tensors)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ StackAlongDimension(int dimension, ReadOnlySpan&lt;System::Numerics::Tensors::Tensor&lt;T&gt; ^&gt; tensors);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
        <Parameter Name="tensors" Type="System.ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;T&gt;&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensors">Input <see cref="T:System.Numerics.Tensors.Tensor`1" />.</param>
        <param name="dimension">Index of where the new dimension will be.</param>
        <summary>
            Join multiple <see cref="T:System.Numerics.Tensors.Tensor`1" /> along a new dimension. The axis parameter specifies the index of the new dimension. All tensors must have the same shape.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StackAlongDimension&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; StackAlongDimension&lt;T&gt; (scoped ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;T&gt;&gt; tensors, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination, int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; StackAlongDimension&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;class System.Numerics.Tensors.Tensor`1&lt;!!T&gt;&gt; tensors, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination, int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.StackAlongDimension``1(System.ReadOnlySpan{System.Numerics.Tensors.Tensor{``0}},System.Numerics.Tensors.TensorSpan{``0}@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function StackAlongDimension(Of T) (tensors As ReadOnlySpan(Of Tensor(Of T)), ByRef destination As TensorSpan(Of T), dimension As Integer) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member StackAlongDimension : ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;'T&gt;&gt; * TensorSpan * int -&gt; TensorSpan" Usage="System.Numerics.Tensors.Tensor.StackAlongDimension (tensors, destination, dimension)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ StackAlongDimension(ReadOnlySpan&lt;System::Numerics::Tensors::Tensor&lt;T&gt; ^&gt; tensors, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination, int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensors" Type="System.ReadOnlySpan&lt;System.Numerics.Tensors.Tensor&lt;T&gt;&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensors">Input <see cref="T:System.Numerics.Tensors.Tensor`1" />.</param>
        <param name="destination" />
        <param name="dimension">Index of where the new dimension will be.</param>
        <summary>
            Join multiple <see cref="T:System.Numerics.Tensors.Tensor`1" /> along a new dimension. The axis parameter specifies the index of the new dimension. All tensors must have the same shape.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StdDev&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T StdDev&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IFloatingPoint&lt;T&gt;, System.Numerics.IPowerFunctions&lt;T&gt;, System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T StdDev&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;, class System.Numerics.IPowerFunctions`1&lt;!!T&gt;, class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.StdDev``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function StdDev(Of T As {IFloatingPoint(Of T), IPowerFunctions(Of T), IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (ByRef x As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member StdDev : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt; and 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt; and 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.StdDev x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt;, System::Numerics::IPowerFunctions&lt;T&gt;, System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static T StdDev(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IPowerFunctions&lt;T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> to take the standard deviation of.</param>
        <summary>
            Returns the standard deviation of the elements in the <paramref name="x" /> tensor.
            </summary>
        <returns>
          <typeparamref name="T" /> representing the standard deviation.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Subtract&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Subtract&lt;(class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Subtract``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract(Of T As ISubtractionOperators(Of T, T, T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Subtract : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Subtract (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Subtract(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> with values to be subtracted from.</param>
        <param name="y">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> with values to subtract.</param>
        <summary>
            Subtracts each element of <paramref name="x" /> from <paramref name="y" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Subtract&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Subtract&lt;(class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Subtract``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract(Of T As ISubtractionOperators(Of T, T, T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Subtract : ReadOnlyTensorSpan * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Subtract (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Subtract(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The <typeparamref name="T" /> to subtract.</param>
        <summary>
            Subtracts <paramref name="y" /> from each element of <paramref name="x" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Subtract&lt;T&gt; (T x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Subtract&lt;(class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(!!T x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Subtract``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract(Of T As ISubtractionOperators(Of T, T, T)) (x As T, ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Subtract : 'T * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Subtract (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Subtract(T x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <typeparamref name="T" /> to be subtracted from.</param>
        <param name="y">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> of values to subtract.</param>
        <summary>
            Subtracts each element of <paramref name="y" /> from <paramref name="x" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Subtract&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Subtract&lt;(class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Subtract``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract(Of T As ISubtractionOperators(Of T, T, T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Subtract : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Subtract (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Subtract(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> of values to be subtracted from.</param>
        <param name="y">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />of values to subtract.</param>
        <param name="destination" />
        <summary>
            Subtracts each element of <paramref name="x" /> from <paramref name="y" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Subtract&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Subtract&lt;(class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Subtract``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract(Of T As ISubtractionOperators(Of T, T, T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Subtract : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Subtract (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Subtract(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> with values to be subtracted from.</param>
        <param name="y">The <typeparamref name="T" /> value to subtract.</param>
        <param name="destination" />
        <summary>
            Subtracts <paramref name="y" /> from each element of <paramref name="x" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Subtract&lt;T&gt; (T x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Subtract&lt;(class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(!!T x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Subtract``1(``0,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Subtract(Of T As ISubtractionOperators(Of T, T, T)) (x As T, ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Subtract : 'T * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Subtract (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Subtract(T x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" />
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <typeparamref name="T" /> value to be subtracted from.</param>
        <param name="y">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> values to subtract.</param>
        <param name="destination" />
        <summary>
            Subtracts each element of <paramref name="y" /> from <paramref name="x" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Sum&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Sum&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Sum``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Sum(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (ByRef x As ReadOnlyTensorSpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Sum : ReadOnlyTensorSpan -&gt; 'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Sum x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static T Sum(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">Tensor to sum</param>
        <summary>
            Sums the elements of the specified tensor.
            </summary>
        <returns />
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Tan&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Tan&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Tan``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Tan(Of T As ITrigonometricFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Tan : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Tan x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Tan(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the sin of.</param>
        <summary>Computes the element-wise tangent of the value in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Tan&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Tan&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Tan``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Tan(Of T As ITrigonometricFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Tan : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Tan (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Tan(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the sin of.</param>
        <param name="destination" />
        <summary>Computes the element-wise tangent of the value in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tanh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Tanh&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Tanh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Tanh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Tanh(Of T As IHyperbolicFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Tanh : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Tanh x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Tanh(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the sin of.</param>
        <summary>Computes the element-wise hyperbolic tangent of each radian angle in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tanh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Tanh&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Tanh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Tanh``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Tanh(Of T As IHyperbolicFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Tanh : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Tanh (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Tanh(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the sin of.</param>
        <param name="destination" />
        <summary>Computes the element-wise hyperbolic tangent of each radian angle in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TanPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; TanPi&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; TanPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.TanPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TanPi(Of T As ITrigonometricFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member TanPi : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.TanPi x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ TanPi(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the sin of.</param>
        <summary>Computes the element-wise tangent of the value in the specified tensor that has been multiplied by Pi.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TanPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; TanPi&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; TanPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.TanPi``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TanPi(Of T As ITrigonometricFunctions(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member TanPi : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.TanPi (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ TanPi(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to take the sin of.</param>
        <param name="destination" />
        <summary>Computes the element-wise tangent of the value in the specified tensor that has been multiplied by Pi.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string ToString&lt;T&gt; (this in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; tensor, scoped ReadOnlySpan&lt;IntPtr&gt; maximumLengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; tensor, valuetype System.ReadOnlySpan`1&lt;native int&gt; maximumLengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ToString``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToString(Of T) (ByRef tensor As ReadOnlyTensorSpan(Of T), maximumLengths As ReadOnlySpan(Of IntPtr)) As String" />
      <MemberSignature Language="F#" Value="static member ToString : ReadOnlyTensorSpan * ReadOnlySpan&lt;nativeint&gt; -&gt; string" Usage="System.Numerics.Tensors.Tensor.ToString (tensor, maximumLengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::String ^ ToString(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % tensor, ReadOnlySpan&lt;IntPtr&gt; maximumLengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="maximumLengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T" />
        <param name="tensor">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> you want to represent as a string.</param>
        <param name="maximumLengths">Maximum Length of each dimension</param>
        <summary>
            Creates a <see cref="T:System.String" /> representation of the <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />."/&gt;
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string ToString&lt;T&gt; (this System.Numerics.Tensors.Tensor&lt;T&gt; tensor, scoped ReadOnlySpan&lt;IntPtr&gt; maximumLengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString&lt;T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; tensor, valuetype System.ReadOnlySpan`1&lt;native int&gt; maximumLengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ToString``1(System.Numerics.Tensors.Tensor{``0},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToString(Of T) (tensor As Tensor(Of T), maximumLengths As ReadOnlySpan(Of IntPtr)) As String" />
      <MemberSignature Language="F#" Value="static member ToString : System.Numerics.Tensors.Tensor&lt;'T&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; string" Usage="System.Numerics.Tensors.Tensor.ToString (tensor, maximumLengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::String ^ ToString(System::Numerics::Tensors::Tensor&lt;T&gt; ^ tensor, ReadOnlySpan&lt;IntPtr&gt; maximumLengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" RefType="this" />
        <Parameter Name="maximumLengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">The <see cref="T:System.Span`1" /> you want to represent as a string.</param>
        <param name="maximumLengths">Maximum Length of each dimension</param>
        <summary>
            Creates a <see cref="T:System.String" /> representation of the <see cref="T:System.Numerics.Tensors.Tensor`1" />."/&gt;
            </summary>
        <returns>A <see cref="T:System.String" /> representation of the <paramref name="tensor" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string ToString&lt;T&gt; (this in System.Numerics.Tensors.TensorSpan&lt;T&gt; tensor, scoped ReadOnlySpan&lt;IntPtr&gt; maximumLengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ToString&lt;T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; tensor, valuetype System.ReadOnlySpan`1&lt;native int&gt; maximumLengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.ToString``1(System.Numerics.Tensors.TensorSpan{``0}@,System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function ToString(Of T) (ByRef tensor As TensorSpan(Of T), maximumLengths As ReadOnlySpan(Of IntPtr)) As String" />
      <MemberSignature Language="F#" Value="static member ToString : TensorSpan * ReadOnlySpan&lt;nativeint&gt; -&gt; string" Usage="System.Numerics.Tensors.Tensor.ToString (tensor, maximumLengths)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::String ^ ToString(System::Numerics::Tensors::TensorSpan&lt;T&gt; % tensor, ReadOnlySpan&lt;IntPtr&gt; maximumLengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="maximumLengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">The <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> you want to represent as a string.</param>
        <param name="maximumLengths">Maximum Length of each dimension</param>
        <summary>
            Creates a <see cref="T:System.String" /> representation of the <see cref="T:System.Numerics.Tensors.TensorSpan`1" />."/&gt;
            </summary>
        <returns>A <see cref="T:System.String" /> representation of the <paramref name="tensor" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrailingZeroCount&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; TrailingZeroCount&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; TrailingZeroCount&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.TrailingZeroCount``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrailingZeroCount(Of T As IBinaryInteger(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member TrailingZeroCount : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.TrailingZeroCount x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ TrailingZeroCount(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>Computes the element-wise trailing zero count of numbers in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrailingZeroCount&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; TrailingZeroCount&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; TrailingZeroCount&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.TrailingZeroCount``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrailingZeroCount(Of T As IBinaryInteger(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member TrailingZeroCount : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.TrailingZeroCount (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ TrailingZeroCount(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>Computes the element-wise trailing zero count of numbers in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Transpose&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Transpose&lt;T&gt; (System.Numerics.Tensors.Tensor&lt;T&gt; tensor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Transpose&lt;T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; tensor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Transpose``1(System.Numerics.Tensors.Tensor{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Transpose(Of T) (tensor As Tensor(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Transpose : System.Numerics.Tensors.Tensor&lt;'T&gt; -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Transpose tensor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Transpose(System::Numerics::Tensors::Tensor&lt;T&gt; ^ tensor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">Input <see cref="T:System.Numerics.Tensors.Tensor`1" />.</param>
        <summary>
            Swaps the last two dimensions of the <paramref name="tensor" /> tensor.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Truncate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Truncate&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Truncate&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Truncate``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Truncate(Of T As IFloatingPoint(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Truncate : ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Truncate x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Truncate(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>Computes the element-wise truncation of numbers in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Truncate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Truncate&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Truncate&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Truncate``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Truncate(Of T As IFloatingPoint(Of T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Truncate : ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Truncate (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Truncate(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>Computes the element-wise truncation of numbers in the specified tensor.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryBroadcastTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryBroadcastTo&lt;T&gt; (this in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; tensor, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryBroadcastTo&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; tensor, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.TryBroadcastTo``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TryBroadcastTo(Of T) (ByRef tensor As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryBroadcastTo : ReadOnlyTensorSpan * TensorSpan -&gt; bool" Usage="System.Numerics.Tensors.Tensor.TryBroadcastTo (tensor, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryBroadcastTo(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % tensor, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">Input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination">Destination <see cref="T:System.Numerics.Tensors.TensorSpan`1" />.</param>
        <summary>
            Broadcast the data from <paramref name="tensor" /> to the smallest broadcastable shape compatible with <paramref name="destination" /> and stores it in <paramref name="destination" />
            If the shapes are not compatible, false is returned.
            </summary>
        <returns>
          <see langword="false" /> if the shapes are not compatible, otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryBroadcastTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryBroadcastTo&lt;T&gt; (this System.Numerics.Tensors.Tensor&lt;T&gt; tensor, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryBroadcastTo&lt;T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; tensor, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.TryBroadcastTo``1(System.Numerics.Tensors.Tensor{``0},System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TryBroadcastTo(Of T) (tensor As Tensor(Of T), ByRef destination As TensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryBroadcastTo : System.Numerics.Tensors.Tensor&lt;'T&gt; * TensorSpan -&gt; bool" Usage="System.Numerics.Tensors.Tensor.TryBroadcastTo (tensor, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryBroadcastTo(System::Numerics::Tensors::Tensor&lt;T&gt; ^ tensor, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" RefType="this" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">Input <see cref="T:System.Numerics.Tensors.Tensor`1" />.</param>
        <param name="destination">Destination <see cref="T:System.Numerics.Tensors.TensorSpan`1" />.</param>
        <summary>
            Broadcast the data from <paramref name="tensor" /> to the smallest broadcastable shape compatible with <paramref name="destination" /> and stores it in <paramref name="destination" />
            If the shapes are not compatible, false is returned.
            </summary>
        <returns>
          <see langword="false" /> if the shapes are not compatible, otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryBroadcastTo&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TryBroadcastTo&lt;T&gt; (this in System.Numerics.Tensors.TensorSpan&lt;T&gt; tensor, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryBroadcastTo&lt;T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; tensor, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.TryBroadcastTo``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function TryBroadcastTo(Of T) (ByRef tensor As TensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryBroadcastTo : TensorSpan * TensorSpan -&gt; bool" Usage="System.Numerics.Tensors.Tensor.TryBroadcastTo (tensor, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static bool TryBroadcastTo(System::Numerics::Tensors::TensorSpan&lt;T&gt; % tensor, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">Input <see cref="T:System.Numerics.Tensors.TensorSpan`1" />.</param>
        <param name="destination">Destination <see cref="T:System.Numerics.Tensors.TensorSpan`1" />.</param>
        <summary>
            Broadcast the data from <paramref name="tensor" /> to the smallest broadcastable shape compatible with <paramref name="destination" /> and stores it in <paramref name="destination" />
            If the shapes are not compatible, false is returned.
            </summary>
        <returns>
          <see langword="false" /> if the shapes are not compatible, otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unsqueeze&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; Unsqueeze&lt;T&gt; (this in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; tensor, int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt; Unsqueeze&lt;T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; tensor, int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Unsqueeze``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Unsqueeze(Of T) (ByRef tensor As ReadOnlyTensorSpan(Of T), dimension As Integer) As ReadOnlyTensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Unsqueeze : ReadOnlyTensorSpan * int -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Unsqueeze (tensor, dimension)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; Unsqueeze(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % tensor, int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">The <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> to add a dimension of length 1.</param>
        <param name="dimension">The index of the dimension to add.</param>
        <summary>
            Insert a new dimension of length 1 that will appear at the dimension position.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unsqueeze&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Unsqueeze&lt;T&gt; (this System.Numerics.Tensors.Tensor&lt;T&gt; tensor, int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Unsqueeze&lt;T&gt;(class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; tensor, int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Unsqueeze``1(System.Numerics.Tensors.Tensor{``0},System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Unsqueeze(Of T) (tensor As Tensor(Of T), dimension As Integer) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Unsqueeze : System.Numerics.Tensors.Tensor&lt;'T&gt; * int -&gt; System.Numerics.Tensors.Tensor&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Unsqueeze (tensor, dimension)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Unsqueeze(System::Numerics::Tensors::Tensor&lt;T&gt; ^ tensor, int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.Tensor&lt;T&gt;" RefType="this" />
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">The <see cref="T:System.Numerics.Tensors.Tensor`1" /> to add a dimension of length 1.</param>
        <param name="dimension">The index of the dimension to add.</param>
        <summary>
            Insert a new dimension of length 1 that will appear at the dimension position.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unsqueeze&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Unsqueeze&lt;T&gt; (this in System.Numerics.Tensors.TensorSpan&lt;T&gt; tensor, int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Unsqueeze&lt;T&gt;([in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; tensor, int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Unsqueeze``1(System.Numerics.Tensors.TensorSpan{``0}@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Unsqueeze(Of T) (ByRef tensor As TensorSpan(Of T), dimension As Integer) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Unsqueeze : TensorSpan * int -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.Tensor.Unsqueeze (tensor, dimension)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Numerics::Tensors::TensorSpan&lt;T&gt; Unsqueeze(System::Numerics::Tensors::TensorSpan&lt;T&gt; % tensor, int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="tensor" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="this">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="tensor">The <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> to add a dimension of length 1.</param>
        <param name="dimension">The index of the dimension to add.</param>
        <summary>
            Insert a new dimension of length 1 that will appear at the dimension position.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Xor&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Xor&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Xor``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Xor(Of T As IBitwiseOperators(Of T, T, T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T)) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Xor : ReadOnlyTensorSpan * ReadOnlyTensorSpan -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Xor (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Xor(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <summary>Computes the element-wise XOR of numbers in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.Tensor&lt;T&gt; Xor&lt;T&gt; (in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Numerics.Tensors.Tensor`1&lt;!!T&gt; Xor&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Xor``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Xor(Of T As IBitwiseOperators(Of T, T, T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T) As Tensor(Of T)" />
      <MemberSignature Language="F#" Value="static member Xor : ReadOnlyTensorSpan * 'T -&gt; System.Numerics.Tensors.Tensor&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Xor (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static System::Numerics::Tensors::Tensor&lt;T&gt; ^ Xor(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.Tensor&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The second value.</param>
        <summary>
            Computes the element-wise Xor of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.Tensor`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Xor&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Xor&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, [in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Xor``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Xor(Of T As IBitwiseOperators(Of T, T, T)) (ByRef x As ReadOnlyTensorSpan(Of T), ByRef y As ReadOnlyTensorSpan(Of T), ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Xor : ReadOnlyTensorSpan * ReadOnlyTensorSpan * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Xor (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Xor(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The right <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="destination" />
        <summary>Computes the element-wise XOR of numbers in the specified tensors.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static ref readonly System.Numerics.Tensors.TensorSpan&lt;T&gt; Xor&lt;T&gt; (scoped in System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; x, T y, in System.Numerics.Tensors.TensorSpan&lt;T&gt; destination) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt; Xor&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;([in]valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!!T&gt;&amp; x, !!T y, [in]valuetype System.Numerics.Tensors.TensorSpan`1&lt;!!T&gt;&amp; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.Tensor.Xor``1(System.Numerics.Tensors.ReadOnlyTensorSpan{``0}@,``0,System.Numerics.Tensors.TensorSpan{``0}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Xor(Of T As IBitwiseOperators(Of T, T, T)) (ByRef x As ReadOnlyTensorSpan(Of T), y As T, ByRef destination As TensorSpan(Of T)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Xor : ReadOnlyTensorSpan * 'T * TensorSpan -&gt; TensorSpan (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.Tensor.Xor (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static System::Numerics::Tensors::TensorSpan&lt;T&gt; ^ Xor(System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt; % x, T y, System::Numerics::Tensors::TensorSpan&lt;T&gt; % destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Readonly">
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
          </Attribute>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" />
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;" RefType="ref">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The left <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</param>
        <param name="y">The second value.</param>
        <param name="destination" />
        <summary>
            Computes the element-wise Xor of the two input <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> and returns a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> with the result.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
