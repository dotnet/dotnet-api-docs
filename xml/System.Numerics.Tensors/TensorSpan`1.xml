<Type Name="TensorSpan&lt;T&gt;" FullName="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
  <TypeSignature Language="C#" Value="public readonly ref struct TensorSpan&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit TensorSpan`1&lt;T&gt; extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Tensors.TensorSpan`1" />
  <TypeSignature Language="VB.NET" Value="Public Structure TensorSpan(Of T)" />
  <TypeSignature Language="F#" Value="type TensorSpan&lt;'T&gt; = struct" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public value class TensorSpan" />
  <AssemblyInfo>
    <AssemblyName>System.Numerics.Tensors</AssemblyName>
    <AssemblyVersion>9.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T">
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.Experimental("SYSLIB5001", UrlFormat="https://aka.ms/dotnet-warnings/{0}")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.Experimental("SYSLIB5001", UrlFormat="https://aka.ms/dotnet-warnings/{0}")&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Diagnostics.DebuggerDisplay("{ToString(),raw}")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerDisplay("{ToString(),raw}")&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Diagnostics.DebuggerTypeProxy(typeof(System.Numerics.Tensors.TensorSpanDebugView&lt;&gt;))]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Diagnostics.DebuggerTypeProxy(typeof(System.Numerics.Tensors.TensorSpanDebugView&lt;&gt;))&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.CompilerServices.CompilerFeatureRequired("RefStructs")]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.CompilerFeatureRequired("RefStructs")&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.CompilerServices.IsByRefLike]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsByRefLike&gt;]</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">To be added.</typeparam>
    <summary>
            TensorSpan represents a contiguous region of arbitrary memory. Unlike arrays, it can point to either managed
            or native memory, or to memory allocated on the stack. It is type-safe and memory-safe.
            </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TensorSpan (Array? array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorSpan`1.#ctor(System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As Array)" />
      <MemberSignature Language="F#" Value="new System.Numerics.Tensors.TensorSpan&lt;'T&gt; : Array -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="new System.Numerics.Tensors.TensorSpan&lt;'T&gt; array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TensorSpan(Array ^ array);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">The target array.</param>
        <summary>
            Creates a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> over the provided <see cref="T:System.Array" />. The new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> will
            have a rank of 1 and a length equal to the length of the provided <see cref="T:System.Array" />.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TensorSpan (Span&lt;T&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Span`1&lt;!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorSpan`1.#ctor(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (span As Span(Of T))" />
      <MemberSignature Language="F#" Value="new System.Numerics.Tensors.TensorSpan&lt;'T&gt; : Span&lt;'T&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="new System.Numerics.Tensors.TensorSpan&lt;'T&gt; span" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TensorSpan(Span&lt;T&gt; span);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="span">The target span.</param>
        <summary>
            Creates a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> over the provided <see cref="T:System.Span`1" />. The new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> will
            have a rank of 1 and a length equal to the length of the provided <see cref="T:System.Span`1" />.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TensorSpan (T[]? array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorSpan`1.#ctor(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T())" />
      <MemberSignature Language="F#" Value="new System.Numerics.Tensors.TensorSpan&lt;'T&gt; : 'T[] -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="new System.Numerics.Tensors.TensorSpan&lt;'T&gt; array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TensorSpan(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">The target array.</param>
        <summary>
            Creates a new span over the entirety of the target array.
            </summary>
        <remarks>Returns default when <paramref name="array" /> is null.</remarks>
        <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array" /> is covariant and array's type is not exactly T[].</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TensorSpan (T* data, IntPtr dataLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T* data, native int dataLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorSpan`1.#ctor(`0*,System.IntPtr)" />
      <MemberSignature Language="F#" Value="new System.Numerics.Tensors.TensorSpan&lt;'T&gt; : nativeptr&lt;'T&gt; * nativeint -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="new System.Numerics.Tensors.TensorSpan&lt;'T&gt; (data, dataLength)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TensorSpan(T* data, IntPtr dataLength);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="data" Type="T*">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="dataLength" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="data">An unmanaged data to memory.</param>
        <param name="dataLength">The number of elements the unmanaged memory can hold.</param>
        <summary>
            Creates a new span over the target unmanaged buffer.  Clearly this
            is quite dangerous the length is not checked.
            But if this creation is correct, then all subsequent uses are correct.
            </summary>
        <remarks>Clearly this is quite dangerous the length is not checked. But if this creation is correct, then all subsequent uses are correct.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TensorSpan (Span&lt;T&gt; span, scoped ReadOnlySpan&lt;IntPtr&gt; lengths, scoped ReadOnlySpan&lt;IntPtr&gt; strides);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Span`1&lt;!T&gt; span, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorSpan`1.#ctor(System.Span{`0},System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (span As Span(Of T), lengths As ReadOnlySpan(Of IntPtr), strides As ReadOnlySpan(Of IntPtr))" />
      <MemberSignature Language="F#" Value="new System.Numerics.Tensors.TensorSpan&lt;'T&gt; : Span&lt;'T&gt; * ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="new System.Numerics.Tensors.TensorSpan&lt;'T&gt; (span, lengths, strides)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TensorSpan(Span&lt;T&gt; span, ReadOnlySpan&lt;IntPtr&gt; lengths, ReadOnlySpan&lt;IntPtr&gt; strides);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="span">The target span.</param>
        <param name="lengths">The lengths of each dimension.</param>
        <param name="strides">The strides for each dimension. Will be automatically calculated if not provided.</param>
        <summary>
            Creates a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> over the provided <see cref="T:System.Span`1" /> using the specified lengths and strides.
            If the strides are not provided, they will be automatically calculated.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TensorSpan (Array? array, scoped ReadOnlySpan&lt;System.Buffers.NIndex&gt; startIndex, scoped ReadOnlySpan&lt;IntPtr&gt; lengths, scoped ReadOnlySpan&lt;IntPtr&gt; strides);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Array array, valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NIndex&gt; startIndex, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorSpan`1.#ctor(System.Array,System.ReadOnlySpan{System.Buffers.NIndex},System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As Array, startIndex As ReadOnlySpan(Of NIndex), lengths As ReadOnlySpan(Of IntPtr), strides As ReadOnlySpan(Of IntPtr))" />
      <MemberSignature Language="F#" Value="new System.Numerics.Tensors.TensorSpan&lt;'T&gt; : Array * ReadOnlySpan&lt;System.Buffers.NIndex&gt; * ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="new System.Numerics.Tensors.TensorSpan&lt;'T&gt; (array, startIndex, lengths, strides)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TensorSpan(Array ^ array, ReadOnlySpan&lt;System::Buffers::NIndex&gt; startIndex, ReadOnlySpan&lt;IntPtr&gt; lengths, ReadOnlySpan&lt;IntPtr&gt; strides);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="System.Array">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="startIndex" Type="System.ReadOnlySpan&lt;System.Buffers.NIndex&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">The target array.</param>
        <param name="startIndex">The starting offset for each dimension.</param>
        <param name="lengths">The lengths of each dimension.</param>
        <param name="strides">The strides for each dimension. Will be automatically calculated if not provided.</param>
        <summary>
            Creates a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> over the provided <see cref="T:System.Array" /> using the specified start offsets, lengths, and strides.
            If the strides are not provided, they will be automatically calculated.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TensorSpan (Array? array, scoped ReadOnlySpan&lt;int&gt; start, scoped ReadOnlySpan&lt;IntPtr&gt; lengths, scoped ReadOnlySpan&lt;IntPtr&gt; strides);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Array array, valuetype System.ReadOnlySpan`1&lt;int32&gt; start, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorSpan`1.#ctor(System.Array,System.ReadOnlySpan{System.Int32},System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As Array, start As ReadOnlySpan(Of Integer), lengths As ReadOnlySpan(Of IntPtr), strides As ReadOnlySpan(Of IntPtr))" />
      <MemberSignature Language="F#" Value="new System.Numerics.Tensors.TensorSpan&lt;'T&gt; : Array * ReadOnlySpan&lt;int&gt; * ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="new System.Numerics.Tensors.TensorSpan&lt;'T&gt; (array, start, lengths, strides)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TensorSpan(Array ^ array, ReadOnlySpan&lt;int&gt; start, ReadOnlySpan&lt;IntPtr&gt; lengths, ReadOnlySpan&lt;IntPtr&gt; strides);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="System.Array">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="start" Type="System.ReadOnlySpan&lt;System.Int32&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">The target array.</param>
        <param name="start">The starting offset for each dimension.</param>
        <param name="lengths">The lengths of each dimension.</param>
        <param name="strides">The strides for each dimension. Will be automatically calculated if not provided.</param>
        <summary>
            Creates a new <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> over the provided <see cref="T:System.Array" /> using the specified start offsets, lengths, and strides.
            If the strides are not provided, they will be automatically calculated.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TensorSpan (T* data, IntPtr dataLength, scoped ReadOnlySpan&lt;IntPtr&gt; lengths, scoped ReadOnlySpan&lt;IntPtr&gt; strides);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T* data, native int dataLength, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorSpan`1.#ctor(`0*,System.IntPtr,System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="F#" Value="new System.Numerics.Tensors.TensorSpan&lt;'T&gt; : nativeptr&lt;'T&gt; * nativeint * ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="new System.Numerics.Tensors.TensorSpan&lt;'T&gt; (data, dataLength, lengths, strides)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TensorSpan(T* data, IntPtr dataLength, ReadOnlySpan&lt;IntPtr&gt; lengths, ReadOnlySpan&lt;IntPtr&gt; strides);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="data" Type="T*">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="dataLength" Type="System.IntPtr" />
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="data">An unmanaged data to memory.</param>
        <param name="dataLength">The number of elements the unmanaged memory can hold.</param>
        <param name="lengths">The lengths of the dimensions. If default is provided its assumed to have 1 dimension with a length equal to the length of the data.</param>
        <param name="strides">The lengths of the strides. If nothing is provided it figures out the default stride configuration.</param>
        <summary>
            Creates a new span over the target unmanaged buffer.  Clearly this
            is quite dangerous, because the length is not checked.
            But if this creation is correct, then all subsequent uses are correct.
            </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
            Thrown when <typeparamref name="T" /> is reference type or contains pointers and hence cannot be stored in unmanaged memory.
            </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified length is negative.
            </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TensorSpan (T[]? array, Index startIndex, scoped ReadOnlySpan&lt;IntPtr&gt; lengths, scoped ReadOnlySpan&lt;IntPtr&gt; strides);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array, valuetype System.Index startIndex, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorSpan`1.#ctor(`0[],System.Index,System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T(), startIndex As Index, lengths As ReadOnlySpan(Of IntPtr), strides As ReadOnlySpan(Of IntPtr))" />
      <MemberSignature Language="F#" Value="new System.Numerics.Tensors.TensorSpan&lt;'T&gt; : 'T[] * Index * ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="new System.Numerics.Tensors.TensorSpan&lt;'T&gt; (array, startIndex, lengths, strides)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TensorSpan(cli::array &lt;T&gt; ^ array, Index startIndex, ReadOnlySpan&lt;IntPtr&gt; lengths, ReadOnlySpan&lt;IntPtr&gt; strides);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="startIndex" Type="System.Index" />
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">The target array.</param>
        <param name="startIndex">The index at which to begin the span.</param>
        <param name="lengths">The lengths of the dimensions. If default is provided its assumed to have 1 dimension with a length equal to the length of the data.</param>
        <param name="strides">The strides of each dimension. If default or span of length 0 is provided then strides will be automatically calculated.</param>
        <summary>
            Creates a new span over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
        <remarks>Returns default when <paramref name="array" /> is null.</remarks>
        <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array" /> is covariant and array's type is not exactly T[].</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="startIndex" /> or end index is not in the range (&lt;0 or &gt;FlattenedLength).
            </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TensorSpan (T[]? array, int start, scoped ReadOnlySpan&lt;IntPtr&gt; lengths, scoped ReadOnlySpan&lt;IntPtr&gt; strides);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array, int32 start, valuetype System.ReadOnlySpan`1&lt;native int&gt; lengths, valuetype System.ReadOnlySpan`1&lt;native int&gt; strides) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorSpan`1.#ctor(`0[],System.Int32,System.ReadOnlySpan{System.IntPtr},System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T(), start As Integer, lengths As ReadOnlySpan(Of IntPtr), strides As ReadOnlySpan(Of IntPtr))" />
      <MemberSignature Language="F#" Value="new System.Numerics.Tensors.TensorSpan&lt;'T&gt; : 'T[] * int * ReadOnlySpan&lt;nativeint&gt; * ReadOnlySpan&lt;nativeint&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="new System.Numerics.Tensors.TensorSpan&lt;'T&gt; (array, start, lengths, strides)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TensorSpan(cli::array &lt;T&gt; ^ array, int start, ReadOnlySpan&lt;IntPtr&gt; lengths, ReadOnlySpan&lt;IntPtr&gt; strides);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="lengths" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="strides" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">The target array.</param>
        <param name="start">The index at which to begin the span.</param>
        <param name="lengths">The lengths of the dimensions. If default is provided its assumed to have 1 dimension with a length equal to the length of the data.</param>
        <param name="strides">The strides of each dimension. If default or span of length 0 is provided then strides will be automatically calculated.</param>
        <summary>
            Creates a new span over the portion of the target array beginning
            at 'start' index and ending at 'end' index (exclusive).
            </summary>
        <remarks>Returns default when <paramref name="array" /> is null.</remarks>
        <exception cref="T:System.ArrayTypeMismatchException">Thrown when <paramref name="array" /> is covariant and array's type is not exactly T[].</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
            Thrown when the specified <paramref name="start" /> or end index is not in the range (&lt;0 or &gt;FlattenedLength).
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorSpan`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="tensorSpan.Clear " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Clears the contents of this span.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (scoped System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorSpan`1.CopyTo(System.Numerics.Tensors.TensorSpan{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As TensorSpan(Of T))" />
      <MemberSignature Language="F#" Value="member this.CopyTo : System.Numerics.Tensors.TensorSpan&lt;'T&gt; -&gt; unit" Usage="tensorSpan.CopyTo destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(System::Numerics::Tensors::TensorSpan&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="destination">The span to copy items into.</param>
        <summary>
            Copies the contents of this span into destination span. If the source
            and destinations overlap, this method behaves as if the original values in
            a temporary location before the destination is overwritten.
            </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
            Thrown when the destination TensorSpan is shorter than the source Span.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static System.Numerics.Tensors.TensorSpan&lt;T&gt; Empty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.Tensors.TensorSpan`1&lt;!T&gt; Empty" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.TensorSpan`1.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Empty As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member Empty : System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.TensorSpan&lt;'T&gt;.Empty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::Tensors::TensorSpan&lt;T&gt; Empty { System::Numerics::Tensors::TensorSpan&lt;T&gt; get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Returns an empty <see cref="T:System.Numerics.Tensors.TensorSpan`1" /></summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object? obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorSpan`1.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="tensorSpan.Equals obj" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Obsolete("Equals() on TensorSpan will always throw an exception. Use the equality operator instead.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Equals() on TensorSpan will always throw an exception. Use the equality operator instead.")&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <summary>
            This method is not supported as spans cannot be boxed. To compare two spans, use operator==.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
            Always thrown by this method.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public void Fill (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Fill(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorSpan`1.Fill(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Fill (value As T)" />
      <MemberSignature Language="F#" Value="member this.Fill : 'T -&gt; unit" Usage="tensorSpan.Fill value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Fill(T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>
            Fills the contents of this span with the given value.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FlattenedLength">
      <MemberSignature Language="C#" Value="public IntPtr FlattenedLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int FlattenedLength" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.TensorSpan`1.FlattenedLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FlattenedLength As IntPtr" />
      <MemberSignature Language="F#" Value="member this.FlattenedLength : nativeint" Usage="System.Numerics.Tensors.TensorSpan&lt;'T&gt;.FlattenedLength" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr FlattenedLength { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            The number of items in the span.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FlattenTo">
      <MemberSignature Language="C#" Value="public void FlattenTo (scoped Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void FlattenTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorSpan`1.FlattenTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub FlattenTo (destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="member this.FlattenTo : Span&lt;'T&gt; -&gt; unit" Usage="tensorSpan.FlattenTo destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void FlattenTo(Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="destination">The span to copy items into.</param>
        <summary>
            Flattens the contents of this span into the provided <see cref="T:System.Span`1" />.
            </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.TensorSpan&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Numerics.Tensors.TensorSpan`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorSpan`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As TensorSpan(Of T).Enumerator" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;.Enumerator" Usage="tensorSpan.GetEnumerator " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Numerics::Tensors::TensorSpan&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets an enumerator for this span.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorSpan`1.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="tensorSpan.GetHashCode " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Obsolete("GetHashCode() on TensorSpan will always throw an exception.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("GetHashCode() on TensorSpan will always throw an exception.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            This method is not supported as spans cannot be boxed.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
            Always thrown by this method.
            </exception>
      </Docs>
    </Member>
    <Member MemberName="GetPinnableReference">
      <MemberSignature Language="C#" Value="public ref T GetPinnableReference ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T GetPinnableReference() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorSpan`1.GetPinnableReference" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPinnableReference () As T" />
      <MemberSignature Language="F#" Value="member this.GetPinnableReference : unit -&gt; 'T" Usage="tensorSpan.GetPinnableReference " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T % GetPinnableReference();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            Returns a reference to the 0th element of the TensorSpan. If the TensorSpan is empty, returns null reference.
            It can be used for pinning and is required to support the use of span within a fixed statement.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.TensorSpan`1.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsEmpty : bool" Usage="System.Numerics.Tensors.TensorSpan&lt;'T&gt;.IsEmpty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEmpty { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets a value indicating whether this <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> is empty.
            </summary>
        <value>
          <see langword="true" /> if this span is empty; otherwise, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public ref T this[scoped ReadOnlySpan&lt;System.Buffers.NIndex&gt; indexes] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NIndex&gt;)" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.TensorSpan`1.Item(System.ReadOnlySpan{System.Buffers.NIndex})" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(indexes As ReadOnlySpan(Of NIndex)) As T" />
      <MemberSignature Language="F#" Value="member this.Item(ReadOnlySpan&lt;System.Buffers.NIndex&gt;) : 'T" Usage="System.Numerics.Tensors.TensorSpan&lt;'T&gt;.Item" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T % default[ReadOnlySpan&lt;System::Buffers::NIndex&gt;] { T % get(ReadOnlySpan&lt;System::Buffers::NIndex&gt; indexes); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexes" Type="System.ReadOnlySpan&lt;System.Buffers.NIndex&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indexes" />
        <summary>
            Returns a reference to specified element of the TensorSpan.
            </summary>
        <value />
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException">
            Thrown when any index is less than 0 or any index is greater than or equal to FlattenedLength
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.TensorSpan&lt;T&gt; this[scoped ReadOnlySpan&lt;System.Buffers.NRange&gt; ranges] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Numerics.Tensors.TensorSpan`1&lt;!T&gt; Item(valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NRange&gt;)" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.TensorSpan`1.Item(System.ReadOnlySpan{System.Buffers.NRange})" />
      <MemberSignature Language="VB.NET" Value="Default Public Property Item(ranges As ReadOnlySpan(Of NRange)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="member this.Item(ReadOnlySpan&lt;System.Buffers.NRange&gt;) : System.Numerics.Tensors.TensorSpan&lt;'T&gt; with get, set" Usage="System.Numerics.Tensors.TensorSpan&lt;'T&gt;.Item" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Numerics::Tensors::TensorSpan&lt;T&gt; default[ReadOnlySpan&lt;System::Buffers::NRange&gt;] { System::Numerics::Tensors::TensorSpan&lt;T&gt; get(ReadOnlySpan&lt;System::Buffers::NRange&gt; ranges); void set(ReadOnlySpan&lt;System::Buffers::NRange&gt; ranges, System::Numerics::Tensors::TensorSpan&lt;T&gt; value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ranges" Type="System.ReadOnlySpan&lt;System.Buffers.NRange&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="ranges" />
        <summary>
            Returns a slice of the TensorSpan.
            </summary>
        <value />
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException">
            Thrown when any index is less than 0 or any index is greater than or equal to FlattenedLength
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public ref T this[scoped ReadOnlySpan&lt;IntPtr&gt; indexes] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(valuetype System.ReadOnlySpan`1&lt;native int&gt;)" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.TensorSpan`1.Item(System.ReadOnlySpan{System.IntPtr})" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(indexes As ReadOnlySpan(Of IntPtr)) As T" />
      <MemberSignature Language="F#" Value="member this.Item(ReadOnlySpan&lt;nativeint&gt;) : 'T" Usage="System.Numerics.Tensors.TensorSpan&lt;'T&gt;.Item" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T % default[ReadOnlySpan&lt;IntPtr&gt;] { T % get(ReadOnlySpan&lt;IntPtr&gt; indexes); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexes" Type="System.ReadOnlySpan&lt;System.IntPtr&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indexes" />
        <summary>
            Returns a reference to specified element of the TensorSpan.
            </summary>
        <value />
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException">
            Thrown when any index is less than 0 or any index is greater than or equal to FlattenedLength
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Lengths">
      <MemberSignature Language="C#" Value="public ReadOnlySpan&lt;IntPtr&gt; Lengths { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;native int&gt; Lengths" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.TensorSpan`1.Lengths" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Lengths As ReadOnlySpan(Of IntPtr)" />
      <MemberSignature Language="F#" Value="member this.Lengths : ReadOnlySpan&lt;nativeint&gt;" Usage="System.Numerics.Tensors.TensorSpan&lt;'T&gt;.Lengths" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ReadOnlySpan&lt;IntPtr&gt; Lengths { ReadOnlySpan&lt;IntPtr&gt; get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.UnscopedRef]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.UnscopedRef&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.IntPtr&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the length of each dimension in this <see cref="T:System.Numerics.Tensors.TensorSpan`1" />.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.Tensors.TensorSpan&lt;T&gt; left, System.Numerics.Tensors.TensorSpan&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!T&gt; left, valuetype System.Numerics.Tensors.TensorSpan`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorSpan`1.op_Equality(System.Numerics.Tensors.TensorSpan{`0},System.Numerics.Tensors.TensorSpan{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As TensorSpan(Of T), right As TensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.Tensors.TensorSpan&lt;'T&gt; * System.Numerics.Tensors.TensorSpan&lt;'T&gt; -&gt; bool" Usage="left = right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::Tensors::TensorSpan&lt;T&gt; left, System::Numerics::Tensors::TensorSpan&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>
            Returns true if left and right point at the same memory and have the same length.  Note that
            this does *not* check to see if the *contents* are equal.
            </summary>
        <returns>
          <see langword="true" /> if left and right point at the same memory and have the same length. This method does *not* check to see if the *contents* are equal.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt; (System.Numerics.Tensors.TensorSpan&lt;T&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Tensors.ReadOnlyTensorSpan`1&lt;!T&gt; op_Implicit(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorSpan`1.op_Implicit(System.Numerics.Tensors.TensorSpan{`0})~System.Numerics.Tensors.ReadOnlyTensorSpan{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (span As TensorSpan(Of T)) As ReadOnlyTensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member op_Implicit : System.Numerics.Tensors.TensorSpan&lt;'T&gt; -&gt; System.Numerics.Tensors.ReadOnlyTensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.TensorSpan&lt;'T&gt;.op_Implicit span" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Tensors::ReadOnlyTensorSpan&lt;T&gt;(System::Numerics::Tensors::TensorSpan&lt;T&gt; span);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.ReadOnlyTensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="span">To be added.</param>
        <summary>Converts a <see cref="T:System.Numerics.Tensors.TensorSpan`1" /> to a <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" />.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Tensors.TensorSpan&lt;T&gt; (T[]? array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Tensors.TensorSpan`1&lt;!T&gt; op_Implicit(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorSpan`1.op_Implicit(`0[])~System.Numerics.Tensors.TensorSpan{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (array As T()) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="static member op_Implicit : 'T[] -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="System.Numerics.Tensors.TensorSpan&lt;'T&gt;.op_Implicit array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Tensors::TensorSpan&lt;T&gt;(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="array">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.Tensors.TensorSpan&lt;T&gt; left, System.Numerics.Tensors.TensorSpan&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!T&gt; left, valuetype System.Numerics.Tensors.TensorSpan`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorSpan`1.op_Inequality(System.Numerics.Tensors.TensorSpan{`0},System.Numerics.Tensors.TensorSpan{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As TensorSpan(Of T), right As TensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.Tensors.TensorSpan&lt;'T&gt; * System.Numerics.Tensors.TensorSpan&lt;'T&gt; -&gt; bool" Usage="System.Numerics.Tensors.TensorSpan&lt;'T&gt;.op_Inequality (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::Tensors::TensorSpan&lt;T&gt; left, System::Numerics::Tensors::TensorSpan&lt;T&gt; right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="right" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="left">To be added.</param>
        <param name="right">To be added.</param>
        <summary>
            Returns false if left and right point at the same memory and have the same length.  Note that
            this does *not* check to see if the *contents* are equal.
            </summary>
        <returns>
          <see langword="false" /> if left and right point at the same memory and have the same length. This method does *not* check to see if the *contents* are unequal.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.TensorSpan`1.Rank" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rank As Integer" />
      <MemberSignature Language="F#" Value="member this.Rank : int" Usage="System.Numerics.Tensors.TensorSpan&lt;'T&gt;.Rank" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Rank { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the rank, aka the number of dimensions, of this <see cref="T:System.Numerics.Tensors.TensorSpan`1" />.
            </summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.TensorSpan&lt;T&gt; Slice (scoped ReadOnlySpan&lt;System.Buffers.NIndex&gt; indexes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Numerics.Tensors.TensorSpan`1&lt;!T&gt; Slice(valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NIndex&gt; indexes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorSpan`1.Slice(System.ReadOnlySpan{System.Buffers.NIndex})" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (indexes As ReadOnlySpan(Of NIndex)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="member this.Slice : ReadOnlySpan&lt;System.Buffers.NIndex&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="tensorSpan.Slice indexes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Numerics::Tensors::TensorSpan&lt;T&gt; Slice(ReadOnlySpan&lt;System::Buffers::NIndex&gt; indexes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indexes" Type="System.ReadOnlySpan&lt;System.Buffers.NIndex&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indexes">The indexes for the slice.</param>
        <summary>
            Returns a reference to specified element of the TensorSpan.
            </summary>
        <returns />
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException">
            Thrown when any index is less than 0 or any index is greater than or equal to FlattenedLength
            </exception>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public System.Numerics.Tensors.TensorSpan&lt;T&gt; Slice (scoped ReadOnlySpan&lt;System.Buffers.NRange&gt; ranges);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Numerics.Tensors.TensorSpan`1&lt;!T&gt; Slice(valuetype System.ReadOnlySpan`1&lt;valuetype System.Buffers.NRange&gt; ranges) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorSpan`1.Slice(System.ReadOnlySpan{System.Buffers.NRange})" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (ranges As ReadOnlySpan(Of NRange)) As TensorSpan(Of T)" />
      <MemberSignature Language="F#" Value="member this.Slice : ReadOnlySpan&lt;System.Buffers.NRange&gt; -&gt; System.Numerics.Tensors.TensorSpan&lt;'T&gt;" Usage="tensorSpan.Slice ranges" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Numerics::Tensors::TensorSpan&lt;T&gt; Slice(ReadOnlySpan&lt;System::Buffers::NRange&gt; ranges);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Tensors.TensorSpan&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-8.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ranges" Type="System.ReadOnlySpan&lt;System.Buffers.NRange&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ParamCollection]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ParamCollection&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="ranges">The ranges for the slice</param>
        <summary>
            Forms a slice out of the given span
            </summary>
        <returns>A <see cref="T:System.Numerics.Tensors.ReadOnlyTensorSpan`1" /> based on the provided <paramref name="ranges" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Strides">
      <MemberSignature Language="C#" Value="public ReadOnlySpan&lt;IntPtr&gt; Strides { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ReadOnlySpan`1&lt;native int&gt; Strides" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Tensors.TensorSpan`1.Strides" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Strides As ReadOnlySpan(Of IntPtr)" />
      <MemberSignature Language="F#" Value="member this.Strides : ReadOnlySpan&lt;nativeint&gt;" Usage="System.Numerics.Tensors.TensorSpan&lt;'T&gt;.Strides" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ReadOnlySpan&lt;IntPtr&gt; Strides { ReadOnlySpan&lt;IntPtr&gt; get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.UnscopedRef]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.UnscopedRef&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.IntPtr&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
            Gets the strides of this <see cref="T:System.Numerics.Tensors.TensorSpan`1" /></summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorSpan`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="tensorSpan.ToString " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
            For <see cref="T:System.Span`1" />, returns a new instance of string that represents the characters pointed to by the span.
            Otherwise, returns a <see cref="T:System.String" /> with the name of the type and the number of elements.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCopyTo">
      <MemberSignature Language="C#" Value="public bool TryCopyTo (scoped System.Numerics.Tensors.TensorSpan&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryCopyTo(valuetype System.Numerics.Tensors.TensorSpan`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorSpan`1.TryCopyTo(System.Numerics.Tensors.TensorSpan{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryCopyTo (destination As TensorSpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryCopyTo : System.Numerics.Tensors.TensorSpan&lt;'T&gt; -&gt; bool" Usage="tensorSpan.TryCopyTo destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryCopyTo(System::Numerics::Tensors::TensorSpan&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Numerics.Tensors.TensorSpan&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="destination">The span to copy items into.</param>
        <summary>
            Copies the contents of this span into destination span. If the source
            and destinations overlap, this method behaves as if the original values in
            a temporary location before the destination is overwritten.
            </summary>
        <returns>If the destination span is shorter than the source span, this method
            return false and no data is written to the destination.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFlattenTo">
      <MemberSignature Language="C#" Value="public bool TryFlattenTo (scoped Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFlattenTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorSpan`1.TryFlattenTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFlattenTo (destination As Span(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFlattenTo : Span&lt;'T&gt; -&gt; bool" Usage="tensorSpan.TryFlattenTo destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryFlattenTo(Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.ScopedRef]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.ScopedRef&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="destination">The span to copy items into.</param>
        <summary>
            Flattens the contents of this span into the provided <see cref="T:System.Span`1" />.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
