<Type Name="TensorPrimitives" FullName="System.Numerics.Tensors.TensorPrimitives">
  <TypeSignature Language="C#" Value="public static class TensorPrimitives" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit TensorPrimitives extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Tensors.TensorPrimitives" />
  <TypeSignature Language="VB.NET" Value="Public Class TensorPrimitives" />
  <TypeSignature Language="F#" Value="type TensorPrimitives = class" />
  <TypeSignature Language="C++ CLI" Value="public ref class TensorPrimitives abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Numerics.Tensors</AssemblyName>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>9.0.0.0</AssemblyVersion>
    <AssemblyVersion>9.0.0.1</AssemblyVersion>
    <AssemblyVersion>9.0.0.2</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Performs primitive tensor operations over spans of memory.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static void Abs (ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Abs(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Abs(System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Abs (x As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Abs : ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Abs (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Abs(ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise absolute value of each single-precision floating-point number in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = MathF.Abs(<paramref name="x" />[i])</c>.
            </para>
          <para>
            The absolute value of a <see cref="T:System.Single" /> is its numeric value without its sign. For example, the absolute value of both 1.2e-03 and -1.2e03 is 1.2e03.
            </para>
          <para>
            If a value is equal to <see cref="F:System.Single.NegativeInfinity" /> or <see cref="F:System.Single.PositiveInfinity" />, the result stored into the corresponding destination location is set to <see cref="F:System.Single.PositiveInfinity" />.
            If a value is equal to <see cref="F:System.Single.NaN" />, the result stored into the corresponding destination location is the original NaN value with the sign bit removed.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Abs&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Abs&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Abs&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Abs``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Abs(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Abs : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Abs (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void Abs(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise absolute value of each number in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Abs(<paramref name="x" />[i])</c>.
            </para>
          <para>
            The absolute value of a <typeparamref name="T" /> is its numeric value without its sign. For example, the absolute value of both 1.2e-03 and -1.2e03 is 1.2e03.
            </para>
          <para>
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity" /> or <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity" />, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity" />.
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the result stored into the corresponding destination location is the original NaN value with the sign bit removed.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
        <exception cref="T:System.OverflowException">
          <typeparamref name="T" /> is a signed integer type and <paramref name="x" /> contained a value equal to <typeparamref name="T" />'s minimum value.</exception>
      </Docs>
    </Member>
    <Member MemberName="Acos&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Acos&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Acos&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Acos``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Acos(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Acos : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Acos (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void Acos(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise angle in radians whose cosine is the specifed number.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Acos(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Acosh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Acosh&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Acosh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Acosh``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Acosh(Of T As IHyperbolicFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Acosh : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Acosh (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static void Acosh(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise hyperbolic arc-cosine of the specifed number.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Acosh(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcosPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void AcosPi&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AcosPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.AcosPi``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AcosPi(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member AcosPi : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.AcosPi (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void AcosPi(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise angle in radians whose cosine is the specifed number and divides the result by Pi.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.AcosPi(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static void Add (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Add(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Add(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Add (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Add : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Add (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Add(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise addition of single-precision floating-point numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] + <paramref name="y" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static void Add (ReadOnlySpan&lt;float&gt; x, float y, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Add(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, float32 y, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Add(System.ReadOnlySpan{System.Single},System.Single,System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Add (x As ReadOnlySpan(Of Single), y As Single, destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Add : ReadOnlySpan&lt;single&gt; * single * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Add (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Add(ReadOnlySpan&lt;float&gt; x, float y, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise addition of single-precision floating-point numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] + <paramref name="y" /></c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Add&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Add&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Add``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Add(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Add : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Add (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static void Add(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise addition of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] + <paramref name="y" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Add&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Add&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Add``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Add(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Add : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Add (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static void Add(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise addition of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] + <paramref name="y" /></c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddMultiply">
      <MemberSignature Language="C#" Value="public static void AddMultiply (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, ReadOnlySpan&lt;float&gt; multiplier, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMultiply(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y, valuetype System.ReadOnlySpan`1&lt;float32&gt; multiplier, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.AddMultiply(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMultiply (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single), multiplier As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member AddMultiply : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.AddMultiply (x, y, multiplier, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMultiply(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, ReadOnlySpan&lt;float&gt; multiplier, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="multiplier" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="multiplier">The third tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> + <paramref name="y" />) * <paramref name="multiplier" /></c> for the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] + <paramref name="y" />[i]) * <paramref name="multiplier" />[i]</c>.
            </para>
          <para>
            If any of the element-wise input values is equal to <see cref="F:System.Single.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="multiplier" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddMultiply">
      <MemberSignature Language="C#" Value="public static void AddMultiply (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, float multiplier, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMultiply(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y, float32 multiplier, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.AddMultiply(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Single,System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMultiply (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single), multiplier As Single, destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member AddMultiply : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; * single * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.AddMultiply (x, y, multiplier, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMultiply(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, float multiplier, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="multiplier" Type="System.Single" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="multiplier">The third tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> + <paramref name="y" />) * <paramref name="multiplier" /></c> for the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] + <paramref name="y" />[i]) * <paramref name="multiplier" /></c>.
            </para>
          <para>
            If any of the element-wise input values is equal to <see cref="F:System.Single.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddMultiply">
      <MemberSignature Language="C#" Value="public static void AddMultiply (ReadOnlySpan&lt;float&gt; x, float y, ReadOnlySpan&lt;float&gt; multiplier, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMultiply(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, float32 y, valuetype System.ReadOnlySpan`1&lt;float32&gt; multiplier, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.AddMultiply(System.ReadOnlySpan{System.Single},System.Single,System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMultiply (x As ReadOnlySpan(Of Single), y As Single, multiplier As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member AddMultiply : ReadOnlySpan&lt;single&gt; * single * ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.AddMultiply (x, y, multiplier, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMultiply(ReadOnlySpan&lt;float&gt; x, float y, ReadOnlySpan&lt;float&gt; multiplier, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="multiplier" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="multiplier">The third tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> + <paramref name="y" />) * <paramref name="multiplier" /></c> for the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] + <paramref name="y" />) * <paramref name="multiplier" />[i]</c>.
            </para>
          <para>
            If any of the element-wise input values is equal to <see cref="F:System.Single.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="multiplier" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddMultiply&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void AddMultiply&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, ReadOnlySpan&lt;T&gt; multiplier, Span&lt;T&gt; destination) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMultiply&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.ReadOnlySpan`1&lt;!!T&gt; multiplier, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.AddMultiply``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMultiply(Of T As {IAdditionOperators(Of T, T, T), IMultiplyOperators(Of T, T, T)}) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), multiplier As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member AddMultiply : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.AddMultiply (x, y, multiplier, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt; static void AddMultiply(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, ReadOnlySpan&lt;T&gt; multiplier, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="multiplier" Type="System.ReadOnlySpan&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="multiplier">The third tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> + <paramref name="y" />) * <paramref name="multiplier" /></c> for the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] + <paramref name="y" />[i]) * <paramref name="multiplier" />[i]</c>.
            </para>
          <para>
            If any of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="multiplier" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddMultiply&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void AddMultiply&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, T multiplier, Span&lt;T&gt; destination) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMultiply&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, !!T multiplier, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.AddMultiply``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMultiply(Of T As {IAdditionOperators(Of T, T, T), IMultiplyOperators(Of T, T, T)}) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), multiplier As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member AddMultiply : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.AddMultiply (x, y, multiplier, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt; static void AddMultiply(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, T multiplier, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="multiplier" Type="T" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="multiplier">The third tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> + <paramref name="y" />) * <paramref name="multiplier" /></c> for the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] + <paramref name="y" />[i]) * <paramref name="multiplier" /></c>.
            </para>
          <para>
            If any of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddMultiply&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void AddMultiply&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, ReadOnlySpan&lt;T&gt; multiplier, Span&lt;T&gt; destination) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMultiply&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.ReadOnlySpan`1&lt;!!T&gt; multiplier, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.AddMultiply``1(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMultiply(Of T As {IAdditionOperators(Of T, T, T), IMultiplyOperators(Of T, T, T)}) (x As ReadOnlySpan(Of T), y As T, multiplier As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member AddMultiply : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.AddMultiply (x, y, multiplier, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt; static void AddMultiply(ReadOnlySpan&lt;T&gt; x, T y, ReadOnlySpan&lt;T&gt; multiplier, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="multiplier" Type="System.ReadOnlySpan&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="multiplier">The third tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> + <paramref name="y" />) * <paramref name="multiplier" /></c> for the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] + <paramref name="y" />) * <paramref name="multiplier" />[i]</c>.
            </para>
          <para>
            If any of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="multiplier" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Asin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Asin&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Asin&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Asin``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Asin(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Asin : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Asin (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void Asin(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise angle in radians whose sine is the specifed number.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Asin(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Asinh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Asinh&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Asinh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Asinh``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Asinh(Of T As IHyperbolicFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Asinh : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Asinh (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static void Asinh(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise hyperbolic arc-sine of the specifed number.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Asinh(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsinPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void AsinPi&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AsinPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.AsinPi``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AsinPi(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member AsinPi : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.AsinPi (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void AsinPi(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise angle in radians whose sine is the specifed number and divides the result by Pi.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.AsinPi(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Atan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Atan&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Atan&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Atan``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Atan(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Atan : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Atan (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void Atan(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise angle in radians whose tangent is the specifed number.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Atan(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Atan2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Atan2&lt;T&gt; (ReadOnlySpan&lt;T&gt; y, ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Atan2&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Atan2``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Atan2(Of T As IFloatingPointIeee754(Of T)) (y As ReadOnlySpan(Of T), x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Atan2 : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Atan2 (y, x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void Atan2(ReadOnlySpan&lt;T&gt; y, ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="y">The first tensor, represented as a span.</param>
        <param name="x">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise arc-tangent for the quotient of two values in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Atan2(<paramref name="y" />[i], <paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Atan2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Atan2&lt;T&gt; (ReadOnlySpan&lt;T&gt; y, T x, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Atan2&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, !!T x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Atan2``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Atan2(Of T As IFloatingPointIeee754(Of T)) (y As ReadOnlySpan(Of T), x As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Atan2 : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Atan2 (y, x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void Atan2(ReadOnlySpan&lt;T&gt; y, T x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="x" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="y">The first tensor, represented as a span.</param>
        <param name="x">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise arc-tangent for the quotient of two values in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Atan2(<paramref name="y" />[i], <paramref name="x" />)</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Atan2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Atan2&lt;T&gt; (T y, ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Atan2&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(!!T y, valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Atan2``1(``0,System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Atan2(Of T As IFloatingPointIeee754(Of T)) (y As T, x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Atan2 : 'T * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Atan2 (y, x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void Atan2(T y, ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="y" Type="T" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="y">The first tensor, represented as a scalar.</param>
        <param name="x">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise arc-tangent for the quotient of two values in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Atan2(<paramref name="y" />, <paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Atan2Pi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Atan2Pi&lt;T&gt; (ReadOnlySpan&lt;T&gt; y, ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Atan2Pi&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Atan2Pi``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Atan2Pi(Of T As IFloatingPointIeee754(Of T)) (y As ReadOnlySpan(Of T), x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Atan2Pi : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Atan2Pi (y, x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void Atan2Pi(ReadOnlySpan&lt;T&gt; y, ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="y">The first tensor, represented as a span.</param>
        <param name="x">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise arc-tangent for the quotient of two values in the specified tensors and divides the result by Pi.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Atan2(<paramref name="y" />[i], <paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Atan2Pi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Atan2Pi&lt;T&gt; (ReadOnlySpan&lt;T&gt; y, T x, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Atan2Pi&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, !!T x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Atan2Pi``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Atan2Pi(Of T As IFloatingPointIeee754(Of T)) (y As ReadOnlySpan(Of T), x As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Atan2Pi : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Atan2Pi (y, x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void Atan2Pi(ReadOnlySpan&lt;T&gt; y, T x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="x" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="y">The first tensor, represented as a span.</param>
        <param name="x">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise arc-tangent for the quotient of two values in the specified tensors and divides the result by Pi.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Atan2(<paramref name="y" />[i], <paramref name="x" />)</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Atan2Pi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Atan2Pi&lt;T&gt; (T y, ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Atan2Pi&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(!!T y, valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Atan2Pi``1(``0,System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Atan2Pi(Of T As IFloatingPointIeee754(Of T)) (y As T, x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Atan2Pi : 'T * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Atan2Pi (y, x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void Atan2Pi(T y, ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="y" Type="T" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="y">The first tensor, represented as a scalar.</param>
        <param name="x">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise arc-tangent for the quotient of two values in the specified tensors and divides the result by Pi.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Atan2(<paramref name="y" />, <paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Atanh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Atanh&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Atanh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Atanh``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Atanh(Of T As IHyperbolicFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Atanh : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Atanh (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static void Atanh(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise hyperbolic arc-tangent of the specifed number.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Atanh(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="AtanPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void AtanPi&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AtanPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.AtanPi``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AtanPi(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member AtanPi : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.AtanPi (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void AtanPi(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise angle in radians whose tangent is the specifed number and divides the result by Pi.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.AtanPi(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Average&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Average&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Average``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Average(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Average : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Average x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static T Average(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes the mean of all elements in the specified non-empty tensor of numbers.</summary>
        <returns>The mean of all elements in <paramref name="x" />.</returns>
        <remarks>
          <para>
            If any of the input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the result value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="BitDecrement&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void BitDecrement&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BitDecrement&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.BitDecrement``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BitDecrement(Of T As IFloatingPointIeee754(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member BitDecrement : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.BitDecrement (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void BitDecrement(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise bit decrement of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.BitDecrement(<paramref name="x" />[i])</c>.
            Each element is decremented to the largest value that compares less than the original.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="BitIncrement&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void BitIncrement&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BitIncrement&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.BitIncrement``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BitIncrement(Of T As IFloatingPointIeee754(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member BitIncrement : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.BitIncrement (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void BitIncrement(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise bit increment of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.BitIncrement(<paramref name="x" />[i])</c>.
            Each element is incremented to the smallest value that compares greater than the original.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="BitwiseAnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void BitwiseAnd&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BitwiseAnd&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.BitwiseAnd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BitwiseAnd(Of T As IBitwiseOperators(Of T, T, T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member BitwiseAnd : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.BitwiseAnd (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static void BitwiseAnd(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise bitwise AND of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] &amp; <paramref name="y" />[i]</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="BitwiseAnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void BitwiseAnd&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BitwiseAnd&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.BitwiseAnd``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BitwiseAnd(Of T As IBitwiseOperators(Of T, T, T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member BitwiseAnd : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.BitwiseAnd (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static void BitwiseAnd(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise bitwise AND of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] &amp; <paramref name="y" /></c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="BitwiseOr&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void BitwiseOr&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BitwiseOr&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.BitwiseOr``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BitwiseOr(Of T As IBitwiseOperators(Of T, T, T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member BitwiseOr : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.BitwiseOr (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static void BitwiseOr(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise bitwise OR of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] | <paramref name="y" />[i]</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="BitwiseOr&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void BitwiseOr&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BitwiseOr&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.BitwiseOr``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BitwiseOr(Of T As IBitwiseOperators(Of T, T, T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member BitwiseOr : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.BitwiseOr (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static void BitwiseOr(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise bitwise OR of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] | <paramref name="y" /></c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cbrt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Cbrt&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Cbrt&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Cbrt``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Cbrt(Of T As IRootFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Cbrt : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Cbrt (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static void Cbrt(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise cube root of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Cbrt(<paramref name="x" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Ceiling&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Ceiling&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Ceiling&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Ceiling``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Ceiling(Of T As IFloatingPoint(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Ceiling : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Ceiling (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static void Ceiling(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise ceiling of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Ceiling(<paramref name="x" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clamp&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Clamp&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; min, ReadOnlySpan&lt;T&gt; max, Span&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clamp&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; min, valuetype System.ReadOnlySpan`1&lt;!!T&gt; max, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Clamp``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Clamp(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T), min As ReadOnlySpan(Of T), max As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Clamp : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Clamp (x, min, max, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static void Clamp(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; min, ReadOnlySpan&lt;T&gt; max, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="min" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="max" Type="System.ReadOnlySpan&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor of values to clamp, represented as a span.</param>
        <param name="min">The tensor of inclusive lower bounds, represented as a span.</param>
        <param name="max">The tensor of inclusive upper bounds, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>
            Computes the element-wise result of clamping <paramref name="x" /> to within the inclusive range specified
            by <paramref name="min" /> and <paramref name="max" /> for the specified tensors.
            </summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Clamp(<paramref name="x" />[i], <paramref name="min" />[i], <paramref name="max" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="max" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clamp&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Clamp&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; min, T max, Span&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clamp&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; min, !!T max, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Clamp``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Clamp(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T), min As ReadOnlySpan(Of T), max As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Clamp : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Clamp (x, min, max, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static void Clamp(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; min, T max, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="min" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="max" Type="T" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor of values to clamp, represented as a span.</param>
        <param name="min">The tensor of inclusive lower bounds, represented as a span.</param>
        <param name="max">The tensor of inclusive upper bounds, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>
            Computes the element-wise result of clamping <paramref name="x" /> to within the inclusive range specified
            by <paramref name="min" /> and <paramref name="max" /> for the specified tensors.
            </summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Clamp(<paramref name="x" />[i], <paramref name="min" />[i], <paramref name="max" />)</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="min" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clamp&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Clamp&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T min, ReadOnlySpan&lt;T&gt; max, Span&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clamp&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T min, valuetype System.ReadOnlySpan`1&lt;!!T&gt; max, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Clamp``1(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Clamp(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T), min As T, max As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Clamp : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * 'T * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Clamp (x, min, max, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static void Clamp(ReadOnlySpan&lt;T&gt; x, T min, ReadOnlySpan&lt;T&gt; max, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="min" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="max" Type="System.ReadOnlySpan&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor of values to clamp, represented as a span.</param>
        <param name="min">The tensor of inclusive lower bounds, represented as a scalar.</param>
        <param name="max">The tensor of inclusive upper bounds, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>
            Computes the element-wise result of clamping <paramref name="x" /> to within the inclusive range specified
            by <paramref name="min" /> and <paramref name="max" /> for the specified tensors.
            </summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Clamp(<paramref name="x" />[i], <paramref name="min" />, <paramref name="max" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="max" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clamp&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Clamp&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T min, T max, Span&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clamp&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T min, !!T max, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Clamp``1(System.ReadOnlySpan{``0},``0,``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Clamp(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T), min As T, max As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Clamp : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * 'T * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Clamp (x, min, max, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static void Clamp(ReadOnlySpan&lt;T&gt; x, T min, T max, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="min" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="max" Type="T" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor of values to clamp, represented as a span.</param>
        <param name="min">The tensor of inclusive lower bounds, represented as a scalar.</param>
        <param name="max">The tensor of inclusive upper bounds, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>
            Computes the element-wise result of clamping <paramref name="x" /> to within the inclusive range specified
            by <paramref name="min" /> and <paramref name="max" /> for the specified tensors.
            </summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Clamp(<paramref name="x" />[i], <paramref name="min" />, <paramref name="max" />)</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clamp&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Clamp&lt;T&gt; (T x, ReadOnlySpan&lt;T&gt; min, ReadOnlySpan&lt;T&gt; max, Span&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clamp&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(!!T x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; min, valuetype System.ReadOnlySpan`1&lt;!!T&gt; max, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Clamp``1(``0,System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Clamp(Of T As INumber(Of T)) (x As T, min As ReadOnlySpan(Of T), max As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Clamp : 'T * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Clamp (x, min, max, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static void Clamp(T x, ReadOnlySpan&lt;T&gt; min, ReadOnlySpan&lt;T&gt; max, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="min" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="max" Type="System.ReadOnlySpan&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor of values to clamp, represented as a scalar.</param>
        <param name="min">The tensor of inclusive lower bounds, represented as a span.</param>
        <param name="max">The tensor of inclusive upper bounds, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>
            Computes the element-wise result of clamping <paramref name="x" /> to within the inclusive range specified
            by <paramref name="min" /> and <paramref name="max" /> for the specified tensors.
            </summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Clamp(<paramref name="x" />, <paramref name="min" />[i], <paramref name="max" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="max" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clamp&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Clamp&lt;T&gt; (T x, ReadOnlySpan&lt;T&gt; min, T max, Span&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clamp&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(!!T x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; min, !!T max, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Clamp``1(``0,System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Clamp(Of T As INumber(Of T)) (x As T, min As ReadOnlySpan(Of T), max As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Clamp : 'T * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Clamp (x, min, max, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static void Clamp(T x, ReadOnlySpan&lt;T&gt; min, T max, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="min" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="max" Type="T" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor of values to clamp, represented as a scalar.</param>
        <param name="min">The tensor of inclusive lower bounds, represented as a span.</param>
        <param name="max">The tensor of inclusive upper bounds, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>
            Computes the element-wise result of clamping <paramref name="x" /> to within the inclusive range specified
            by <paramref name="min" /> and <paramref name="max" /> for the specified tensors.
            </summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Clamp(<paramref name="x" />, <paramref name="min" />[i], <paramref name="max" />)</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="min" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clamp&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Clamp&lt;T&gt; (T x, T min, ReadOnlySpan&lt;T&gt; max, Span&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clamp&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(!!T x, !!T min, valuetype System.ReadOnlySpan`1&lt;!!T&gt; max, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Clamp``1(``0,``0,System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Clamp(Of T As INumber(Of T)) (x As T, min As T, max As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Clamp : 'T * 'T * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Clamp (x, min, max, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static void Clamp(T x, T min, ReadOnlySpan&lt;T&gt; max, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="min" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="max" Type="System.ReadOnlySpan&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor of values to clamp, represented as a scalar.</param>
        <param name="min">The tensor of inclusive lower bounds, represented as a scalar.</param>
        <param name="max">The tensor of inclusive upper bounds, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>
            Computes the element-wise result of clamping <paramref name="x" /> to within the inclusive range specified
            by <paramref name="min" /> and <paramref name="max" /> for the specified tensors.
            </summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Clamp(<paramref name="x" />, <paramref name="min" />, <paramref name="max" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="max" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertChecked&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static void ConvertChecked&lt;TFrom,TTo&gt; (ReadOnlySpan&lt;TFrom&gt; source, Span&lt;TTo&gt; destination) where TFrom : System.Numerics.INumberBase&lt;TFrom&gt; where TTo : System.Numerics.INumberBase&lt;TTo&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConvertChecked&lt;(class System.Numerics.INumberBase`1&lt;!!TFrom&gt;) TFrom, (class System.Numerics.INumberBase`1&lt;!!TTo&gt;) TTo&gt;(valuetype System.ReadOnlySpan`1&lt;!!TFrom&gt; source, valuetype System.Span`1&lt;!!TTo&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ConvertChecked``2(System.ReadOnlySpan{``0},System.Span{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConvertChecked(Of TFrom As INumberBase(Of TFrom), TTo As INumberBase(Of TFrom)) (source As ReadOnlySpan(Of TFrom), destination As Span(Of TTo))" />
      <MemberSignature Language="F#" Value="static member ConvertChecked : ReadOnlySpan&lt;'From (requires 'From :&gt; System.Numerics.INumberBase&lt;'From&gt;)&gt; * Span&lt;'o (requires 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)&gt; -&gt; unit (requires 'From :&gt; System.Numerics.INumberBase&lt;'From&gt; and 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.ConvertChecked (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; where TFrom : System::Numerics::INumberBase&lt;TFrom&gt; where TTo : System::Numerics::INumberBase&lt;TTo&gt; static void ConvertChecked(ReadOnlySpan&lt;TFrom&gt; source, Span&lt;TTo&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TFrom&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TTo&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;TFrom&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;TTo&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TFrom">To be added.</typeparam>
        <typeparam name="TTo">To be added.</typeparam>
        <param name="source">The source span from which to copy values.</param>
        <param name="destination">The destination span into which the converted values should be written.</param>
        <summary>
            Copies <paramref name="source" /> to <paramref name="destination" />, converting each <typeparamref name="TFrom" />
            value to a <typeparamref name="TTo" /> value.
            </summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = TTo.CreateChecked(<paramref name="source" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Destination is too short.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertSaturating&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static void ConvertSaturating&lt;TFrom,TTo&gt; (ReadOnlySpan&lt;TFrom&gt; source, Span&lt;TTo&gt; destination) where TFrom : System.Numerics.INumberBase&lt;TFrom&gt; where TTo : System.Numerics.INumberBase&lt;TTo&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConvertSaturating&lt;(class System.Numerics.INumberBase`1&lt;!!TFrom&gt;) TFrom, (class System.Numerics.INumberBase`1&lt;!!TTo&gt;) TTo&gt;(valuetype System.ReadOnlySpan`1&lt;!!TFrom&gt; source, valuetype System.Span`1&lt;!!TTo&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ConvertSaturating``2(System.ReadOnlySpan{``0},System.Span{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConvertSaturating(Of TFrom As INumberBase(Of TFrom), TTo As INumberBase(Of TFrom)) (source As ReadOnlySpan(Of TFrom), destination As Span(Of TTo))" />
      <MemberSignature Language="F#" Value="static member ConvertSaturating : ReadOnlySpan&lt;'From (requires 'From :&gt; System.Numerics.INumberBase&lt;'From&gt;)&gt; * Span&lt;'o (requires 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)&gt; -&gt; unit (requires 'From :&gt; System.Numerics.INumberBase&lt;'From&gt; and 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.ConvertSaturating (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; where TFrom : System::Numerics::INumberBase&lt;TFrom&gt; where TTo : System::Numerics::INumberBase&lt;TTo&gt; static void ConvertSaturating(ReadOnlySpan&lt;TFrom&gt; source, Span&lt;TTo&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TFrom&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TTo&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;TFrom&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;TTo&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TFrom">To be added.</typeparam>
        <typeparam name="TTo">To be added.</typeparam>
        <param name="source">The source span from which to copy values.</param>
        <param name="destination">The destination span into which the converted values should be written.</param>
        <summary>
            Copies <paramref name="source" /> to <paramref name="destination" />, converting each <typeparamref name="TFrom" />
            value to a <typeparamref name="TTo" /> value.
            </summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = TTo.CreateSaturating(<paramref name="source" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Destination is too short.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertToHalf">
      <MemberSignature Language="C#" Value="public static void ConvertToHalf (ReadOnlySpan&lt;float&gt; source, Span&lt;Half&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConvertToHalf(valuetype System.ReadOnlySpan`1&lt;float32&gt; source, valuetype System.Span`1&lt;valuetype System.Half&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ConvertToHalf(System.ReadOnlySpan{System.Single},System.Span{System.Half})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConvertToHalf (source As ReadOnlySpan(Of Single), destination As Span(Of Half))" />
      <MemberSignature Language="F#" Value="static member ConvertToHalf : ReadOnlySpan&lt;single&gt; * Span&lt;Half&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.ConvertToHalf (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ConvertToHalf(ReadOnlySpan&lt;float&gt; source, Span&lt;Half&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Single&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;System.Half&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
      </Parameters>
      <Docs>
        <param name="source">The source span from which to copy values.</param>
        <param name="destination">The destination span into which the converted values should be written.</param>
        <summary>
            Copies <paramref name="source" /> to <paramref name="destination" />, converting each <see cref="T:System.Single" />
            value to its nearest representable half-precision floating-point value.
            </summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (Half)<paramref name="source" />[i]</c>.
            </para>
          <para>
            <paramref name="source" /> and <paramref name="destination" /> must not overlap. If they do, behavior is undefined.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Destination is too short.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertToInteger&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static void ConvertToInteger&lt;TFrom,TTo&gt; (ReadOnlySpan&lt;TFrom&gt; source, Span&lt;TTo&gt; destination) where TFrom : System.Numerics.IFloatingPoint&lt;TFrom&gt; where TTo : System.Numerics.IBinaryInteger&lt;TTo&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConvertToInteger&lt;(class System.Numerics.IFloatingPoint`1&lt;!!TFrom&gt;) TFrom, (class System.Numerics.IBinaryInteger`1&lt;!!TTo&gt;) TTo&gt;(valuetype System.ReadOnlySpan`1&lt;!!TFrom&gt; source, valuetype System.Span`1&lt;!!TTo&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ConvertToInteger``2(System.ReadOnlySpan{``0},System.Span{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConvertToInteger(Of TFrom As IFloatingPoint(Of TFrom), TTo As IFloatingPoint(Of TFrom)) (source As ReadOnlySpan(Of TFrom), destination As Span(Of TTo))" />
      <MemberSignature Language="F#" Value="static member ConvertToInteger : ReadOnlySpan&lt;'From (requires 'From :&gt; System.Numerics.IFloatingPoint&lt;'From&gt;)&gt; * Span&lt;'o (requires 'o :&gt; System.Numerics.IBinaryInteger&lt;'o&gt;)&gt; -&gt; unit (requires 'From :&gt; System.Numerics.IFloatingPoint&lt;'From&gt; and 'o :&gt; System.Numerics.IBinaryInteger&lt;'o&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.ConvertToInteger (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; where TFrom : System::Numerics::IFloatingPoint&lt;TFrom&gt; where TTo : System::Numerics::IBinaryInteger&lt;TTo&gt; static void ConvertToInteger(ReadOnlySpan&lt;TFrom&gt; source, Span&lt;TTo&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;TFrom&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;TTo&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;TFrom&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;TTo&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TFrom">To be added.</typeparam>
        <typeparam name="TTo">To be added.</typeparam>
        <param name="source">The source span from which to copy values.</param>
        <param name="destination">The destination span into which the converted values should be written.</param>
        <summary>
            Copies <paramref name="source" /> to <paramref name="destination" />, converting each <typeparamref name="TFrom" />
            value to a <typeparamref name="TTo" /> integer type using saturation on overflow.
            </summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = TTo.ConvertToInteger(<paramref name="source" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Destination is too short.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertToIntegerNative&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static void ConvertToIntegerNative&lt;TFrom,TTo&gt; (ReadOnlySpan&lt;TFrom&gt; source, Span&lt;TTo&gt; destination) where TFrom : System.Numerics.IFloatingPoint&lt;TFrom&gt; where TTo : System.Numerics.IBinaryInteger&lt;TTo&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConvertToIntegerNative&lt;(class System.Numerics.IFloatingPoint`1&lt;!!TFrom&gt;) TFrom, (class System.Numerics.IBinaryInteger`1&lt;!!TTo&gt;) TTo&gt;(valuetype System.ReadOnlySpan`1&lt;!!TFrom&gt; source, valuetype System.Span`1&lt;!!TTo&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ConvertToIntegerNative``2(System.ReadOnlySpan{``0},System.Span{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConvertToIntegerNative(Of TFrom As IFloatingPoint(Of TFrom), TTo As IFloatingPoint(Of TFrom)) (source As ReadOnlySpan(Of TFrom), destination As Span(Of TTo))" />
      <MemberSignature Language="F#" Value="static member ConvertToIntegerNative : ReadOnlySpan&lt;'From (requires 'From :&gt; System.Numerics.IFloatingPoint&lt;'From&gt;)&gt; * Span&lt;'o (requires 'o :&gt; System.Numerics.IBinaryInteger&lt;'o&gt;)&gt; -&gt; unit (requires 'From :&gt; System.Numerics.IFloatingPoint&lt;'From&gt; and 'o :&gt; System.Numerics.IBinaryInteger&lt;'o&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.ConvertToIntegerNative (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; where TFrom : System::Numerics::IFloatingPoint&lt;TFrom&gt; where TTo : System::Numerics::IBinaryInteger&lt;TTo&gt; static void ConvertToIntegerNative(ReadOnlySpan&lt;TFrom&gt; source, Span&lt;TTo&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;TFrom&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;TTo&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;TFrom&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;TTo&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TFrom">To be added.</typeparam>
        <typeparam name="TTo">To be added.</typeparam>
        <param name="source">The source span from which to copy values.</param>
        <param name="destination">The destination span into which the converted values should be written.</param>
        <summary>
            Copies <paramref name="source" /> to <paramref name="destination" />, converting each <typeparamref name="TFrom" />
            value to a <typeparamref name="TTo" /> integer type using platform-specific behavior on overflow.
            </summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = TTo.ConvertToInteger(<paramref name="source" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Destination is too short.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertToSingle">
      <MemberSignature Language="C#" Value="public static void ConvertToSingle (ReadOnlySpan&lt;Half&gt; source, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConvertToSingle(valuetype System.ReadOnlySpan`1&lt;valuetype System.Half&gt; source, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ConvertToSingle(System.ReadOnlySpan{System.Half},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConvertToSingle (source As ReadOnlySpan(Of Half), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member ConvertToSingle : ReadOnlySpan&lt;Half&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.ConvertToSingle (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ConvertToSingle(ReadOnlySpan&lt;Half&gt; source, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Half&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
      </Parameters>
      <Docs>
        <param name="source">The source span from which to copy values.</param>
        <param name="destination">The destination span into which the converted values should be written.</param>
        <summary>
            Copies <paramref name="source" /> to <paramref name="destination" />, converting each half-precision
            floating-point value to its nearest representable <see cref="T:System.Single" /> value.
            </summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (float)<paramref name="source" />[i]</c>.
            </para>
          <para>
            <paramref name="source" /> and <paramref name="destination" /> must not overlap. If they do, behavior is undefined.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Destination is too short.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertTruncating&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static void ConvertTruncating&lt;TFrom,TTo&gt; (ReadOnlySpan&lt;TFrom&gt; source, Span&lt;TTo&gt; destination) where TFrom : System.Numerics.INumberBase&lt;TFrom&gt; where TTo : System.Numerics.INumberBase&lt;TTo&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConvertTruncating&lt;(class System.Numerics.INumberBase`1&lt;!!TFrom&gt;) TFrom, (class System.Numerics.INumberBase`1&lt;!!TTo&gt;) TTo&gt;(valuetype System.ReadOnlySpan`1&lt;!!TFrom&gt; source, valuetype System.Span`1&lt;!!TTo&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ConvertTruncating``2(System.ReadOnlySpan{``0},System.Span{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConvertTruncating(Of TFrom As INumberBase(Of TFrom), TTo As INumberBase(Of TFrom)) (source As ReadOnlySpan(Of TFrom), destination As Span(Of TTo))" />
      <MemberSignature Language="F#" Value="static member ConvertTruncating : ReadOnlySpan&lt;'From (requires 'From :&gt; System.Numerics.INumberBase&lt;'From&gt;)&gt; * Span&lt;'o (requires 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)&gt; -&gt; unit (requires 'From :&gt; System.Numerics.INumberBase&lt;'From&gt; and 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.ConvertTruncating (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; where TFrom : System::Numerics::INumberBase&lt;TFrom&gt; where TTo : System::Numerics::INumberBase&lt;TTo&gt; static void ConvertTruncating(ReadOnlySpan&lt;TFrom&gt; source, Span&lt;TTo&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TFrom&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TTo&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;TFrom&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;TTo&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TFrom">To be added.</typeparam>
        <typeparam name="TTo">To be added.</typeparam>
        <param name="source">The source span from which to copy values.</param>
        <param name="destination">The destination span into which the converted values should be written.</param>
        <summary>
            Copies <paramref name="source" /> to <paramref name="destination" />, converting each <typeparamref name="TFrom" />
            value to a <typeparamref name="TTo" /> value.
            </summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = TTo.CreateTruncating(<paramref name="source" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Destination is too short.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopySign&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void CopySign&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; sign, Span&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopySign&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; sign, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.CopySign``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopySign(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T), sign As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member CopySign : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.CopySign (x, sign, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static void CopySign(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; sign, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="sign" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="sign">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of copying the sign from one number to another number in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.CopySign(<paramref name="x" />[i], <paramref name="sign" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="sign" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopySign&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void CopySign&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T sign, Span&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopySign&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T sign, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.CopySign``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopySign(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T), sign As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member CopySign : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.CopySign (x, sign, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static void CopySign(ReadOnlySpan&lt;T&gt; x, T sign, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="sign" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="sign">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of copying the sign from one number to another number in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.CopySign(<paramref name="x" />[i], <paramref name="sign" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cos&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Cos&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Cos&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Cos``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Cos(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Cos : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Cos (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void Cos(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise cosine of the value in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Cos(<paramref name="x" />[i])</c>.
            </para>
          <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians(System.Single)" /> or multiply by <typeparamref name="T" />.Pi/180 to convert degrees to radians.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static void Cosh (ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Cosh(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Cosh(System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Cosh (x As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Cosh : ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Cosh (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Cosh(ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise hyperbolic cosine of each single-precision floating-point radian angle in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <see cref="T:System.MathF" />.Cosh(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value is equal to <see cref="F:System.Single.NegativeInfinity" /> or <see cref="F:System.Single.PositiveInfinity" />, the result stored into the corresponding destination location is set to <see cref="F:System.Single.PositiveInfinity" />.
            If a value is equal to <see cref="F:System.Single.NaN" />, the result stored into the corresponding destination location is also NaN.
            </para>
          <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians(System.Single)" /> or multiply by <see cref="F:System.MathF.PI" />/180 to convert degrees to radians.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cosh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Cosh&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Cosh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Cosh``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Cosh(Of T As IHyperbolicFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Cosh : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Cosh (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static void Cosh(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise hyperbolic cosine of each radian angle in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Cosh(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity" /> or <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity" />, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity" />.
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the result stored into the corresponding destination location is also NaN.
            </para>
          <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians(System.Single)" /> or multiply by <typeparamref name="T" />.Pi/180 to convert degrees to radians.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="CosineSimilarity">
      <MemberSignature Language="C#" Value="public static float CosineSimilarity (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 CosineSimilarity(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.CosineSimilarity(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CosineSimilarity (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single)) As Single" />
      <MemberSignature Language="F#" Value="static member CosineSimilarity : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; -&gt; single" Usage="System.Numerics.Tensors.TensorPrimitives.CosineSimilarity (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float CosineSimilarity(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the cosine similarity between the two specified non-empty, equal-length tensors of single-precision floating-point numbers.</summary>
        <returns>The cosine similarity of the two tensors.</returns>
        <remarks>
          <para>
            This method effectively computes <c>TensorPrimitives.Dot(x, y) / (MathF.Sqrt(TensorPrimitives.SumOfSquares(x)) * MathF.Sqrt(TensorPrimitives.SumOfSquares(y)).</c></para>
          <para>
            If any element in either input tensor is equal to <see cref="F:System.Single.NegativeInfinity" />, <see cref="F:System.Single.PositiveInfinity" />, or <see cref="F:System.Single.NaN" />,
            NaN is returned.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="y" /> must not be empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="CosineSimilarity&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CosineSimilarity&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CosineSimilarity&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.CosineSimilarity``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CosineSimilarity(Of T As IRootFunctions(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member CosineSimilarity : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.CosineSimilarity (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static T CosineSimilarity(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the cosine similarity between the two specified non-empty, equal-length tensors of numbers.</summary>
        <returns>The cosine similarity of the two tensors.</returns>
        <remarks>
          <para>
            This method effectively computes <c>TensorPrimitives.Dot(x, y) / (<typeparamref name="T" />.Sqrt(TensorPrimitives.SumOfSquares(x)) * <typeparamref name="T" />.Sqrt(TensorPrimitives.SumOfSquares(y)).</c></para>
          <para>
            If any element in either input tensor is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity" />, <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity" />, or <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />,
            NaN is returned.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="y" /> must not be empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="CosPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void CosPi&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CosPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.CosPi``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CosPi(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member CosPi : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.CosPi (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void CosPi(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise cosine of the value in the specified tensor that has been multiplied by Pi.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.CosPi(<paramref name="x" />[i])</c>.
            </para>
          <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians(System.Single)" /> or multiply by <typeparamref name="T" />.Pi/180 to convert degrees to radians.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Decrement&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Decrement&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IDecrementOperators&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Decrement&lt;(class System.Numerics.IDecrementOperators`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Decrement``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Decrement(Of T As IDecrementOperators(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Decrement : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IDecrementOperators&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IDecrementOperators&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IDecrementOperators&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Decrement (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IDecrementOperators&lt;T&gt; static void Decrement(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IDecrementOperators&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise decrement of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] - 1</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="DegreesToRadians&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void DegreesToRadians&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DegreesToRadians&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.DegreesToRadians``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DegreesToRadians(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member DegreesToRadians : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.DegreesToRadians (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void DegreesToRadians(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise conversion of each number of degrees in the specified tensor to radians.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.DegreesToRadians(<paramref name="x" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Distance">
      <MemberSignature Language="C#" Value="public static float Distance (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Distance(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Distance(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Distance (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single)) As Single" />
      <MemberSignature Language="F#" Value="static member Distance : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; -&gt; single" Usage="System.Numerics.Tensors.TensorPrimitives.Distance (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Distance(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the distance between two points, specified as non-empty, equal-length tensors of single-precision floating-point numbers, in Euclidean space.</summary>
        <returns>The Euclidean distance.</returns>
        <remarks>
          <para>
            This method effectively computes the equivalent of:
            <c>
                Span&lt;float&gt; difference = ...;
                TensorPrimitives.Subtract(x, y, difference);
                float result = MathF.Sqrt(TensorPrimitives.SumOfSquares(difference));
            </c>
            but without requiring additional temporary storage for the intermediate differences.
            </para>
          <para>
            If any element in either input tensor is equal to <see cref="F:System.Single.NaN" />, NaN is returned.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="y" /> must not be empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Distance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Distance&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Distance&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Distance``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Distance(Of T As IRootFunctions(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Distance : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Distance (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static T Distance(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the distance between two points, specified as non-empty, equal-length tensors of numbers, in Euclidean space.</summary>
        <returns>The Euclidean distance.</returns>
        <remarks>
          <para>
            This method effectively computes the equivalent of:
            <c>
                Span&lt;T&gt; difference = ...;
                TensorPrimitives.Subtract(x, y, difference);
                T result = <typeparamref name="T" />.Sqrt(TensorPrimitives.SumOfSquares(difference));
            </c>
            but without requiring additional temporary storage for the intermediate differences.
            </para>
          <para>
            If any element in either input tensor is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, NaN is returned.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="y" /> must not be empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static void Divide (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Divide(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Divide(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Divide (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Divide : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Divide (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Divide(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise division of single-precision floating-point numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] / <paramref name="y" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static void Divide (ReadOnlySpan&lt;float&gt; x, float y, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Divide(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, float32 y, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Divide(System.ReadOnlySpan{System.Single},System.Single,System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Divide (x As ReadOnlySpan(Of Single), y As Single, destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Divide : ReadOnlySpan&lt;single&gt; * single * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Divide (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Divide(ReadOnlySpan&lt;float&gt; x, float y, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise division of single-precision floating-point numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] / <paramref name="y" /></c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Divide&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Divide&lt;(class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Divide``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Divide(Of T As IDivisionOperators(Of T, T, T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Divide : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Divide (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IDivisionOperators&lt;T, T, T&gt; static void Divide(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise division of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] / <paramref name="y" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
        <exception cref="T:System.DivideByZeroException">
          <typeparamref name="T" /> is an integer type and an element in <paramref name="y" /> is equal to zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Divide&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Divide&lt;(class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Divide``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Divide(Of T As IDivisionOperators(Of T, T, T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Divide : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Divide (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IDivisionOperators&lt;T, T, T&gt; static void Divide(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise division of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] / <paramref name="y" /></c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
        <exception cref="T:System.DivideByZeroException">
          <typeparamref name="T" /> is an integer type and <paramref name="y" /> is equal to zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Divide&lt;T&gt; (T x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Divide&lt;(class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(!!T x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Divide``1(``0,System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Divide(Of T As IDivisionOperators(Of T, T, T)) (x As T, y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Divide : 'T * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Divide (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IDivisionOperators&lt;T, T, T&gt; static void Divide(T x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a scalar.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise division of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" /> / <paramref name="y" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
        <exception cref="T:System.DivideByZeroException">
          <typeparamref name="T" /> is an integer type and an element in <paramref name="y" /> is equal to zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="DivRem&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void DivRem&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; quotientDestination, Span&lt;T&gt; remainderDestination) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DivRem&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; quotientDestination, valuetype System.Span`1&lt;!!T&gt; remainderDestination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.DivRem``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DivRem(Of T As IBinaryInteger(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), quotientDestination As Span(Of T), remainderDestination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member DivRem : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.DivRem (x, y, quotientDestination, remainderDestination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static void DivRem(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; quotientDestination, Span&lt;T&gt; remainderDestination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="quotientDestination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="remainderDestination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="quotientDestination">The quotient destination tensor, represented as a span.</param>
        <param name="remainderDestination">The remainder destination tensor, represented as a span.</param>
        <summary>Computes the element-wise quotient and remainder of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c>(<paramref name="quotientDestination" />[i], <paramref name="remainderDestination" />[i]) = T.DivRem(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise values are also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> or <paramref name="y" /> and <paramref name="remainderDestination" /> reference overlapping memory locations and do not begin at the same location.</exception>
        <exception cref="T:System.DivideByZeroException">
          <typeparamref name="T" /> is an integer type and an element in <paramref name="y" /> is equal to zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="DivRem&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void DivRem&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; quotientDestination, Span&lt;T&gt; remainderDestination) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DivRem&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; quotientDestination, valuetype System.Span`1&lt;!!T&gt; remainderDestination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.DivRem``1(System.ReadOnlySpan{``0},``0,System.Span{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DivRem(Of T As IBinaryInteger(Of T)) (x As ReadOnlySpan(Of T), y As T, quotientDestination As Span(Of T), remainderDestination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member DivRem : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.DivRem (x, y, quotientDestination, remainderDestination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static void DivRem(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; quotientDestination, Span&lt;T&gt; remainderDestination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="quotientDestination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="remainderDestination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="quotientDestination">The quotient destination tensor, represented as a span.</param>
        <param name="remainderDestination">The remainder destination tensor, represented as a span.</param>
        <summary>Computes the element-wise quotient and remainder of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c>(<paramref name="quotientDestination" />[i], <paramref name="remainderDestination" />[i]) = T.DivRem(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise values are also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="remainderDestination" /> reference overlapping memory locations and do not begin at the same location.</exception>
        <exception cref="T:System.DivideByZeroException">
          <typeparamref name="T" /> is an integer type and <paramref name="y" /> is equal to zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="DivRem&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void DivRem&lt;T&gt; (T x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; quotientDestination, Span&lt;T&gt; remainderDestination) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DivRem&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;(!!T x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; quotientDestination, valuetype System.Span`1&lt;!!T&gt; remainderDestination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.DivRem``1(``0,System.ReadOnlySpan{``0},System.Span{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DivRem(Of T As IBinaryInteger(Of T)) (x As T, y As ReadOnlySpan(Of T), quotientDestination As Span(Of T), remainderDestination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member DivRem : 'T * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.DivRem (x, y, quotientDestination, remainderDestination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static void DivRem(T x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; quotientDestination, Span&lt;T&gt; remainderDestination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="quotientDestination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="remainderDestination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a scalar.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="quotientDestination">The quotient destination tensor, represented as a span.</param>
        <param name="remainderDestination">The remainder destination tensor, represented as a span.</param>
        <summary>Computes the element-wise quotient and remainder of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c>(<paramref name="quotientDestination" />[i], <paramref name="remainderDestination" />[i]) = T.DivRem(<paramref name="x" />, <paramref name="y" />[i])</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise values are also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="remainderDestination" /> reference overlapping memory locations and do not begin at the same location.</exception>
        <exception cref="T:System.DivideByZeroException">
          <typeparamref name="T" /> is an integer type and an element in <paramref name="y" /> is equal to zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dot">
      <MemberSignature Language="C#" Value="public static float Dot (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Dot(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Dot(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dot (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single)) As Single" />
      <MemberSignature Language="F#" Value="static member Dot : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; -&gt; single" Usage="System.Numerics.Tensors.TensorPrimitives.Dot (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Dot(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the dot product of two tensors containing single-precision floating-point numbers.</summary>
        <returns>The dot product.</returns>
        <remarks>
          <para>
            This method effectively computes the equivalent of:
            <c>
                Span&lt;float&gt; products = ...;
                TensorPrimitives.Multiply(x, y, products);
                float result = TensorPrimitives.Sum(products);
            </c>
            but without requiring additional temporary storage for the intermediate products. It corresponds to the <c>dot</c> method defined by <c>BLAS1</c>.
            </para>
          <para>
            If any of the input elements is equal to <see cref="F:System.Single.NaN" />, the resulting value is also NaN.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dot&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Dot&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Dot&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Dot``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dot(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T), IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Dot : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Dot (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static T Dot(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the dot product of two tensors containing numbers.</summary>
        <returns>The dot product.</returns>
        <remarks>
          <para>
            This method effectively computes the equivalent of:
            <c>
                Span&lt;T&gt; products = ...;
                TensorPrimitives.Multiply(x, y, products);
                T result = TensorPrimitives.Sum(products);
            </c>
            but without requiring additional temporary storage for the intermediate products. It corresponds to the <c>dot</c> method defined by <c>BLAS1</c>.
            </para>
          <para>
            If any of the input elements is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting value is also NaN.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static void Exp (ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exp(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Exp(System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exp (x As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Exp : ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Exp (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exp(ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of raising <c>e</c> to the single-precision floating-point number powers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <see cref="T:System.MathF" />.Exp(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value equals <see cref="F:System.Single.NaN" /> or <see cref="F:System.Single.PositiveInfinity" />, the result stored into the corresponding destination location is set to NaN.
            If a value equals <see cref="F:System.Single.NegativeInfinity" />, the result stored into the corresponding destination location is set to 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exp&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Exp&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exp&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Exp``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exp(Of T As IExponentialFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Exp : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Exp (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static void Exp(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of raising <c>e</c> to the number powers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Exp(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value equals <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" /> or <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity" />, the result stored into the corresponding destination location is set to NaN.
            If a value equals <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity" />, the result stored into the corresponding destination location is set to 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exp10&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Exp10&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exp10&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Exp10``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exp10(Of T As IExponentialFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Exp10 : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Exp10 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static void Exp10(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of raising 10 to the number powers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Exp10(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exp10M1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Exp10M1&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exp10M1&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Exp10M1``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exp10M1(Of T As IExponentialFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Exp10M1 : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Exp10M1 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static void Exp10M1(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of raising 10 to the number powers in the specified tensor, minus one.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Exp10M1(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exp2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Exp2&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exp2&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Exp2``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exp2(Of T As IExponentialFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Exp2 : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Exp2 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static void Exp2(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of raising 2 to the number powers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Exp2(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exp2M1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Exp2M1&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exp2M1&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Exp2M1``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exp2M1(Of T As IExponentialFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Exp2M1 : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Exp2M1 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static void Exp2M1(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of raising 2 to the number powers in the specified tensor, minus one.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Exp2M1(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExpM1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ExpM1&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExpM1&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ExpM1``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExpM1(Of T As IExponentialFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member ExpM1 : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.ExpM1 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static void ExpM1(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of raising <c>e</c> to the number powers in the specified tensor, minus 1.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.ExpM1(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Floor&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Floor&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Floor&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Floor``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Floor(Of T As IFloatingPoint(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Floor : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Floor (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static void Floor(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise floor of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Floor(<paramref name="x" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="FusedMultiplyAdd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void FusedMultiplyAdd&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, ReadOnlySpan&lt;T&gt; addend, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FusedMultiplyAdd&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.ReadOnlySpan`1&lt;!!T&gt; addend, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FusedMultiplyAdd(Of T As IFloatingPointIeee754(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), addend As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member FusedMultiplyAdd : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAdd (x, y, addend, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void FusedMultiplyAdd(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, ReadOnlySpan&lt;T&gt; addend, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="addend" Type="System.ReadOnlySpan&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="addend">The third tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
          <para>
            This computes (<paramref name="x" /> * <paramref name="y" />) as if to infinite precision, adds <paramref name="addend" /> to that result as if to
            infinite precision, and finally rounds to the nearest representable value. This differs from the non-fused sequence which would compute
            (<paramref name="x" /> * <paramref name="y" />) as if to infinite precision, round the result to the nearest representable value, add <paramref name="addend" /> to the
            rounded result as if to infinite precision, and finally round to the nearest representable value.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="addend" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="FusedMultiplyAdd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void FusedMultiplyAdd&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, T addend, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FusedMultiplyAdd&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, !!T addend, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FusedMultiplyAdd(Of T As IFloatingPointIeee754(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), addend As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member FusedMultiplyAdd : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAdd (x, y, addend, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void FusedMultiplyAdd(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, T addend, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="addend" Type="T" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="addend">The third tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" /></c>.
            It corresponds to the <c>axpy</c> method defined by <c>BLAS1</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
          <para>
            This computes (<paramref name="x" /> * <paramref name="y" />) as if to infinite precision, adds <paramref name="addend" /> to that result as if to
            infinite precision, and finally rounds to the nearest representable value. This differs from the non-fused sequence which would compute
            (<paramref name="x" /> * <paramref name="y" />) as if to infinite precision, round the result to the nearest representable value, add <paramref name="addend" /> to the
            rounded result as if to infinite precision, and finally round to the nearest representable value.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="FusedMultiplyAdd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void FusedMultiplyAdd&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, ReadOnlySpan&lt;T&gt; addend, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FusedMultiplyAdd&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.ReadOnlySpan`1&lt;!!T&gt; addend, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAdd``1(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FusedMultiplyAdd(Of T As IFloatingPointIeee754(Of T)) (x As ReadOnlySpan(Of T), y As T, addend As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member FusedMultiplyAdd : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * 'T * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAdd (x, y, addend, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void FusedMultiplyAdd(ReadOnlySpan&lt;T&gt; x, T y, ReadOnlySpan&lt;T&gt; addend, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="addend" Type="System.ReadOnlySpan&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="addend">The third tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />) + <paramref name="addend" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
          <para>
            This computes (<paramref name="x" /> * <paramref name="y" />) as if to infinite precision, adds <paramref name="addend" /> to that result as if to
            infinite precision, and finally rounds to the nearest representable value. This differs from the non-fused sequence which would compute
            (<paramref name="x" /> * <paramref name="y" />) as if to infinite precision, round the result to the nearest representable value, add <paramref name="addend" /> to the
            rounded result as if to infinite precision, and finally round to the nearest representable value.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="addend" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="HammingBitDistance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static long HammingBitDistance&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 HammingBitDistance&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.HammingBitDistance``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HammingBitDistance(Of T As IBinaryInteger(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T)) As Long" />
      <MemberSignature Language="F#" Value="static member HammingBitDistance : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; -&gt; int64 (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.HammingBitDistance (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static long HammingBitDistance(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the bitwise Hamming distance between two equal-length tensors of values.</summary>
        <returns>The number of bits that differ between the two spans.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="y" /> must not be empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="HammingDistance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int HammingDistance&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 HammingDistance&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.HammingDistance``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HammingDistance(Of T) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member HammingDistance : ReadOnlySpan&lt;'T&gt; * ReadOnlySpan&lt;'T&gt; -&gt; int" Usage="System.Numerics.Tensors.TensorPrimitives.HammingDistance (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int HammingDistance(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the Hamming distance between two equal-length tensors of values.</summary>
        <returns>The number of elements that differ between the two spans.</returns>
        <remarks>
          <para>
            This method computes the number of locations <c>i</c> where <c>!EqualityComparer&gt;T&lt;.Default.Equal(x[i], y[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="y" /> must not be empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Hypot&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Hypot&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Hypot&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Hypot``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Hypot(Of T As IRootFunctions(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Hypot : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Hypot (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static void Hypot(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise hypotenuse given values from two tensors representing the lengths of the shorter sides in a right-angled triangle.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Hypot(<paramref name="x" />[i], <paramref name="x" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Ieee754Remainder&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Ieee754Remainder&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Ieee754Remainder&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Ieee754Remainder``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Ieee754Remainder(Of T As IFloatingPointIeee754(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Ieee754Remainder : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Ieee754Remainder (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void Ieee754Remainder(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise remainder of the numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Ieee754Remainder(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Ieee754Remainder&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Ieee754Remainder&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Ieee754Remainder&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Ieee754Remainder``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Ieee754Remainder(Of T As IFloatingPointIeee754(Of T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Ieee754Remainder : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Ieee754Remainder (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void Ieee754Remainder(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise remainder of the numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Ieee754Remainder(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Ieee754Remainder&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Ieee754Remainder&lt;T&gt; (T x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Ieee754Remainder&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(!!T x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Ieee754Remainder``1(``0,System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Ieee754Remainder(Of T As IFloatingPointIeee754(Of T)) (x As T, y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Ieee754Remainder : 'T * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Ieee754Remainder (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void Ieee754Remainder(T x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a scalar.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise remainder of the numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Ieee754Remainder(<paramref name="x" />, <paramref name="y" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="ILogB&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ILogB&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;int&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ILogB&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;int32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ILogB``1(System.ReadOnlySpan{``0},System.Span{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ILogB(Of T As IFloatingPointIeee754(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of Integer))" />
      <MemberSignature Language="F#" Value="static member ILogB : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * Span&lt;int&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.ILogB (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void ILogB(ReadOnlySpan&lt;T&gt; x, Span&lt;int&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;System.Int32&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise integer logarithm of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.ILogB(<paramref name="x" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Increment&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Increment&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IIncrementOperators&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Increment&lt;(class System.Numerics.IIncrementOperators`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Increment``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Increment(Of T As IIncrementOperators(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Increment : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IIncrementOperators&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IIncrementOperators&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IIncrementOperators&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Increment (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IIncrementOperators&lt;T&gt; static void Increment(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IIncrementOperators&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise increment of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] + 1</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMax">
      <MemberSignature Language="C#" Value="public static int IndexOfMax (ReadOnlySpan&lt;float&gt; x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMax(valuetype System.ReadOnlySpan`1&lt;float32&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMax(System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOfMax (x As ReadOnlySpan(Of Single)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMax : ReadOnlySpan&lt;single&gt; -&gt; int" Usage="System.Numerics.Tensors.TensorPrimitives.IndexOfMax x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOfMax(ReadOnlySpan&lt;float&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the index of the largest single-precision floating-point number in the specified tensor.</summary>
        <returns>The index of the maximum element in <paramref name="x" />, or -1 if <paramref name="x" /> is empty.</returns>
        <remarks>
          <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If any value equal to <see cref="F:System.Single.NaN" />
            is present, the index of the first is returned. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMax&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfMax&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMax&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMax``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOfMax(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMax : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IndexOfMax x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static int IndexOfMax(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the index of the largest number in the specified tensor.</summary>
        <returns>The index of the maximum element in <paramref name="x" />, or -1 if <paramref name="x" /> is empty.</returns>
        <remarks>
          <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If any value equal to NaN
            is present, the index of the first is returned. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMaxMagnitude">
      <MemberSignature Language="C#" Value="public static int IndexOfMaxMagnitude (ReadOnlySpan&lt;float&gt; x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMaxMagnitude(valuetype System.ReadOnlySpan`1&lt;float32&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMaxMagnitude(System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOfMaxMagnitude (x As ReadOnlySpan(Of Single)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMaxMagnitude : ReadOnlySpan&lt;single&gt; -&gt; int" Usage="System.Numerics.Tensors.TensorPrimitives.IndexOfMaxMagnitude x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOfMaxMagnitude(ReadOnlySpan&lt;float&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the index of the single-precision floating-point number with the largest magnitude in the specified tensor.</summary>
        <returns>The index of the element in <paramref name="x" /> with the largest magnitude (absolute value), or -1 if <paramref name="x" /> is empty.</returns>
        <remarks>
          <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `maximumMagnitude` function. If any value equal to <see cref="F:System.Single.NaN" />
            is present, the index of the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the positive value is considered to have the larger magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMaxMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfMaxMagnitude&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMaxMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMaxMagnitude``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOfMaxMagnitude(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMaxMagnitude : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IndexOfMaxMagnitude x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static int IndexOfMaxMagnitude(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the index of the number with the largest magnitude in the specified tensor.</summary>
        <returns>The index of the element in <paramref name="x" /> with the largest magnitude (absolute value), or -1 if <paramref name="x" /> is empty.</returns>
        <remarks>
          <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `maximumMagnitude` function. If any value equal to NaN
            is present, the index of the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the positive value is considered to have the larger magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMin">
      <MemberSignature Language="C#" Value="public static int IndexOfMin (ReadOnlySpan&lt;float&gt; x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMin(valuetype System.ReadOnlySpan`1&lt;float32&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMin(System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOfMin (x As ReadOnlySpan(Of Single)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMin : ReadOnlySpan&lt;single&gt; -&gt; int" Usage="System.Numerics.Tensors.TensorPrimitives.IndexOfMin x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOfMin(ReadOnlySpan&lt;float&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the index of the smallest single-precision floating-point number in the specified tensor.</summary>
        <returns>The index of the minimum element in <paramref name="x" />, or -1 if <paramref name="x" /> is empty.</returns>
        <remarks>
          <para>
            The determination of the minimum element matches the IEEE 754:2019 `minimum` function. If any value equal to <see cref="F:System.Single.NaN" />
            is present, the index of the first is returned. Negative 0 is considered smaller than positive 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfMin&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMin&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMin``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOfMin(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMin : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IndexOfMin x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static int IndexOfMin(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the index of the smallest number in the specified tensor.</summary>
        <returns>The index of the minimum element in <paramref name="x" />, or -1 if <paramref name="x" /> is empty.</returns>
        <remarks>
          <para>
            The determination of the minimum element matches the IEEE 754:2019 `minimum` function. If any value equal to NaN
            is present, the index of the first is returned. Negative 0 is considered smaller than positive 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMinMagnitude">
      <MemberSignature Language="C#" Value="public static int IndexOfMinMagnitude (ReadOnlySpan&lt;float&gt; x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMinMagnitude(valuetype System.ReadOnlySpan`1&lt;float32&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMinMagnitude(System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOfMinMagnitude (x As ReadOnlySpan(Of Single)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMinMagnitude : ReadOnlySpan&lt;single&gt; -&gt; int" Usage="System.Numerics.Tensors.TensorPrimitives.IndexOfMinMagnitude x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOfMinMagnitude(ReadOnlySpan&lt;float&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the index of the single-precision floating-point number with the smallest magnitude in the specified tensor.</summary>
        <returns>The index of the element in <paramref name="x" /> with the smallest magnitude (absolute value), or -1 if <paramref name="x" /> is empty.</returns>
        <remarks>
          <para>
            The determination of the minimum magnitude matches the IEEE 754:2019 `minimumMagnitude` function. If any value equal to <see cref="F:System.Single.NaN" />
            is present, the index of the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMinMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfMinMagnitude&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMinMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMinMagnitude``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOfMinMagnitude(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMinMagnitude : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IndexOfMinMagnitude x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static int IndexOfMinMagnitude(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the index of the number with the smallest magnitude in the specified tensor.</summary>
        <returns>The index of the element in <paramref name="x" /> with the smallest magnitude (absolute value), or -1 if <paramref name="x" /> is empty.</returns>
        <remarks>
          <para>
            The determination of the minimum magnitude matches the IEEE 754:2019 `minimumMagnitude` function. If any value equal to NaN
            is present, the index of the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCanonical&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void IsCanonical&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void IsCanonical&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;bool&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsCanonical``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub IsCanonical(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of Boolean))" />
      <MemberSignature Language="F#" Value="static member IsCanonical : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;bool&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsCanonical (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void IsCanonical(ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;System.Boolean&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes for each value in the specified tensor whether it's in its canonical representation.</summary>
        <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.IsCanonical(<paramref name="x" />[i])</c>.
            </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsCanonicalAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsCanonicalAll&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsCanonicalAll&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsCanonicalAll``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsCanonicalAll(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsCanonicalAll : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsCanonicalAll x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsCanonicalAll(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether all of the values in the specified tensor are in their canonical representations.</summary>
        <returns>
          <see langword="true" /> if all of the values in <paramref name="x" /> are in their canonical representations; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCanonicalAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsCanonicalAny&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsCanonicalAny&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsCanonicalAny``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsCanonicalAny(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsCanonicalAny : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsCanonicalAny x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsCanonicalAny(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether any of the values in the specified tensor is in its canonical representation.</summary>
        <returns>
          <see langword="true" /> if any of the values in <paramref name="x" /> is in its canonical representation; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsComplexNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void IsComplexNumber&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void IsComplexNumber&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;bool&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsComplexNumber``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub IsComplexNumber(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of Boolean))" />
      <MemberSignature Language="F#" Value="static member IsComplexNumber : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;bool&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsComplexNumber (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void IsComplexNumber(ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;System.Boolean&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes for each value in the specified tensor whether it's a complex number.</summary>
        <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.IsComplexNumber(<paramref name="x" />[i])</c>.
            </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsComplexNumberAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsComplexNumberAll&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsComplexNumberAll&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsComplexNumberAll``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsComplexNumberAll(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsComplexNumberAll : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsComplexNumberAll x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsComplexNumberAll(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether all of the values in the specified tensor are complex numbers.</summary>
        <returns>
          <see langword="true" /> if all of the values in <paramref name="x" /> are complex numbers; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsComplexNumberAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsComplexNumberAny&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsComplexNumberAny&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsComplexNumberAny``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsComplexNumberAny(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsComplexNumberAny : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsComplexNumberAny x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsComplexNumberAny(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether any of the values in the specified tensor is a complex number.</summary>
        <returns>
          <see langword="true" /> if any of the values in <paramref name="x" /> is a complex number; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEvenInteger&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void IsEvenInteger&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void IsEvenInteger&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;bool&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsEvenInteger``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub IsEvenInteger(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of Boolean))" />
      <MemberSignature Language="F#" Value="static member IsEvenInteger : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;bool&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsEvenInteger (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void IsEvenInteger(ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;System.Boolean&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes for each value in the specified tensor whether it's an even integral number.</summary>
        <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.IsEvenInteger(<paramref name="x" />[i])</c>.
            </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEvenIntegerAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsEvenIntegerAll&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEvenIntegerAll&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsEvenIntegerAll``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEvenIntegerAll(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsEvenIntegerAll : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsEvenIntegerAll x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsEvenIntegerAll(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether all of the values in the specified tensor are even integral numbers.</summary>
        <returns>
          <see langword="true" /> if all of the values in <paramref name="x" /> are even integral numbers; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEvenIntegerAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsEvenIntegerAny&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEvenIntegerAny&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsEvenIntegerAny``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEvenIntegerAny(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsEvenIntegerAny : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsEvenIntegerAny x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsEvenIntegerAny(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether any of the values in the specified tensor is an even integral number.</summary>
        <returns>
          <see langword="true" /> if any of the values in <paramref name="x" /> is an even integral number; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinite&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void IsFinite&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void IsFinite&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;bool&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsFinite``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub IsFinite(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of Boolean))" />
      <MemberSignature Language="F#" Value="static member IsFinite : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;bool&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsFinite (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void IsFinite(ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;System.Boolean&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes for each value in the specified tensor whether it's finite.</summary>
        <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.IsFinite(<paramref name="x" />[i])</c>.
            </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsFiniteAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsFiniteAll&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFiniteAll&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsFiniteAll``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFiniteAll(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsFiniteAll : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsFiniteAll x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsFiniteAll(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether all of the values in the specified tensor are finite.</summary>
        <returns>
          <see langword="true" /> if all of the values in <paramref name="x" /> are finite; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFiniteAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsFiniteAny&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFiniteAny&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsFiniteAny``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFiniteAny(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsFiniteAny : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsFiniteAny x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsFiniteAny(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether any of the values in the specified tensor is finite.</summary>
        <returns>
          <see langword="true" /> if any of the values in <paramref name="x" /> is finite; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImaginaryNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void IsImaginaryNumber&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void IsImaginaryNumber&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;bool&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsImaginaryNumber``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub IsImaginaryNumber(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of Boolean))" />
      <MemberSignature Language="F#" Value="static member IsImaginaryNumber : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;bool&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsImaginaryNumber (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void IsImaginaryNumber(ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;System.Boolean&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes for each value in the specified tensor whether it's a imaginary number.</summary>
        <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.IsImaginaryNumber(<paramref name="x" />[i])</c>.
            </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsImaginaryNumberAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsImaginaryNumberAll&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsImaginaryNumberAll&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsImaginaryNumberAll``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsImaginaryNumberAll(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsImaginaryNumberAll : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsImaginaryNumberAll x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsImaginaryNumberAll(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether all of the values in the specified tensor are imaginary numbers.</summary>
        <returns>
          <see langword="true" /> if all of the values in <paramref name="x" /> are imaginary numbers; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImaginaryNumberAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsImaginaryNumberAny&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsImaginaryNumberAny&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsImaginaryNumberAny``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsImaginaryNumberAny(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsImaginaryNumberAny : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsImaginaryNumberAny x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsImaginaryNumberAny(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether any of the values in the specified tensor is a imaginary number.</summary>
        <returns>
          <see langword="true" /> if any of the values in <paramref name="x" /> is a imaginary number; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void IsInfinity&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void IsInfinity&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;bool&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsInfinity``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub IsInfinity(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of Boolean))" />
      <MemberSignature Language="F#" Value="static member IsInfinity : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;bool&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsInfinity (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void IsInfinity(ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;System.Boolean&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes for each value in the specified tensor whether it's infinity.</summary>
        <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.IsInfinity(<paramref name="x" />[i])</c>.
            </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsInfinityAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsInfinityAll&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinityAll&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsInfinityAll``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinityAll(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsInfinityAll : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsInfinityAll x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsInfinityAll(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether all of the values in the specified tensor are infinity.</summary>
        <returns>
          <see langword="true" /> if all of the values in <paramref name="x" /> are infinity; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinityAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsInfinityAny&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinityAny&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsInfinityAny``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinityAny(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsInfinityAny : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsInfinityAny x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsInfinityAny(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether any of the values in the specified tensor is infinity.</summary>
        <returns>
          <see langword="true" /> if any of the values in <paramref name="x" /> is infinity; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInteger&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void IsInteger&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void IsInteger&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;bool&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsInteger``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub IsInteger(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of Boolean))" />
      <MemberSignature Language="F#" Value="static member IsInteger : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;bool&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsInteger (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void IsInteger(ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;System.Boolean&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes for each value in the specified tensor whether it's an integer.</summary>
        <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.IsInteger(<paramref name="x" />[i])</c>.
            </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsIntegerAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsIntegerAll&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsIntegerAll&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsIntegerAll``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsIntegerAll(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsIntegerAll : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsIntegerAll x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsIntegerAll(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether all of the values in the specified tensor are integers.</summary>
        <returns>
          <see langword="true" /> if all of the values in <paramref name="x" /> are integers; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsIntegerAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsIntegerAny&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsIntegerAny&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsIntegerAny``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsIntegerAny(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsIntegerAny : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsIntegerAny x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsIntegerAny(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether any of the values in the specified tensor is an integer.</summary>
        <returns>
          <see langword="true" /> if any of the values in <paramref name="x" /> is an integer; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNaN&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void IsNaN&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void IsNaN&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;bool&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsNaN``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub IsNaN(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of Boolean))" />
      <MemberSignature Language="F#" Value="static member IsNaN : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;bool&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsNaN (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void IsNaN(ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;System.Boolean&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes for each value in the specified tensor whether it's a naN.</summary>
        <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.IsNaN(<paramref name="x" />[i])</c>.
            </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNaNAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsNaNAll&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaNAll&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsNaNAll``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaNAll(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsNaNAll : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsNaNAll x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsNaNAll(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether all of the values in the specified tensor are naNs.</summary>
        <returns>
          <see langword="true" /> if all of the values in <paramref name="x" /> are naNs; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNaNAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsNaNAny&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaNAny&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsNaNAny``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaNAny(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsNaNAny : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsNaNAny x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsNaNAny(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether any of the values in the specified tensor is a naN.</summary>
        <returns>
          <see langword="true" /> if any of the values in <paramref name="x" /> is a naN; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegative&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void IsNegative&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void IsNegative&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;bool&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsNegative``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub IsNegative(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of Boolean))" />
      <MemberSignature Language="F#" Value="static member IsNegative : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;bool&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsNegative (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void IsNegative(ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;System.Boolean&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes for each value in the specified tensor whether it's negative.</summary>
        <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.IsNegative(<paramref name="x" />[i])</c>.
            </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsNegativeAll&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeAll&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsNegativeAll``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeAll(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsNegativeAll : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsNegativeAll x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsNegativeAll(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether all of the values in the specified tensor are negative.</summary>
        <returns>
          <see langword="true" /> if all of the values in <paramref name="x" /> are negative; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsNegativeAny&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeAny&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsNegativeAny``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeAny(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsNegativeAny : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsNegativeAny x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsNegativeAny(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether any of the values in the specified tensor is negative.</summary>
        <returns>
          <see langword="true" /> if any of the values in <paramref name="x" /> is negative; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void IsNegativeInfinity&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void IsNegativeInfinity&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;bool&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsNegativeInfinity``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub IsNegativeInfinity(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of Boolean))" />
      <MemberSignature Language="F#" Value="static member IsNegativeInfinity : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;bool&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsNegativeInfinity (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void IsNegativeInfinity(ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;System.Boolean&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes for each value in the specified tensor whether it's negative infinity.</summary>
        <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.IsNegativeInfinity(<paramref name="x" />[i])</c>.
            </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinityAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinityAll&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinityAll&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsNegativeInfinityAll``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinityAll(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsNegativeInfinityAll : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsNegativeInfinityAll x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsNegativeInfinityAll(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether all of the values in the specified tensor are negative infinity.</summary>
        <returns>
          <see langword="true" /> if all of the values in <paramref name="x" /> are negative infinity; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinityAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinityAny&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinityAny&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsNegativeInfinityAny``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinityAny(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsNegativeInfinityAny : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsNegativeInfinityAny x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsNegativeInfinityAny(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether any of the values in the specified tensor is negative infinity.</summary>
        <returns>
          <see langword="true" /> if any of the values in <paramref name="x" /> is negative infinity; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNormal&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void IsNormal&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void IsNormal&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;bool&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsNormal``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub IsNormal(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of Boolean))" />
      <MemberSignature Language="F#" Value="static member IsNormal : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;bool&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsNormal (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void IsNormal(ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;System.Boolean&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes for each value in the specified tensor whether it's normal.</summary>
        <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.IsNormal(<paramref name="x" />[i])</c>.
            </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNormalAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsNormalAll&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormalAll&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsNormalAll``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormalAll(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsNormalAll : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsNormalAll x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsNormalAll(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether all of the values in the specified tensor are normal.</summary>
        <returns>
          <see langword="true" /> if all of the values in <paramref name="x" /> are normal; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNormalAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsNormalAny&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormalAny&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsNormalAny``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormalAny(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsNormalAny : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsNormalAny x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsNormalAny(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether any of the values in the specified tensor is normal.</summary>
        <returns>
          <see langword="true" /> if any of the values in <paramref name="x" /> is normal; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOddInteger&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void IsOddInteger&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void IsOddInteger&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;bool&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsOddInteger``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub IsOddInteger(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of Boolean))" />
      <MemberSignature Language="F#" Value="static member IsOddInteger : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;bool&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsOddInteger (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void IsOddInteger(ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;System.Boolean&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes for each value in the specified tensor whether it's an odd integral number.</summary>
        <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.IsOddInteger(<paramref name="x" />[i])</c>.
            </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsOddIntegerAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsOddIntegerAll&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsOddIntegerAll&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsOddIntegerAll``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsOddIntegerAll(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsOddIntegerAll : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsOddIntegerAll x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsOddIntegerAll(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether all of the values in the specified tensor are odd integral numbers.</summary>
        <returns>
          <see langword="true" /> if all of the values in <paramref name="x" /> are odd integral numbers; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOddIntegerAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsOddIntegerAny&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsOddIntegerAny&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsOddIntegerAny``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsOddIntegerAny(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsOddIntegerAny : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsOddIntegerAny x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsOddIntegerAny(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether any of the values in the specified tensor is an odd integral number.</summary>
        <returns>
          <see langword="true" /> if any of the values in <paramref name="x" /> is an odd integral number; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositive&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void IsPositive&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void IsPositive&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;bool&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsPositive``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub IsPositive(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of Boolean))" />
      <MemberSignature Language="F#" Value="static member IsPositive : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;bool&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsPositive (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void IsPositive(ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;System.Boolean&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes for each value in the specified tensor whether it's positive.</summary>
        <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.IsPositive(<paramref name="x" />[i])</c>.
            </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsPositiveAll&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveAll&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsPositiveAll``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveAll(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsPositiveAll : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsPositiveAll x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsPositiveAll(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether all of the values in the specified tensor are positive.</summary>
        <returns>
          <see langword="true" /> if all of the values in <paramref name="x" /> are positive; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsPositiveAny&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveAny&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsPositiveAny``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveAny(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsPositiveAny : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsPositiveAny x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsPositiveAny(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether any of the values in the specified tensor is positive.</summary>
        <returns>
          <see langword="true" /> if any of the values in <paramref name="x" /> is positive; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void IsPositiveInfinity&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void IsPositiveInfinity&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;bool&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsPositiveInfinity``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub IsPositiveInfinity(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of Boolean))" />
      <MemberSignature Language="F#" Value="static member IsPositiveInfinity : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;bool&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsPositiveInfinity (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void IsPositiveInfinity(ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;System.Boolean&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes for each value in the specified tensor whether it's positive infinity.</summary>
        <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.IsPositiveInfinity(<paramref name="x" />[i])</c>.
            </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinityAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinityAll&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinityAll&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsPositiveInfinityAll``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinityAll(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsPositiveInfinityAll : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsPositiveInfinityAll x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsPositiveInfinityAll(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether all of the values in the specified tensor are positive infinity.</summary>
        <returns>
          <see langword="true" /> if all of the values in <paramref name="x" /> are positive infinity; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinityAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinityAny&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinityAny&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsPositiveInfinityAny``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinityAny(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsPositiveInfinityAny : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsPositiveInfinityAny x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsPositiveInfinityAny(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether any of the values in the specified tensor is positive infinity.</summary>
        <returns>
          <see langword="true" /> if any of the values in <paramref name="x" /> is positive infinity; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPow2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void IsPow2&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination) where T : System.Numerics.IBinaryNumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void IsPow2&lt;(class System.Numerics.IBinaryNumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;bool&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsPow2``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub IsPow2(Of T As IBinaryNumber(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of Boolean))" />
      <MemberSignature Language="F#" Value="static member IsPow2 : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBinaryNumber&lt;'T&gt;)&gt; * Span&lt;bool&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IBinaryNumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsPow2 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryNumber&lt;T&gt; static void IsPow2(ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryNumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;System.Boolean&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes for each value in the specified tensor whether it's a power of two.</summary>
        <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.IsPow2(<paramref name="x" />[i])</c>.
            </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsPow2All&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsPow2All&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.IBinaryNumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPow2All&lt;(class System.Numerics.IBinaryNumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsPow2All``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPow2All(Of T As IBinaryNumber(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsPow2All : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBinaryNumber&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.IBinaryNumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsPow2All x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryNumber&lt;T&gt; static bool IsPow2All(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryNumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether all of the values in the specified tensor are powers of two.</summary>
        <returns>
          <see langword="true" /> if all of the values in <paramref name="x" /> are powers of two; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPow2Any&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsPow2Any&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.IBinaryNumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPow2Any&lt;(class System.Numerics.IBinaryNumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsPow2Any``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPow2Any(Of T As IBinaryNumber(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsPow2Any : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBinaryNumber&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.IBinaryNumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsPow2Any x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryNumber&lt;T&gt; static bool IsPow2Any(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryNumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether any of the values in the specified tensor are powers of two.</summary>
        <returns>
          <see langword="true" /> if any of the values in <paramref name="x" /> are powers of two; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRealNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void IsRealNumber&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void IsRealNumber&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;bool&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsRealNumber``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub IsRealNumber(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of Boolean))" />
      <MemberSignature Language="F#" Value="static member IsRealNumber : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;bool&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsRealNumber (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void IsRealNumber(ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;System.Boolean&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes for each value in the specified tensor whether it's a real number.</summary>
        <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.IsRealNumber(<paramref name="x" />[i])</c>.
            </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsRealNumberAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsRealNumberAll&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsRealNumberAll&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsRealNumberAll``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsRealNumberAll(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsRealNumberAll : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsRealNumberAll x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsRealNumberAll(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether all of the values in the specified tensor are real numbers.</summary>
        <returns>
          <see langword="true" /> if all of the values in <paramref name="x" /> are real numbers; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRealNumberAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsRealNumberAny&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsRealNumberAny&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsRealNumberAny``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsRealNumberAny(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsRealNumberAny : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsRealNumberAny x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsRealNumberAny(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether any of the values in the specified tensor is a real number.</summary>
        <returns>
          <see langword="true" /> if any of the values in <paramref name="x" /> is a real number; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void IsSubnormal&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void IsSubnormal&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;bool&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsSubnormal``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub IsSubnormal(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of Boolean))" />
      <MemberSignature Language="F#" Value="static member IsSubnormal : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;bool&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsSubnormal (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void IsSubnormal(ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;System.Boolean&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes for each value in the specified tensor whether it's subnormal.</summary>
        <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.IsSubnormal(<paramref name="x" />[i])</c>.
            </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSubnormalAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsSubnormalAll&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormalAll&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsSubnormalAll``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormalAll(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsSubnormalAll : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsSubnormalAll x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsSubnormalAll(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether all of the values in the specified tensor are subnormal.</summary>
        <returns>
          <see langword="true" /> if all of the values in <paramref name="x" /> are subnormal; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSubnormalAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsSubnormalAny&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormalAny&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsSubnormalAny``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormalAny(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsSubnormalAny : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsSubnormalAny x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsSubnormalAny(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether any of the values in the specified tensor is subnormal.</summary>
        <returns>
          <see langword="true" /> if any of the values in <paramref name="x" /> is subnormal; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsZero&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void IsZero&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void IsZero&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;bool&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsZero``1(System.ReadOnlySpan{``0},System.Span{System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub IsZero(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of Boolean))" />
      <MemberSignature Language="F#" Value="static member IsZero : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;bool&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsZero (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void IsZero(ReadOnlySpan&lt;T&gt; x, Span&lt;bool&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;System.Boolean&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes for each value in the specified tensor whether it's zero.</summary>
        <remarks>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.IsZero(<paramref name="x" />[i])</c>.
            </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsZeroAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsZeroAll&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsZeroAll&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsZeroAll``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsZeroAll(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsZeroAll : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsZeroAll x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsZeroAll(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether all of the values in the specified tensor are zero.</summary>
        <returns>
          <see langword="true" /> if all of the values in <paramref name="x" /> are zero; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsZeroAny&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsZeroAny&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsZeroAny&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IsZeroAny``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsZeroAny(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsZeroAny : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; bool (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IsZeroAny x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static bool IsZeroAny(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes whether any of the values in the specified tensor is zero.</summary>
        <returns>
          <see langword="true" /> if any of the values in <paramref name="x" /> is zero; otherwise, <see langword="false" />.
            If <paramref name="x" /> is empty, <see langword="false" /> is returned.
            </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeadingZeroCount&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void LeadingZeroCount&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeadingZeroCount&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.LeadingZeroCount``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeadingZeroCount(Of T As IBinaryInteger(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member LeadingZeroCount : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.LeadingZeroCount (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static void LeadingZeroCount(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise leading zero count of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.LeadingZeroCount(<paramref name="x" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lerp&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Lerp&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, ReadOnlySpan&lt;T&gt; amount, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Lerp&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.ReadOnlySpan`1&lt;!!T&gt; amount, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Lerp``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Lerp(Of T As IFloatingPointIeee754(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), amount As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Lerp : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Lerp (x, y, amount, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void Lerp(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, ReadOnlySpan&lt;T&gt; amount, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="amount" Type="System.ReadOnlySpan&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="amount">The third tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise linear interpolation between two values based on the given weight in the specified tensors of numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Lerp(<paramref name="x" />[i], <paramref name="y" />[i], <paramref name="amount" />[i])</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="amount" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lerp&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Lerp&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, T amount, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Lerp&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, !!T amount, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Lerp``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Lerp(Of T As IFloatingPointIeee754(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), amount As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Lerp : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Lerp (x, y, amount, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void Lerp(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, T amount, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="amount" Type="T" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="amount">The third tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise linear interpolation between two values based on the given weight in the specified tensors of numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Lerp(<paramref name="x" />[i], <paramref name="y" />[i], <paramref name="amount" />)</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lerp&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Lerp&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, ReadOnlySpan&lt;T&gt; amount, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Lerp&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.ReadOnlySpan`1&lt;!!T&gt; amount, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Lerp``1(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Lerp(Of T As IFloatingPointIeee754(Of T)) (x As ReadOnlySpan(Of T), y As T, amount As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Lerp : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * 'T * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Lerp (x, y, amount, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void Lerp(ReadOnlySpan&lt;T&gt; x, T y, ReadOnlySpan&lt;T&gt; amount, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="amount" Type="System.ReadOnlySpan&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="amount">The third tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise linear interpolation between two values based on the given weight in the specified tensors of numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Lerp(<paramref name="x" />[i], <paramref name="y" />, <paramref name="amount" />[i])</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="amount" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static void Log (ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Log(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Log(System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Log (x As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Log : ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Log (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Log(ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise natural (base <c>e</c>) logarithm of single-precision floating-point numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <see cref="T:System.MathF" />.Log(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="F:System.Single.NegativeInfinity" />.
            If a value is negative or equal to <see cref="F:System.Single.NaN" />, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="F:System.Single.PositiveInfinity" />.
            Otherwise, if a value is positive, its natural logarithm is stored into the corresponding destination location.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Log&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Log&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Log&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Log``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Log(Of T As ILogarithmicFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Log : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Log (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static void Log(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise natural (base <c>e</c>) logarithm of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Log(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity" />.
            If a value is negative or equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity" />.
            Otherwise, if a value is positive, its natural logarithm is stored into the corresponding destination location.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Log&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Log&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Log&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Log``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Log(Of T As ILogarithmicFunctions(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Log : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Log (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static void Log(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise logarithm of the numbers in a specified tensor to the specified base in another specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Log(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Log&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Log&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Log&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Log``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Log(Of T As ILogarithmicFunctions(Of T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Log : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Log (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static void Log(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise logarithm of the numbers in a specified tensor to the specified base in another specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Log(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Log10&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Log10&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Log10&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Log10``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Log10(Of T As ILogarithmicFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Log10 : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Log10 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static void Log10(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise base 10 logarithm of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Log10(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity" />.
            If a value is negative or equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity" />.
            Otherwise, if a value is positive, its base 10 logarithm is stored into the corresponding destination location.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Log10P1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Log10P1&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Log10P1&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Log10P1``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Log10P1(Of T As ILogarithmicFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Log10P1 : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Log10P1 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static void Log10P1(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise base 10 logarithm of numbers in the specified tensor plus 1.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Log10P1(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity" />.
            If a value is negative or equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity" />.
            Otherwise, if a value is positive, its base 10 logarithm plus 1 is stored into the corresponding destination location.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Log2">
      <MemberSignature Language="C#" Value="public static void Log2 (ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Log2(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Log2(System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Log2 (x As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Log2 : ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Log2 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Log2(ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise base 2 logarithm of single-precision floating-point numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <see cref="T:System.MathF" />.Log2(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="F:System.Single.NegativeInfinity" />.
            If a value is negative or equal to <see cref="F:System.Single.NaN" />, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="F:System.Single.PositiveInfinity" />.
            Otherwise, if a value is positive, its natural logarithm is stored into the corresponding destination location.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Log2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Log2&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Log2&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Log2``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Log2(Of T As ILogarithmicFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Log2 : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Log2 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static void Log2(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise base 2 logarithm of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Log2(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity" />.
            If a value is negative or equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity" />.
            Otherwise, if a value is positive, its base 2 logarithm is stored into the corresponding destination location.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Log2P1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Log2P1&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Log2P1&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Log2P1``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Log2P1(Of T As ILogarithmicFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Log2P1 : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Log2P1 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static void Log2P1(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise base 2 logarithm of numbers in the specified tensor plus 1.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Log2P1(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity" />.
            If a value is negative or equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity" />.
            Otherwise, if a value is positive, its base 2 logarithm plus 1 is stored into the corresponding destination location.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="LogP1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void LogP1&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LogP1&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.LogP1``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LogP1(Of T As ILogarithmicFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member LogP1 : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.LogP1 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static void LogP1(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise natural (base <c>e</c>) logarithm of numbers in the specified tensor plus 1.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.LogP1(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity" />.
            If a value is negative or equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity" />.
            Otherwise, if a value is positive, its natural logarithm plus 1 is stored into the corresponding destination location.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static float Max (ReadOnlySpan&lt;float&gt; x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max(valuetype System.ReadOnlySpan`1&lt;float32&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Max(System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (x As ReadOnlySpan(Of Single)) As Single" />
      <MemberSignature Language="F#" Value="static member Max : ReadOnlySpan&lt;single&gt; -&gt; single" Usage="System.Numerics.Tensors.TensorPrimitives.Max x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Max(ReadOnlySpan&lt;float&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the largest single-precision floating-point number in the specified tensor.</summary>
        <returns>The maximum element in <paramref name="x" />.</returns>
        <remarks>
          <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If any value equal to <see cref="F:System.Single.NaN" />
            is present, the first is returned. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static void Max (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Max(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Max(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Max (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Max : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Max (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Max(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise maximum of the single-precision floating-point numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = MathF.Max(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
          <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If either value is equal to <see cref="F:System.Single.NaN" />,
            that value is stored as the result. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Max&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Max&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Max``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Max : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Max x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T Max(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the largest number in the specified tensor.</summary>
        <returns>The maximum element in <paramref name="x" />.</returns>
        <remarks>
          <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If any value equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />
            is present, the first is returned. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Max&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Max&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Max``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Max(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Max : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Max (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static void Max(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Max(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
          <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If either value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />,
            that value is stored as the result. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Max&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Max&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Max``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Max(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Max : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Max (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static void Max(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Max(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
          <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If either value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />,
            that value is stored as the result. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude">
      <MemberSignature Language="C#" Value="public static float MaxMagnitude (ReadOnlySpan&lt;float&gt; x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 MaxMagnitude(valuetype System.ReadOnlySpan`1&lt;float32&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MaxMagnitude(System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MaxMagnitude (x As ReadOnlySpan(Of Single)) As Single" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : ReadOnlySpan&lt;single&gt; -&gt; single" Usage="System.Numerics.Tensors.TensorPrimitives.MaxMagnitude x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float MaxMagnitude(ReadOnlySpan&lt;float&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the single-precision floating-point number with the largest magnitude in the specified tensor.</summary>
        <returns>The element in <paramref name="x" /> with the largest magnitude (absolute value).</returns>
        <remarks>
          <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `maximumMagnitude` function. If any value equal to <see cref="F:System.Single.NaN" />
            is present, the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the positive value is considered to have the larger magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude">
      <MemberSignature Language="C#" Value="public static void MaxMagnitude (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MaxMagnitude(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MaxMagnitude(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MaxMagnitude (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.MaxMagnitude (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MaxMagnitude(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise single-precision floating-point number with the largest magnitude in the specified tensors.</summary>
        <remarks>This method effectively computes <c><paramref name="destination" />[i] = MathF.MaxMagnitude(<paramref name="x" />[i], <paramref name="y" />[i])</c>.</remarks>
        <remarks>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MaxMagnitude&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MaxMagnitude&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MaxMagnitude``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MaxMagnitude(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MaxMagnitude x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static T MaxMagnitude(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the number with the largest magnitude in the specified tensor.</summary>
        <returns>The element in <paramref name="x" /> with the largest magnitude (absolute value).</returns>
        <remarks>
          <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `maximumMagnitude` function. If any value equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />
            is present, the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the positive value is considered to have the larger magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MaxMagnitude&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MaxMagnitude&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MaxMagnitude``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MaxMagnitude(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MaxMagnitude (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void MaxMagnitude(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the largest magnitude in the specified tensors.</summary>
        <remarks>This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.MaxMagnitude(<paramref name="x" />[i], <paramref name="y" />[i])</c>.</remarks>
        <remarks>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MaxMagnitude&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MaxMagnitude&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MaxMagnitude``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MaxMagnitude(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MaxMagnitude (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void MaxMagnitude(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the largest magnitude in the specified tensors.</summary>
        <remarks>This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.MaxMagnitude(<paramref name="x" />[i], <paramref name="y" />)</c>.</remarks>
        <remarks>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitudeNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MaxMagnitudeNumber&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MaxMagnitudeNumber&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MaxMagnitudeNumber``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MaxMagnitudeNumber(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MaxMagnitudeNumber : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MaxMagnitudeNumber x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static T MaxMagnitudeNumber(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the number with the largest magnitude in the specified tensor.</summary>
        <returns>The element in <paramref name="x" /> with the largest magnitude (absolute value).</returns>
        <remarks>
          <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `maximumMagnitudeNumber` function.
            If two values have the same magnitude and one is positive and the other is negative,
            the positive value is considered to have the larger magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitudeNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MaxMagnitudeNumber&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MaxMagnitudeNumber&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MaxMagnitudeNumber``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MaxMagnitudeNumber(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MaxMagnitudeNumber : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MaxMagnitudeNumber (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void MaxMagnitudeNumber(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the largest magnitude in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.MaxMagnitudeNumber(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
          <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `maximumMagnitudeNumber` function.
            If the two values have the same magnitude and one is positive and the other is negative,
            the positive value is considered to have the larger magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitudeNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MaxMagnitudeNumber&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MaxMagnitudeNumber&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MaxMagnitudeNumber``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MaxMagnitudeNumber(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MaxMagnitudeNumber : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MaxMagnitudeNumber (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void MaxMagnitudeNumber(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the largest magnitude in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.MaxMagnitudeNumber(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
          <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `maximumMagnitudeNumber` function.
            If the two values have the same magnitude and one is positive and the other is negative,
            the positive value is considered to have the larger magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MaxNumber&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MaxNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MaxNumber``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MaxNumber(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MaxNumber : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MaxNumber x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T MaxNumber(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the largest number in the specified tensor.</summary>
        <returns>The maximum element in <paramref name="x" />.</returns>
        <remarks>
          <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximumNumber` function. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MaxNumber&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MaxNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MaxNumber``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MaxNumber(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MaxNumber : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MaxNumber (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static void MaxNumber(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.MaxNumber(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
          <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximumNumber` function. If either value is <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />
            the other is returned. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MaxNumber&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MaxNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MaxNumber``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MaxNumber(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MaxNumber : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MaxNumber (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static void MaxNumber(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.MaxNumber(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
          <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximumNumber` function. If either value is <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />
            the other is returned. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static float Min (ReadOnlySpan&lt;float&gt; x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min(valuetype System.ReadOnlySpan`1&lt;float32&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Min(System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (x As ReadOnlySpan(Of Single)) As Single" />
      <MemberSignature Language="F#" Value="static member Min : ReadOnlySpan&lt;single&gt; -&gt; single" Usage="System.Numerics.Tensors.TensorPrimitives.Min x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Min(ReadOnlySpan&lt;float&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the smallest single-precision floating-point number in the specified tensor.</summary>
        <returns>The minimum element in <paramref name="x" />.</returns>
        <remarks>
          <para>
            The determination of the minimum element matches the IEEE 754:2019 `minimum` function. If any value is equal to <see cref="F:System.Single.NaN" />
            is present, the first is returned. Negative 0 is considered smaller than positive 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static void Min (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Min(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Min(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Min (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Min : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Min (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Min(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise minimum of the single-precision floating-point numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = MathF.Max(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
          <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If either value is equal to <see cref="F:System.Single.NaN" />,
            that value is stored as the result. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Min&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Min&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Min``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Min : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Min x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T Min(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the smallest number in the specified tensor.</summary>
        <returns>The minimum element in <paramref name="x" />.</returns>
        <remarks>
          <para>
            The determination of the minimum element matches the IEEE 754:2019 `minimum` function. If any value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />
            is present, the first is returned. Negative 0 is considered smaller than positive 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Min&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Min&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Min``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Min(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Min : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Min (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static void Min(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise minimum of the numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Max(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
          <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If either value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />,
            that value is stored as the result. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Min&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Min&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Min``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Min(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Min : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Min (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static void Min(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise minimum of the numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Max(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
          <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If either value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />,
            that value is stored as the result. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude">
      <MemberSignature Language="C#" Value="public static float MinMagnitude (ReadOnlySpan&lt;float&gt; x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 MinMagnitude(valuetype System.ReadOnlySpan`1&lt;float32&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MinMagnitude(System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MinMagnitude (x As ReadOnlySpan(Of Single)) As Single" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : ReadOnlySpan&lt;single&gt; -&gt; single" Usage="System.Numerics.Tensors.TensorPrimitives.MinMagnitude x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float MinMagnitude(ReadOnlySpan&lt;float&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the single-precision floating-point number with the smallest magnitude in the specified tensor.</summary>
        <returns>The element in <paramref name="x" /> with the smallest magnitude (absolute value).</returns>
        <remarks>
          <para>
            The determination of the minimum magnitude matches the IEEE 754:2019 `minimumMagnitude` function. If any value equal to <see cref="F:System.Single.NaN" />
            is present, the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude">
      <MemberSignature Language="C#" Value="public static void MinMagnitude (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MinMagnitude(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MinMagnitude(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MinMagnitude (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.MinMagnitude (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MinMagnitude(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise single-precision floating-point number with the smallest magnitude in the specified tensors.</summary>
        <remarks>This method effectively computes <c><paramref name="destination" />[i] = MathF.MinMagnitude(<paramref name="x" />[i], <paramref name="y" />[i])</c>.</remarks>
        <remarks>
          <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `minimumMagnitude` function. If either value is equal to <see cref="F:System.Single.NaN" />,
            that value is stored as the result. If the two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MinMagnitude&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MinMagnitude&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MinMagnitude``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MinMagnitude(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MinMagnitude x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static T MinMagnitude(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the number with the smallest magnitude in the specified tensor.</summary>
        <returns>The element in <paramref name="x" /> with the smallest magnitude (absolute value).</returns>
        <remarks>
          <para>
            The determination of the minimum magnitude matches the IEEE 754:2019 `minimumMagnitude` function. If any value equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />
            is present, the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MinMagnitude&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MinMagnitude&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MinMagnitude``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MinMagnitude(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MinMagnitude (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void MinMagnitude(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the smallest magnitude in the specified tensors.</summary>
        <remarks>This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.MinMagnitude(<paramref name="x" />[i], <paramref name="y" />[i])</c>.</remarks>
        <remarks>
          <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `minimumMagnitude` function. If either value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />,
            that value is stored as the result. If the two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MinMagnitude&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MinMagnitude&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MinMagnitude``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MinMagnitude(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MinMagnitude (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void MinMagnitude(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the smallest magnitude in the specified tensors.</summary>
        <remarks>This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.MinMagnitude(<paramref name="x" />[i], <paramref name="y" />)</c>.</remarks>
        <remarks>
          <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `minimumMagnitude` function. If either value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />,
            that value is stored as the result. If the two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitudeNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MinMagnitudeNumber&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MinMagnitudeNumber&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MinMagnitudeNumber``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MinMagnitudeNumber(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MinMagnitudeNumber : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MinMagnitudeNumber x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static T MinMagnitudeNumber(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the number with the smallest magnitude in the specified tensor.</summary>
        <returns>The element in <paramref name="x" /> with the smallest magnitude (absolute value).</returns>
        <remarks>
          <para>
            The determination of the minimum magnitude matches the IEEE 754:2019 `minimumMagnitudeNumber` function.
            If two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitudeNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MinMagnitudeNumber&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MinMagnitudeNumber&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MinMagnitudeNumber``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MinMagnitudeNumber(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MinMagnitudeNumber : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MinMagnitudeNumber (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void MinMagnitudeNumber(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the smallest magnitude in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.MinMagnitudeNumber(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
          <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `minimumMagnitudeNumber` function.
            If the two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitudeNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MinMagnitudeNumber&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MinMagnitudeNumber&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MinMagnitudeNumber``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MinMagnitudeNumber(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MinMagnitudeNumber : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MinMagnitudeNumber (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void MinMagnitudeNumber(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the smallest magnitude in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.MinMagnitudeNumber(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
          <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `minimumMagnitudeNumber` function.
            If the two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MinNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MinNumber&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MinNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MinNumber``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MinNumber(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MinNumber : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MinNumber x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T MinNumber(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the smallest number in the specified tensor.</summary>
        <returns>The minimum element in <paramref name="x" />.</returns>
        <remarks>
          <para>
            The determination of the minimum element matches the IEEE 754:2019 `minimumNumber` function. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="MinNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MinNumber&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MinNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MinNumber``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MinNumber(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MinNumber : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MinNumber (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static void MinNumber(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise minimum of the numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.MinNumber(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
          <para>
            The determination of the minimum element matches the IEEE 754:2019 `minimumNumber` function. If either value is <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />
            the other is returned. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MinNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MinNumber&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MinNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MinNumber``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MinNumber(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MinNumber : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MinNumber (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static void MinNumber(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise minimum of the numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.MinNumber(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
          <para>
            The determination of the minimum element matches the IEEE 754:2019 `minimumNumber` function. If either value is <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />
            the other is returned. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static void Multiply (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Multiply(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Multiply(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Multiply (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Multiply : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Multiply (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Multiply(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise product of single-precision floating-point numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] * <paramref name="y" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static void Multiply (ReadOnlySpan&lt;float&gt; x, float y, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Multiply(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, float32 y, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Multiply(System.ReadOnlySpan{System.Single},System.Single,System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Multiply (x As ReadOnlySpan(Of Single), y As Single, destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Multiply : ReadOnlySpan&lt;single&gt; * single * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Multiply (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Multiply(ReadOnlySpan&lt;float&gt; x, float y, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise product of single-precision floating-point numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] * <paramref name="y" /></c>.
            It corresponds to the <c>scal</c> method defined by <c>BLAS1</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Multiply&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Multiply&lt;(class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Multiply``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Multiply(Of T As {IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Multiply : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Multiply (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static void Multiply(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise product of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] * <paramref name="y" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Multiply&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Multiply&lt;(class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Multiply``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Multiply(Of T As {IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Multiply : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Multiply (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static void Multiply(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise product of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] * <paramref name="y" /></c>.
            It corresponds to the <c>scal</c> method defined by <c>BLAS1</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAdd">
      <MemberSignature Language="C#" Value="public static void MultiplyAdd (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, ReadOnlySpan&lt;float&gt; addend, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MultiplyAdd(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y, valuetype System.ReadOnlySpan`1&lt;float32&gt; addend, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MultiplyAdd (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single), addend As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member MultiplyAdd : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.MultiplyAdd (x, y, addend, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MultiplyAdd(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, ReadOnlySpan&lt;float&gt; addend, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="addend" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="addend">The third tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of single-precision floating-point numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="addend" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAdd">
      <MemberSignature Language="C#" Value="public static void MultiplyAdd (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, float addend, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MultiplyAdd(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y, float32 addend, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Single,System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MultiplyAdd (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single), addend As Single, destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member MultiplyAdd : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; * single * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.MultiplyAdd (x, y, addend, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MultiplyAdd(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, float addend, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="addend" Type="System.Single" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="addend">The third tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of single-precision floating-point numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" /></c>.
            It corresponds to the <c>axpy</c> method defined by <c>BLAS1</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAdd">
      <MemberSignature Language="C#" Value="public static void MultiplyAdd (ReadOnlySpan&lt;float&gt; x, float y, ReadOnlySpan&lt;float&gt; addend, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MultiplyAdd(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, float32 y, valuetype System.ReadOnlySpan`1&lt;float32&gt; addend, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd(System.ReadOnlySpan{System.Single},System.Single,System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MultiplyAdd (x As ReadOnlySpan(Of Single), y As Single, addend As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member MultiplyAdd : ReadOnlySpan&lt;single&gt; * single * ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.MultiplyAdd (x, y, addend, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MultiplyAdd(ReadOnlySpan&lt;float&gt; x, float y, ReadOnlySpan&lt;float&gt; addend, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="addend" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="addend">The third tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of single-precision floating-point numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />) + <paramref name="addend" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="addend" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAdd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MultiplyAdd&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, ReadOnlySpan&lt;T&gt; addend, Span&lt;T&gt; destination) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MultiplyAdd&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.ReadOnlySpan`1&lt;!!T&gt; addend, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MultiplyAdd(Of T As {IAdditionOperators(Of T, T, T), IMultiplyOperators(Of T, T, T)}) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), addend As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MultiplyAdd : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MultiplyAdd (x, y, addend, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt; static void MultiplyAdd(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, ReadOnlySpan&lt;T&gt; addend, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="addend" Type="System.ReadOnlySpan&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="addend">The third tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="addend" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAdd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MultiplyAdd&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, T addend, Span&lt;T&gt; destination) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MultiplyAdd&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, !!T addend, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MultiplyAdd(Of T As {IAdditionOperators(Of T, T, T), IMultiplyOperators(Of T, T, T)}) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), addend As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MultiplyAdd : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MultiplyAdd (x, y, addend, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt; static void MultiplyAdd(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, T addend, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="addend" Type="T" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="addend">The third tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" /></c>.
            It corresponds to the <c>axpy</c> method defined by <c>BLAS1</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAdd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MultiplyAdd&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, ReadOnlySpan&lt;T&gt; addend, Span&lt;T&gt; destination) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MultiplyAdd&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.ReadOnlySpan`1&lt;!!T&gt; addend, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd``1(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MultiplyAdd(Of T As {IAdditionOperators(Of T, T, T), IMultiplyOperators(Of T, T, T)}) (x As ReadOnlySpan(Of T), y As T, addend As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MultiplyAdd : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MultiplyAdd (x, y, addend, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt; static void MultiplyAdd(ReadOnlySpan&lt;T&gt; x, T y, ReadOnlySpan&lt;T&gt; addend, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="addend" Type="System.ReadOnlySpan&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="addend">The third tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />) + <paramref name="addend" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="addend" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAddEstimate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MultiplyAddEstimate&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, ReadOnlySpan&lt;T&gt; addend, Span&lt;T&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MultiplyAddEstimate&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.ReadOnlySpan`1&lt;!!T&gt; addend, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAddEstimate``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MultiplyAddEstimate(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), addend As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MultiplyAddEstimate : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MultiplyAddEstimate (x, y, addend, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void MultiplyAddEstimate(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, ReadOnlySpan&lt;T&gt; addend, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="addend" Type="System.ReadOnlySpan&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="addend">The third tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
          <para>
            Behaves the same as either <see cref="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" /> or
            <see cref="M:System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" /> depending on the current machine's capabilities.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="addend" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAddEstimate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MultiplyAddEstimate&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, T addend, Span&lt;T&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MultiplyAddEstimate&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, !!T addend, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAddEstimate``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MultiplyAddEstimate(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), addend As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MultiplyAddEstimate : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MultiplyAddEstimate (x, y, addend, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void MultiplyAddEstimate(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, T addend, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="addend" Type="T" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="addend">The third tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" /></c>.
            It corresponds to the <c>axpy</c> method defined by <c>BLAS1</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
          <para>
            Behaves the same as either <see cref="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})" /> or
            <see cref="M:System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})" /> depending on the current machine's capabilities.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAddEstimate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MultiplyAddEstimate&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, ReadOnlySpan&lt;T&gt; addend, Span&lt;T&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MultiplyAddEstimate&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.ReadOnlySpan`1&lt;!!T&gt; addend, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAddEstimate``1(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MultiplyAddEstimate(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), y As T, addend As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MultiplyAddEstimate : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * 'T * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MultiplyAddEstimate (x, y, addend, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void MultiplyAddEstimate(ReadOnlySpan&lt;T&gt; x, T y, ReadOnlySpan&lt;T&gt; addend, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="addend" Type="System.ReadOnlySpan&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="addend">The third tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />) + <paramref name="addend" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
          <para>
            Behaves the same as either <see cref="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd``1(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})" /> or
            <see cref="M:System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAdd``1(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})" /> depending on the current machine's capabilities.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="addend" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static void Negate (ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Negate(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Negate(System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Negate (x As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Negate : ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Negate (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Negate(ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise negation of each single-precision floating-point number in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = -<paramref name="x" />[i]</c>.
            </para>
          <para>
            If any of the element-wise input values is equal to <see cref="F:System.Single.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Negate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Negate&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IUnaryNegationOperators&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Negate&lt;(class System.Numerics.IUnaryNegationOperators`2&lt;!!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Negate``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Negate(Of T As IUnaryNegationOperators(Of T, T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Negate : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IUnaryNegationOperators&lt;'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IUnaryNegationOperators&lt;'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IUnaryNegationOperators&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Negate (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IUnaryNegationOperators&lt;T, T&gt; static void Negate(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IUnaryNegationOperators&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise negation of each number in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = -<paramref name="x" />[i]</c>.
            </para>
          <para>
            If any of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Norm">
      <MemberSignature Language="C#" Value="public static float Norm (ReadOnlySpan&lt;float&gt; x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Norm(valuetype System.ReadOnlySpan`1&lt;float32&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Norm(System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Norm (x As ReadOnlySpan(Of Single)) As Single" />
      <MemberSignature Language="F#" Value="static member Norm : ReadOnlySpan&lt;single&gt; -&gt; single" Usage="System.Numerics.Tensors.TensorPrimitives.Norm x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Norm(ReadOnlySpan&lt;float&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <summary>Computes the Euclidean norm of the specified tensor of single-precision floating-point numbers.</summary>
        <returns>The norm.</returns>
        <remarks>
          <para>
            This method effectively computes <c>MathF.Sqrt(TensorPrimitives.SumOfSquares(x))</c>.
            This is often referred to as the Euclidean norm or L2 norm.
            It corresponds to the <c>nrm2</c> method defined by <c>BLAS1</c>.
            </para>
          <para>
            If any of the input values is equal to <see cref="F:System.Single.NaN" />, the result value is also NaN.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Norm&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Norm&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Norm&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Norm``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Norm(Of T As IRootFunctions(Of T)) (x As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Norm : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Norm x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static T Norm(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <summary>Computes the Euclidean norm of the specified tensor of numbers.</summary>
        <returns>The norm.</returns>
        <remarks>
          <para>
            This method effectively computes <c><typeparamref name="T" />.Sqrt(TensorPrimitives.SumOfSquares(x))</c>.
            This is often referred to as the Euclidean norm or L2 norm.
            It corresponds to the <c>nrm2</c> method defined by <c>BLAS1</c>.
            </para>
          <para>
            If any of the input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the result value is also NaN.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnesComplement&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void OnesComplement&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void OnesComplement&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.OnesComplement``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub OnesComplement(Of T As IBitwiseOperators(Of T, T, T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member OnesComplement : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.OnesComplement (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static void OnesComplement(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise one's complement of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = ~<paramref name="x" />[i]</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="PopCount&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static long PopCount&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 PopCount&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.PopCount``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PopCount(Of T As IBinaryInteger(Of T)) (x As ReadOnlySpan(Of T)) As Long" />
      <MemberSignature Language="F#" Value="static member PopCount : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; -&gt; int64 (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.PopCount x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static long PopCount(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes the population count of all elements in the specified tensor.</summary>
        <returns>The sum of the number of bits set in each element in <paramref name="x" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PopCount&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void PopCount&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PopCount&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.PopCount``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PopCount(Of T As IBinaryInteger(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member PopCount : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.PopCount (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static void PopCount(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise population count of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.PopCount(<paramref name="x" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pow&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Pow&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.IPowerFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pow&lt;(class System.Numerics.IPowerFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Pow``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pow(Of T As IPowerFunctions(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Pow : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Pow (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IPowerFunctions&lt;T&gt; static void Pow(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IPowerFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise power of a number in a specified tensor raised to a number in another specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Pow(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pow&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Pow&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.IPowerFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pow&lt;(class System.Numerics.IPowerFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Pow``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pow(Of T As IPowerFunctions(Of T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Pow : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Pow (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IPowerFunctions&lt;T&gt; static void Pow(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IPowerFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise power of a number in a specified tensor raised to a number in another specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Pow(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pow&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Pow&lt;T&gt; (T x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.IPowerFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pow&lt;(class System.Numerics.IPowerFunctions`1&lt;!!T&gt;) T&gt;(!!T x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Pow``1(``0,System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pow(Of T As IPowerFunctions(Of T)) (x As T, y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Pow : 'T * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Pow (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IPowerFunctions&lt;T&gt; static void Pow(T x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IPowerFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a scalar.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise power of a number in a specified tensor raised to a number in another specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Pow(<paramref name="x" />, <paramref name="y" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Product">
      <MemberSignature Language="C#" Value="public static float Product (ReadOnlySpan&lt;float&gt; x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Product(valuetype System.ReadOnlySpan`1&lt;float32&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Product(System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Product (x As ReadOnlySpan(Of Single)) As Single" />
      <MemberSignature Language="F#" Value="static member Product : ReadOnlySpan&lt;single&gt; -&gt; single" Usage="System.Numerics.Tensors.TensorPrimitives.Product x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Product(ReadOnlySpan&lt;float&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes the product of all elements in the specified non-empty tensor of single-precision floating-point numbers.</summary>
        <returns>The result of multiplying all elements in <paramref name="x" />.</returns>
        <remarks>
          <para>
            If any of the input values is equal to <see cref="F:System.Single.NaN" />, the result value is also NaN.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Product&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Product&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Product&lt;(class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Product``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Product(Of T As {IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (x As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Product : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Product x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static T Product(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes the product of all elements in the specified non-empty tensor of numbers.</summary>
        <returns>The result of multiplying all elements in <paramref name="x" />.</returns>
        <remarks>
          <para>
            If any of the input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the result value is also NaN.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProductOfDifferences">
      <MemberSignature Language="C#" Value="public static float ProductOfDifferences (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ProductOfDifferences(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ProductOfDifferences(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ProductOfDifferences (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single)) As Single" />
      <MemberSignature Language="F#" Value="static member ProductOfDifferences : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; -&gt; single" Usage="System.Numerics.Tensors.TensorPrimitives.ProductOfDifferences (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float ProductOfDifferences(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the product of the element-wise differences of the single-precision floating-point numbers in the specified non-empty tensors.</summary>
        <returns>The result of multiplying the element-wise subtraction of the elements in the second tensor from the first tensor.</returns>
        <remarks>
          <para>
            This method effectively computes:
            <c>
                Span&lt;float&gt; differences = ...;
                TensorPrimitives.Subtract(x, y, differences);
                float result = TensorPrimitives.Product(differences);
            </c>
            but without requiring additional temporary storage for the intermediate differences.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="y" /> must have the same length.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProductOfDifferences&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T ProductOfDifferences&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y) where T : System.Numerics.ISubtractionOperators&lt;T,T,T&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T ProductOfDifferences&lt;(class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ProductOfDifferences``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ProductOfDifferences(Of T As {ISubtractionOperators(Of T, T, T), IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member ProductOfDifferences : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.ProductOfDifferences (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ISubtractionOperators&lt;T, T, T&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static T ProductOfDifferences(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the product of the element-wise differences of the numbers in the specified non-empty tensors.</summary>
        <returns>The result of multiplying the element-wise subtraction of the elements in the second tensor from the first tensor.</returns>
        <remarks>
          <para>
            This method effectively computes:
            <c>
                Span&lt;T&gt; differences = ...;
                TensorPrimitives.Subtract(x, y, differences);
                T result = TensorPrimitives.Product(differences);
            </c>
            but without requiring additional temporary storage for the intermediate differences.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="y" /> must have the same length.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProductOfSums">
      <MemberSignature Language="C#" Value="public static float ProductOfSums (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ProductOfSums(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ProductOfSums(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ProductOfSums (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single)) As Single" />
      <MemberSignature Language="F#" Value="static member ProductOfSums : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; -&gt; single" Usage="System.Numerics.Tensors.TensorPrimitives.ProductOfSums (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float ProductOfSums(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the product of the element-wise sums of the single-precision floating-point numbers in the specified non-empty tensors.</summary>
        <returns>The result of multiplying the element-wise additions of the elements in each tensor.</returns>
        <remarks>
          <para>
            This method effectively computes:
            <c>
                Span&lt;float&gt; sums = ...;
                TensorPrimitives.Add(x, y, sums);
                float result = TensorPrimitives.Product(sums);
            </c>
            but without requiring additional temporary storage for the intermediate sums.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="y" /> must have the same length.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProductOfSums&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T ProductOfSums&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T ProductOfSums&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ProductOfSums``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ProductOfSums(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T), IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member ProductOfSums : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.ProductOfSums (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static T ProductOfSums(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the product of the element-wise sums of the numbers in the specified non-empty tensors.</summary>
        <returns>The result of multiplying the element-wise additions of the elements in each tensor.</returns>
        <remarks>
          <para>
            This method effectively computes:
            <c>
                Span&lt;T&gt; sums = ...;
                TensorPrimitives.Add(x, y, sums);
                T result = TensorPrimitives.Product(sums);
            </c>
            but without requiring additional temporary storage for the intermediate sums.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="y" /> must have the same length.</exception>
      </Docs>
    </Member>
    <Member MemberName="RadiansToDegrees&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void RadiansToDegrees&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RadiansToDegrees&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.RadiansToDegrees``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RadiansToDegrees(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member RadiansToDegrees : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.RadiansToDegrees (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void RadiansToDegrees(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise conversion of each number of radians in the specified tensor to degrees.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.RadiansToDegrees(<paramref name="x" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reciprocal&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reciprocal&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reciprocal&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Reciprocal``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reciprocal(Of T As IFloatingPoint(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Reciprocal : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Reciprocal (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static void Reciprocal(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise reciprocal of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = 1 / <paramref name="x" />[i]</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
        <exception cref="T:System.DivideByZeroException">
          <typeparamref name="T" /> is an integer type and an element in <paramref name="x" /> is equal to zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReciprocalEstimate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ReciprocalEstimate&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReciprocalEstimate&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ReciprocalEstimate``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReciprocalEstimate(Of T As IFloatingPointIeee754(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member ReciprocalEstimate : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.ReciprocalEstimate (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void ReciprocalEstimate(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise reciprocal of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = 1 / <paramref name="x" />[i]</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
        <exception cref="T:System.DivideByZeroException">
          <typeparamref name="T" /> is an integer type and an element in <paramref name="x" /> is equal to zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReciprocalSqrt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ReciprocalSqrt&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReciprocalSqrt&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ReciprocalSqrt``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReciprocalSqrt(Of T As IFloatingPointIeee754(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member ReciprocalSqrt : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.ReciprocalSqrt (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void ReciprocalSqrt(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise reciprocal of the square root of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = 1 / T.Sqrt(<paramref name="x" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
        <exception cref="T:System.DivideByZeroException">
          <typeparamref name="T" /> is an integer type and an element in <paramref name="x" /> is equal to zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReciprocalSqrtEstimate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ReciprocalSqrtEstimate&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReciprocalSqrtEstimate&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ReciprocalSqrtEstimate``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReciprocalSqrtEstimate(Of T As IFloatingPointIeee754(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member ReciprocalSqrtEstimate : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.ReciprocalSqrtEstimate (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void ReciprocalSqrtEstimate(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise reciprocal of the square root of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = 1 / T.Sqrt(<paramref name="x" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
        <exception cref="T:System.DivideByZeroException">
          <typeparamref name="T" /> is an integer type and an element in <paramref name="x" /> is equal to zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remainder&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Remainder&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.IModulusOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Remainder&lt;(class System.Numerics.IModulusOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Remainder``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Remainder(Of T As IModulusOperators(Of T, T, T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Remainder : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IModulusOperators&lt;'T, 'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IModulusOperators&lt;'T, 'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IModulusOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IModulusOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Remainder (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IModulusOperators&lt;T, T, T&gt; static void Remainder(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IModulusOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise remainder of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] % <paramref name="y" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise values are also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> or <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
        <exception cref="T:System.DivideByZeroException">
          <typeparamref name="T" /> is an integer type and an element in <paramref name="y" /> is equal to zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remainder&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Remainder&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.IModulusOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Remainder&lt;(class System.Numerics.IModulusOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Remainder``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Remainder(Of T As IModulusOperators(Of T, T, T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Remainder : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IModulusOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.IModulusOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IModulusOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Remainder (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IModulusOperators&lt;T, T, T&gt; static void Remainder(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IModulusOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise remainder of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] % <paramref name="y" /></c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise values are also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
        <exception cref="T:System.DivideByZeroException">
          <typeparamref name="T" /> is an integer type and <paramref name="y" /> is equal to zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remainder&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Remainder&lt;T&gt; (T x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.IModulusOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Remainder&lt;(class System.Numerics.IModulusOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(!!T x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Remainder``1(``0,System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Remainder(Of T As IModulusOperators(Of T, T, T)) (x As T, y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Remainder : 'T * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IModulusOperators&lt;'T, 'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IModulusOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IModulusOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Remainder (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IModulusOperators&lt;T, T, T&gt; static void Remainder(T x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IModulusOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise remainder of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" /> % <paramref name="y" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise values are also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
        <exception cref="T:System.DivideByZeroException">
          <typeparamref name="T" /> is an integer type and an element in <paramref name="y" /> is equal to zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="RootN&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void RootN&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, int n, Span&lt;T&gt; destination) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RootN&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, int32 n, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.RootN``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RootN(Of T As IRootFunctions(Of T)) (x As ReadOnlySpan(Of T), n As Integer, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member RootN : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; * int * Span&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.RootN (x, n, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static void RootN(ReadOnlySpan&lt;T&gt; x, int n, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="n" Type="System.Int32" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <param name="n">The degree of the root to be computed, represented as a scalar.</param>
        <summary>Computes the element-wise n-th root of the values in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.RootN(<paramref name="x" />[i], <paramref name="n" />)</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="RotateLeft&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void RotateLeft&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, int rotateAmount, Span&lt;T&gt; destination) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RotateLeft&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, int32 rotateAmount, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.RotateLeft``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RotateLeft(Of T As IBinaryInteger(Of T)) (x As ReadOnlySpan(Of T), rotateAmount As Integer, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member RotateLeft : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; * int * Span&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.RotateLeft (x, rotateAmount, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static void RotateLeft(ReadOnlySpan&lt;T&gt; x, int rotateAmount, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="rotateAmount" Type="System.Int32" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <param name="rotateAmount">The number of bits to rotate, represented as a scalar.</param>
        <summary>Computes the element-wise rotation left of numbers in the specified tensor by the specified rotation amount.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.RotateLeft(<paramref name="x" />[i], <paramref name="rotateAmount" />)</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="RotateRight&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void RotateRight&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, int rotateAmount, Span&lt;T&gt; destination) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RotateRight&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, int32 rotateAmount, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.RotateRight``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RotateRight(Of T As IBinaryInteger(Of T)) (x As ReadOnlySpan(Of T), rotateAmount As Integer, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member RotateRight : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; * int * Span&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.RotateRight (x, rotateAmount, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static void RotateRight(ReadOnlySpan&lt;T&gt; x, int rotateAmount, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="rotateAmount" Type="System.Int32" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <param name="rotateAmount">The number of bits to rotate, represented as a scalar.</param>
        <summary>Computes the element-wise rotation right of numbers in the specified tensor by the specified rotation amount.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.RotateRight(<paramref name="x" />[i], <paramref name="rotateAmount" />)</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Round&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Round&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Round&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Round``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Round(Of T As IFloatingPoint(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Round : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Round (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static void Round(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Round(<paramref name="x" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Round&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Round&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, int digits, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Round&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, int32 digits, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Round``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Round(Of T As IFloatingPoint(Of T)) (x As ReadOnlySpan(Of T), digits As Integer, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Round : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; * int * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Round (x, digits, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static void Round(ReadOnlySpan&lt;T&gt; x, int digits, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="digits" Type="System.Int32" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="digits">The number of fractional digits to which the numbers in <paramref name="x" /> should be rounded.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Round(<paramref name="x" />[i], <paramref name="digits" />)</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Round&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Round&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, MidpointRounding mode, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Round&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.MidpointRounding mode, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Round``1(System.ReadOnlySpan{``0},System.MidpointRounding,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Round(Of T As IFloatingPoint(Of T)) (x As ReadOnlySpan(Of T), mode As MidpointRounding, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Round : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; * MidpointRounding * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Round (x, mode, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static void Round(ReadOnlySpan&lt;T&gt; x, MidpointRounding mode, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="mode" Type="System.MidpointRounding" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="mode">The mode under which <paramref name="x" /> should be rounded.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Round(<paramref name="x" />[i], <paramref name="mode" />)</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Round&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Round&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, int digits, MidpointRounding mode, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Round&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, int32 digits, valuetype System.MidpointRounding mode, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Round``1(System.ReadOnlySpan{``0},System.Int32,System.MidpointRounding,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Round(Of T As IFloatingPoint(Of T)) (x As ReadOnlySpan(Of T), digits As Integer, mode As MidpointRounding, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Round : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; * int * MidpointRounding * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Round (x, digits, mode, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static void Round(ReadOnlySpan&lt;T&gt; x, int digits, MidpointRounding mode, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="digits" Type="System.Int32" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="mode" Type="System.MidpointRounding" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="digits">The number of fractional digits to which the numbers in <paramref name="x" /> should be rounded.</param>
        <param name="mode">The mode under which <paramref name="x" /> should be rounded.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Round(<paramref name="x" />[i], <paramref name="digits" />, <paramref name="mode" />)</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="mode" /> is invalid.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="digits" /> is invalid.</exception>
      </Docs>
    </Member>
    <Member MemberName="ScaleB&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ScaleB&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, int n, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ScaleB&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, int32 n, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ScaleB``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ScaleB(Of T As IFloatingPointIeee754(Of T)) (x As ReadOnlySpan(Of T), n As Integer, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member ScaleB : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * int * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.ScaleB (x, n, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void ScaleB(ReadOnlySpan&lt;T&gt; x, int n, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="n" Type="System.Int32" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="n">The value to which base-radix is raised before multipliying x, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise product of numbers in the specified tensor and their base-radix raised to the specified power.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.ILogB(<paramref name="x" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShiftLeft&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ShiftLeft&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, int shiftAmount, Span&lt;T&gt; destination) where T : System.Numerics.IShiftOperators&lt;T,int,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ShiftLeft&lt;(class System.Numerics.IShiftOperators`3&lt;!!T, int32, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, int32 shiftAmount, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ShiftLeft``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ShiftLeft(Of T As IShiftOperators(Of T, Integer, T)) (x As ReadOnlySpan(Of T), shiftAmount As Integer, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member ShiftLeft : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IShiftOperators&lt;'T, int, 'T&gt;)&gt; * int * Span&lt;'T (requires 'T :&gt; System.Numerics.IShiftOperators&lt;'T, int, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IShiftOperators&lt;'T, int, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.ShiftLeft (x, shiftAmount, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IShiftOperators&lt;T, int, T&gt; static void ShiftLeft(ReadOnlySpan&lt;T&gt; x, int shiftAmount, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IShiftOperators&lt;T,System.Int32,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="shiftAmount" Type="System.Int32" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <param name="shiftAmount">The number of bits to shift, represented as a scalar.</param>
        <summary>Computes the element-wise shifting left of numbers in the specified tensor by the specified shift amount.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] &lt;&lt; <paramref name="shiftAmount" /></c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShiftRightArithmetic&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ShiftRightArithmetic&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, int shiftAmount, Span&lt;T&gt; destination) where T : System.Numerics.IShiftOperators&lt;T,int,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ShiftRightArithmetic&lt;(class System.Numerics.IShiftOperators`3&lt;!!T, int32, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, int32 shiftAmount, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ShiftRightArithmetic``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ShiftRightArithmetic(Of T As IShiftOperators(Of T, Integer, T)) (x As ReadOnlySpan(Of T), shiftAmount As Integer, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member ShiftRightArithmetic : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IShiftOperators&lt;'T, int, 'T&gt;)&gt; * int * Span&lt;'T (requires 'T :&gt; System.Numerics.IShiftOperators&lt;'T, int, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IShiftOperators&lt;'T, int, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.ShiftRightArithmetic (x, shiftAmount, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IShiftOperators&lt;T, int, T&gt; static void ShiftRightArithmetic(ReadOnlySpan&lt;T&gt; x, int shiftAmount, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IShiftOperators&lt;T,System.Int32,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="shiftAmount" Type="System.Int32" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <param name="shiftAmount">The number of bits to shift, represented as a scalar.</param>
        <summary>Computes the element-wise arithmetic (signed) shifting right of numbers in the specified tensor by the specified shift amount.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] &gt;&gt; <paramref name="shiftAmount" /></c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShiftRightLogical&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ShiftRightLogical&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, int shiftAmount, Span&lt;T&gt; destination) where T : System.Numerics.IShiftOperators&lt;T,int,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ShiftRightLogical&lt;(class System.Numerics.IShiftOperators`3&lt;!!T, int32, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, int32 shiftAmount, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ShiftRightLogical``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ShiftRightLogical(Of T As IShiftOperators(Of T, Integer, T)) (x As ReadOnlySpan(Of T), shiftAmount As Integer, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member ShiftRightLogical : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IShiftOperators&lt;'T, int, 'T&gt;)&gt; * int * Span&lt;'T (requires 'T :&gt; System.Numerics.IShiftOperators&lt;'T, int, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IShiftOperators&lt;'T, int, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.ShiftRightLogical (x, shiftAmount, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IShiftOperators&lt;T, int, T&gt; static void ShiftRightLogical(ReadOnlySpan&lt;T&gt; x, int shiftAmount, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IShiftOperators&lt;T,System.Int32,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="shiftAmount" Type="System.Int32" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <param name="shiftAmount">The number of bits to shift, represented as a scalar.</param>
        <summary>Computes the element-wise logical (unsigned) shifting right of numbers in the specified tensor by the specified shift amount.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] &gt;&gt;&gt; <paramref name="shiftAmount" /></c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sigmoid">
      <MemberSignature Language="C#" Value="public static void Sigmoid (ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sigmoid(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Sigmoid(System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sigmoid (x As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Sigmoid : ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Sigmoid (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sigmoid(ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor.</param>
        <summary>Computes the element-wise sigmoid function on the specified non-empty tensor of single-precision floating-point numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = 1f / (1f + <see cref="T:System.MathF" />.Exp(-<paramref name="x" />[i]))</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sigmoid&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sigmoid&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sigmoid&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Sigmoid``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sigmoid(Of T As IExponentialFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Sigmoid : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Sigmoid (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static void Sigmoid(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor.</param>
        <summary>Computes the element-wise sigmoid function on the specified non-empty tensor of numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = 1f / (1f + <typeparamref name="T" />.Exp(-<paramref name="x" />[i]))</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sign&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sign&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;int&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sign&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;int32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Sign``1(System.ReadOnlySpan{``0},System.Span{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sign(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of Integer))" />
      <MemberSignature Language="F#" Value="static member Sign : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * Span&lt;int&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Sign (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static void Sign(ReadOnlySpan&lt;T&gt; x, Span&lt;int&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;System.Int32&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise sign of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Sign(<paramref name="x" />[i])</c>.
            If the value is less than 0, the result is -1; if the value is 0, the result is 0; if the value is greater than 0, the result is 1.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sin&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sin&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Sin``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sin(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Sin : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Sin (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void Sin(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise sine of the value in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Sin(<paramref name="x" />[i])</c>.
            </para>
          <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians(System.Single)" /> or multiply by <typeparamref name="T" />.Pi/180 to convert degrees to radians.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="SinCos&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void SinCos&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; sinDestination, Span&lt;T&gt; cosDestination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SinCos&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; sinDestination, valuetype System.Span`1&lt;!!T&gt; cosDestination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.SinCos``1(System.ReadOnlySpan{``0},System.Span{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SinCos(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), sinDestination As Span(Of T), cosDestination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member SinCos : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.SinCos (x, sinDestination, cosDestination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void SinCos(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; sinDestination, Span&lt;T&gt; cosDestination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="sinDestination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="cosDestination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="sinDestination">The destination tensor for the element-wise sine result, represented as a span.</param>
        <param name="cosDestination">The destination tensor for the element-wise cosine result, represented as a span.</param>
        <summary>Computes the element-wise sine and cosine of the value in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c>(<paramref name="sinDestination" />[i], <paramref name="cosDestination" />[i]) = <typeparamref name="T" />.SinCos(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="sinDestination" /> or <paramref name="cosDestination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="SinCosPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void SinCosPi&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; sinPiDestination, Span&lt;T&gt; cosPiDestination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SinCosPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; sinPiDestination, valuetype System.Span`1&lt;!!T&gt; cosPiDestination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.SinCosPi``1(System.ReadOnlySpan{``0},System.Span{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SinCosPi(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), sinPiDestination As Span(Of T), cosPiDestination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member SinCosPi : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.SinCosPi (x, sinPiDestination, cosPiDestination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void SinCosPi(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; sinPiDestination, Span&lt;T&gt; cosPiDestination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="sinPiDestination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="cosPiDestination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="sinPiDestination">The destination tensor for the element-wise sine result, represented as a span.</param>
        <param name="cosPiDestination">The destination tensor for the element-wise cosine result, represented as a span.</param>
        <summary>Computes the element-wise sine and cosine of the value in the specified tensor that has been multiplied by Pi.</summary>
        <remarks>
          <para>
            This method effectively computes <c>(<paramref name="sinPiDestination" />[i], <paramref name="cosPiDestination" />[i]) = <typeparamref name="T" />.SinCos(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="sinPiDestination" /> or <paramref name="cosPiDestination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static void Sinh (ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sinh(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Sinh(System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sinh (x As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Sinh : ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Sinh (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sinh(ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise hyperbolic sine of each single-precision floating-point radian angle in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <see cref="T:System.MathF" />.Sinh(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value is equal to <see cref="F:System.Single.NegativeInfinity" />, <see cref="F:System.Single.PositiveInfinity" />, or <see cref="F:System.Single.NaN" />,
            the corresponding destination location is set to that value.
            </para>
          <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians(System.Single)" /> or multiply by <see cref="F:System.MathF.PI" />/180 to convert degrees to radians.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sinh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sinh&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sinh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Sinh``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sinh(Of T As IHyperbolicFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Sinh : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Sinh (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static void Sinh(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise hyperbolic sine of each radian angle in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Sinh(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity" />, <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity" />, or <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />,
            the corresponding destination location is set to that value.
            </para>
          <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians(System.Single)" /> or multiply by <typeparamref name="T" />.Pi / 180 to convert degrees to radians.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="SinPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void SinPi&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SinPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.SinPi``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SinPi(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member SinPi : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.SinPi (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void SinPi(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise sine of the value in the specified tensor that has been multiplied by Pi.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.SinPi(<paramref name="x" />[i])</c>.
            </para>
          <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians(System.Single)" /> or multiply by <typeparamref name="T" />.Pi/180 to convert degrees to radians.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="SoftMax">
      <MemberSignature Language="C#" Value="public static void SoftMax (ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SoftMax(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.SoftMax(System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SoftMax (x As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member SoftMax : ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.SoftMax (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SoftMax(ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor.</param>
        <summary>Computes the softmax function over the specified non-empty tensor of single-precision floating-point numbers.</summary>
        <remarks>
          <para>
            This method effectively computes a sum of <c>MathF.Exp(x[i])</c> for all elements in <paramref name="x" />.
            It then effectively computes <c><paramref name="destination" />[i] = MathF.Exp(<paramref name="x" />[i]) / sum</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="SoftMax&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void SoftMax&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SoftMax&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.SoftMax``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SoftMax(Of T As IExponentialFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member SoftMax : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.SoftMax (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static void SoftMax(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor.</param>
        <summary>Computes the softmax function over the specified non-empty tensor of numbers.</summary>
        <remarks>
          <para>
            This method effectively computes a sum of <c><typeparamref name="T" />.Exp(x[i])</c> for all elements in <paramref name="x" />.
            It then effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Exp(<paramref name="x" />[i]) / sum</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sqrt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sqrt&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sqrt&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Sqrt``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sqrt(Of T As IRootFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Sqrt : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Sqrt (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static void Sqrt(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise square root of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Sqrt(<paramref name="x" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="StdDev&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T StdDev&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T StdDev&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.StdDev``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function StdDev(Of T As IRootFunctions(Of T)) (x As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member StdDev : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.StdDev x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static T StdDev(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes the standard deviation of all elements in the specified non-empty tensor of numbers.</summary>
        <returns>The standard deviation of all elements in <paramref name="x" />.</returns>
        <remarks>
          <para>
            If any of the input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the result value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static void Subtract (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Subtract(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Subtract(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Subtract (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Subtract : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Subtract (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Subtract(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise difference between single-precision floating-point numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] - <paramref name="y" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static void Subtract (ReadOnlySpan&lt;float&gt; x, float y, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Subtract(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, float32 y, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Subtract(System.ReadOnlySpan{System.Single},System.Single,System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Subtract (x As ReadOnlySpan(Of Single), y As Single, destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Subtract : ReadOnlySpan&lt;single&gt; * single * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Subtract (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Subtract(ReadOnlySpan&lt;float&gt; x, float y, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise difference between single-precision floating-point numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] - <paramref name="y" /></c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Subtract&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Subtract&lt;(class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Subtract``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Subtract(Of T As ISubtractionOperators(Of T, T, T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Subtract : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Subtract (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static void Subtract(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise difference between numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] - <paramref name="y" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Subtract&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Subtract&lt;(class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Subtract``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Subtract(Of T As ISubtractionOperators(Of T, T, T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Subtract : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Subtract (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static void Subtract(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise difference between numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] - <paramref name="y" /></c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Subtract&lt;T&gt; (T x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Subtract&lt;(class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(!!T x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Subtract``1(``0,System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Subtract(Of T As ISubtractionOperators(Of T, T, T)) (x As T, y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Subtract : 'T * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Subtract (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static void Subtract(T x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a scalar.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise difference between numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" /> - <paramref name="y" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static float Sum (ReadOnlySpan&lt;float&gt; x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum(valuetype System.ReadOnlySpan`1&lt;float32&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Sum(System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sum (x As ReadOnlySpan(Of Single)) As Single" />
      <MemberSignature Language="F#" Value="static member Sum : ReadOnlySpan&lt;single&gt; -&gt; single" Usage="System.Numerics.Tensors.TensorPrimitives.Sum x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Sum(ReadOnlySpan&lt;float&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes the sum of all elements in the specified tensor of single-precision floating-point numbers.</summary>
        <returns>The result of adding all elements in <paramref name="x" />, or zero if <paramref name="x" /> is empty.</returns>
        <remarks>
          <para>
            If any of the values in the input is equal to <see cref="F:System.Single.NaN" />, the result is also NaN.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Sum&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Sum&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Sum``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sum(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (x As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Sum : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Sum x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static T Sum(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes the sum of all elements in the specified tensor of numbers.</summary>
        <returns>The result of adding all elements in <paramref name="x" />, or zero if <paramref name="x" /> is empty.</returns>
        <remarks>
          <para>
            If any of the values in the input is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the result is also NaN.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SumOfMagnitudes">
      <MemberSignature Language="C#" Value="public static float SumOfMagnitudes (ReadOnlySpan&lt;float&gt; x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 SumOfMagnitudes(valuetype System.ReadOnlySpan`1&lt;float32&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.SumOfMagnitudes(System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SumOfMagnitudes (x As ReadOnlySpan(Of Single)) As Single" />
      <MemberSignature Language="F#" Value="static member SumOfMagnitudes : ReadOnlySpan&lt;single&gt; -&gt; single" Usage="System.Numerics.Tensors.TensorPrimitives.SumOfMagnitudes x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float SumOfMagnitudes(ReadOnlySpan&lt;float&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes the sum of the absolute values of every element in the specified tensor of single-precision floating-point numbers.</summary>
        <returns>The result of adding the absolute value of every element in <paramref name="x" />, or zero if <paramref name="x" /> is empty.</returns>
        <remarks>
          <para>
            This method effectively computes:
            <c>
                Span&lt;float&gt; absoluteValues = ...;
                TensorPrimitives.Abs(x, absoluteValues);
                float result = TensorPrimitives.Sum(absoluteValues);
            </c>
            but without requiring intermediate storage for the absolute values. It corresponds to the <c>asum</c> method defined by <c>BLAS1</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SumOfMagnitudes&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T SumOfMagnitudes&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T SumOfMagnitudes&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.SumOfMagnitudes``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SumOfMagnitudes(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member SumOfMagnitudes : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.SumOfMagnitudes x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static T SumOfMagnitudes(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes the sum of the absolute values of every element in the specified tensor of numbers.</summary>
        <returns>The result of adding the absolute value of every element in <paramref name="x" />, or zero if <paramref name="x" /> is empty.</returns>
        <remarks>
          <para>
            This method effectively computes:
            <c>
                Span&lt;T&gt; absoluteValues = ...;
                TensorPrimitives.Abs(x, absoluteValues);
                T result = TensorPrimitives.Sum(absoluteValues);
            </c>
            but without requiring intermediate storage for the absolute values. It corresponds to the <c>asum</c> method defined by <c>BLAS1</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.OverflowException">
          <typeparamref name="T" /> is a signed integer type and <paramref name="x" /> contained a value equal to <typeparamref name="T" />'s minimum value.</exception>
      </Docs>
    </Member>
    <Member MemberName="SumOfSquares">
      <MemberSignature Language="C#" Value="public static float SumOfSquares (ReadOnlySpan&lt;float&gt; x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 SumOfSquares(valuetype System.ReadOnlySpan`1&lt;float32&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.SumOfSquares(System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SumOfSquares (x As ReadOnlySpan(Of Single)) As Single" />
      <MemberSignature Language="F#" Value="static member SumOfSquares : ReadOnlySpan&lt;single&gt; -&gt; single" Usage="System.Numerics.Tensors.TensorPrimitives.SumOfSquares x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float SumOfSquares(ReadOnlySpan&lt;float&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes the sum of the square of every element in the specified tensor of single-precision floating-point numbers.</summary>
        <returns>The result of adding the square of every element in <paramref name="x" />, or zero if <paramref name="x" /> is empty.</returns>
        <remarks>
          <para>
            This method effectively computes:
            <c>
                Span&lt;float&gt; squaredValues = ...;
                TensorPrimitives.Multiply(x, x, squaredValues);
                float result = TensorPrimitives.Sum(squaredValues);
            </c>
            but without requiring intermediate storage for the squared values.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SumOfSquares&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T SumOfSquares&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T SumOfSquares&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.SumOfSquares``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SumOfSquares(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T), IMultiplyOperators(Of T, T, T)}) (x As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member SumOfSquares : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.SumOfSquares x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt; static T SumOfSquares(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes the sum of the square of every element in the specified tensor of numbers.</summary>
        <returns>The result of adding the square of every element in <paramref name="x" />, or zero if <paramref name="x" /> is empty.</returns>
        <remarks>
          <para>
            This method effectively computes:
            <c>
                Span&lt;T&gt; squaredValues = ...;
                TensorPrimitives.Multiply(x, x, squaredValues);
                T result = TensorPrimitives.Sum(squaredValues);
            </c>
            but without requiring intermediate storage for the squared values.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Tan&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Tan&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Tan``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Tan(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Tan : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Tan (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void Tan(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise tangent of the value in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Tan(<paramref name="x" />[i])</c>.
            </para>
          <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians(System.Single)" /> or multiply by <typeparamref name="T" />.Pi/180 to convert degrees to radians.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static void Tanh (ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Tanh(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Tanh(System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Tanh (x As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Tanh : ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Tanh (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Tanh(ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise hyperbolic tangent of each single-precision floating-point radian angle in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <see cref="T:System.MathF" />.Tanh(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value is equal to <see cref="F:System.Single.NegativeInfinity" />, the corresponding destination location is set to -1.
            If a value is equal to <see cref="F:System.Single.PositiveInfinity" />, the corresponding destination location is set to 1.
            If a value is equal to <see cref="F:System.Single.NaN" />, the corresponding destination location is set to NaN.
            </para>
          <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians(System.Single)" /> or multiply by <see cref="F:System.MathF.PI" />/180 to convert degrees to radians.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Tanh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Tanh&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Tanh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Tanh``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Tanh(Of T As IHyperbolicFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Tanh : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Tanh (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static void Tanh(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise hyperbolic tangent of each radian angle in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Tanh(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity" />, the corresponding destination location is set to -1.
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity" />, the corresponding destination location is set to 1.
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the corresponding destination location is set to NaN.
            </para>
          <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians(System.Single)" /> or multiply by <typeparamref name="T" />.Pi / 180 to convert degrees to radians.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="TanPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void TanPi&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TanPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.TanPi``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TanPi(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member TanPi : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.TanPi (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void TanPi(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise tangent of the value in the specified tensor that has been multiplied by Pi.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.TanPi(<paramref name="x" />[i])</c>.
            </para>
          <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians(System.Single)" /> or multiply by <typeparamref name="T" />.Pi/180 to convert degrees to radians.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="TrailingZeroCount&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void TrailingZeroCount&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TrailingZeroCount&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.TrailingZeroCount``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TrailingZeroCount(Of T As IBinaryInteger(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member TrailingZeroCount : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.TrailingZeroCount (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static void TrailingZeroCount(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise trailing zero count of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.TrailingZeroCount(<paramref name="x" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Truncate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Truncate&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Truncate&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Truncate``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Truncate(Of T As IFloatingPoint(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Truncate : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Truncate (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static void Truncate(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise truncation of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Truncate(<paramref name="x" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Xor&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Xor&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Xor&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Xor``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Xor(Of T As IBitwiseOperators(Of T, T, T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Xor : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Xor (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static void Xor(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise XOR of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] ^ <paramref name="y" />[i]</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Xor&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Xor&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Xor&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Xor``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Xor(Of T As IBitwiseOperators(Of T, T, T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Xor : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Xor (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static void Xor(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-10.0-pp;net-8.0-pp;net-9.0-pp">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise XOR of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] ^ <paramref name="y" /></c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
