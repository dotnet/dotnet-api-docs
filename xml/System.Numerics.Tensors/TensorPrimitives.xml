<Type Name="TensorPrimitives" FullName="System.Numerics.Tensors.TensorPrimitives">
  <TypeSignature Language="C#" Value="public static class TensorPrimitives" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit TensorPrimitives extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Tensors.TensorPrimitives" />
  <TypeSignature Language="VB.NET" Value="Public Class TensorPrimitives" />
  <TypeSignature Language="F#" Value="type TensorPrimitives = class" />
  <TypeSignature Language="C++ CLI" Value="public ref class TensorPrimitives abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Numerics.Tensors</AssemblyName>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>9.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Performs primitive tensor operations over spans of memory.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static void Abs (ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Abs(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Abs(System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Abs (x As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Abs : ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Abs (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Abs(ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise absolute value of each single-precision floating-point number in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = MathF.Abs(<paramref name="x" />[i])</c>.
            </para>
          <para>
            The absolute value of a <see cref="T:System.Single" /> is its numeric value without its sign. For example, the absolute value of both 1.2e-03 and -1.2e03 is 1.2e03.
            </para>
          <para>
            If a value is equal to <see cref="F:System.Single.NegativeInfinity" /> or <see cref="F:System.Single.PositiveInfinity" />, the result stored into the corresponding destination location is set to <see cref="F:System.Single.PositiveInfinity" />.
            If a value is equal to <see cref="F:System.Single.NaN" />, the result stored into the corresponding destination location is the original NaN value with the sign bit removed.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Abs&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Abs&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Abs&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Abs``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Abs(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Abs : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Abs (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void Abs(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise absolute value of each number in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Abs(<paramref name="x" />[i])</c>.
            </para>
          <para>
            The absolute value of a <typeparamref name="T" /> is its numeric value without its sign. For example, the absolute value of both 1.2e-03 and -1.2e03 is 1.2e03.
            </para>
          <para>
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity" /> or <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity" />, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity" />.
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the result stored into the corresponding destination location is the original NaN value with the sign bit removed.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
        <exception cref="T:System.OverflowException">
          <typeparamref name="T" /> is a signed integer type and <paramref name="x" /> contained a value equal to <typeparamref name="T" />'s minimum value.</exception>
      </Docs>
    </Member>
    <Member MemberName="Acos&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Acos&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Acos&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Acos``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Acos(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Acos : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Acos (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void Acos(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise angle in radians whose cosine is the specifed number.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Acos(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Acosh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Acosh&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Acosh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Acosh``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Acosh(Of T As IHyperbolicFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Acosh : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Acosh (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static void Acosh(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise hyperbolic arc-cosine of the specifed number.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Acosh(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcosPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void AcosPi&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AcosPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.AcosPi``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AcosPi(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member AcosPi : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.AcosPi (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void AcosPi(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise angle in radians whose cosine is the specifed number and divides the result by Pi.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.AcosPi(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static void Add (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Add(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Add(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Add (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Add : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Add (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Add(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise addition of single-precision floating-point numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] + <paramref name="y" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static void Add (ReadOnlySpan&lt;float&gt; x, float y, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Add(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, float32 y, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Add(System.ReadOnlySpan{System.Single},System.Single,System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Add (x As ReadOnlySpan(Of Single), y As Single, destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Add : ReadOnlySpan&lt;single&gt; * single * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Add (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Add(ReadOnlySpan&lt;float&gt; x, float y, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise addition of single-precision floating-point numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] + <paramref name="y" /></c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Add&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Add&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Add``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Add(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Add : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Add (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static void Add(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise addition of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] + <paramref name="y" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Add&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Add&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Add``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Add(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Add : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Add (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static void Add(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise addition of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] + <paramref name="y" /></c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddMultiply">
      <MemberSignature Language="C#" Value="public static void AddMultiply (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, ReadOnlySpan&lt;float&gt; multiplier, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMultiply(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y, valuetype System.ReadOnlySpan`1&lt;float32&gt; multiplier, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.AddMultiply(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMultiply (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single), multiplier As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member AddMultiply : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.AddMultiply (x, y, multiplier, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMultiply(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, ReadOnlySpan&lt;float&gt; multiplier, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="multiplier" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="multiplier">The third tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> + <paramref name="y" />) * <paramref name="multiplier" /></c> for the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] + <paramref name="y" />[i]) * <paramref name="multiplier" />[i]</c>.
            </para>
          <para>
            If any of the element-wise input values is equal to <see cref="F:System.Single.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="multiplier" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddMultiply">
      <MemberSignature Language="C#" Value="public static void AddMultiply (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, float multiplier, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMultiply(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y, float32 multiplier, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.AddMultiply(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Single,System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMultiply (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single), multiplier As Single, destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member AddMultiply : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; * single * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.AddMultiply (x, y, multiplier, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMultiply(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, float multiplier, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="multiplier" Type="System.Single" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="multiplier">The third tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> + <paramref name="y" />) * <paramref name="multiplier" /></c> for the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] + <paramref name="y" />[i]) * <paramref name="multiplier" /></c>.
            </para>
          <para>
            If any of the element-wise input values is equal to <see cref="F:System.Single.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddMultiply">
      <MemberSignature Language="C#" Value="public static void AddMultiply (ReadOnlySpan&lt;float&gt; x, float y, ReadOnlySpan&lt;float&gt; multiplier, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMultiply(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, float32 y, valuetype System.ReadOnlySpan`1&lt;float32&gt; multiplier, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.AddMultiply(System.ReadOnlySpan{System.Single},System.Single,System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMultiply (x As ReadOnlySpan(Of Single), y As Single, multiplier As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member AddMultiply : ReadOnlySpan&lt;single&gt; * single * ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.AddMultiply (x, y, multiplier, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMultiply(ReadOnlySpan&lt;float&gt; x, float y, ReadOnlySpan&lt;float&gt; multiplier, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="multiplier" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="multiplier">The third tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> + <paramref name="y" />) * <paramref name="multiplier" /></c> for the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] + <paramref name="y" />) * <paramref name="multiplier" />[i]</c>.
            </para>
          <para>
            If any of the element-wise input values is equal to <see cref="F:System.Single.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="multiplier" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddMultiply&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void AddMultiply&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, ReadOnlySpan&lt;T&gt; multiplier, Span&lt;T&gt; destination) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMultiply&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.ReadOnlySpan`1&lt;!!T&gt; multiplier, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.AddMultiply``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMultiply(Of T As {IAdditionOperators(Of T, T, T), IMultiplyOperators(Of T, T, T)}) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), multiplier As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member AddMultiply : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.AddMultiply (x, y, multiplier, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt; static void AddMultiply(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, ReadOnlySpan&lt;T&gt; multiplier, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="multiplier" Type="System.ReadOnlySpan&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="multiplier">The third tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> + <paramref name="y" />) * <paramref name="multiplier" /></c> for the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] + <paramref name="y" />[i]) * <paramref name="multiplier" />[i]</c>.
            </para>
          <para>
            If any of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="multiplier" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddMultiply&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void AddMultiply&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, T multiplier, Span&lt;T&gt; destination) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMultiply&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, !!T multiplier, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.AddMultiply``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMultiply(Of T As {IAdditionOperators(Of T, T, T), IMultiplyOperators(Of T, T, T)}) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), multiplier As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member AddMultiply : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.AddMultiply (x, y, multiplier, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt; static void AddMultiply(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, T multiplier, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="multiplier" Type="T" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="multiplier">The third tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> + <paramref name="y" />) * <paramref name="multiplier" /></c> for the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] + <paramref name="y" />[i]) * <paramref name="multiplier" /></c>.
            </para>
          <para>
            If any of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddMultiply&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void AddMultiply&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, ReadOnlySpan&lt;T&gt; multiplier, Span&lt;T&gt; destination) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMultiply&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.ReadOnlySpan`1&lt;!!T&gt; multiplier, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.AddMultiply``1(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMultiply(Of T As {IAdditionOperators(Of T, T, T), IMultiplyOperators(Of T, T, T)}) (x As ReadOnlySpan(Of T), y As T, multiplier As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member AddMultiply : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.AddMultiply (x, y, multiplier, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt; static void AddMultiply(ReadOnlySpan&lt;T&gt; x, T y, ReadOnlySpan&lt;T&gt; multiplier, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="multiplier" Type="System.ReadOnlySpan&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="multiplier">The third tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> + <paramref name="y" />) * <paramref name="multiplier" /></c> for the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] + <paramref name="y" />) * <paramref name="multiplier" />[i]</c>.
            </para>
          <para>
            If any of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="multiplier" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Asin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Asin&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Asin&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Asin``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Asin(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Asin : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Asin (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void Asin(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise angle in radians whose sine is the specifed number.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Asin(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Asinh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Asinh&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Asinh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Asinh``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Asinh(Of T As IHyperbolicFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Asinh : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Asinh (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static void Asinh(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise hyperbolic arc-sine of the specifed number.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Asinh(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsinPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void AsinPi&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AsinPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.AsinPi``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AsinPi(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member AsinPi : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.AsinPi (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void AsinPi(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise angle in radians whose sine is the specifed number and divides the result by Pi.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.AsinPi(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Atan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Atan&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Atan&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Atan``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Atan(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Atan : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Atan (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void Atan(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise angle in radians whose tangent is the specifed number.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Atan(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Atan2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Atan2&lt;T&gt; (ReadOnlySpan&lt;T&gt; y, ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Atan2&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Atan2``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Atan2(Of T As IFloatingPointIeee754(Of T)) (y As ReadOnlySpan(Of T), x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Atan2 : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Atan2 (y, x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void Atan2(ReadOnlySpan&lt;T&gt; y, ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="y">The first tensor, represented as a span.</param>
        <param name="x">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise arc-tangent for the quotient of two values in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Atan2(<paramref name="y" />[i], <paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Atan2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Atan2&lt;T&gt; (ReadOnlySpan&lt;T&gt; y, T x, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Atan2&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, !!T x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Atan2``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Atan2(Of T As IFloatingPointIeee754(Of T)) (y As ReadOnlySpan(Of T), x As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Atan2 : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Atan2 (y, x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void Atan2(ReadOnlySpan&lt;T&gt; y, T x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="x" Type="T" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="y">The first tensor, represented as a span.</param>
        <param name="x">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise arc-tangent for the quotient of two values in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Atan2(<paramref name="y" />[i], <paramref name="x" />)</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Atan2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Atan2&lt;T&gt; (T y, ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Atan2&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(!!T y, valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Atan2``1(``0,System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Atan2(Of T As IFloatingPointIeee754(Of T)) (y As T, x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Atan2 : 'T * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Atan2 (y, x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void Atan2(T y, ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="y" Type="T" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="y">The first tensor, represented as a scalar.</param>
        <param name="x">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise arc-tangent for the quotient of two values in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Atan2(<paramref name="y" />, <paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Atan2Pi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Atan2Pi&lt;T&gt; (ReadOnlySpan&lt;T&gt; y, ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Atan2Pi&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Atan2Pi``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Atan2Pi(Of T As IFloatingPointIeee754(Of T)) (y As ReadOnlySpan(Of T), x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Atan2Pi : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Atan2Pi (y, x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void Atan2Pi(ReadOnlySpan&lt;T&gt; y, ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="y">The first tensor, represented as a span.</param>
        <param name="x">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise arc-tangent for the quotient of two values in the specified tensors and divides the result by Pi.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Atan2(<paramref name="y" />[i], <paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Atan2Pi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Atan2Pi&lt;T&gt; (ReadOnlySpan&lt;T&gt; y, T x, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Atan2Pi&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, !!T x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Atan2Pi``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Atan2Pi(Of T As IFloatingPointIeee754(Of T)) (y As ReadOnlySpan(Of T), x As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Atan2Pi : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Atan2Pi (y, x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void Atan2Pi(ReadOnlySpan&lt;T&gt; y, T x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="x" Type="T" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="y">The first tensor, represented as a span.</param>
        <param name="x">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise arc-tangent for the quotient of two values in the specified tensors and divides the result by Pi.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Atan2(<paramref name="y" />[i], <paramref name="x" />)</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Atan2Pi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Atan2Pi&lt;T&gt; (T y, ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Atan2Pi&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(!!T y, valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Atan2Pi``1(``0,System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Atan2Pi(Of T As IFloatingPointIeee754(Of T)) (y As T, x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Atan2Pi : 'T * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Atan2Pi (y, x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void Atan2Pi(T y, ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="y" Type="T" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="y">The first tensor, represented as a scalar.</param>
        <param name="x">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise arc-tangent for the quotient of two values in the specified tensors and divides the result by Pi.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Atan2(<paramref name="y" />, <paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Atanh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Atanh&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Atanh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Atanh``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Atanh(Of T As IHyperbolicFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Atanh : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Atanh (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static void Atanh(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise hyperbolic arc-tangent of the specifed number.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Atanh(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="AtanPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void AtanPi&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AtanPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.AtanPi``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AtanPi(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member AtanPi : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.AtanPi (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void AtanPi(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise angle in radians whose tangent is the specifed number and divides the result by Pi.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.AtanPi(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="BitwiseAnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void BitwiseAnd&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BitwiseAnd&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.BitwiseAnd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BitwiseAnd(Of T As IBitwiseOperators(Of T, T, T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member BitwiseAnd : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.BitwiseAnd (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static void BitwiseAnd(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise bitwise AND of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] &amp; <paramref name="y" />[i]</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="BitwiseAnd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void BitwiseAnd&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BitwiseAnd&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.BitwiseAnd``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BitwiseAnd(Of T As IBitwiseOperators(Of T, T, T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member BitwiseAnd : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.BitwiseAnd (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static void BitwiseAnd(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise bitwise AND of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] &amp; <paramref name="y" /></c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="BitwiseOr&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void BitwiseOr&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BitwiseOr&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.BitwiseOr``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BitwiseOr(Of T As IBitwiseOperators(Of T, T, T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member BitwiseOr : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.BitwiseOr (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static void BitwiseOr(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise bitwise OR of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] | <paramref name="y" />[i]</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="BitwiseOr&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void BitwiseOr&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BitwiseOr&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.BitwiseOr``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BitwiseOr(Of T As IBitwiseOperators(Of T, T, T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member BitwiseOr : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.BitwiseOr (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static void BitwiseOr(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise bitwise OR of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] | <paramref name="y" /></c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cbrt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Cbrt&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Cbrt&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Cbrt``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Cbrt(Of T As IRootFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Cbrt : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Cbrt (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static void Cbrt(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise cube root of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Cbrt(<paramref name="x" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Ceiling&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Ceiling&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Ceiling&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Ceiling``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Ceiling(Of T As IFloatingPoint(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Ceiling : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Ceiling (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static void Ceiling(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise ceiling of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Ceiling(<paramref name="x" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertChecked&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static void ConvertChecked&lt;TFrom,TTo&gt; (ReadOnlySpan&lt;TFrom&gt; source, Span&lt;TTo&gt; destination) where TFrom : System.Numerics.INumberBase&lt;TFrom&gt; where TTo : System.Numerics.INumberBase&lt;TTo&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConvertChecked&lt;(class System.Numerics.INumberBase`1&lt;!!TFrom&gt;) TFrom, (class System.Numerics.INumberBase`1&lt;!!TTo&gt;) TTo&gt;(valuetype System.ReadOnlySpan`1&lt;!!TFrom&gt; source, valuetype System.Span`1&lt;!!TTo&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ConvertChecked``2(System.ReadOnlySpan{``0},System.Span{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConvertChecked(Of TFrom As INumberBase(Of TFrom), TTo As INumberBase(Of TFrom)) (source As ReadOnlySpan(Of TFrom), destination As Span(Of TTo))" />
      <MemberSignature Language="F#" Value="static member ConvertChecked : ReadOnlySpan&lt;'From (requires 'From :&gt; System.Numerics.INumberBase&lt;'From&gt;)&gt; * Span&lt;'o (requires 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)&gt; -&gt; unit (requires 'From :&gt; System.Numerics.INumberBase&lt;'From&gt; and 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.ConvertChecked (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; where TFrom : System::Numerics::INumberBase&lt;TFrom&gt; where TTo : System::Numerics::INumberBase&lt;TTo&gt; static void ConvertChecked(ReadOnlySpan&lt;TFrom&gt; source, Span&lt;TTo&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TFrom&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TTo&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;TFrom&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;TTo&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TFrom">To be added.</typeparam>
        <typeparam name="TTo">To be added.</typeparam>
        <param name="source">The source span from which to copy values.</param>
        <param name="destination">The destination span into which the converted values should be written.</param>
        <summary>
            Copies <paramref name="source" /> to <paramref name="destination" />, converting each <typeparamref name="TFrom" />
            value to a <typeparamref name="TTo" /> value.
            </summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = TTo.CreateChecked(<paramref name="source" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Destination is too short.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertSaturating&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static void ConvertSaturating&lt;TFrom,TTo&gt; (ReadOnlySpan&lt;TFrom&gt; source, Span&lt;TTo&gt; destination) where TFrom : System.Numerics.INumberBase&lt;TFrom&gt; where TTo : System.Numerics.INumberBase&lt;TTo&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConvertSaturating&lt;(class System.Numerics.INumberBase`1&lt;!!TFrom&gt;) TFrom, (class System.Numerics.INumberBase`1&lt;!!TTo&gt;) TTo&gt;(valuetype System.ReadOnlySpan`1&lt;!!TFrom&gt; source, valuetype System.Span`1&lt;!!TTo&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ConvertSaturating``2(System.ReadOnlySpan{``0},System.Span{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConvertSaturating(Of TFrom As INumberBase(Of TFrom), TTo As INumberBase(Of TFrom)) (source As ReadOnlySpan(Of TFrom), destination As Span(Of TTo))" />
      <MemberSignature Language="F#" Value="static member ConvertSaturating : ReadOnlySpan&lt;'From (requires 'From :&gt; System.Numerics.INumberBase&lt;'From&gt;)&gt; * Span&lt;'o (requires 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)&gt; -&gt; unit (requires 'From :&gt; System.Numerics.INumberBase&lt;'From&gt; and 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.ConvertSaturating (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; where TFrom : System::Numerics::INumberBase&lt;TFrom&gt; where TTo : System::Numerics::INumberBase&lt;TTo&gt; static void ConvertSaturating(ReadOnlySpan&lt;TFrom&gt; source, Span&lt;TTo&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TFrom&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TTo&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;TFrom&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;TTo&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TFrom">To be added.</typeparam>
        <typeparam name="TTo">To be added.</typeparam>
        <param name="source">The source span from which to copy values.</param>
        <param name="destination">The destination span into which the converted values should be written.</param>
        <summary>
            Copies <paramref name="source" /> to <paramref name="destination" />, converting each <typeparamref name="TFrom" />
            value to a <typeparamref name="TTo" /> value.
            </summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = TTo.CreateSaturating(<paramref name="source" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Destination is too short.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertToHalf">
      <MemberSignature Language="C#" Value="public static void ConvertToHalf (ReadOnlySpan&lt;float&gt; source, Span&lt;Half&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConvertToHalf(valuetype System.ReadOnlySpan`1&lt;float32&gt; source, valuetype System.Span`1&lt;valuetype System.Half&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ConvertToHalf(System.ReadOnlySpan{System.Single},System.Span{System.Half})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConvertToHalf (source As ReadOnlySpan(Of Single), destination As Span(Of Half))" />
      <MemberSignature Language="F#" Value="static member ConvertToHalf : ReadOnlySpan&lt;single&gt; * Span&lt;Half&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.ConvertToHalf (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ConvertToHalf(ReadOnlySpan&lt;float&gt; source, Span&lt;Half&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Single&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-8.0;net-8.0;net-9.0;net-7.0" />
        <Parameter Name="destination" Type="System.Span&lt;System.Half&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-8.0;net-8.0;net-9.0;net-7.0" />
      </Parameters>
      <Docs>
        <param name="source">The source span from which to copy values.</param>
        <param name="destination">The destination span into which the converted values should be written.</param>
        <summary>
            Copies <paramref name="source" /> to <paramref name="destination" />, converting each <see cref="T:System.Single" />
            value to its nearest representable half-precision floating-point value.
            </summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (Half)<paramref name="source" />[i]</c>.
            </para>
          <para>
            <paramref name="source" /> and <paramref name="destination" /> must not overlap. If they do, behavior is undefined.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Destination is too short.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertToSingle">
      <MemberSignature Language="C#" Value="public static void ConvertToSingle (ReadOnlySpan&lt;Half&gt; source, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConvertToSingle(valuetype System.ReadOnlySpan`1&lt;valuetype System.Half&gt; source, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ConvertToSingle(System.ReadOnlySpan{System.Half},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConvertToSingle (source As ReadOnlySpan(Of Half), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member ConvertToSingle : ReadOnlySpan&lt;Half&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.ConvertToSingle (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ConvertToSingle(ReadOnlySpan&lt;Half&gt; source, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Half&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-8.0;net-8.0;net-9.0;net-7.0" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-8.0;net-8.0;net-9.0;net-7.0" />
      </Parameters>
      <Docs>
        <param name="source">The source span from which to copy values.</param>
        <param name="destination">The destination span into which the converted values should be written.</param>
        <summary>
            Copies <paramref name="source" /> to <paramref name="destination" />, converting each half-precision
            floating-point value to its nearest representable <see cref="T:System.Single" /> value.
            </summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (float)<paramref name="source" />[i]</c>.
            </para>
          <para>
            <paramref name="source" /> and <paramref name="destination" /> must not overlap. If they do, behavior is undefined.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Destination is too short.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertTruncating&lt;TFrom,TTo&gt;">
      <MemberSignature Language="C#" Value="public static void ConvertTruncating&lt;TFrom,TTo&gt; (ReadOnlySpan&lt;TFrom&gt; source, Span&lt;TTo&gt; destination) where TFrom : System.Numerics.INumberBase&lt;TFrom&gt; where TTo : System.Numerics.INumberBase&lt;TTo&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConvertTruncating&lt;(class System.Numerics.INumberBase`1&lt;!!TFrom&gt;) TFrom, (class System.Numerics.INumberBase`1&lt;!!TTo&gt;) TTo&gt;(valuetype System.ReadOnlySpan`1&lt;!!TFrom&gt; source, valuetype System.Span`1&lt;!!TTo&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ConvertTruncating``2(System.ReadOnlySpan{``0},System.Span{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConvertTruncating(Of TFrom As INumberBase(Of TFrom), TTo As INumberBase(Of TFrom)) (source As ReadOnlySpan(Of TFrom), destination As Span(Of TTo))" />
      <MemberSignature Language="F#" Value="static member ConvertTruncating : ReadOnlySpan&lt;'From (requires 'From :&gt; System.Numerics.INumberBase&lt;'From&gt;)&gt; * Span&lt;'o (requires 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)&gt; -&gt; unit (requires 'From :&gt; System.Numerics.INumberBase&lt;'From&gt; and 'o :&gt; System.Numerics.INumberBase&lt;'o&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.ConvertTruncating (source, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TFrom, typename TTo&gt;&#xA; where TFrom : System::Numerics::INumberBase&lt;TFrom&gt; where TTo : System::Numerics::INumberBase&lt;TTo&gt; static void ConvertTruncating(ReadOnlySpan&lt;TFrom&gt; source, Span&lt;TTo&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFrom">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TFrom&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
        <TypeParameter Name="TTo">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TTo&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;TFrom&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;TTo&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TFrom">To be added.</typeparam>
        <typeparam name="TTo">To be added.</typeparam>
        <param name="source">The source span from which to copy values.</param>
        <param name="destination">The destination span into which the converted values should be written.</param>
        <summary>
            Copies <paramref name="source" /> to <paramref name="destination" />, converting each <typeparamref name="TFrom" />
            value to a <typeparamref name="TTo" /> value.
            </summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = TTo.CreateTruncating(<paramref name="source" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Destination is too short.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopySign&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void CopySign&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; sign, Span&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopySign&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; sign, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.CopySign``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopySign(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T), sign As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member CopySign : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.CopySign (x, sign, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static void CopySign(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; sign, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="sign" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="sign">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of copying the sign from one number to another number in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.CopySign(<paramref name="x" />[i], <paramref name="sign" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="sign" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopySign&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void CopySign&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T sign, Span&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CopySign&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T sign, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.CopySign``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CopySign(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T), sign As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member CopySign : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.CopySign (x, sign, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static void CopySign(ReadOnlySpan&lt;T&gt; x, T sign, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="sign" Type="T" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="sign">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of copying the sign from one number to another number in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.CopySign(<paramref name="x" />[i], <paramref name="sign" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cos&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Cos&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Cos&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Cos``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Cos(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Cos : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Cos (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void Cos(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise cosine of the value in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Cos(<paramref name="x" />[i])</c>.
            </para>
          <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians" /> or multiply by <typeparamref name="T" />.Pi/180 to convert degrees to radians.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static void Cosh (ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Cosh(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Cosh(System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Cosh (x As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Cosh : ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Cosh (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Cosh(ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise hyperbolic cosine of each single-precision floating-point radian angle in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <see cref="T:System.MathF" />.Cosh(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value is equal to <see cref="F:System.Single.NegativeInfinity" /> or <see cref="F:System.Single.PositiveInfinity" />, the result stored into the corresponding destination location is set to <see cref="F:System.Single.PositiveInfinity" />.
            If a value is equal to <see cref="F:System.Single.NaN" />, the result stored into the corresponding destination location is also NaN.
            </para>
          <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians" /> or multiply by <see cref="F:System.MathF.PI" />/180 to convert degrees to radians.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cosh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Cosh&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Cosh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Cosh``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Cosh(Of T As IHyperbolicFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Cosh : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Cosh (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static void Cosh(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise hyperbolic cosine of each radian angle in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Cosh(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity" /> or <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity" />, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity" />.
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the result stored into the corresponding destination location is also NaN.
            </para>
          <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians" /> or multiply by <typeparamref name="T" />.Pi/180 to convert degrees to radians.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="CosineSimilarity">
      <MemberSignature Language="C#" Value="public static float CosineSimilarity (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 CosineSimilarity(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.CosineSimilarity(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CosineSimilarity (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single)) As Single" />
      <MemberSignature Language="F#" Value="static member CosineSimilarity : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; -&gt; single" Usage="System.Numerics.Tensors.TensorPrimitives.CosineSimilarity (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float CosineSimilarity(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the cosine similarity between the two specified non-empty, equal-length tensors of single-precision floating-point numbers.</summary>
        <returns>The cosine similarity of the two tensors.</returns>
        <remarks>
          <para>
            This method effectively computes <c>TensorPrimitives.Dot(x, y) / (MathF.Sqrt(TensorPrimitives.SumOfSquares(x)) * MathF.Sqrt(TensorPrimitives.SumOfSquares(y)).</c></para>
          <para>
            If any element in either input tensor is equal to <see cref="F:System.Single.NegativeInfinity" />, <see cref="F:System.Single.PositiveInfinity" />, or <see cref="F:System.Single.NaN" />,
            NaN is returned.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="y" /> must not be empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="CosineSimilarity&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CosineSimilarity&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CosineSimilarity&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.CosineSimilarity``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CosineSimilarity(Of T As IRootFunctions(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member CosineSimilarity : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.CosineSimilarity (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static T CosineSimilarity(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the cosine similarity between the two specified non-empty, equal-length tensors of numbers.</summary>
        <returns>The cosine similarity of the two tensors.</returns>
        <remarks>
          <para>
            This method effectively computes <c>TensorPrimitives.Dot(x, y) / (<typeparamref name="T" />.Sqrt(TensorPrimitives.SumOfSquares(x)) * <typeparamref name="T" />.Sqrt(TensorPrimitives.SumOfSquares(y)).</c></para>
          <para>
            If any element in either input tensor is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity" />, <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity" />, or <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />,
            NaN is returned.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="y" /> must not be empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="CosPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void CosPi&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CosPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.CosPi``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CosPi(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member CosPi : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.CosPi (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void CosPi(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise cosine of the value in the specified tensor that has been multiplied by Pi.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.CosPi(<paramref name="x" />[i])</c>.
            </para>
          <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians" /> or multiply by <typeparamref name="T" />.Pi/180 to convert degrees to radians.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="DegreesToRadians&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void DegreesToRadians&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DegreesToRadians&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.DegreesToRadians``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DegreesToRadians(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member DegreesToRadians : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.DegreesToRadians (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void DegreesToRadians(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise conversion of each number of degrees in the specified tensor to radians.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.DegreesToRadians(<paramref name="x" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Distance">
      <MemberSignature Language="C#" Value="public static float Distance (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Distance(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Distance(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Distance (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single)) As Single" />
      <MemberSignature Language="F#" Value="static member Distance : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; -&gt; single" Usage="System.Numerics.Tensors.TensorPrimitives.Distance (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Distance(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the distance between two points, specified as non-empty, equal-length tensors of single-precision floating-point numbers, in Euclidean space.</summary>
        <returns>The Euclidean distance.</returns>
        <remarks>
          <para>
            This method effectively computes the equivalent of:
            <c>
                Span&lt;float&gt; difference = ...;
                TensorPrimitives.Subtract(x, y, difference);
                float result = MathF.Sqrt(TensorPrimitives.SumOfSquares(difference));
            </c>
            but without requiring additional temporary storage for the intermediate differences.
            </para>
          <para>
            If any element in either input tensor is equal to <see cref="F:System.Single.NaN" />, NaN is returned.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="y" /> must not be empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Distance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Distance&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Distance&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Distance``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Distance(Of T As IRootFunctions(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Distance : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Distance (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static T Distance(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the distance between two points, specified as non-empty, equal-length tensors of numbers, in Euclidean space.</summary>
        <returns>The Euclidean distance.</returns>
        <remarks>
          <para>
            This method effectively computes the equivalent of:
            <c>
                Span&lt;T&gt; difference = ...;
                TensorPrimitives.Subtract(x, y, difference);
                T result = <typeparamref name="T" />.Sqrt(TensorPrimitives.SumOfSquares(difference));
            </c>
            but without requiring additional temporary storage for the intermediate differences.
            </para>
          <para>
            If any element in either input tensor is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, NaN is returned.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="y" /> must not be empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static void Divide (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Divide(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Divide(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Divide (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Divide : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Divide (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Divide(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise division of single-precision floating-point numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] / <paramref name="y" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static void Divide (ReadOnlySpan&lt;float&gt; x, float y, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Divide(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, float32 y, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Divide(System.ReadOnlySpan{System.Single},System.Single,System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Divide (x As ReadOnlySpan(Of Single), y As Single, destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Divide : ReadOnlySpan&lt;single&gt; * single * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Divide (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Divide(ReadOnlySpan&lt;float&gt; x, float y, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise division of single-precision floating-point numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] / <paramref name="y" /></c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Divide&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Divide&lt;(class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Divide``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Divide(Of T As IDivisionOperators(Of T, T, T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Divide : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Divide (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IDivisionOperators&lt;T, T, T&gt; static void Divide(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise division of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] / <paramref name="y" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
        <exception cref="T:System.DivideByZeroException">
          <typeparamref name="T" /> is an integer type and an element in <paramref name="y" /> is equal to zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Divide&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Divide&lt;(class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Divide``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Divide(Of T As IDivisionOperators(Of T, T, T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Divide : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Divide (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IDivisionOperators&lt;T, T, T&gt; static void Divide(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise division of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] / <paramref name="y" /></c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
        <exception cref="T:System.DivideByZeroException">
          <typeparamref name="T" /> is an integer type and <paramref name="y" /> is equal to zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Divide&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Divide&lt;T&gt; (T x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.IDivisionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Divide&lt;(class System.Numerics.IDivisionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(!!T x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Divide``1(``0,System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Divide(Of T As IDivisionOperators(Of T, T, T)) (x As T, y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Divide : 'T * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IDivisionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Divide (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IDivisionOperators&lt;T, T, T&gt; static void Divide(T x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IDivisionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a scalar.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise division of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" /> / <paramref name="y" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
        <exception cref="T:System.DivideByZeroException">
          <typeparamref name="T" /> is an integer type and an element in <paramref name="y" /> is equal to zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dot">
      <MemberSignature Language="C#" Value="public static float Dot (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Dot(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Dot(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dot (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single)) As Single" />
      <MemberSignature Language="F#" Value="static member Dot : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; -&gt; single" Usage="System.Numerics.Tensors.TensorPrimitives.Dot (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Dot(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the dot product of two tensors containing single-precision floating-point numbers.</summary>
        <returns>The dot product.</returns>
        <remarks>
          <para>
            This method effectively computes the equivalent of:
            <c>
                Span&lt;float&gt; products = ...;
                TensorPrimitives.Multiply(x, y, products);
                float result = TensorPrimitives.Sum(products);
            </c>
            but without requiring additional temporary storage for the intermediate products. It corresponds to the <c>dot</c> method defined by <c>BLAS1</c>.
            </para>
          <para>
            If any of the input elements is equal to <see cref="F:System.Single.NaN" />, the resulting value is also NaN.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dot&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Dot&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Dot&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Dot``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Dot(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T), IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Dot : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Dot (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static T Dot(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the dot product of two tensors containing numbers.</summary>
        <returns>The dot product.</returns>
        <remarks>
          <para>
            This method effectively computes the equivalent of:
            <c>
                Span&lt;T&gt; products = ...;
                TensorPrimitives.Multiply(x, y, products);
                T result = TensorPrimitives.Sum(products);
            </c>
            but without requiring additional temporary storage for the intermediate products. It corresponds to the <c>dot</c> method defined by <c>BLAS1</c>.
            </para>
          <para>
            If any of the input elements is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting value is also NaN.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be same as length of <paramref name="y" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static void Exp (ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exp(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Exp(System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exp (x As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Exp : ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Exp (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exp(ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of raising <c>e</c> to the single-precision floating-point number powers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <see cref="T:System.MathF" />.Exp(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value equals <see cref="F:System.Single.NaN" /> or <see cref="F:System.Single.PositiveInfinity" />, the result stored into the corresponding destination location is set to NaN.
            If a value equals <see cref="F:System.Single.NegativeInfinity" />, the result stored into the corresponding destination location is set to 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exp&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Exp&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exp&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Exp``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exp(Of T As IExponentialFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Exp : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Exp (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static void Exp(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of raising <c>e</c> to the number powers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Exp(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value equals <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" /> or <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity" />, the result stored into the corresponding destination location is set to NaN.
            If a value equals <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity" />, the result stored into the corresponding destination location is set to 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exp10&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Exp10&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exp10&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Exp10``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exp10(Of T As IExponentialFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Exp10 : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Exp10 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static void Exp10(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of raising 10 to the number powers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Exp10(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exp10M1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Exp10M1&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exp10M1&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Exp10M1``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exp10M1(Of T As IExponentialFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Exp10M1 : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Exp10M1 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static void Exp10M1(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of raising 10 to the number powers in the specified tensor, minus one.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Exp10M1(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exp2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Exp2&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exp2&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Exp2``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exp2(Of T As IExponentialFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Exp2 : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Exp2 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static void Exp2(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of raising 2 to the number powers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Exp2(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exp2M1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Exp2M1&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exp2M1&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Exp2M1``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exp2M1(Of T As IExponentialFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Exp2M1 : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Exp2M1 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static void Exp2M1(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of raising 2 to the number powers in the specified tensor, minus one.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Exp2M1(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExpM1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ExpM1&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExpM1&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ExpM1``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExpM1(Of T As IExponentialFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member ExpM1 : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.ExpM1 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static void ExpM1(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of raising <c>e</c> to the number powers in the specified tensor, minus 1.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.ExpM1(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Floor&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Floor&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Floor&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Floor``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Floor(Of T As IFloatingPoint(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Floor : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Floor (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static void Floor(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise floor of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Floor(<paramref name="x" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="FusedMultiplyAdd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void FusedMultiplyAdd&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, ReadOnlySpan&lt;T&gt; addend, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FusedMultiplyAdd&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.ReadOnlySpan`1&lt;!!T&gt; addend, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FusedMultiplyAdd(Of T As IFloatingPointIeee754(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), addend As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member FusedMultiplyAdd : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAdd (x, y, addend, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void FusedMultiplyAdd(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, ReadOnlySpan&lt;T&gt; addend, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="addend" Type="System.ReadOnlySpan&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="addend">The third tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
          <para>
            This computes (<paramref name="x" /> * <paramref name="y" />) as if to infinite precision, adds <paramref name="addend" /> to that result as if to
            infinite precision, and finally rounds to the nearest representable value. This differs from the non-fused sequence which would compute
            (<paramref name="x" /> * <paramref name="y" />) as if to infinite precision, round the result to the nearest representable value, add <paramref name="addend" /> to the
            rounded result as if to infinite precision, and finally round to the nearest representable value.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="addend" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="FusedMultiplyAdd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void FusedMultiplyAdd&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, T addend, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FusedMultiplyAdd&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, !!T addend, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FusedMultiplyAdd(Of T As IFloatingPointIeee754(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), addend As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member FusedMultiplyAdd : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAdd (x, y, addend, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void FusedMultiplyAdd(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, T addend, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="addend" Type="T" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="addend">The third tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" /></c>.
            It corresponds to the <c>axpy</c> method defined by <c>BLAS1</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
          <para>
            This computes (<paramref name="x" /> * <paramref name="y" />) as if to infinite precision, adds <paramref name="addend" /> to that result as if to
            infinite precision, and finally rounds to the nearest representable value. This differs from the non-fused sequence which would compute
            (<paramref name="x" /> * <paramref name="y" />) as if to infinite precision, round the result to the nearest representable value, add <paramref name="addend" /> to the
            rounded result as if to infinite precision, and finally round to the nearest representable value.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="FusedMultiplyAdd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void FusedMultiplyAdd&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, ReadOnlySpan&lt;T&gt; addend, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FusedMultiplyAdd&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.ReadOnlySpan`1&lt;!!T&gt; addend, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAdd``1(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FusedMultiplyAdd(Of T As IFloatingPointIeee754(Of T)) (x As ReadOnlySpan(Of T), y As T, addend As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member FusedMultiplyAdd : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * 'T * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAdd (x, y, addend, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void FusedMultiplyAdd(ReadOnlySpan&lt;T&gt; x, T y, ReadOnlySpan&lt;T&gt; addend, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="addend" Type="System.ReadOnlySpan&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="addend">The third tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />) + <paramref name="addend" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
          <para>
            This computes (<paramref name="x" /> * <paramref name="y" />) as if to infinite precision, adds <paramref name="addend" /> to that result as if to
            infinite precision, and finally rounds to the nearest representable value. This differs from the non-fused sequence which would compute
            (<paramref name="x" /> * <paramref name="y" />) as if to infinite precision, round the result to the nearest representable value, add <paramref name="addend" /> to the
            rounded result as if to infinite precision, and finally round to the nearest representable value.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="addend" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="HammingBitDistance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static long HammingBitDistance&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 HammingBitDistance&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.HammingBitDistance``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HammingBitDistance(Of T As IBinaryInteger(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T)) As Long" />
      <MemberSignature Language="F#" Value="static member HammingBitDistance : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; -&gt; int64 (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.HammingBitDistance (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static long HammingBitDistance(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the bitwise Hamming distance between two equal-length tensors of values.</summary>
        <returns>The number of bits that differ between the two spans.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="y" /> must not be empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="HammingDistance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int HammingDistance&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 HammingDistance&lt;T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.HammingDistance``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HammingDistance(Of T) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member HammingDistance : ReadOnlySpan&lt;'T&gt; * ReadOnlySpan&lt;'T&gt; -&gt; int" Usage="System.Numerics.Tensors.TensorPrimitives.HammingDistance (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int HammingDistance(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the Hamming distance between two equal-length tensors of values.</summary>
        <returns>The number of elements that differ between the two spans.</returns>
        <remarks>
          <para>
            This method computes the number of locations <c>i</c> where <c>!EqualityComparer&gt;T&lt;.Default.Equal(x[i], y[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="y" /> must not be empty.</exception>
      </Docs>
    </Member>
    <Member MemberName="Hypot&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Hypot&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Hypot&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Hypot``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Hypot(Of T As IRootFunctions(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Hypot : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Hypot (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static void Hypot(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise hypotenuse given values from two tensors representing the lengths of the shorter sides in a right-angled triangle.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Hypot(<paramref name="x" />[i], <paramref name="x" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Ieee754Remainder&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Ieee754Remainder&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Ieee754Remainder&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Ieee754Remainder``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Ieee754Remainder(Of T As IFloatingPointIeee754(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Ieee754Remainder : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Ieee754Remainder (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void Ieee754Remainder(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise remainder of the numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Ieee754Remainder(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Ieee754Remainder&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Ieee754Remainder&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Ieee754Remainder&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Ieee754Remainder``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Ieee754Remainder(Of T As IFloatingPointIeee754(Of T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Ieee754Remainder : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Ieee754Remainder (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void Ieee754Remainder(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise remainder of the numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Ieee754Remainder(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Ieee754Remainder&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Ieee754Remainder&lt;T&gt; (T x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Ieee754Remainder&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(!!T x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Ieee754Remainder``1(``0,System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Ieee754Remainder(Of T As IFloatingPointIeee754(Of T)) (x As T, y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Ieee754Remainder : 'T * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Ieee754Remainder (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void Ieee754Remainder(T x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a scalar.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise remainder of the numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Ieee754Remainder(<paramref name="x" />, <paramref name="y" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="ILogB&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ILogB&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;int&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ILogB&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;int32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ILogB``1(System.ReadOnlySpan{``0},System.Span{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ILogB(Of T As IFloatingPointIeee754(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of Integer))" />
      <MemberSignature Language="F#" Value="static member ILogB : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * Span&lt;int&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.ILogB (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void ILogB(ReadOnlySpan&lt;T&gt; x, Span&lt;int&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;System.Int32&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise integer logarithm of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.ILogB(<paramref name="x" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMax">
      <MemberSignature Language="C#" Value="public static int IndexOfMax (ReadOnlySpan&lt;float&gt; x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMax(valuetype System.ReadOnlySpan`1&lt;float32&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMax(System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOfMax (x As ReadOnlySpan(Of Single)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMax : ReadOnlySpan&lt;single&gt; -&gt; int" Usage="System.Numerics.Tensors.TensorPrimitives.IndexOfMax x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOfMax(ReadOnlySpan&lt;float&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the index of the largest single-precision floating-point number in the specified tensor.</summary>
        <returns>The index of the maximum element in <paramref name="x" />, or -1 if <paramref name="x" /> is empty.</returns>
        <remarks>
          <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If any value equal to <see cref="F:System.Single.NaN" />
            is present, the index of the first is returned. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMax&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfMax&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMax&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMax``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOfMax(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMax : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IndexOfMax x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static int IndexOfMax(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the index of the largest number in the specified tensor.</summary>
        <returns>The index of the maximum element in <paramref name="x" />, or -1 if <paramref name="x" /> is empty.</returns>
        <remarks>
          <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If any value equal to NaN
            is present, the index of the first is returned. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMaxMagnitude">
      <MemberSignature Language="C#" Value="public static int IndexOfMaxMagnitude (ReadOnlySpan&lt;float&gt; x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMaxMagnitude(valuetype System.ReadOnlySpan`1&lt;float32&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMaxMagnitude(System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOfMaxMagnitude (x As ReadOnlySpan(Of Single)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMaxMagnitude : ReadOnlySpan&lt;single&gt; -&gt; int" Usage="System.Numerics.Tensors.TensorPrimitives.IndexOfMaxMagnitude x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOfMaxMagnitude(ReadOnlySpan&lt;float&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the index of the single-precision floating-point number with the largest magnitude in the specified tensor.</summary>
        <returns>The index of the element in <paramref name="x" /> with the largest magnitude (absolute value), or -1 if <paramref name="x" /> is empty.</returns>
        <remarks>
          <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `maximumMagnitude` function. If any value equal to <see cref="F:System.Single.NaN" />
            is present, the index of the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the positive value is considered to have the larger magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMaxMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfMaxMagnitude&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMaxMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMaxMagnitude``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOfMaxMagnitude(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMaxMagnitude : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IndexOfMaxMagnitude x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static int IndexOfMaxMagnitude(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the index of the number with the largest magnitude in the specified tensor.</summary>
        <returns>The index of the element in <paramref name="x" /> with the largest magnitude (absolute value), or -1 if <paramref name="x" /> is empty.</returns>
        <remarks>
          <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `maximumMagnitude` function. If any value equal to NaN
            is present, the index of the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the positive value is considered to have the larger magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMin">
      <MemberSignature Language="C#" Value="public static int IndexOfMin (ReadOnlySpan&lt;float&gt; x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMin(valuetype System.ReadOnlySpan`1&lt;float32&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMin(System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOfMin (x As ReadOnlySpan(Of Single)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMin : ReadOnlySpan&lt;single&gt; -&gt; int" Usage="System.Numerics.Tensors.TensorPrimitives.IndexOfMin x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOfMin(ReadOnlySpan&lt;float&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the index of the smallest single-precision floating-point number in the specified tensor.</summary>
        <returns>The index of the minimum element in <paramref name="x" />, or -1 if <paramref name="x" /> is empty.</returns>
        <remarks>
          <para>
            The determination of the minimum element matches the IEEE 754:2019 `minimum` function. If any value equal to <see cref="F:System.Single.NaN" />
            is present, the index of the first is returned. Negative 0 is considered smaller than positive 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfMin&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMin&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMin``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOfMin(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMin : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IndexOfMin x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static int IndexOfMin(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the index of the smallest number in the specified tensor.</summary>
        <returns>The index of the minimum element in <paramref name="x" />, or -1 if <paramref name="x" /> is empty.</returns>
        <remarks>
          <para>
            The determination of the minimum element matches the IEEE 754:2019 `minimum` function. If any value equal to NaN
            is present, the index of the first is returned. Negative 0 is considered smaller than positive 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMinMagnitude">
      <MemberSignature Language="C#" Value="public static int IndexOfMinMagnitude (ReadOnlySpan&lt;float&gt; x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMinMagnitude(valuetype System.ReadOnlySpan`1&lt;float32&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMinMagnitude(System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOfMinMagnitude (x As ReadOnlySpan(Of Single)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMinMagnitude : ReadOnlySpan&lt;single&gt; -&gt; int" Usage="System.Numerics.Tensors.TensorPrimitives.IndexOfMinMagnitude x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOfMinMagnitude(ReadOnlySpan&lt;float&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the index of the single-precision floating-point number with the smallest magnitude in the specified tensor.</summary>
        <returns>The index of the element in <paramref name="x" /> with the smallest magnitude (absolute value), or -1 if <paramref name="x" /> is empty.</returns>
        <remarks>
          <para>
            The determination of the minimum magnitude matches the IEEE 754:2019 `minimumMagnitude` function. If any value equal to <see cref="F:System.Single.NaN" />
            is present, the index of the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOfMinMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOfMinMagnitude&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOfMinMagnitude&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.IndexOfMinMagnitude``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOfMinMagnitude(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T)) As Integer" />
      <MemberSignature Language="F#" Value="static member IndexOfMinMagnitude : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; int (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.IndexOfMinMagnitude x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static int IndexOfMinMagnitude(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the index of the number with the smallest magnitude in the specified tensor.</summary>
        <returns>The index of the element in <paramref name="x" /> with the smallest magnitude (absolute value), or -1 if <paramref name="x" /> is empty.</returns>
        <remarks>
          <para>
            The determination of the minimum magnitude matches the IEEE 754:2019 `minimumMagnitude` function. If any value equal to NaN
            is present, the index of the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeadingZeroCount&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void LeadingZeroCount&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeadingZeroCount&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.LeadingZeroCount``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeadingZeroCount(Of T As IBinaryInteger(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member LeadingZeroCount : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.LeadingZeroCount (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static void LeadingZeroCount(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise leading zero count of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.LeadingZeroCount(<paramref name="x" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lerp&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Lerp&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, ReadOnlySpan&lt;T&gt; amount, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Lerp&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.ReadOnlySpan`1&lt;!!T&gt; amount, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Lerp``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Lerp(Of T As IFloatingPointIeee754(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), amount As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Lerp : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Lerp (x, y, amount, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void Lerp(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, ReadOnlySpan&lt;T&gt; amount, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="amount" Type="System.ReadOnlySpan&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="amount">The third tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise linear interpolation between two values based on the given weight in the specified tensors of numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Lerp(<paramref name="x" />[i], <paramref name="y" />[i], <paramref name="amount" />[i])</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="amount" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lerp&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Lerp&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, T amount, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Lerp&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, !!T amount, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Lerp``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Lerp(Of T As IFloatingPointIeee754(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), amount As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Lerp : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Lerp (x, y, amount, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void Lerp(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, T amount, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="amount" Type="T" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="amount">The third tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise linear interpolation between two values based on the given weight in the specified tensors of numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Lerp(<paramref name="x" />[i], <paramref name="y" />[i], <paramref name="amount" />)</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lerp&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Lerp&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, ReadOnlySpan&lt;T&gt; amount, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Lerp&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.ReadOnlySpan`1&lt;!!T&gt; amount, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Lerp``1(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Lerp(Of T As IFloatingPointIeee754(Of T)) (x As ReadOnlySpan(Of T), y As T, amount As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Lerp : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * 'T * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Lerp (x, y, amount, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void Lerp(ReadOnlySpan&lt;T&gt; x, T y, ReadOnlySpan&lt;T&gt; amount, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="amount" Type="System.ReadOnlySpan&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="amount">The third tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise linear interpolation between two values based on the given weight in the specified tensors of numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Lerp(<paramref name="x" />[i], <paramref name="y" />, <paramref name="amount" />[i])</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="amount" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static void Log (ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Log(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Log(System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Log (x As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Log : ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Log (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Log(ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise natural (base <c>e</c>) logarithm of single-precision floating-point numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <see cref="T:System.MathF" />.Log(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="F:System.Single.NegativeInfinity" />.
            If a value is negative or equal to <see cref="F:System.Single.NaN" />, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="F:System.Single.PositiveInfinity" />.
            Otherwise, if a value is positive, its natural logarithm is stored into the corresponding destination location.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Log&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Log&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Log&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Log``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Log(Of T As ILogarithmicFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Log : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Log (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static void Log(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise natural (base <c>e</c>) logarithm of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Log(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity" />.
            If a value is negative or equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity" />.
            Otherwise, if a value is positive, its natural logarithm is stored into the corresponding destination location.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Log&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Log&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Log&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Log``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Log(Of T As ILogarithmicFunctions(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Log : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Log (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static void Log(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise logarithm of the numbers in a specified tensor to the specified base in another specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Log(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Log&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Log&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Log&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Log``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Log(Of T As ILogarithmicFunctions(Of T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Log : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Log (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static void Log(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise logarithm of the numbers in a specified tensor to the specified base in another specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Log(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Log10&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Log10&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Log10&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Log10``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Log10(Of T As ILogarithmicFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Log10 : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Log10 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static void Log10(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise base 10 logarithm of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Log10(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity" />.
            If a value is negative or equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity" />.
            Otherwise, if a value is positive, its base 10 logarithm is stored into the corresponding destination location.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Log10P1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Log10P1&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Log10P1&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Log10P1``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Log10P1(Of T As ILogarithmicFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Log10P1 : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Log10P1 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static void Log10P1(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise base 10 logarithm of numbers in the specified tensor plus 1.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Log10P1(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity" />.
            If a value is negative or equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity" />.
            Otherwise, if a value is positive, its base 10 logarithm plus 1 is stored into the corresponding destination location.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Log2">
      <MemberSignature Language="C#" Value="public static void Log2 (ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Log2(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Log2(System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Log2 (x As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Log2 : ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Log2 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Log2(ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise base 2 logarithm of single-precision floating-point numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <see cref="T:System.MathF" />.Log2(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="F:System.Single.NegativeInfinity" />.
            If a value is negative or equal to <see cref="F:System.Single.NaN" />, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="F:System.Single.PositiveInfinity" />.
            Otherwise, if a value is positive, its natural logarithm is stored into the corresponding destination location.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Log2&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Log2&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Log2&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Log2``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Log2(Of T As ILogarithmicFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Log2 : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Log2 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static void Log2(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise base 2 logarithm of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Log2(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity" />.
            If a value is negative or equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity" />.
            Otherwise, if a value is positive, its base 2 logarithm is stored into the corresponding destination location.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Log2P1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Log2P1&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Log2P1&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Log2P1``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Log2P1(Of T As ILogarithmicFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Log2P1 : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Log2P1 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static void Log2P1(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise base 2 logarithm of numbers in the specified tensor plus 1.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Log2P1(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity" />.
            If a value is negative or equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity" />.
            Otherwise, if a value is positive, its base 2 logarithm plus 1 is stored into the corresponding destination location.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="LogP1&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void LogP1&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ILogarithmicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LogP1&lt;(class System.Numerics.ILogarithmicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.LogP1``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LogP1(Of T As ILogarithmicFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member LogP1 : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ILogarithmicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.LogP1 (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ILogarithmicFunctions&lt;T&gt; static void LogP1(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ILogarithmicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise natural (base <c>e</c>) logarithm of numbers in the specified tensor plus 1.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.LogP1(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value equals 0, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity" />.
            If a value is negative or equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the result stored into the corresponding destination location is set to NaN.
            If a value is positive infinity, the result stored into the corresponding destination location is set to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity" />.
            Otherwise, if a value is positive, its natural logarithm plus 1 is stored into the corresponding destination location.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static float Max (ReadOnlySpan&lt;float&gt; x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max(valuetype System.ReadOnlySpan`1&lt;float32&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Max(System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (x As ReadOnlySpan(Of Single)) As Single" />
      <MemberSignature Language="F#" Value="static member Max : ReadOnlySpan&lt;single&gt; -&gt; single" Usage="System.Numerics.Tensors.TensorPrimitives.Max x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Max(ReadOnlySpan&lt;float&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the largest single-precision floating-point number in the specified tensor.</summary>
        <returns>The maximum element in <paramref name="x" />.</returns>
        <remarks>
          <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If any value equal to <see cref="F:System.Single.NaN" />
            is present, the first is returned. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static void Max (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Max(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Max(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Max (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Max : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Max (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Max(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise maximum of the single-precision floating-point numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = MathF.Max(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
          <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If either value is equal to <see cref="F:System.Single.NaN" />,
            that value is stored as the result. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Max&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Max&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Max``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Max : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Max x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T Max(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the largest number in the specified tensor.</summary>
        <returns>The maximum element in <paramref name="x" />.</returns>
        <remarks>
          <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If any value equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />
            is present, the first is returned. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Max&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Max&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Max``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Max(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Max : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Max (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static void Max(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Max(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
          <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If either value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />,
            that value is stored as the result. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Max&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Max&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Max``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Max(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Max : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Max (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static void Max(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Max(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
          <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If either value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />,
            that value is stored as the result. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude">
      <MemberSignature Language="C#" Value="public static float MaxMagnitude (ReadOnlySpan&lt;float&gt; x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 MaxMagnitude(valuetype System.ReadOnlySpan`1&lt;float32&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MaxMagnitude(System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MaxMagnitude (x As ReadOnlySpan(Of Single)) As Single" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : ReadOnlySpan&lt;single&gt; -&gt; single" Usage="System.Numerics.Tensors.TensorPrimitives.MaxMagnitude x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float MaxMagnitude(ReadOnlySpan&lt;float&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the single-precision floating-point number with the largest magnitude in the specified tensor.</summary>
        <returns>The element in <paramref name="x" /> with the largest magnitude (absolute value).</returns>
        <remarks>
          <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `maximumMagnitude` function. If any value equal to <see cref="F:System.Single.NaN" />
            is present, the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the positive value is considered to have the larger magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude">
      <MemberSignature Language="C#" Value="public static void MaxMagnitude (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MaxMagnitude(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MaxMagnitude(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MaxMagnitude (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.MaxMagnitude (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MaxMagnitude(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise single-precision floating-point number with the largest magnitude in the specified tensors.</summary>
        <remarks>This method effectively computes <c><paramref name="destination" />[i] = MathF.MaxMagnitude(<paramref name="x" />[i], <paramref name="y" />[i])</c>.</remarks>
        <remarks>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MaxMagnitude&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MaxMagnitude&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MaxMagnitude``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MaxMagnitude(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MaxMagnitude x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static T MaxMagnitude(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the number with the largest magnitude in the specified tensor.</summary>
        <returns>The element in <paramref name="x" /> with the largest magnitude (absolute value).</returns>
        <remarks>
          <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `maximumMagnitude` function. If any value equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />
            is present, the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the positive value is considered to have the larger magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MaxMagnitude&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MaxMagnitude&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MaxMagnitude``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MaxMagnitude(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MaxMagnitude (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void MaxMagnitude(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the largest magnitude in the specified tensors.</summary>
        <remarks>This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.MaxMagnitude(<paramref name="x" />[i], <paramref name="y" />[i])</c>.</remarks>
        <remarks>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MaxMagnitude&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MaxMagnitude&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MaxMagnitude``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MaxMagnitude(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MaxMagnitude (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void MaxMagnitude(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the largest magnitude in the specified tensors.</summary>
        <remarks>This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.MaxMagnitude(<paramref name="x" />[i], <paramref name="y" />)</c>.</remarks>
        <remarks>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitudeNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MaxMagnitudeNumber&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MaxMagnitudeNumber&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MaxMagnitudeNumber``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MaxMagnitudeNumber(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MaxMagnitudeNumber : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MaxMagnitudeNumber x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static T MaxMagnitudeNumber(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the number with the largest magnitude in the specified tensor.</summary>
        <returns>The element in <paramref name="x" /> with the largest magnitude (absolute value).</returns>
        <remarks>
          <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `maximumMagnitudeNumber` function.
            If two values have the same magnitude and one is positive and the other is negative,
            the positive value is considered to have the larger magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitudeNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MaxMagnitudeNumber&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MaxMagnitudeNumber&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MaxMagnitudeNumber``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MaxMagnitudeNumber(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MaxMagnitudeNumber : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MaxMagnitudeNumber (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void MaxMagnitudeNumber(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the largest magnitude in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.MaxMagnitudeNumber(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
          <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `maximumMagnitudeNumber` function.
            If the two values have the same magnitude and one is positive and the other is negative,
            the positive value is considered to have the larger magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitudeNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MaxMagnitudeNumber&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MaxMagnitudeNumber&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MaxMagnitudeNumber``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MaxMagnitudeNumber(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MaxMagnitudeNumber : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MaxMagnitudeNumber (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void MaxMagnitudeNumber(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the largest magnitude in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.MaxMagnitudeNumber(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
          <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `maximumMagnitudeNumber` function.
            If the two values have the same magnitude and one is positive and the other is negative,
            the positive value is considered to have the larger magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MaxNumber&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MaxNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MaxNumber``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MaxNumber(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MaxNumber : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MaxNumber x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T MaxNumber(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the largest number in the specified tensor.</summary>
        <returns>The maximum element in <paramref name="x" />.</returns>
        <remarks>
          <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximumNumber` function. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MaxNumber&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MaxNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MaxNumber``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MaxNumber(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MaxNumber : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MaxNumber (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static void MaxNumber(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.MaxNumber(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
          <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximumNumber` function. If either value is <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />
            the other is returned. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MaxNumber&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MaxNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MaxNumber``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MaxNumber(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MaxNumber : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MaxNumber (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static void MaxNumber(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.MaxNumber(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
          <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximumNumber` function. If either value is <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />
            the other is returned. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static float Min (ReadOnlySpan&lt;float&gt; x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min(valuetype System.ReadOnlySpan`1&lt;float32&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Min(System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (x As ReadOnlySpan(Of Single)) As Single" />
      <MemberSignature Language="F#" Value="static member Min : ReadOnlySpan&lt;single&gt; -&gt; single" Usage="System.Numerics.Tensors.TensorPrimitives.Min x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Min(ReadOnlySpan&lt;float&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the smallest single-precision floating-point number in the specified tensor.</summary>
        <returns>The minimum element in <paramref name="x" />.</returns>
        <remarks>
          <para>
            The determination of the minimum element matches the IEEE 754:2019 `minimum` function. If any value is equal to <see cref="F:System.Single.NaN" />
            is present, the first is returned. Negative 0 is considered smaller than positive 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static void Min (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Min(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Min(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Min (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Min : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Min (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Min(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise minimum of the single-precision floating-point numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = MathF.Max(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
          <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If either value is equal to <see cref="F:System.Single.NaN" />,
            that value is stored as the result. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Min&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Min&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Min``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Min : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Min x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T Min(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the smallest number in the specified tensor.</summary>
        <returns>The minimum element in <paramref name="x" />.</returns>
        <remarks>
          <para>
            The determination of the minimum element matches the IEEE 754:2019 `minimum` function. If any value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />
            is present, the first is returned. Negative 0 is considered smaller than positive 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Min&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Min&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Min``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Min(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Min : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Min (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static void Min(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise minimum of the numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Max(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
          <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If either value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />,
            that value is stored as the result. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Min&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Min&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Min``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Min(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Min : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Min (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static void Min(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise minimum of the numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Max(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
          <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximum` function. If either value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />,
            that value is stored as the result. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude">
      <MemberSignature Language="C#" Value="public static float MinMagnitude (ReadOnlySpan&lt;float&gt; x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 MinMagnitude(valuetype System.ReadOnlySpan`1&lt;float32&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MinMagnitude(System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MinMagnitude (x As ReadOnlySpan(Of Single)) As Single" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : ReadOnlySpan&lt;single&gt; -&gt; single" Usage="System.Numerics.Tensors.TensorPrimitives.MinMagnitude x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float MinMagnitude(ReadOnlySpan&lt;float&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the single-precision floating-point number with the smallest magnitude in the specified tensor.</summary>
        <returns>The element in <paramref name="x" /> with the smallest magnitude (absolute value).</returns>
        <remarks>
          <para>
            The determination of the minimum magnitude matches the IEEE 754:2019 `minimumMagnitude` function. If any value equal to <see cref="F:System.Single.NaN" />
            is present, the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude">
      <MemberSignature Language="C#" Value="public static void MinMagnitude (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MinMagnitude(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MinMagnitude(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MinMagnitude (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.MinMagnitude (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MinMagnitude(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise single-precision floating-point number with the smallest magnitude in the specified tensors.</summary>
        <remarks>This method effectively computes <c><paramref name="destination" />[i] = MathF.MinMagnitude(<paramref name="x" />[i], <paramref name="y" />[i])</c>.</remarks>
        <remarks>
          <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `minimumMagnitude` function. If either value is equal to <see cref="F:System.Single.NaN" />,
            that value is stored as the result. If the two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MinMagnitude&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MinMagnitude&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MinMagnitude``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MinMagnitude(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MinMagnitude x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static T MinMagnitude(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the number with the smallest magnitude in the specified tensor.</summary>
        <returns>The element in <paramref name="x" /> with the smallest magnitude (absolute value).</returns>
        <remarks>
          <para>
            The determination of the minimum magnitude matches the IEEE 754:2019 `minimumMagnitude` function. If any value equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />
            is present, the first is returned. If two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MinMagnitude&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MinMagnitude&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MinMagnitude``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MinMagnitude(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MinMagnitude (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void MinMagnitude(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the smallest magnitude in the specified tensors.</summary>
        <remarks>This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.MinMagnitude(<paramref name="x" />[i], <paramref name="y" />[i])</c>.</remarks>
        <remarks>
          <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `minimumMagnitude` function. If either value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />,
            that value is stored as the result. If the two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MinMagnitude&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MinMagnitude&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MinMagnitude``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MinMagnitude(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MinMagnitude (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void MinMagnitude(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the smallest magnitude in the specified tensors.</summary>
        <remarks>This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.MinMagnitude(<paramref name="x" />[i], <paramref name="y" />)</c>.</remarks>
        <remarks>
          <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `minimumMagnitude` function. If either value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />,
            that value is stored as the result. If the two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitudeNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MinMagnitudeNumber&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MinMagnitudeNumber&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MinMagnitudeNumber``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MinMagnitudeNumber(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MinMagnitudeNumber : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MinMagnitudeNumber x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static T MinMagnitudeNumber(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the number with the smallest magnitude in the specified tensor.</summary>
        <returns>The element in <paramref name="x" /> with the smallest magnitude (absolute value).</returns>
        <remarks>
          <para>
            The determination of the minimum magnitude matches the IEEE 754:2019 `minimumMagnitudeNumber` function.
            If two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitudeNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MinMagnitudeNumber&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MinMagnitudeNumber&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MinMagnitudeNumber``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MinMagnitudeNumber(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MinMagnitudeNumber : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MinMagnitudeNumber (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void MinMagnitudeNumber(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the smallest magnitude in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.MinMagnitudeNumber(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
          <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `minimumMagnitudeNumber` function.
            If the two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitudeNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MinMagnitudeNumber&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MinMagnitudeNumber&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MinMagnitudeNumber``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MinMagnitudeNumber(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MinMagnitudeNumber : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MinMagnitudeNumber (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void MinMagnitudeNumber(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise number with the smallest magnitude in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.MinMagnitudeNumber(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
          <para>
            The determination of the maximum magnitude matches the IEEE 754:2019 `minimumMagnitudeNumber` function.
            If the two values have the same magnitude and one is positive and the other is negative,
            the negative value is considered to have the smaller magnitude.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MinNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T MinNumber&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T MinNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MinNumber``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MinNumber(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member MinNumber : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MinNumber x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static T MinNumber(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Searches for the largest number in the specified tensor.</summary>
        <returns>The maximum element in <paramref name="x" />.</returns>
        <remarks>
          <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximumNumber` function. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="MinNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MinNumber&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MinNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MinNumber``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MinNumber(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MinNumber : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MinNumber (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static void MinNumber(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.MinNumber(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
          <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximumNumber` function. If either value is <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />
            the other is returned. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MinNumber&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MinNumber&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.INumber&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MinNumber&lt;(class System.Numerics.INumber`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MinNumber``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MinNumber(Of T As INumber(Of T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MinNumber : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumber&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MinNumber (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumber&lt;T&gt; static void MinNumber(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise maximum of the numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.MinNumber(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
          <para>
            The determination of the maximum element matches the IEEE 754:2019 `maximumNumber` function. If either value is <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />
            the other is returned. Positive 0 is considered greater than negative 0.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static void Multiply (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Multiply(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Multiply(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Multiply (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Multiply : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Multiply (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Multiply(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise product of single-precision floating-point numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] * <paramref name="y" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static void Multiply (ReadOnlySpan&lt;float&gt; x, float y, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Multiply(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, float32 y, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Multiply(System.ReadOnlySpan{System.Single},System.Single,System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Multiply (x As ReadOnlySpan(Of Single), y As Single, destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Multiply : ReadOnlySpan&lt;single&gt; * single * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Multiply (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Multiply(ReadOnlySpan&lt;float&gt; x, float y, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise product of single-precision floating-point numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] * <paramref name="y" /></c>.
            It corresponds to the <c>scal</c> method defined by <c>BLAS1</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Multiply&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Multiply&lt;(class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Multiply``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Multiply(Of T As {IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Multiply : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Multiply (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static void Multiply(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise product of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] * <paramref name="y" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Multiply&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Multiply&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Multiply&lt;(class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Multiply``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Multiply(Of T As {IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Multiply : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Multiply (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static void Multiply(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise product of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] * <paramref name="y" /></c>.
            It corresponds to the <c>scal</c> method defined by <c>BLAS1</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAdd">
      <MemberSignature Language="C#" Value="public static void MultiplyAdd (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, ReadOnlySpan&lt;float&gt; addend, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MultiplyAdd(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y, valuetype System.ReadOnlySpan`1&lt;float32&gt; addend, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MultiplyAdd (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single), addend As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member MultiplyAdd : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.MultiplyAdd (x, y, addend, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MultiplyAdd(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, ReadOnlySpan&lt;float&gt; addend, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="addend" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="addend">The third tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of single-precision floating-point numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="addend" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAdd">
      <MemberSignature Language="C#" Value="public static void MultiplyAdd (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, float addend, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MultiplyAdd(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y, float32 addend, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Single,System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MultiplyAdd (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single), addend As Single, destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member MultiplyAdd : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; * single * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.MultiplyAdd (x, y, addend, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MultiplyAdd(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, float addend, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="addend" Type="System.Single" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="addend">The third tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of single-precision floating-point numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" /></c>.
            It corresponds to the <c>axpy</c> method defined by <c>BLAS1</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAdd">
      <MemberSignature Language="C#" Value="public static void MultiplyAdd (ReadOnlySpan&lt;float&gt; x, float y, ReadOnlySpan&lt;float&gt; addend, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MultiplyAdd(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, float32 y, valuetype System.ReadOnlySpan`1&lt;float32&gt; addend, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd(System.ReadOnlySpan{System.Single},System.Single,System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MultiplyAdd (x As ReadOnlySpan(Of Single), y As Single, addend As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member MultiplyAdd : ReadOnlySpan&lt;single&gt; * single * ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.MultiplyAdd (x, y, addend, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MultiplyAdd(ReadOnlySpan&lt;float&gt; x, float y, ReadOnlySpan&lt;float&gt; addend, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="addend" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="addend">The third tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of single-precision floating-point numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />) + <paramref name="addend" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="addend" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAdd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MultiplyAdd&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, ReadOnlySpan&lt;T&gt; addend, Span&lt;T&gt; destination) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MultiplyAdd&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.ReadOnlySpan`1&lt;!!T&gt; addend, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MultiplyAdd(Of T As {IAdditionOperators(Of T, T, T), IMultiplyOperators(Of T, T, T)}) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), addend As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MultiplyAdd : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MultiplyAdd (x, y, addend, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt; static void MultiplyAdd(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, ReadOnlySpan&lt;T&gt; addend, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="addend" Type="System.ReadOnlySpan&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="addend">The third tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="addend" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAdd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MultiplyAdd&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, T addend, Span&lt;T&gt; destination) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MultiplyAdd&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, !!T addend, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MultiplyAdd(Of T As {IAdditionOperators(Of T, T, T), IMultiplyOperators(Of T, T, T)}) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), addend As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MultiplyAdd : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MultiplyAdd (x, y, addend, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt; static void MultiplyAdd(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, T addend, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="addend" Type="T" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="addend">The third tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" /></c>.
            It corresponds to the <c>axpy</c> method defined by <c>BLAS1</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAdd&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MultiplyAdd&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, ReadOnlySpan&lt;T&gt; addend, Span&lt;T&gt; destination) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MultiplyAdd&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.ReadOnlySpan`1&lt;!!T&gt; addend, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd``1(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MultiplyAdd(Of T As {IAdditionOperators(Of T, T, T), IMultiplyOperators(Of T, T, T)}) (x As ReadOnlySpan(Of T), y As T, addend As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MultiplyAdd : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MultiplyAdd (x, y, addend, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt; static void MultiplyAdd(ReadOnlySpan&lt;T&gt; x, T y, ReadOnlySpan&lt;T&gt; addend, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="addend" Type="System.ReadOnlySpan&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="addend">The third tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />) + <paramref name="addend" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="addend" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAddEstimate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MultiplyAddEstimate&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, ReadOnlySpan&lt;T&gt; addend, Span&lt;T&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MultiplyAddEstimate&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.ReadOnlySpan`1&lt;!!T&gt; addend, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAddEstimate``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MultiplyAddEstimate(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), addend As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MultiplyAddEstimate : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MultiplyAddEstimate (x, y, addend, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void MultiplyAddEstimate(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, ReadOnlySpan&lt;T&gt; addend, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="addend" Type="System.ReadOnlySpan&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="addend">The third tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
          <para>
            Behaves the same as either <see cref="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" /> or
            <see cref="M:System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" /> depending on the current machine's capabilities.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="addend" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAddEstimate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MultiplyAddEstimate&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, T addend, Span&lt;T&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MultiplyAddEstimate&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, !!T addend, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAddEstimate``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MultiplyAddEstimate(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), addend As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MultiplyAddEstimate : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MultiplyAddEstimate (x, y, addend, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void MultiplyAddEstimate(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, T addend, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="addend" Type="T" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="addend">The third tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />[i]) + <paramref name="addend" /></c>.
            It corresponds to the <c>axpy</c> method defined by <c>BLAS1</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
          <para>
            Behaves the same as either <see cref="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})" /> or
            <see cref="M:System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAdd``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},``0,System.Span{``0})" /> depending on the current machine's capabilities.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="MultiplyAddEstimate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void MultiplyAddEstimate&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, ReadOnlySpan&lt;T&gt; addend, Span&lt;T&gt; destination) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MultiplyAddEstimate&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.ReadOnlySpan`1&lt;!!T&gt; addend, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAddEstimate``1(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MultiplyAddEstimate(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T), y As T, addend As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member MultiplyAddEstimate : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * 'T * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.MultiplyAddEstimate (x, y, addend, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static void MultiplyAddEstimate(ReadOnlySpan&lt;T&gt; x, T y, ReadOnlySpan&lt;T&gt; addend, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="addend" Type="System.ReadOnlySpan&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="addend">The third tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise result of <c>(<paramref name="x" /> * <paramref name="y" />) + <paramref name="addend" /></c> for the specified tensors of numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = (<paramref name="x" />[i] * <paramref name="y" />) + <paramref name="addend" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
          <para>
            Behaves the same as either <see cref="M:System.Numerics.Tensors.TensorPrimitives.MultiplyAdd``1(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})" /> or
            <see cref="M:System.Numerics.Tensors.TensorPrimitives.FusedMultiplyAdd``1(System.ReadOnlySpan{``0},``0,System.ReadOnlySpan{``0},System.Span{``0})" /> depending on the current machine's capabilities.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="addend" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static void Negate (ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Negate(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Negate(System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Negate (x As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Negate : ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Negate (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Negate(ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise negation of each single-precision floating-point number in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = -<paramref name="x" />[i]</c>.
            </para>
          <para>
            If any of the element-wise input values is equal to <see cref="F:System.Single.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Negate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Negate&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IUnaryNegationOperators&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Negate&lt;(class System.Numerics.IUnaryNegationOperators`2&lt;!!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Negate``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Negate(Of T As IUnaryNegationOperators(Of T, T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Negate : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IUnaryNegationOperators&lt;'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IUnaryNegationOperators&lt;'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IUnaryNegationOperators&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Negate (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IUnaryNegationOperators&lt;T, T&gt; static void Negate(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IUnaryNegationOperators&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise negation of each number in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = -<paramref name="x" />[i]</c>.
            </para>
          <para>
            If any of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Norm">
      <MemberSignature Language="C#" Value="public static float Norm (ReadOnlySpan&lt;float&gt; x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Norm(valuetype System.ReadOnlySpan`1&lt;float32&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Norm(System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Norm (x As ReadOnlySpan(Of Single)) As Single" />
      <MemberSignature Language="F#" Value="static member Norm : ReadOnlySpan&lt;single&gt; -&gt; single" Usage="System.Numerics.Tensors.TensorPrimitives.Norm x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Norm(ReadOnlySpan&lt;float&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <summary>Computes the Euclidean norm of the specified tensor of single-precision floating-point numbers.</summary>
        <returns>The norm.</returns>
        <remarks>
          <para>
            This method effectively computes <c>MathF.Sqrt(TensorPrimitives.SumOfSquares(x))</c>.
            This is often referred to as the Euclidean norm or L2 norm.
            It corresponds to the <c>nrm2</c> method defined by <c>BLAS1</c>.
            </para>
          <para>
            If any of the input values is equal to <see cref="F:System.Single.NaN" />, the result value is also NaN.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Norm&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Norm&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Norm&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Norm``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Norm(Of T As IRootFunctions(Of T)) (x As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Norm : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Norm x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static T Norm(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <summary>Computes the Euclidean norm of the specified tensor of numbers.</summary>
        <returns>The norm.</returns>
        <remarks>
          <para>
            This method effectively computes <c><typeparamref name="T" />.Sqrt(TensorPrimitives.SumOfSquares(x))</c>.
            This is often referred to as the Euclidean norm or L2 norm.
            It corresponds to the <c>nrm2</c> method defined by <c>BLAS1</c>.
            </para>
          <para>
            If any of the input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the result value is also NaN.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnesComplement&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void OnesComplement&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void OnesComplement&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.OnesComplement``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub OnesComplement(Of T As IBitwiseOperators(Of T, T, T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member OnesComplement : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.OnesComplement (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static void OnesComplement(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise one's complement of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = ~<paramref name="x" />[i]</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="PopCount&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static long PopCount&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 PopCount&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.PopCount``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PopCount(Of T As IBinaryInteger(Of T)) (x As ReadOnlySpan(Of T)) As Long" />
      <MemberSignature Language="F#" Value="static member PopCount : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; -&gt; int64 (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.PopCount x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static long PopCount(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes the population count of all elements in the specified tensor.</summary>
        <returns>The sum of the number of bits set in each element in <paramref name="x" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PopCount&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void PopCount&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PopCount&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.PopCount``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PopCount(Of T As IBinaryInteger(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member PopCount : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.PopCount (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static void PopCount(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise population count of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.PopCount(<paramref name="x" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pow&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Pow&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.IPowerFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pow&lt;(class System.Numerics.IPowerFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Pow``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pow(Of T As IPowerFunctions(Of T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Pow : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Pow (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IPowerFunctions&lt;T&gt; static void Pow(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IPowerFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise power of a number in a specified tensor raised to a number in another specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Pow(<paramref name="x" />[i], <paramref name="y" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pow&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Pow&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.IPowerFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pow&lt;(class System.Numerics.IPowerFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Pow``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pow(Of T As IPowerFunctions(Of T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Pow : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Pow (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IPowerFunctions&lt;T&gt; static void Pow(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IPowerFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise power of a number in a specified tensor raised to a number in another specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Pow(<paramref name="x" />[i], <paramref name="y" />)</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pow&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Pow&lt;T&gt; (T x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.IPowerFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pow&lt;(class System.Numerics.IPowerFunctions`1&lt;!!T&gt;) T&gt;(!!T x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Pow``1(``0,System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pow(Of T As IPowerFunctions(Of T)) (x As T, y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Pow : 'T * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IPowerFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Pow (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IPowerFunctions&lt;T&gt; static void Pow(T x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IPowerFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a scalar.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise power of a number in a specified tensor raised to a number in another specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Pow(<paramref name="x" />, <paramref name="y" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Product">
      <MemberSignature Language="C#" Value="public static float Product (ReadOnlySpan&lt;float&gt; x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Product(valuetype System.ReadOnlySpan`1&lt;float32&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Product(System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Product (x As ReadOnlySpan(Of Single)) As Single" />
      <MemberSignature Language="F#" Value="static member Product : ReadOnlySpan&lt;single&gt; -&gt; single" Usage="System.Numerics.Tensors.TensorPrimitives.Product x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Product(ReadOnlySpan&lt;float&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes the product of all elements in the specified non-empty tensor of single-precision floating-point numbers.</summary>
        <returns>The result of multiplying all elements in <paramref name="x" />.</returns>
        <remarks>
          <para>
            If any of the input values is equal to <see cref="F:System.Single.NaN" />, the result value is also NaN.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Product&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Product&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Product&lt;(class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Product``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Product(Of T As {IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (x As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Product : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Product x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static T Product(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes the product of all elements in the specified non-empty tensor of numbers.</summary>
        <returns>The result of multiplying all elements in <paramref name="x" />.</returns>
        <remarks>
          <para>
            If any of the input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the result value is also NaN.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">Length of <paramref name="x" /> must be greater than zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProductOfDifferences">
      <MemberSignature Language="C#" Value="public static float ProductOfDifferences (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ProductOfDifferences(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ProductOfDifferences(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ProductOfDifferences (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single)) As Single" />
      <MemberSignature Language="F#" Value="static member ProductOfDifferences : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; -&gt; single" Usage="System.Numerics.Tensors.TensorPrimitives.ProductOfDifferences (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float ProductOfDifferences(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the product of the element-wise differences of the single-precision floating-point numbers in the specified non-empty tensors.</summary>
        <returns>The result of multiplying the element-wise subtraction of the elements in the second tensor from the first tensor.</returns>
        <remarks>
          <para>
            This method effectively computes:
            <c>
                Span&lt;float&gt; differences = ...;
                TensorPrimitives.Subtract(x, y, differences);
                float result = TensorPrimitives.Product(differences);
            </c>
            but without requiring additional temporary storage for the intermediate differences.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="y" /> must have the same length.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProductOfDifferences&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T ProductOfDifferences&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y) where T : System.Numerics.ISubtractionOperators&lt;T,T,T&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T ProductOfDifferences&lt;(class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ProductOfDifferences``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ProductOfDifferences(Of T As {ISubtractionOperators(Of T, T, T), IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member ProductOfDifferences : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.ProductOfDifferences (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ISubtractionOperators&lt;T, T, T&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static T ProductOfDifferences(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the product of the element-wise differences of the numbers in the specified non-empty tensors.</summary>
        <returns>The result of multiplying the element-wise subtraction of the elements in the second tensor from the first tensor.</returns>
        <remarks>
          <para>
            This method effectively computes:
            <c>
                Span&lt;T&gt; differences = ...;
                TensorPrimitives.Subtract(x, y, differences);
                T result = TensorPrimitives.Product(differences);
            </c>
            but without requiring additional temporary storage for the intermediate differences.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="y" /> must have the same length.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProductOfSums">
      <MemberSignature Language="C#" Value="public static float ProductOfSums (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ProductOfSums(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ProductOfSums(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ProductOfSums (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single)) As Single" />
      <MemberSignature Language="F#" Value="static member ProductOfSums : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; -&gt; single" Usage="System.Numerics.Tensors.TensorPrimitives.ProductOfSums (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float ProductOfSums(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the product of the element-wise sums of the single-precision floating-point numbers in the specified non-empty tensors.</summary>
        <returns>The result of multiplying the element-wise additions of the elements in each tensor.</returns>
        <remarks>
          <para>
            This method effectively computes:
            <c>
                Span&lt;float&gt; sums = ...;
                TensorPrimitives.Add(x, y, sums);
                float result = TensorPrimitives.Product(sums);
            </c>
            but without requiring additional temporary storage for the intermediate sums.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="y" /> must have the same length.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProductOfSums&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T ProductOfSums&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;, System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T ProductOfSums&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ProductOfSums``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ProductOfSums(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T), IMultiplyOperators(Of T, T, T), IMultiplicativeIdentity(Of T, T)}) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member ProductOfSums : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplicativeIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.ProductOfSums (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt;, System::Numerics::IMultiplicativeIdentity&lt;T, T&gt; static T ProductOfSums(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <summary>Computes the product of the element-wise sums of the numbers in the specified non-empty tensors.</summary>
        <returns>The result of multiplying the element-wise additions of the elements in each tensor.</returns>
        <remarks>
          <para>
            This method effectively computes:
            <c>
                Span&lt;T&gt; sums = ...;
                TensorPrimitives.Add(x, y, sums);
                T result = TensorPrimitives.Product(sums);
            </c>
            but without requiring additional temporary storage for the intermediate sums.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="y" /> must have the same length.</exception>
      </Docs>
    </Member>
    <Member MemberName="RadiansToDegrees&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void RadiansToDegrees&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RadiansToDegrees&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.RadiansToDegrees``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RadiansToDegrees(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member RadiansToDegrees : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.RadiansToDegrees (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void RadiansToDegrees(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise conversion of each number of radians in the specified tensor to degrees.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.RadiansToDegrees(<paramref name="x" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reciprocal&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reciprocal&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reciprocal&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Reciprocal``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reciprocal(Of T As IFloatingPoint(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Reciprocal : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Reciprocal (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static void Reciprocal(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise reciprocal of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = 1 / <paramref name="x" />[i]</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
        <exception cref="T:System.DivideByZeroException">
          <typeparamref name="T" /> is an integer type and an element in <paramref name="x" /> is equal to zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReciprocalEstimate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ReciprocalEstimate&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReciprocalEstimate&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ReciprocalEstimate``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReciprocalEstimate(Of T As IFloatingPointIeee754(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member ReciprocalEstimate : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.ReciprocalEstimate (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void ReciprocalEstimate(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise reciprocal of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = 1 / <paramref name="x" />[i]</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
        <exception cref="T:System.DivideByZeroException">
          <typeparamref name="T" /> is an integer type and an element in <paramref name="x" /> is equal to zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReciprocalSqrt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ReciprocalSqrt&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReciprocalSqrt&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ReciprocalSqrt``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReciprocalSqrt(Of T As IFloatingPointIeee754(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member ReciprocalSqrt : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.ReciprocalSqrt (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void ReciprocalSqrt(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise reciprocal of the square root of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = 1 / <paramref name="x" />[i]</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
        <exception cref="T:System.DivideByZeroException">
          <typeparamref name="T" /> is an integer type and an element in <paramref name="x" /> is equal to zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReciprocalSqrtEstimate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ReciprocalSqrtEstimate&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReciprocalSqrtEstimate&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ReciprocalSqrtEstimate``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReciprocalSqrtEstimate(Of T As IFloatingPointIeee754(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member ReciprocalSqrtEstimate : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.ReciprocalSqrtEstimate (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void ReciprocalSqrtEstimate(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise reciprocal of the square root of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = 1 / <paramref name="x" />[i]</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
        <exception cref="T:System.DivideByZeroException">
          <typeparamref name="T" /> is an integer type and an element in <paramref name="x" /> is equal to zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="RootN&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void RootN&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, int n, Span&lt;T&gt; destination) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RootN&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, int32 n, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.RootN``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RootN(Of T As IRootFunctions(Of T)) (x As ReadOnlySpan(Of T), n As Integer, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member RootN : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; * int * Span&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.RootN (x, n, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static void RootN(ReadOnlySpan&lt;T&gt; x, int n, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="n" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <param name="n">The degree of the root to be computed, represented as a scalar.</param>
        <summary>Computes the element-wise n-th root of the values in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.RootN(<paramref name="x" />[i], <paramref name="n" />)</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="RotateLeft&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void RotateLeft&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, int rotateAmount, Span&lt;T&gt; destination) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RotateLeft&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, int32 rotateAmount, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.RotateLeft``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RotateLeft(Of T As IBinaryInteger(Of T)) (x As ReadOnlySpan(Of T), rotateAmount As Integer, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member RotateLeft : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; * int * Span&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.RotateLeft (x, rotateAmount, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static void RotateLeft(ReadOnlySpan&lt;T&gt; x, int rotateAmount, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="rotateAmount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <param name="rotateAmount">The number of bits to rotate, represented as a scalar.</param>
        <summary>Computes the element-wise rotation left of numbers in the specified tensor by the specified rotation amount.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.RotateLeft(<paramref name="x" />[i], <paramref name="rotateAmount" />)</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="RotateRight&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void RotateRight&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, int rotateAmount, Span&lt;T&gt; destination) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RotateRight&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, int32 rotateAmount, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.RotateRight``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RotateRight(Of T As IBinaryInteger(Of T)) (x As ReadOnlySpan(Of T), rotateAmount As Integer, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member RotateRight : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; * int * Span&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.RotateRight (x, rotateAmount, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static void RotateRight(ReadOnlySpan&lt;T&gt; x, int rotateAmount, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="rotateAmount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <param name="rotateAmount">The number of bits to rotate, represented as a scalar.</param>
        <summary>Computes the element-wise rotation right of numbers in the specified tensor by the specified rotation amount.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.RotateRight(<paramref name="x" />[i], <paramref name="rotateAmount" />)</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Round&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Round&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Round&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Round``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Round(Of T As IFloatingPoint(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Round : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Round (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static void Round(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Round(<paramref name="x" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Round&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Round&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, int digits, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Round&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, int32 digits, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Round``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Round(Of T As IFloatingPoint(Of T)) (x As ReadOnlySpan(Of T), digits As Integer, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Round : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; * int * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Round (x, digits, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static void Round(ReadOnlySpan&lt;T&gt; x, int digits, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="digits" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="digits">The number of fractional digits to which the numbers in <paramref name="x" /> should be rounded.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Round(<paramref name="x" />[i], <paramref name="digits" />)</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Round&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Round&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, MidpointRounding mode, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Round&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.MidpointRounding mode, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Round``1(System.ReadOnlySpan{``0},System.MidpointRounding,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Round(Of T As IFloatingPoint(Of T)) (x As ReadOnlySpan(Of T), mode As MidpointRounding, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Round : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; * MidpointRounding * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Round (x, mode, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static void Round(ReadOnlySpan&lt;T&gt; x, MidpointRounding mode, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="mode" Type="System.MidpointRounding" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="mode">The mode under which <paramref name="x" /> should be rounded.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Round(<paramref name="x" />[i], <paramref name="mode" />)</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Round&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Round&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, int digits, MidpointRounding mode, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Round&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, int32 digits, valuetype System.MidpointRounding mode, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Round``1(System.ReadOnlySpan{``0},System.Int32,System.MidpointRounding,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Round(Of T As IFloatingPoint(Of T)) (x As ReadOnlySpan(Of T), digits As Integer, mode As MidpointRounding, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Round : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; * int * MidpointRounding * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Round (x, digits, mode, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static void Round(ReadOnlySpan&lt;T&gt; x, int digits, MidpointRounding mode, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="digits" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="mode" Type="System.MidpointRounding" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="3" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="digits">The number of fractional digits to which the numbers in <paramref name="x" /> should be rounded.</param>
        <param name="mode">The mode under which <paramref name="x" /> should be rounded.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise rounding of the numbers in the specified tensor</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Round(<paramref name="x" />[i], <paramref name="digits" />, <paramref name="mode" />)</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="mode" /> is invalid.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="digits" /> is invalid.</exception>
      </Docs>
    </Member>
    <Member MemberName="ScaleB&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ScaleB&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, int n, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPointIeee754&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ScaleB&lt;(class System.Numerics.IFloatingPointIeee754`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, int32 n, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ScaleB``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ScaleB(Of T As IFloatingPointIeee754(Of T)) (x As ReadOnlySpan(Of T), n As Integer, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member ScaleB : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; * int * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPointIeee754&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.ScaleB (x, n, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPointIeee754&lt;T&gt; static void ScaleB(ReadOnlySpan&lt;T&gt; x, int n, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPointIeee754&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="n" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="n">The value to which base-radix is raised before multipliying x, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise product of numbers in the specified tensor and their base-radix raised to the specified power.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.ILogB(<paramref name="x" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShiftLeft&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ShiftLeft&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, int shiftAmount, Span&lt;T&gt; destination) where T : System.Numerics.IShiftOperators&lt;T,int,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ShiftLeft&lt;(class System.Numerics.IShiftOperators`3&lt;!!T, int32, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, int32 shiftAmount, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ShiftLeft``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ShiftLeft(Of T As IShiftOperators(Of T, Integer, T)) (x As ReadOnlySpan(Of T), shiftAmount As Integer, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member ShiftLeft : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IShiftOperators&lt;'T, int, 'T&gt;)&gt; * int * Span&lt;'T (requires 'T :&gt; System.Numerics.IShiftOperators&lt;'T, int, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IShiftOperators&lt;'T, int, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.ShiftLeft (x, shiftAmount, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IShiftOperators&lt;T, int, T&gt; static void ShiftLeft(ReadOnlySpan&lt;T&gt; x, int shiftAmount, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IShiftOperators&lt;T,System.Int32,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="shiftAmount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <param name="shiftAmount">The number of bits to shift, represented as a scalar.</param>
        <summary>Computes the element-wise shifting left of numbers in the specified tensor by the specified shift amount.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] &lt;&lt; <paramref name="shiftAmount" /></c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShiftRightArithmetic&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ShiftRightArithmetic&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, int shiftAmount, Span&lt;T&gt; destination) where T : System.Numerics.IShiftOperators&lt;T,int,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ShiftRightArithmetic&lt;(class System.Numerics.IShiftOperators`3&lt;!!T, int32, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, int32 shiftAmount, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ShiftRightArithmetic``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ShiftRightArithmetic(Of T As IShiftOperators(Of T, Integer, T)) (x As ReadOnlySpan(Of T), shiftAmount As Integer, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member ShiftRightArithmetic : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IShiftOperators&lt;'T, int, 'T&gt;)&gt; * int * Span&lt;'T (requires 'T :&gt; System.Numerics.IShiftOperators&lt;'T, int, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IShiftOperators&lt;'T, int, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.ShiftRightArithmetic (x, shiftAmount, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IShiftOperators&lt;T, int, T&gt; static void ShiftRightArithmetic(ReadOnlySpan&lt;T&gt; x, int shiftAmount, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IShiftOperators&lt;T,System.Int32,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="shiftAmount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <param name="shiftAmount">The number of bits to shift, represented as a scalar.</param>
        <summary>Computes the element-wise arithmetic (signed) shifting right of numbers in the specified tensor by the specified shift amount.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] &gt;&gt; <paramref name="shiftAmount" /></c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShiftRightLogical&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ShiftRightLogical&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, int shiftAmount, Span&lt;T&gt; destination) where T : System.Numerics.IShiftOperators&lt;T,int,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ShiftRightLogical&lt;(class System.Numerics.IShiftOperators`3&lt;!!T, int32, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, int32 shiftAmount, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.ShiftRightLogical``1(System.ReadOnlySpan{``0},System.Int32,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ShiftRightLogical(Of T As IShiftOperators(Of T, Integer, T)) (x As ReadOnlySpan(Of T), shiftAmount As Integer, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member ShiftRightLogical : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IShiftOperators&lt;'T, int, 'T&gt;)&gt; * int * Span&lt;'T (requires 'T :&gt; System.Numerics.IShiftOperators&lt;'T, int, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IShiftOperators&lt;'T, int, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.ShiftRightLogical (x, shiftAmount, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IShiftOperators&lt;T, int, T&gt; static void ShiftRightLogical(ReadOnlySpan&lt;T&gt; x, int shiftAmount, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IShiftOperators&lt;T,System.Int32,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="shiftAmount" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <param name="shiftAmount">The number of bits to shift, represented as a scalar.</param>
        <summary>Computes the element-wise logical (unsigned) shifting right of numbers in the specified tensor by the specified shift amount.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] &gt;&gt;&gt; <paramref name="shiftAmount" /></c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sigmoid">
      <MemberSignature Language="C#" Value="public static void Sigmoid (ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sigmoid(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Sigmoid(System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sigmoid (x As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Sigmoid : ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Sigmoid (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sigmoid(ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor.</param>
        <summary>Computes the element-wise sigmoid function on the specified non-empty tensor of single-precision floating-point numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = 1f / (1f + <see cref="T:System.MathF" />.Exp(-<paramref name="x" />[i]))</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sigmoid&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sigmoid&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sigmoid&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Sigmoid``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sigmoid(Of T As IExponentialFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Sigmoid : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Sigmoid (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static void Sigmoid(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor.</param>
        <summary>Computes the element-wise sigmoid function on the specified non-empty tensor of numbers.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = 1f / (1f + <typeparamref name="T" />.Exp(-<paramref name="x" />[i]))</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sin&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sin&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Sin``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sin(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Sin : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Sin (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void Sin(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise sine of the value in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Sin(<paramref name="x" />[i])</c>.
            </para>
          <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians" /> or multiply by <typeparamref name="T" />.Pi/180 to convert degrees to radians.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="SinCos&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void SinCos&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; sinDestination, Span&lt;T&gt; cosDestination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SinCos&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; sinDestination, valuetype System.Span`1&lt;!!T&gt; cosDestination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.SinCos``1(System.ReadOnlySpan{``0},System.Span{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SinCos(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), sinDestination As Span(Of T), cosDestination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member SinCos : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.SinCos (x, sinDestination, cosDestination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void SinCos(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; sinDestination, Span&lt;T&gt; cosDestination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="sinDestination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="cosDestination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="sinDestination">The destination tensor for the element-wise sine result, represented as a span.</param>
        <param name="cosDestination">The destination tensor for the element-wise cosine result, represented as a span.</param>
        <summary>Computes the element-wise sine and cosine of the value in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c>(<paramref name="sinDestination" />[i], <paramref name="cosDestination" />[i]) = <typeparamref name="T" />.SinCos(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="sinDestination" /> or <paramref name="cosDestination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="SinCosPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void SinCosPi&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; sinPiDestination, Span&lt;T&gt; cosPiDestination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SinCosPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; sinPiDestination, valuetype System.Span`1&lt;!!T&gt; cosPiDestination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.SinCosPi``1(System.ReadOnlySpan{``0},System.Span{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SinCosPi(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), sinPiDestination As Span(Of T), cosPiDestination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member SinCosPi : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.SinCosPi (x, sinPiDestination, cosPiDestination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void SinCosPi(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; sinPiDestination, Span&lt;T&gt; cosPiDestination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="sinPiDestination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="cosPiDestination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="sinPiDestination">The destination tensor for the element-wise sine result, represented as a span.</param>
        <param name="cosPiDestination">The destination tensor for the element-wise cosine result, represented as a span.</param>
        <summary>Computes the element-wise sine and cosine of the value in the specified tensor that has been multiplied by Pi.</summary>
        <remarks>
          <para>
            This method effectively computes <c>(<paramref name="sinPiDestination" />[i], <paramref name="cosPiDestination" />[i]) = <typeparamref name="T" />.SinCos(<paramref name="x" />[i])</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="sinPiDestination" /> or <paramref name="cosPiDestination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static void Sinh (ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sinh(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Sinh(System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sinh (x As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Sinh : ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Sinh (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sinh(ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise hyperbolic sine of each single-precision floating-point radian angle in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <see cref="T:System.MathF" />.Sinh(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value is equal to <see cref="F:System.Single.NegativeInfinity" />, <see cref="F:System.Single.PositiveInfinity" />, or <see cref="F:System.Single.NaN" />,
            the corresponding destination location is set to that value.
            </para>
          <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians" /> or multiply by <see cref="F:System.MathF.PI" />/180 to convert degrees to radians.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sinh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sinh&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sinh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Sinh``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sinh(Of T As IHyperbolicFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Sinh : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Sinh (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static void Sinh(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise hyperbolic sine of each radian angle in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Sinh(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity" />, <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity" />, or <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />,
            the corresponding destination location is set to that value.
            </para>
          <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians" /> or multiply by <typeparamref name="T" />.Pi / 180 to convert degrees to radians.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="SinPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void SinPi&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SinPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.SinPi``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SinPi(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member SinPi : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.SinPi (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void SinPi(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise sine of the value in the specified tensor that has been multiplied by Pi.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.SinPi(<paramref name="x" />[i])</c>.
            </para>
          <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians" /> or multiply by <typeparamref name="T" />.Pi/180 to convert degrees to radians.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="SoftMax">
      <MemberSignature Language="C#" Value="public static void SoftMax (ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SoftMax(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.SoftMax(System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SoftMax (x As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member SoftMax : ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.SoftMax (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SoftMax(ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor.</param>
        <summary>Computes the softmax function over the specified non-empty tensor of single-precision floating-point numbers.</summary>
        <remarks>
          <para>
            This method effectively computes a sum of <c>MathF.Exp(x[i])</c> for all elements in <paramref name="x" />.
            It then effectively computes <c><paramref name="destination" />[i] = MathF.Exp(<paramref name="x" />[i]) / sum</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="SoftMax&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void SoftMax&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IExponentialFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SoftMax&lt;(class System.Numerics.IExponentialFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.SoftMax``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SoftMax(Of T As IExponentialFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member SoftMax : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IExponentialFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.SoftMax (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IExponentialFunctions&lt;T&gt; static void SoftMax(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IExponentialFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor.</param>
        <summary>Computes the softmax function over the specified non-empty tensor of numbers.</summary>
        <remarks>
          <para>
            This method effectively computes a sum of <c><typeparamref name="T" />.Exp(x[i])</c> for all elements in <paramref name="x" />.
            It then effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Exp(<paramref name="x" />[i]) / sum</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sqrt&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sqrt&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IRootFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sqrt&lt;(class System.Numerics.IRootFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Sqrt``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sqrt(Of T As IRootFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Sqrt : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IRootFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Sqrt (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IRootFunctions&lt;T&gt; static void Sqrt(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IRootFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise square root of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Sqrt(<paramref name="x" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static void Subtract (ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Subtract(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.ReadOnlySpan`1&lt;float32&gt; y, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Subtract(System.ReadOnlySpan{System.Single},System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Subtract (x As ReadOnlySpan(Of Single), y As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Subtract : ReadOnlySpan&lt;single&gt; * ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Subtract (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Subtract(ReadOnlySpan&lt;float&gt; x, ReadOnlySpan&lt;float&gt; y, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise difference between single-precision floating-point numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] - <paramref name="y" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static void Subtract (ReadOnlySpan&lt;float&gt; x, float y, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Subtract(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, float32 y, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Subtract(System.ReadOnlySpan{System.Single},System.Single,System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Subtract (x As ReadOnlySpan(Of Single), y As Single, destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Subtract : ReadOnlySpan&lt;single&gt; * single * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Subtract (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Subtract(ReadOnlySpan&lt;float&gt; x, float y, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise difference between single-precision floating-point numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] - <paramref name="y" /></c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="F:System.Single.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Subtract&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Subtract&lt;(class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Subtract``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Subtract(Of T As ISubtractionOperators(Of T, T, T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Subtract : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Subtract (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static void Subtract(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise difference between numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] - <paramref name="y" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Subtract&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Subtract&lt;(class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Subtract``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Subtract(Of T As ISubtractionOperators(Of T, T, T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Subtract : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Subtract (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static void Subtract(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise difference between numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] - <paramref name="y" /></c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Subtract&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Subtract&lt;T&gt; (T x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.ISubtractionOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Subtract&lt;(class System.Numerics.ISubtractionOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(!!T x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Subtract``1(``0,System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Subtract(Of T As ISubtractionOperators(Of T, T, T)) (x As T, y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Subtract : 'T * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ISubtractionOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Subtract (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ISubtractionOperators&lt;T, T, T&gt; static void Subtract(T x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.ISubtractionOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="T" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a scalar.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise difference between numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" /> - <paramref name="y" />[i]</c>.
            </para>
          <para>
            If either of the element-wise input values is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the resulting element-wise value is also NaN.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static float Sum (ReadOnlySpan&lt;float&gt; x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum(valuetype System.ReadOnlySpan`1&lt;float32&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Sum(System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sum (x As ReadOnlySpan(Of Single)) As Single" />
      <MemberSignature Language="F#" Value="static member Sum : ReadOnlySpan&lt;single&gt; -&gt; single" Usage="System.Numerics.Tensors.TensorPrimitives.Sum x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Sum(ReadOnlySpan&lt;float&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes the sum of all elements in the specified tensor of single-precision floating-point numbers.</summary>
        <returns>The result of adding all elements in <paramref name="x" />, or zero if <paramref name="x" /> is empty.</returns>
        <remarks>
          <para>
            If any of the values in the input is equal to <see cref="F:System.Single.NaN" />, the result is also NaN.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Sum&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Sum&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Sum``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sum(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T)}) (x As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member Sum : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Sum x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt; static T Sum(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes the sum of all elements in the specified tensor of numbers.</summary>
        <returns>The result of adding all elements in <paramref name="x" />, or zero if <paramref name="x" /> is empty.</returns>
        <remarks>
          <para>
            If any of the values in the input is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the result is also NaN.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SumOfMagnitudes">
      <MemberSignature Language="C#" Value="public static float SumOfMagnitudes (ReadOnlySpan&lt;float&gt; x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 SumOfMagnitudes(valuetype System.ReadOnlySpan`1&lt;float32&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.SumOfMagnitudes(System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SumOfMagnitudes (x As ReadOnlySpan(Of Single)) As Single" />
      <MemberSignature Language="F#" Value="static member SumOfMagnitudes : ReadOnlySpan&lt;single&gt; -&gt; single" Usage="System.Numerics.Tensors.TensorPrimitives.SumOfMagnitudes x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float SumOfMagnitudes(ReadOnlySpan&lt;float&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes the sum of the absolute values of every element in the specified tensor of single-precision floating-point numbers.</summary>
        <returns>The result of adding the absolute value of every element in <paramref name="x" />, or zero if <paramref name="x" /> is empty.</returns>
        <remarks>
          <para>
            This method effectively computes:
            <c>
                Span&lt;float&gt; absoluteValues = ...;
                TensorPrimitives.Abs(x, absoluteValues);
                float result = TensorPrimitives.Sum(absoluteValues);
            </c>
            but without requiring intermediate storage for the absolute values. It corresponds to the <c>asum</c> method defined by <c>BLAS1</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SumOfMagnitudes&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T SumOfMagnitudes&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.INumberBase&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T SumOfMagnitudes&lt;(class System.Numerics.INumberBase`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.SumOfMagnitudes``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SumOfMagnitudes(Of T As INumberBase(Of T)) (x As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member SumOfMagnitudes : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.INumberBase&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.SumOfMagnitudes x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::INumberBase&lt;T&gt; static T SumOfMagnitudes(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes the sum of the absolute values of every element in the specified tensor of numbers.</summary>
        <returns>The result of adding the absolute value of every element in <paramref name="x" />, or zero if <paramref name="x" /> is empty.</returns>
        <remarks>
          <para>
            This method effectively computes:
            <c>
                Span&lt;T&gt; absoluteValues = ...;
                TensorPrimitives.Abs(x, absoluteValues);
                T result = TensorPrimitives.Sum(absoluteValues);
            </c>
            but without requiring intermediate storage for the absolute values. It corresponds to the <c>asum</c> method defined by <c>BLAS1</c>.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.OverflowException">
          <typeparamref name="T" /> is a signed integer type and <paramref name="x" /> contained a value equal to <typeparamref name="T" />'s minimum value.</exception>
      </Docs>
    </Member>
    <Member MemberName="SumOfSquares">
      <MemberSignature Language="C#" Value="public static float SumOfSquares (ReadOnlySpan&lt;float&gt; x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 SumOfSquares(valuetype System.ReadOnlySpan`1&lt;float32&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.SumOfSquares(System.ReadOnlySpan{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SumOfSquares (x As ReadOnlySpan(Of Single)) As Single" />
      <MemberSignature Language="F#" Value="static member SumOfSquares : ReadOnlySpan&lt;single&gt; -&gt; single" Usage="System.Numerics.Tensors.TensorPrimitives.SumOfSquares x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float SumOfSquares(ReadOnlySpan&lt;float&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes the sum of the square of every element in the specified tensor of single-precision floating-point numbers.</summary>
        <returns>The result of adding the square of every element in <paramref name="x" />, or zero if <paramref name="x" /> is empty.</returns>
        <remarks>
          <para>
            This method effectively computes:
            <c>
                Span&lt;float&gt; squaredValues = ...;
                TensorPrimitives.Multiply(x, x, squaredValues);
                float result = TensorPrimitives.Sum(squaredValues);
            </c>
            but without requiring intermediate storage for the squared values.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SumOfSquares&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T SumOfSquares&lt;T&gt; (ReadOnlySpan&lt;T&gt; x) where T : System.Numerics.IAdditionOperators&lt;T,T,T&gt;, System.Numerics.IAdditiveIdentity&lt;T,T&gt;, System.Numerics.IMultiplyOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T SumOfSquares&lt;(class System.Numerics.IAdditionOperators`3&lt;!!T, !!T, !!T&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!!T, !!T&gt;, class System.Numerics.IMultiplyOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.SumOfSquares``1(System.ReadOnlySpan{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SumOfSquares(Of T As {IAdditionOperators(Of T, T, T), IAdditiveIdentity(Of T, T), IMultiplyOperators(Of T, T, T)}) (x As ReadOnlySpan(Of T)) As T" />
      <MemberSignature Language="F#" Value="static member SumOfSquares : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; 'T (requires 'T :&gt; System.Numerics.IAdditionOperators&lt;'T, 'T, 'T&gt; and 'T :&gt; System.Numerics.IAdditiveIdentity&lt;'T, 'T&gt; and 'T :&gt; System.Numerics.IMultiplyOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.SumOfSquares x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IAdditionOperators&lt;T, T, T&gt;, System::Numerics::IAdditiveIdentity&lt;T, T&gt;, System::Numerics::IMultiplyOperators&lt;T, T, T&gt; static T SumOfSquares(ReadOnlySpan&lt;T&gt; x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IAdditionOperators&lt;T,T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IAdditiveIdentity&lt;T,T&gt;</InterfaceName>
            <InterfaceName>System.Numerics.IMultiplyOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <summary>Computes the sum of the square of every element in the specified tensor of numbers.</summary>
        <returns>The result of adding the square of every element in <paramref name="x" />, or zero if <paramref name="x" /> is empty.</returns>
        <remarks>
          <para>
            This method effectively computes:
            <c>
                Span&lt;T&gt; squaredValues = ...;
                TensorPrimitives.Multiply(x, x, squaredValues);
                T result = TensorPrimitives.Sum(squaredValues);
            </c>
            but without requiring intermediate storage for the squared values.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tan&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Tan&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Tan&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Tan``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Tan(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Tan : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Tan (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void Tan(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise tangent of the value in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Tan(<paramref name="x" />[i])</c>.
            </para>
          <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians" /> or multiply by <typeparamref name="T" />.Pi/180 to convert degrees to radians.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static void Tanh (ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Tanh(valuetype System.ReadOnlySpan`1&lt;float32&gt; x, valuetype System.Span`1&lt;float32&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Tanh(System.ReadOnlySpan{System.Single},System.Span{System.Single})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Tanh (x As ReadOnlySpan(Of Single), destination As Span(Of Single))" />
      <MemberSignature Language="F#" Value="static member Tanh : ReadOnlySpan&lt;single&gt; * Span&lt;single&gt; -&gt; unit" Usage="System.Numerics.Tensors.TensorPrimitives.Tanh (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Tanh(ReadOnlySpan&lt;float&gt; x, Span&lt;float&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;System.Single&gt;" />
        <Parameter Name="destination" Type="System.Span&lt;System.Single&gt;" />
      </Parameters>
      <Docs>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise hyperbolic tangent of each single-precision floating-point radian angle in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <see cref="T:System.MathF" />.Tanh(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value is equal to <see cref="F:System.Single.NegativeInfinity" />, the corresponding destination location is set to -1.
            If a value is equal to <see cref="F:System.Single.PositiveInfinity" />, the corresponding destination location is set to 1.
            If a value is equal to <see cref="F:System.Single.NaN" />, the corresponding destination location is set to NaN.
            </para>
          <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians" /> or multiply by <see cref="F:System.MathF.PI" />/180 to convert degrees to radians.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Tanh&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Tanh&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IHyperbolicFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Tanh&lt;(class System.Numerics.IHyperbolicFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Tanh``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Tanh(Of T As IHyperbolicFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Tanh : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IHyperbolicFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Tanh (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IHyperbolicFunctions&lt;T&gt; static void Tanh(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IHyperbolicFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise hyperbolic tangent of each radian angle in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.Tanh(<paramref name="x" />[i])</c>.
            </para>
          <para>
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NegativeInfinity" />, the corresponding destination location is set to -1.
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.PositiveInfinity" />, the corresponding destination location is set to 1.
            If a value is equal to <see cref="P:System.Numerics.IFloatingPointIeee754`1.NaN" />, the corresponding destination location is set to NaN.
            </para>
          <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians" /> or multiply by <typeparamref name="T" />.Pi / 180 to convert degrees to radians.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="TanPi&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void TanPi&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.ITrigonometricFunctions&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TanPi&lt;(class System.Numerics.ITrigonometricFunctions`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.TanPi``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TanPi(Of T As ITrigonometricFunctions(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member TanPi : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.ITrigonometricFunctions&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.TanPi (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::ITrigonometricFunctions&lt;T&gt; static void TanPi(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.ITrigonometricFunctions&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise tangent of the value in the specified tensor that has been multiplied by Pi.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <typeparamref name="T" />.TanPi(<paramref name="x" />[i])</c>.
            </para>
          <para>
            The angles in x must be in radians. Use <see cref="M:System.Single.DegreesToRadians" /> or multiply by <typeparamref name="T" />.Pi/180 to convert degrees to radians.
            </para>
          <para>
            This method may call into the underlying C runtime or employ instructions specific to the current architecture. Exact results may differ between different
            operating systems or architectures.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="TrailingZeroCount&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void TrailingZeroCount&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IBinaryInteger&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TrailingZeroCount&lt;(class System.Numerics.IBinaryInteger`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.TrailingZeroCount``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TrailingZeroCount(Of T As IBinaryInteger(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member TrailingZeroCount : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IBinaryInteger&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.TrailingZeroCount (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBinaryInteger&lt;T&gt; static void TrailingZeroCount(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise trailing zero count of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.TrailingZeroCount(<paramref name="x" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Truncate&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Truncate&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination) where T : System.Numerics.IFloatingPoint&lt;T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Truncate&lt;(class System.Numerics.IFloatingPoint`1&lt;!!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Truncate``1(System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Truncate(Of T As IFloatingPoint(Of T)) (x As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Truncate : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IFloatingPoint&lt;'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Truncate (x, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IFloatingPoint&lt;T&gt; static void Truncate(ReadOnlySpan&lt;T&gt; x, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IFloatingPoint&lt;T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise truncation of numbers in the specified tensor.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = T.Truncate(<paramref name="x" />[i])</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Xor&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Xor&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Xor&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, valuetype System.ReadOnlySpan`1&lt;!!T&gt; y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Xor``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Xor(Of T As IBitwiseOperators(Of T, T, T)) (x As ReadOnlySpan(Of T), y As ReadOnlySpan(Of T), destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Xor : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; * ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; * Span&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Xor (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static void Xor(ReadOnlySpan&lt;T&gt; x, ReadOnlySpan&lt;T&gt; y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="System.ReadOnlySpan&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a span.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise XOR of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] ^ <paramref name="y" />[i]</c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="y" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
    <Member MemberName="Xor&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Xor&lt;T&gt; (ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination) where T : System.Numerics.IBitwiseOperators&lt;T,T,T&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Xor&lt;(class System.Numerics.IBitwiseOperators`3&lt;!!T, !!T, !!T&gt;) T&gt;(valuetype System.ReadOnlySpan`1&lt;!!T&gt; x, !!T y, valuetype System.Span`1&lt;!!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Tensors.TensorPrimitives.Xor``1(System.ReadOnlySpan{``0},``0,System.Span{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Xor(Of T As IBitwiseOperators(Of T, T, T)) (x As ReadOnlySpan(Of T), y As T, destination As Span(Of T))" />
      <MemberSignature Language="F#" Value="static member Xor : ReadOnlySpan&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; * 'T * Span&lt;'T (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)&gt; -&gt; unit (requires 'T :&gt; System.Numerics.IBitwiseOperators&lt;'T, 'T, 'T&gt;)" Usage="System.Numerics.Tensors.TensorPrimitives.Xor (x, y, destination)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : System::Numerics::IBitwiseOperators&lt;T, T, T&gt; static void Xor(ReadOnlySpan&lt;T&gt; x, T y, Span&lt;T&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Numerics.Tensors</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBitwiseOperators&lt;T,T,T&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="x" Type="System.ReadOnlySpan&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="y" Type="T" Index="1" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0" />
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" Index="2" FrameworkAlternate="dotnet-plat-ext-9.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 0, 1 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="x">The first tensor, represented as a span.</param>
        <param name="y">The second tensor, represented as a scalar.</param>
        <param name="destination">The destination tensor, represented as a span.</param>
        <summary>Computes the element-wise XOR of numbers in the specified tensors.</summary>
        <remarks>
          <para>
            This method effectively computes <c><paramref name="destination" />[i] = <paramref name="x" />[i] ^ <paramref name="y" /></c>.
            </para>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="x" /> and <paramref name="destination" /> reference overlapping memory locations and do not begin at the same location.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
