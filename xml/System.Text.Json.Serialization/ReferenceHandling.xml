<Type Name="ReferenceHandling" FullName="System.Text.Json.Serialization.ReferenceHandling">
  <TypeSignature Language="C#" Value="public sealed class ReferenceHandling" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ReferenceHandling extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Text.Json.Serialization.ReferenceHandling" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ReferenceHandling" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReferenceHandling sealed" />
  <TypeSignature Language="F#" Value="type ReferenceHandling = class" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Json</AssemblyName>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Defines how the <see cref="T:System.Text.Json.JsonSerializer" /> deals with references during serialization and deserialization.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.ReferenceHandling Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Json.Serialization.ReferenceHandling Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Serialization.ReferenceHandling.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As ReferenceHandling" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Json::Serialization::ReferenceHandling ^ Default { System::Text::Json::Serialization::ReferenceHandling ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Text.Json.Serialization.ReferenceHandling" Usage="System.Text.Json.Serialization.ReferenceHandling.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.ReferenceHandling</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Serialization does not support objects with cycles and does not preserve duplicate references. Metadata properties will not be written when serializing reference types and will be treated as regular properties on deserialize.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

* On Serialize:
 Treats duplicate object references as if they were unique and writes all their properties.
 The serializer throws a <xref:System.Text.Json.JsonException> if an object contains a cycle.
 * On Deserialize:
 Metadata properties (`$id`, `$values`, and `$ref`) are not consumed and, therefore, are treated as regular JSON properties.
 The metadata properties can map to a real property on the returned object if the property names match. Or, if the <xref:System.Text.Json.Serialization.JsonExtensionDataAttribute> overflow dictionary exists, the metadata properties are added to it. Otherwise, the metadata properties are ignored.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Preserve">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Serialization.ReferenceHandling Preserve { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Json.Serialization.ReferenceHandling Preserve" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.Serialization.ReferenceHandling.Preserve" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Preserve As ReferenceHandling" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Json::Serialization::ReferenceHandling ^ Preserve { System::Text::Json::Serialization::ReferenceHandling ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Preserve : System.Text.Json.Serialization.ReferenceHandling" Usage="System.Text.Json.Serialization.ReferenceHandling.Preserve" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.ReferenceHandling</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Metadata properties will be honored when deserializing JSON objects and arrays into reference types and written when serializing reference types. This is necessary to create round-trippable JSON from objects that contain cycles or duplicate references.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

* On Serialize:
 When writing complex reference types, the serializer also writes metadata properties (`$id`, `$values`, and `$ref`) within them.
 The output JSON will contain an extra `$id` property for every object. For every enumerable type, the JSON array emitted will be nested within a JSON object containing an `$id` and `$values` property.
 <xref:System.Object.ReferenceEquals(System.Object,System.Object)> is used to determine whether objects are identical.
 When an object is identical to a previously serialized one, a pointer (`$ref`) to the identifier (`$id`) of such object is written instead.
 No metadata properties are written for value types.
 * On Deserialize:
 The metadata properties within the JSON that are used to preserve duplicated references, and cycles will be honored as long as they are well-formed**.
 For JSON objects that don't contain any metadata properties, the deserialization behavior is identical to <xref:System.Text.Json.Serialization.ReferenceHandling.Default>.
 
   For value types:
   
   * The `$id` metadata property is ignored.
   * A <xref:System.Text.Json.JsonException> is thrown if a `$ref` metadata property is found within the JSON object.
   * For enumerable value types, the `$values` metadata property is ignored.
   
 For the metadata properties within the JSON to be considered well-formed, they must follow these rules:
 - The `$id` metadata property must be the first property in the JSON object.
 - A JSON object that contains a `$ref` metadata property must not contain any other properties.
 - The value of the `$ref` metadata property must refer to an `$id` that has appeared earlier in the JSON.
 - The value of the `$id` and `$ref` metadata properties must be a JSON string.
 - For enumerable types, such as <xref:System.Collections.Generic.List`1>, the JSON array must be nested within a JSON object containing an `$id` and `$values` metadata property, in that order.
 - For enumerable types, the `$values` metadata property must be a JSON array.
 - The `$values` metadata property is only valid when referring to enumerable types.


          ]]></format>
        </remarks>
        <exception cref="T:System.Text.Json.JsonException">The JSON is not well formed.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
