<Type Name="RandomAccess" FullName="System.IO.RandomAccess">
  <TypeSignature Language="C#" Value="public static class RandomAccess" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit RandomAccess extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.RandomAccess" />
  <TypeSignature Language="VB.NET" Value="Public Class RandomAccess" />
  <TypeSignature Language="F#" Value="type RandomAccess = class" />
  <TypeSignature Language="C++ CLI" Value="public ref class RandomAccess abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Provides offset-based APIs for reading and writing files in a thread-safe manner.</summary>
    <remarks>Only regular disk files are supported. Unseekable files, like pipes, are not supported.
    
    </remarks>
    <related type="Article" href="/en-us/windows/win32/sync/synchronization-and-overlapped-input-and-output">Synchronization and Overlapped Input and Output</related>
    <related type="Article" href="/en-us/windows/win32/api/minwinbase/ns-minwinbase-overlapped">OVERLAPPED structure</related>
  </Docs>
  <Members>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public static long GetLength (Microsoft.Win32.SafeHandles.SafeFileHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetLength(class Microsoft.Win32.SafeHandles.SafeFileHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.RandomAccess.GetLength(Microsoft.Win32.SafeHandles.SafeFileHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLength (handle As SafeFileHandle) As Long" />
      <MemberSignature Language="F#" Value="static member GetLength : Microsoft.Win32.SafeHandles.SafeFileHandle -&gt; int64" Usage="System.IO.RandomAccess.GetLength handle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetLength(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
      </Parameters>
      <Docs>
        <param name="handle">The file handle.</param>
        <summary>Gets the length of the file in bytes.</summary>
        <returns>A long value representing the length of the file in bytes.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handle" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="handle" /> is invalid.</exception>
        <exception cref="T:System.ObjectDisposedException">The file is closed.</exception>
        <exception cref="T:System.NotSupportedException">The file does not support seeking (pipe or socket).</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public static long Read (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.Collections.Generic.IReadOnlyList&lt;Memory&lt;byte&gt;&gt; buffers, long fileOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Read(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, class System.Collections.Generic.IReadOnlyList`1&lt;valuetype System.Memory`1&lt;unsigned int8&gt;&gt; buffers, int64 fileOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.RandomAccess.Read(Microsoft.Win32.SafeHandles.SafeFileHandle,System.Collections.Generic.IReadOnlyList{System.Memory{System.Byte}},System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Read (handle As SafeFileHandle, buffers As IReadOnlyList(Of Memory(Of Byte)), fileOffset As Long) As Long" />
      <MemberSignature Language="F#" Value="static member Read : Microsoft.Win32.SafeHandles.SafeFileHandle * System.Collections.Generic.IReadOnlyList&lt;Memory&lt;byte&gt;&gt; * int64 -&gt; int64" Usage="System.IO.RandomAccess.Read (handle, buffers, fileOffset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Read(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::Collections::Generic::IReadOnlyList&lt;Memory&lt;System::Byte&gt;&gt; ^ buffers, long fileOffset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="buffers" Type="System.Collections.Generic.IReadOnlyList&lt;System.Memory&lt;System.Byte&gt;&gt;" />
        <Parameter Name="fileOffset" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="handle">The file handle.</param>
        <param name="buffers">A list of memory buffers. When this method returns, the contents of the buffers are replaced by the bytes read from the file.</param>
        <param name="fileOffset">The file position to read from.</param>
        <summary>Reads a sequence of bytes from given file at given offset.</summary>
        <returns>The total number of bytes read into the buffers. This can be less than the number of bytes allocated in the buffers if that many bytes are not currently available, or zero (0) if the end of the file has been reached.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Position of the file is not advanced.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handle" /> or <paramref name="buffers" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="handle" /> is invalid.</exception>
        <exception cref="T:System.ObjectDisposedException">The file is closed.</exception>
        <exception cref="T:System.NotSupportedException">The file does not support seeking (pipe or socket).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="fileOffset" /> is negative.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="handle" /> was not opened for reading.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public static int Read (Microsoft.Win32.SafeHandles.SafeFileHandle handle, Span&lt;byte&gt; buffer, long fileOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Read(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.Span`1&lt;unsigned int8&gt; buffer, int64 fileOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.RandomAccess.Read(Microsoft.Win32.SafeHandles.SafeFileHandle,System.Span{System.Byte},System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Read (handle As SafeFileHandle, buffer As Span(Of Byte), fileOffset As Long) As Integer" />
      <MemberSignature Language="F#" Value="static member Read : Microsoft.Win32.SafeHandles.SafeFileHandle * Span&lt;byte&gt; * int64 -&gt; int" Usage="System.IO.RandomAccess.Read (handle, buffer, fileOffset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Read(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, Span&lt;System::Byte&gt; buffer, long fileOffset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="fileOffset" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="handle">The file handle.</param>
        <param name="buffer">A region of memory. When this method returns, the contents of this region are replaced by the bytes read from the file.</param>
        <param name="fileOffset">The file position to read from.</param>
        <summary>Reads a sequence of bytes from given file at given offset.</summary>
        <returns>The total number of bytes read into the buffer. This can be less than the number of bytes allocated in the buffer if that many bytes are not currently available, or zero (0) if the end of the file has been reached.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Position of the file is not advanced.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handle" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="handle" /> is invalid.</exception>
        <exception cref="T:System.ObjectDisposedException">The file is closed.</exception>
        <exception cref="T:System.NotSupportedException">The file does not support seeking (pipe or socket).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="fileOffset" /> is negative.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="handle" /> was not opened for reading.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ValueTask&lt;long&gt; ReadAsync (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.Collections.Generic.IReadOnlyList&lt;Memory&lt;byte&gt;&gt; buffers, long fileOffset, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ValueTask`1&lt;int64&gt; ReadAsync(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, class System.Collections.Generic.IReadOnlyList`1&lt;valuetype System.Memory`1&lt;unsigned int8&gt;&gt; buffers, int64 fileOffset, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.RandomAccess.ReadAsync(Microsoft.Win32.SafeHandles.SafeFileHandle,System.Collections.Generic.IReadOnlyList{System.Memory{System.Byte}},System.Int64,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAsync (handle As SafeFileHandle, buffers As IReadOnlyList(Of Memory(Of Byte)), fileOffset As Long, Optional cancellationToken As CancellationToken = Nothing) As ValueTask(Of Long)" />
      <MemberSignature Language="F#" Value="static member ReadAsync : Microsoft.Win32.SafeHandles.SafeFileHandle * System.Collections.Generic.IReadOnlyList&lt;Memory&lt;byte&gt;&gt; * int64 * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int64&gt;" Usage="System.IO.RandomAccess.ReadAsync (handle, buffers, fileOffset, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="buffers" Type="System.Collections.Generic.IReadOnlyList&lt;System.Memory&lt;System.Byte&gt;&gt;" />
        <Parameter Name="fileOffset" Type="System.Int64" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="handle">The file handle.</param>
        <param name="buffers">A list of memory buffers. When this method returns, the contents of these buffers are replaced by the bytes read from the file.</param>
        <param name="fileOffset">The file position to read from.</param>
        <param name="cancellationToken">The token to monitor for cancellation requests. The default value is <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Reads a sequence of bytes from given file at given offset.</summary>
        <returns>The total number of bytes read into the buffers. This can be less than the number of bytes allocated in the buffers if that many bytes are not currently available, or zero (0) if the end of the file has been reached.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Position of the file is not advanced.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handle" /> or <paramref name="buffers" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="handle" /> is invalid.</exception>
        <exception cref="T:System.ObjectDisposedException">The file is closed.</exception>
        <exception cref="T:System.NotSupportedException">The file does not support seeking (pipe or socket).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="fileOffset" /> is negative.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="handle" /> was not opened for reading.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ValueTask&lt;int&gt; ReadAsync (Microsoft.Win32.SafeHandles.SafeFileHandle handle, Memory&lt;byte&gt; buffer, long fileOffset, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ValueTask`1&lt;int32&gt; ReadAsync(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.Memory`1&lt;unsigned int8&gt; buffer, int64 fileOffset, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.RandomAccess.ReadAsync(Microsoft.Win32.SafeHandles.SafeFileHandle,System.Memory{System.Byte},System.Int64,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadAsync (handle As SafeFileHandle, buffer As Memory(Of Byte), fileOffset As Long, Optional cancellationToken As CancellationToken = Nothing) As ValueTask(Of Integer)" />
      <MemberSignature Language="F#" Value="static member ReadAsync : Microsoft.Win32.SafeHandles.SafeFileHandle * Memory&lt;byte&gt; * int64 * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;int&gt;" Usage="System.IO.RandomAccess.ReadAsync (handle, buffer, fileOffset, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="buffer" Type="System.Memory&lt;System.Byte&gt;" />
        <Parameter Name="fileOffset" Type="System.Int64" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="handle">The file handle.</param>
        <param name="buffer">A region of memory. When this method returns, the contents of this region are replaced by the bytes read from the file.</param>
        <param name="fileOffset">The file position to read from.</param>
        <param name="cancellationToken">The token to monitor for cancellation requests. The default value is <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Reads a sequence of bytes from given file at given offset.</summary>
        <returns>The total number of bytes read into the buffer. This can be less than the number of bytes allocated in the buffer if that many bytes are not currently available, or zero (0) if the end of the file has been reached.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Position of the file is not advanced.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handle" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="handle" /> is invalid.</exception>
        <exception cref="T:System.ObjectDisposedException">The file is closed.</exception>
        <exception cref="T:System.NotSupportedException">The file does not support seeking (pipe or socket).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="fileOffset" /> is negative.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="handle" /> was not opened for reading.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public static void SetLength (Microsoft.Win32.SafeHandles.SafeFileHandle handle, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLength(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.RandomAccess.SetLength(Microsoft.Win32.SafeHandles.SafeFileHandle,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetLength (handle As SafeFileHandle, length As Long)" />
      <MemberSignature Language="F#" Value="static member SetLength : Microsoft.Win32.SafeHandles.SafeFileHandle * int64 -&gt; unit" Usage="System.IO.RandomAccess.SetLength (handle, length)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetLength(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="length" Type="System.Int64" Index="1" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <param name="handle">The file handle.</param>
        <param name="length">The length of the file in bytes.</param>
        <summary>Sets the length of the file to the given value.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handle" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="handle" /> is invalid.</exception>
        <exception cref="T:System.ObjectDisposedException">The file is closed.</exception>
        <exception cref="T:System.NotSupportedException">The file does not support seeking (pipe or socket).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> is negative.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.Collections.Generic.IReadOnlyList&lt;ReadOnlyMemory&lt;byte&gt;&gt; buffers, long fileOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, class System.Collections.Generic.IReadOnlyList`1&lt;valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt;&gt; buffers, int64 fileOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.RandomAccess.Write(Microsoft.Win32.SafeHandles.SafeFileHandle,System.Collections.Generic.IReadOnlyList{System.ReadOnlyMemory{System.Byte}},System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (handle As SafeFileHandle, buffers As IReadOnlyList(Of ReadOnlyMemory(Of Byte)), fileOffset As Long)" />
      <MemberSignature Language="F#" Value="static member Write : Microsoft.Win32.SafeHandles.SafeFileHandle * System.Collections.Generic.IReadOnlyList&lt;ReadOnlyMemory&lt;byte&gt;&gt; * int64 -&gt; unit" Usage="System.IO.RandomAccess.Write (handle, buffers, fileOffset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, System::Collections::Generic::IReadOnlyList&lt;ReadOnlyMemory&lt;System::Byte&gt;&gt; ^ buffers, long fileOffset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="buffers" Type="System.Collections.Generic.IReadOnlyList&lt;System.ReadOnlyMemory&lt;System.Byte&gt;&gt;" />
        <Parameter Name="fileOffset" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="handle">The file handle.</param>
        <param name="buffers">A list of memory buffers. This method copies the contents of these buffers to the file.</param>
        <param name="fileOffset">The file position to write to.</param>
        <summary>Writes a sequence of bytes from given buffers to given file at given offset.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Position of the file is not advanced.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handle" /> or <paramref name="buffers" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="handle" /> is invalid.</exception>
        <exception cref="T:System.ObjectDisposedException">The file is closed.</exception>
        <exception cref="T:System.NotSupportedException">The file does not support seeking (pipe or socket).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="fileOffset" /> is negative.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="handle" /> was not opened for writing.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (Microsoft.Win32.SafeHandles.SafeFileHandle handle, ReadOnlySpan&lt;byte&gt; buffer, long fileOffset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, int64 fileOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.RandomAccess.Write(Microsoft.Win32.SafeHandles.SafeFileHandle,System.ReadOnlySpan{System.Byte},System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (handle As SafeFileHandle, buffer As ReadOnlySpan(Of Byte), fileOffset As Long)" />
      <MemberSignature Language="F#" Value="static member Write : Microsoft.Win32.SafeHandles.SafeFileHandle * ReadOnlySpan&lt;byte&gt; * int64 -&gt; unit" Usage="System.IO.RandomAccess.Write (handle, buffer, fileOffset)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(Microsoft::Win32::SafeHandles::SafeFileHandle ^ handle, ReadOnlySpan&lt;System::Byte&gt; buffer, long fileOffset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="fileOffset" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="handle">The file handle.</param>
        <param name="buffer">A region of memory. This method copies the contents of this region to the file.</param>
        <param name="fileOffset">The file position to write to.</param>
        <summary>Writes a sequence of bytes from given buffer to given file at given offset.</summary>
        <returns>To be added.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Position of the file is not advanced.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handle" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="handle" /> is invalid.</exception>
        <exception cref="T:System.ObjectDisposedException">The file is closed.</exception>
        <exception cref="T:System.NotSupportedException">The file does not support seeking (pipe or socket).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="fileOffset" /> is negative.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="handle" /> was not opened for writing.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ValueTask WriteAsync (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.Collections.Generic.IReadOnlyList&lt;ReadOnlyMemory&lt;byte&gt;&gt; buffers, long fileOffset, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ValueTask WriteAsync(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, class System.Collections.Generic.IReadOnlyList`1&lt;valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt;&gt; buffers, int64 fileOffset, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.RandomAccess.WriteAsync(Microsoft.Win32.SafeHandles.SafeFileHandle,System.Collections.Generic.IReadOnlyList{System.ReadOnlyMemory{System.Byte}},System.Int64,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WriteAsync (handle As SafeFileHandle, buffers As IReadOnlyList(Of ReadOnlyMemory(Of Byte)), fileOffset As Long, Optional cancellationToken As CancellationToken = Nothing) As ValueTask" />
      <MemberSignature Language="F#" Value="static member WriteAsync : Microsoft.Win32.SafeHandles.SafeFileHandle * System.Collections.Generic.IReadOnlyList&lt;ReadOnlyMemory&lt;byte&gt;&gt; * int64 * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask" Usage="System.IO.RandomAccess.WriteAsync (handle, buffers, fileOffset, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="buffers" Type="System.Collections.Generic.IReadOnlyList&lt;System.ReadOnlyMemory&lt;System.Byte&gt;&gt;" />
        <Parameter Name="fileOffset" Type="System.Int64" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="handle">The file handle.</param>
        <param name="buffers">A list of memory buffers. This method copies the contents of these buffers to the file.</param>
        <param name="fileOffset">The file position to write to.</param>
        <param name="cancellationToken">The token to monitor for cancellation requests. The default value is <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Writes a sequence of bytes from given buffers to given file at given offset.</summary>
        <returns>A task representing the asynchronous completion of the write operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Position of the file is not advanced.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handle" /> or <paramref name="buffers" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="handle" /> is invalid.</exception>
        <exception cref="T:System.ObjectDisposedException">The file is closed.</exception>
        <exception cref="T:System.NotSupportedException">The file does not support seeking (pipe or socket).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="fileOffset" /> is negative.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="handle" /> was not opened for writing.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ValueTask WriteAsync (Microsoft.Win32.SafeHandles.SafeFileHandle handle, ReadOnlyMemory&lt;byte&gt; buffer, long fileOffset, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ValueTask WriteAsync(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.ReadOnlyMemory`1&lt;unsigned int8&gt; buffer, int64 fileOffset, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.RandomAccess.WriteAsync(Microsoft.Win32.SafeHandles.SafeFileHandle,System.ReadOnlyMemory{System.Byte},System.Int64,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WriteAsync (handle As SafeFileHandle, buffer As ReadOnlyMemory(Of Byte), fileOffset As Long, Optional cancellationToken As CancellationToken = Nothing) As ValueTask" />
      <MemberSignature Language="F#" Value="static member WriteAsync : Microsoft.Win32.SafeHandles.SafeFileHandle * ReadOnlyMemory&lt;byte&gt; * int64 * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask" Usage="System.IO.RandomAccess.WriteAsync (handle, buffer, fileOffset, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="buffer" Type="System.ReadOnlyMemory&lt;System.Byte&gt;" />
        <Parameter Name="fileOffset" Type="System.Int64" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="handle">The file handle.</param>
        <param name="buffer">A region of memory. This method copies the contents of this region to the file.</param>
        <param name="fileOffset">The file position to write to.</param>
        <param name="cancellationToken">The token to monitor for cancellation requests. The default value is <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Writes a sequence of bytes from given buffer to given file at given offset.</summary>
        <returns>A task representing the asynchronous completion of the write operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Position of the file is not advanced.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handle" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="handle" /> is invalid.</exception>
        <exception cref="T:System.ObjectDisposedException">The file is closed.</exception>
        <exception cref="T:System.NotSupportedException">The file does not support seeking (pipe or socket).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="fileOffset" /> is negative.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="handle" /> was not opened for writing.</exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
