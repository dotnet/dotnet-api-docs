<Type Name="ContextMenu" FullName="System.Windows.Controls.ContextMenu">
  <TypeSignature Language="C#" Value="public class ContextMenu : System.Windows.Controls.Primitives.MenuBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ContextMenu extends System.Windows.Controls.Primitives.MenuBase" FrameworkAlternate="netcore-3.0;netcore-3.1" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Controls.ContextMenu" />
  <TypeSignature Language="VB.NET" Value="Public Class ContextMenu&#xA;Inherits MenuBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class ContextMenu : System::Windows::Controls::Primitives::MenuBase" />
  <TypeSignature Language="F#" Value="type ContextMenu = class&#xA;    inherit MenuBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ContextMenu extends System.Windows.Controls.Primitives.MenuBase" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.Primitives.MenuBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Opened")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a pop-up menu that enables a control to expose functionality that is specific to the context of the control.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ContextMenu> is an <xref:System.Windows.Controls.ItemsControl>, which means it can contain a collection of objects of any type (such as string, image, or panel). For more information, see the <xref:System.Windows.Controls.ItemsControl> class.  
  
 The properties of the <xref:System.Windows.Controls.ContextMenu> class are used to define the position and behavior of the <xref:System.Windows.Controls.ContextMenu>.  
  
 A <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> can have a <xref:System.Windows.Controls.ContextMenu>.  If you assign a <xref:System.Windows.Controls.ContextMenu> to the <xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=nameWithType> or <xref:System.Windows.FrameworkContentElement.ContextMenu%2A?displayProperty=nameWithType> property, the <xref:System.Windows.Controls.ContextMenuService> class handles context menu operations in response to user interaction. Part of the work the <xref:System.Windows.Controls.ContextMenuService> does is opening the <xref:System.Windows.Controls.ContextMenu> when the user clicks the right mouse button over the control.  
  
 The following properties are defined by the <xref:System.Windows.Controls.ContextMenu> and <xref:System.Windows.Controls.ContextMenuService> classes.  If any of these properties are set on both <xref:System.Windows.Controls.ContextMenu> and the <xref:System.Windows.Controls.ContextMenuService>, the property value from the <xref:System.Windows.Controls.ContextMenuService> is used.  
  
-   <xref:System.Windows.Controls.ContextMenu.Placement%2A>  
  
-   <xref:System.Windows.Controls.ContextMenu.PlacementRectangle%2A>  
  
-   <xref:System.Windows.Controls.ContextMenu.PlacementTargetProperty>  
  
-   <xref:System.Windows.Controls.ContextMenu.HorizontalOffset%2A>  
  
-   <xref:System.Windows.Controls.ContextMenu.VerticalOffsetProperty>  
  
-   <xref:System.Windows.Controls.ContextMenu.HasDropShadow%2A>  
  
 A <xref:System.Windows.Controls.ContextMenu> is automatically placed inside a <xref:System.Windows.Controls.Primitives.Popup> control. This behavior cannot be changed.  
  
## Customizing the ContextMenu Control  
 To apply the same property settings to multiple <xref:System.Windows.Controls.ContextMenu> controls, use the <xref:System.Windows.FrameworkElement.Style%2A> property. You can modify the default <xref:System.Windows.Controls.ControlTemplate> to give the control a unique appearance. For more information about creating a <xref:System.Windows.Controls.ControlTemplate>, see [Customizing the Appearance of an Existing Control by Creating a ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  To see the parts and states that are specific to the <xref:System.Windows.Controls.ContextMenu>, see [ContextMenu Styles and Templates](~/docs/framework/wpf/controls/contextmenu-styles-and-templates.md).  
  
 Dependency properties for this control might be set by the control's default style.  If a property is set by a default style, the property might change from its default value when the control appears in the application. The default style is determined by which desktop theme is used when the application is running.  For more information, see [Default WPF Themes](https://go.microsoft.com/fwlink/?LinkID=158252).  
  
[!INCLUDE[setting-a-visual-property](~/includes/visual-property-note.md)]  
  
## Examples  
 The following example creates a <xref:System.Windows.Controls.ContextMenu> that manipulates the text of a <xref:System.Windows.Controls.TextBox>.  The example demonstrates how to subscribe to and handle the events of <xref:System.Windows.Controls.MenuItem> objects in a <xref:System.Windows.Controls.ContextMenu>.  
  
 [!code-xaml[ContextMenu#Events](~/samples/snippets/csharp/VS_Snippets_Wpf/ContextMenu/CSharp/Pane1.xaml#events)]  
  
 [!code-csharp[MenuItemCommandsAndEvents#2](~/samples/snippets/csharp/VS_Snippets_Wpf/MenuItemCommandsAndEvents/CSharp/Window1.xaml.cs#2)]
 [!code-vb[MenuItemCommandsAndEvents#2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MenuItemCommandsAndEvents/VisualBasic/Window1.xaml.vb#2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Controls.ContextMenuService" />
    <altmember cref="T:System.Windows.Controls.MenuItem" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ContextMenu ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ContextMenu.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ContextMenu();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Windows.Controls.ContextMenu" /> class.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.ContextMenu.Closed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closed As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Closed;" />
      <MemberSignature Language="F#" Value="member this.Closed : System.Windows.RoutedEventHandler " Usage="member this.Closed : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a particular instance of a <see cref="T:System.Windows.Controls.ContextMenu" /> closes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_Closed"></a>   
## Routed Event Information  
  
|||  
|-|-|  
|Identifier field|<xref:System.Windows.Controls.ContextMenu.ClosedEvent>|  
|Routing strategy|Bubbling|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
   
  
## Examples  
 The following example shows how use the <xref:System.Windows.Controls.ContextMenu> events: <xref:System.Windows.Controls.ContextMenu.Opened> and <xref:System.Windows.Controls.ContextMenu.Closed>.  
  
 [!code-xaml[ContextMenu#ContextMenuEvents](~/samples/snippets/csharp/VS_Snippets_Wpf/ContextMenu/CSharp/Pane1.xaml#contextmenuevents)]  
  
 [!code-csharp[ContextMenu#ContextMenuEventHandlers](~/samples/snippets/csharp/VS_Snippets_Wpf/ContextMenu/CSharp/Pane1.xaml.cs#contextmenueventhandlers)]
 [!code-vb[ContextMenu#ContextMenuEventHandlers](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContextMenu/VisualBasic/Pane1.xaml.vb#contextmenueventhandlers)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="ClosedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ClosedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ClosedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ContextMenu.ClosedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClosedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ClosedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClosedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.ContextMenu.ClosedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="E:System.Windows.Controls.ContextMenu.Closed" /> routed event.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomPopupPlacementCallback">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.Primitives.CustomPopupPlacementCallback CustomPopupPlacementCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.Primitives.CustomPopupPlacementCallback CustomPopupPlacementCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ContextMenu.CustomPopupPlacementCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property CustomPopupPlacementCallback As CustomPopupPlacementCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::Primitives::CustomPopupPlacementCallback ^ CustomPopupPlacementCallback { System::Windows::Controls::Primitives::CustomPopupPlacementCallback ^ get(); void set(System::Windows::Controls::Primitives::CustomPopupPlacementCallback ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CustomPopupPlacementCallback : System.Windows.Controls.Primitives.CustomPopupPlacementCallback with get, set" Usage="System.Windows.Controls.ContextMenu.CustomPopupPlacementCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Layout")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.Primitives.CustomPopupPlacementCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a callback that indicates where a <see cref="T:System.Windows.Controls.ContextMenu" /> should be placed on the screen.</summary>
        <value>A callback that specifies the location of the <see cref="T:System.Windows.Controls.ContextMenu" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 The <xref:System.Windows.Controls.ContextMenu.Placement%2A> property must be set to <xref:System.Windows.Controls.Primitives.PlacementMode.Custom> for the callback delegate to be used.  
  
 The <xref:System.Windows.Controls.Primitives.CustomPopupPlacementCallback> delegate returns an array of possible points that are defined with respect to the <xref:System.Windows.Controls.ContextMenu.PlacementTarget%2A>. When the context menu is displayed, a point is chosen that maximizes the amount of the <xref:System.Windows.Controls.ToolTip> window that is visible.  
  
 The behavior is the same as it is for the popup.  For more information, see [How to: Specify a Custom Popup Position](~/docs/framework/wpf/controls/how-to-specify-a-custom-popup-position.md) and [Popup Placement Sample](https://go.microsoft.com/fwlink/?LinkID=160032).  
  
<a name="dependencyPropertyInfo_CustomPopupPlacementCallback"></a>   
## Dependency Property Information  
  
|||  
|-|-|  
|Identifier field|<xref:System.Windows.Controls.ContextMenu.CustomPopupPlacementCallbackProperty>|  
|Metadata properties set to `true`|None|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomPopupPlacementCallbackProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CustomPopupPlacementCallbackProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CustomPopupPlacementCallbackProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ContextMenu.CustomPopupPlacementCallbackProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CustomPopupPlacementCallbackProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CustomPopupPlacementCallbackProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CustomPopupPlacementCallbackProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ContextMenu.CustomPopupPlacementCallbackProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ContextMenu.CustomPopupPlacementCallback" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HandlesScrolling">
      <MemberSignature Language="C#" Value="protected internal override bool HandlesScrolling { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HandlesScrolling" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ContextMenu.HandlesScrolling" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property HandlesScrolling As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool HandlesScrolling { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HandlesScrolling : bool" Usage="System.Windows.Controls.ContextMenu.HandlesScrolling" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the control supports scrolling.</summary>
        <value>Always <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 If the control has a <xref:System.Windows.Controls.ScrollViewer> in its style and has a custom keyboard scrolling behavior, <xref:System.Windows.Controls.ListBox.HandlesScrolling%2A> should return `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasDropShadow">
      <MemberSignature Language="C#" Value="public bool HasDropShadow { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasDropShadow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ContextMenu.HasDropShadow" />
      <MemberSignature Language="VB.NET" Value="Public Property HasDropShadow As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasDropShadow { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.HasDropShadow : bool with get, set" Usage="System.Windows.Controls.ContextMenu.HasDropShadow" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the context menu appears with a dropped shadow.</summary>
        <value>
          <see langword="true" /> if the context menu appears with a dropped shadow; otherwise, <see langword="false" />. The default is <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When the <xref:System.Windows.Controls.ContextMenu> opens, the value is set to the value of <xref:System.Windows.SystemParameters.DropShadow%2A?displayProperty=nameWithType>. Setting this property to `true` has no effect if the <xref:System.Windows.SystemParameters.DropShadow%2A?displayProperty=nameWithType> property is `false`.  
  
<a name="dependencyPropertyInfo_"></a>   
## Dependency Property Information  
  
|||  
|-|-|  
|Identifier field|<xref:System.Windows.Controls.ContextMenu.HasDropShadowProperty>|  
|Metadata properties set to `true`|None|  
  
   
  
## Examples  
 The following example shows how to use the <xref:System.Windows.Controls.ContextMenu.HasDropShadow%2A> property.  
  
 [!code-xaml[ContextMenu#ContextMenuProps](~/samples/snippets/csharp/VS_Snippets_Wpf/ContextMenu/CSharp/Pane1.xaml#contextmenuprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="HasDropShadowProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HasDropShadowProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HasDropShadowProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ContextMenu.HasDropShadowProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HasDropShadowProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HasDropShadowProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HasDropShadowProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ContextMenu.HasDropShadowProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ContextMenu.HasDropShadow" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalOffset">
      <MemberSignature Language="C#" Value="public double HorizontalOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 HorizontalOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ContextMenu.HorizontalOffset" />
      <MemberSignature Language="VB.NET" Value="Public Property HorizontalOffset As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double HorizontalOffset { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.HorizontalOffset : double with get, set" Usage="System.Windows.Controls.ContextMenu.HorizontalOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Layout")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Get or sets the horizontal distance between the target origin and the popup alignment point.</summary>
        <value>The horizontal distance between the target origin and the popup alignment point. For information about the target origin and popup alignment point, see [Popup Placement Behavior](~/docs/framework/wpf/controls/popup-placement-behavior.md). The default is 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 You can position a <xref:System.Windows.Controls.ContextMenu> by setting the <xref:System.Windows.Controls.ContextMenu.PlacementTarget%2A>, <xref:System.Windows.Controls.ContextMenu.PlacementRectangle%2A>, <xref:System.Windows.Controls.ContextMenu.Placement%2A>, <xref:System.Windows.Controls.ContextMenu.HorizontalOffset%2A>, and <xref:System.Windows.Controls.ContextMenu.VerticalOffsetProperty> properties.  These properties behave the same as they do for a <xref:System.Windows.Controls.Primitives.Popup>. For more information, see [Popup Placement Behavior](~/docs/framework/wpf/controls/popup-placement-behavior.md).  
  
<a name="dependencyPropertyInfo_HorizontalOffset"></a>   
## Dependency Property Information  
  
|||  
|-|-|  
|Identifier field|<xref:System.Windows.Controls.ContextMenu.HorizontalOffsetProperty>|  
|Metadata properties set to `true`|None|  
  
<a name="xamlAttributeUsage_HorizontalOffset"></a>   
## XAML Attribute Usage  
  
```  
<object HorizontalOffset="double"/>  
- or -  
<object HorizontalOffset ="qualifiedDouble"/>  
```  
  
<a name="xamlValues_HorizontalOffset"></a>   
## XAML Values  
 *double*  
 <xref:System.Double>  
  
 String representation of a <xref:System.Double> value. This is interpreted as a [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] measurement. Strings need not explicitly include decimal points. For instance a value of `1` is acceptable.  
  
 The same <xref:System.Double> range restrictions as mentioned in the Property Value section apply.  
  
 *qualifiedDouble*  
 A *double* value as described above, followed by one of the following unit declaration strings: `px`, `in`, `cm`, `pt`.  
  
 `px` (default) is [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm` is centimeters; 1cm==(96/2.54) px  
  
 `pt` is points; 1pt==(96/72) px  
  
 **Note** In many cases a double may be set to Auto but a <xref:System.Windows.Controls.ContextMenu> will not appear if the offsets are set to Auto.  
  
   
  
## Examples  
 The following example shows how to use the <xref:System.Windows.Controls.ContextMenu.HorizontalOffset%2A> property to cause a <xref:System.Windows.Controls.ContextMenu> to open at a specified location in relation to its button parent.  
  
 [!code-xaml[ContextMenu#ContextMenuProps](~/samples/snippets/csharp/VS_Snippets_Wpf/ContextMenu/CSharp/Pane1.xaml#contextmenuprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="HorizontalOffsetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HorizontalOffsetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HorizontalOffsetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ContextMenu.HorizontalOffsetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HorizontalOffsetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HorizontalOffsetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable HorizontalOffsetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ContextMenu.HorizontalOffsetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ContextMenu.HorizontalOffset" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOpen">
      <MemberSignature Language="C#" Value="public bool IsOpen { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOpen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ContextMenu.IsOpen" />
      <MemberSignature Language="VB.NET" Value="Public Property IsOpen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOpen { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsOpen : bool with get, set" Usage="System.Windows.Controls.ContextMenu.IsOpen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the <see cref="T:System.Windows.Controls.ContextMenu" /> is visible.</summary>
        <value>
          <see langword="true" /> if the <see cref="T:System.Windows.Controls.ContextMenu" /> is visible; otherwise, <see langword="false" />. The default is <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When <xref:System.Windows.Controls.ContextMenu.IsOpen%2A> is set to `true`, mouse capture is set to the <xref:System.Windows.Controls.ContextMenu> and its subtree.  
  
<a name="dependencyPropertyInfo_IsOpen"></a>   
## Dependency Property Information  
  
|||  
|-|-|  
|Identifier field|<xref:System.Windows.Controls.ContextMenu.IsOpenProperty>|  
|Metadata properties set to `true`|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>|  
  
   
  
## Examples  
 This example shows how to check to determine whether the <xref:System.Windows.Controls.ContextMenu.IsOpen%2A> property is set to `true`.  
  
 [!code-csharp[ContextMenu#ContextMenuIsOpen](~/samples/snippets/csharp/VS_Snippets_Wpf/ContextMenu/CSharp/Pane1.xaml.cs#contextmenuisopen)]
 [!code-vb[ContextMenu#ContextMenuIsOpen](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContextMenu/VisualBasic/Pane1.xaml.vb#contextmenuisopen)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="IsOpenProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsOpenProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsOpenProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ContextMenu.IsOpenProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsOpenProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsOpenProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsOpenProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ContextMenu.IsOpenProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ContextMenu.IsOpen" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ContextMenu.OnClosed(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosed (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosed(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClosed : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnClosed : System.Windows.RoutedEventArgs -&gt; unit" Usage="contextMenu.OnClosed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">The event data for the <see cref="E:System.Windows.Controls.ContextMenu.Closed" /> event.</param>
        <summary>Called when the <see cref="E:System.Windows.Controls.ContextMenu.Closed" /> event occurs.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ContextMenu.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="contextMenu.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates and returns a <see cref="T:System.Windows.Automation.Peers.ContextMenuAutomationPeer" /> object for this <see cref="T:System.Windows.Controls.ContextMenu" />.</summary>
        <returns>A <see cref="T:System.Windows.Automation.Peers.ContextMenuAutomationPeer" /> object for this <see cref="T:System.Windows.Controls.ContextMenu" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="protected override void OnIsKeyboardFocusWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnIsKeyboardFocusWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ContextMenu.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnIsKeyboardFocusWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnIsKeyboardFocusWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="override this.OnIsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contextMenu.OnIsKeyboardFocusWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">The event data for the <see cref="E:System.Windows.UIElement.IsKeyboardFocusWithinChanged" /> event.</param>
        <summary>Reports that the <see cref="P:System.Windows.UIElement.IsKeyboardFocusWithin" /> property changed.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected override void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ContextMenu.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="contextMenu.OnKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">The event data for the <see cref="E:System.Windows.UIElement.KeyDown" /> event.</param>
        <summary>Called when a <see cref="E:System.Windows.ContentElement.KeyDown" /> event is raised by an object inside the <see cref="T:System.Windows.Controls.ContextMenu" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected override void OnKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ContextMenu.OnKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="contextMenu.OnKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">The event data for the <see cref="E:System.Windows.UIElement.KeyUp" /> event.</param>
        <summary>Responds to the <see cref="E:System.Windows.ContentElement.KeyUp" /> event.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnOpened">
      <MemberSignature Language="C#" Value="protected virtual void OnOpened (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnOpened(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ContextMenu.OnOpened(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnOpened (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnOpened(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnOpened : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnOpened : System.Windows.RoutedEventArgs -&gt; unit" Usage="contextMenu.OnOpened e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">The event data for the <see cref="E:System.Windows.Controls.ContextMenu.Opened" /> event.</param>
        <summary>Called when the <see cref="E:System.Windows.Controls.ContextMenu.Opened" /> event occurs.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ContextMenu.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="contextMenu.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">The object that the context menu was previously attached to.</param>
        <summary>Called when a context menu's visual parent changes.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Opened">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Opened;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Opened" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Controls.ContextMenu.Opened" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Opened As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Opened;" />
      <MemberSignature Language="F#" Value="member this.Opened : System.Windows.RoutedEventHandler " Usage="member this.Opened : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Occurs when a particular instance of a context menu opens.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_Opened"></a>   
## Routed Event Information  
  
|||  
|-|-|  
|Identifier field|<xref:System.Windows.Controls.ContextMenu.OpenedEvent>|  
|Routing strategy|Bubbling|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
   
  
## Examples  
 The following example shows how use the <xref:System.Windows.Controls.ContextMenu> events: <xref:System.Windows.Controls.ContextMenu.Opened> and <xref:System.Windows.Controls.ContextMenu.Closed>.  
  
 [!code-xaml[ContextMenu#ContextMenuEvents](~/samples/snippets/csharp/VS_Snippets_Wpf/ContextMenu/CSharp/Pane1.xaml#contextmenuevents)]  
  
 [!code-csharp[ContextMenu#ContextMenuEventHandlers](~/samples/snippets/csharp/VS_Snippets_Wpf/ContextMenu/CSharp/Pane1.xaml.cs#contextmenueventhandlers)]
 [!code-vb[ContextMenu#ContextMenuEventHandlers](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContextMenu/VisualBasic/Pane1.xaml.vb#contextmenueventhandlers)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="OpenedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent OpenedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent OpenedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ContextMenu.OpenedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OpenedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ OpenedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable OpenedEvent : System.Windows.RoutedEvent" Usage="System.Windows.Controls.ContextMenu.OpenedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="E:System.Windows.Controls.ContextMenu.Opened" /> routed event.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Placement">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.Primitives.PlacementMode Placement { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Controls.Primitives.PlacementMode Placement" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ContextMenu.Placement" />
      <MemberSignature Language="VB.NET" Value="Public Property Placement As PlacementMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::Primitives::PlacementMode Placement { System::Windows::Controls::Primitives::PlacementMode get(); void set(System::Windows::Controls::Primitives::PlacementMode value); };" />
      <MemberSignature Language="F#" Value="member this.Placement : System.Windows.Controls.Primitives.PlacementMode with get, set" Usage="System.Windows.Controls.ContextMenu.Placement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Layout")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.Primitives.PlacementMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="P:System.Windows.Controls.ContextMenu.Placement" /> property of a <see cref="T:System.Windows.Controls.ContextMenu" />.</summary>
        <value>One of the <see cref="T:System.Windows.Controls.Primitives.PlacementMode" /> enumeration. The default is <see cref="F:System.Windows.Controls.Primitives.PlacementMode.MousePoint" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When the <xref:System.Windows.Controls.ContextMenu> is assigned to the <xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=nameWithType> or <xref:System.Windows.FrameworkContentElement.ContextMenu%2A?displayProperty=nameWithType> property, the <xref:System.Windows.Controls.ContextMenuService> changes this value of this property when the <xref:System.Windows.Controls.ContextMenu> opens. If the user opens the <xref:System.Windows.Controls.ContextMenu> by using the mouse, <xref:System.Windows.Controls.ContextMenu.Placement%2A> is set to <xref:System.Windows.Controls.Primitives.PlacementMode.MousePoint>.  If the user opens the <xref:System.Windows.Controls.ContextMenu> by using the keyboard, <xref:System.Windows.Controls.ContextMenu.Placement%2A> is set to <xref:System.Windows.Controls.Primitives.PlacementMode.Center>.  If you want to change the position of the <xref:System.Windows.Controls.ContextMenu>, set the <xref:System.Windows.Controls.ContextMenuService.Placement%2A?displayProperty=nameWithType> property on the <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>.  
  
 You can position a <xref:System.Windows.Controls.ContextMenu> by setting the <xref:System.Windows.Controls.ContextMenu.PlacementTarget%2A>, <xref:System.Windows.Controls.ContextMenu.PlacementRectangle%2A>, <xref:System.Windows.Controls.ContextMenu.Placement%2A>, <xref:System.Windows.Controls.ContextMenu.HorizontalOffset%2A>, and <xref:System.Windows.Controls.ContextMenu.VerticalOffsetProperty> properties.  These properties behave the same as they do for a <xref:System.Windows.Controls.Primitives.Popup>. For more information, see [Popup Placement Behavior](~/docs/framework/wpf/controls/popup-placement-behavior.md).  
  
<a name="dependencyPropertyInfo_Placement"></a>   
## Dependency Property Information  
  
|||  
|-|-|  
|Identifier field|<xref:System.Windows.Controls.ContextMenu.PlacementProperty>|  
|Metadata properties set to `true`|None|  
  
   
  
## Examples  
 The following example shows how to use the <xref:System.Windows.Controls.ContextMenu.Placement%2A> property and a placement mode to specify where the <xref:System.Windows.Controls.ContextMenu> is placed.  
  
 [!code-xaml[ContextMenu#ContextMenuPlacement](~/samples/snippets/csharp/VS_Snippets_Wpf/ContextMenu/CSharp/Pane1.xaml#contextmenuplacement)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="PlacementProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty PlacementProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty PlacementProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ContextMenu.PlacementProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PlacementProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ PlacementProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable PlacementProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ContextMenu.PlacementProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ContextMenu.Placement" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PlacementRectangle">
      <MemberSignature Language="C#" Value="public System.Windows.Rect PlacementRectangle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect PlacementRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ContextMenu.PlacementRectangle" />
      <MemberSignature Language="VB.NET" Value="Public Property PlacementRectangle As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Rect PlacementRectangle { System::Windows::Rect get(); void set(System::Windows::Rect value); };" />
      <MemberSignature Language="F#" Value="member this.PlacementRectangle : System.Windows.Rect with get, set" Usage="System.Windows.Controls.ContextMenu.PlacementRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Layout")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the area relative to which the context menu is positioned when it opens.</summary>
        <value>The area that defines the rectangle that is used to position the context menu. The default is <see cref="P:System.Windows.Rect.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 You can position a <xref:System.Windows.Controls.ContextMenu> by setting the <xref:System.Windows.Controls.ContextMenu.PlacementTarget%2A>, <xref:System.Windows.Controls.ContextMenu.PlacementRectangle%2A>, <xref:System.Windows.Controls.ContextMenu.Placement%2A>, <xref:System.Windows.Controls.ContextMenu.HorizontalOffset%2A>, and <xref:System.Windows.Controls.ContextMenu.VerticalOffsetProperty> properties.  These properties behave the same as they do for a <xref:System.Windows.Controls.Primitives.Popup>. For more information, see [Popup Placement Behavior](~/docs/framework/wpf/controls/popup-placement-behavior.md).  
  
<a name="dependencyPropertyInfo_PlacementRectangle"></a>   
## Dependency Property Information  
  
|||  
|-|-|  
|Identifier field|<xref:System.Windows.Controls.ContextMenu.PlacementRectangleProperty>|  
|Metadata properties set to `true`|None|  
  
   
  
## Examples  
 The following example shows how to use the <xref:System.Windows.Controls.ContextMenu.PlacementRectangle%2A> property and specify where the <xref:System.Windows.Controls.ContextMenu> is placed.  
  
 [!code-xaml[ContextMenu#ContextMenuPlacement](~/samples/snippets/csharp/VS_Snippets_Wpf/ContextMenu/CSharp/Pane1.xaml#contextmenuplacement)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="PlacementRectangleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty PlacementRectangleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty PlacementRectangleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ContextMenu.PlacementRectangleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PlacementRectangleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ PlacementRectangleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable PlacementRectangleProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ContextMenu.PlacementRectangleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ContextMenu.PlacementRectangle" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PlacementTarget">
      <MemberSignature Language="C#" Value="public System.Windows.UIElement PlacementTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.UIElement PlacementTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ContextMenu.PlacementTarget" />
      <MemberSignature Language="VB.NET" Value="Public Property PlacementTarget As UIElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::UIElement ^ PlacementTarget { System::Windows::UIElement ^ get(); void set(System::Windows::UIElement ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PlacementTarget : System.Windows.UIElement with get, set" Usage="System.Windows.Controls.ContextMenu.PlacementTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Layout")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.UIElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.Windows.UIElement" /> relative to which the <see cref="T:System.Windows.Controls.ContextMenu" /> is positioned when it opens.</summary>
        <value>The element relative to which the <see cref="T:System.Windows.Controls.ContextMenu" /> is positioned when it opens. The default is <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 When the <xref:System.Windows.Controls.ContextMenu> is assigned to the <xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=nameWithType> or <xref:System.Windows.FrameworkContentElement.ContextMenu%2A?displayProperty=nameWithType> property, the <xref:System.Windows.Controls.ContextMenuService> changes this value of this property to the owning <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> when the <xref:System.Windows.Controls.ContextMenu> opens. To use a different <xref:System.Windows.UIElement>, set the <xref:System.Windows.Controls.ContextMenuService.PlacementTarget%2A?displayProperty=nameWithType> property.  
  
<a name="dependencyPropertyInfo_PlacementTarget"></a>   
## Dependency Property Information  
  
|||  
|-|-|  
|Identifier field|<xref:System.Windows.Controls.ContextMenu.PlacementTargetProperty>|  
|Metadata properties set to `true`|None|  
  
   
  
## Examples  
 The target of a <xref:System.Windows.Controls.ContextMenu> is its parent. The following examples show how to use the <xref:System.Windows.Controls.ContextMenu.PlacementTarget%2A> property to find the parent of a <xref:System.Windows.Controls.ContextMenu>.  
  
 [!code-csharp[TabControlwithContextMenu#3](~/samples/snippets/csharp/VS_Snippets_Wpf/TabControlwithContextMenu/CSharp/Pane1.xaml.cs#3)]
 [!code-vb[TabControlwithContextMenu#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TabControlwithContextMenu/visualbasic/pane1.xaml.vb#3)]  
  
 [!code-csharp[TabControlContextMenu_snip#FromItemContainer](~/samples/snippets/csharp/VS_Snippets_Wpf/TabControlContextMenu_snip/CSharp/Pane1.xaml.cs#fromitemcontainer)]
 [!code-vb[TabControlContextMenu_snip#FromItemContainer](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TabControlContextMenu_snip/visualbasic/pane1.xaml.vb#fromitemcontainer)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="PlacementTargetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty PlacementTargetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty PlacementTargetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ContextMenu.PlacementTargetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PlacementTargetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ PlacementTargetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable PlacementTargetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ContextMenu.PlacementTargetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ContextMenu.PlacementTarget" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PrepareContainerForItemOverride">
      <MemberSignature Language="C#" Value="protected override void PrepareContainerForItemOverride (System.Windows.DependencyObject element, object item);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void PrepareContainerForItemOverride(class System.Windows.DependencyObject element, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Controls.ContextMenu.PrepareContainerForItemOverride(System.Windows.DependencyObject,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub PrepareContainerForItemOverride (element As DependencyObject, item As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void PrepareContainerForItemOverride(System::Windows::DependencyObject ^ element, System::Object ^ item);" />
      <MemberSignature Language="F#" Value="override this.PrepareContainerForItemOverride : System.Windows.DependencyObject * obj -&gt; unit" Usage="contextMenu.PrepareContainerForItemOverride (element, item)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="element">Element used to display the specified item.</param>
        <param name="item">Specified item.</param>
        <summary>Prepares the specified element to display the specified item.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Preparing the element may involve applying styles, setting bindings, and so on.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StaysOpen">
      <MemberSignature Language="C#" Value="public bool StaysOpen { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool StaysOpen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ContextMenu.StaysOpen" />
      <MemberSignature Language="VB.NET" Value="Public Property StaysOpen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool StaysOpen { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.StaysOpen : bool with get, set" Usage="System.Windows.Controls.ContextMenu.StaysOpen" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether the <see cref="T:System.Windows.Controls.ContextMenu" /> should close automatically.</summary>
        <value>
          <see langword="true" /> if the menu should stay open until the <see cref="P:System.Windows.Controls.ContextMenu.IsOpen" /> property changes to <see langword="false" />; otherwise, <see langword="false" />. The default is <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_StaysOpen"></a>   
## Dependency Property Information  
  
|||  
|-|-|  
|Identifier field|<xref:System.Windows.Controls.ContextMenu.StaysOpenProperty>|  
|Metadata properties set to `true`|None|  
  
   
  
## Examples  
 The following example uses the <xref:System.Windows.Controls.ContextMenu.StaysOpen%2A> property to make a context menu that will stay open until an event occurs that changes the <xref:System.Windows.Controls.ContextMenu.IsOpen%2A> property to `false`.  
  
 [!code-xaml[ContextMenu#ContextMenuEvents](~/samples/snippets/csharp/VS_Snippets_Wpf/ContextMenu/CSharp/Pane1.xaml#contextmenuevents)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="StaysOpenProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StaysOpenProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StaysOpenProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ContextMenu.StaysOpenProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StaysOpenProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StaysOpenProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable StaysOpenProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ContextMenu.StaysOpenProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ContextMenu.StaysOpen" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalOffset">
      <MemberSignature Language="C#" Value="public double VerticalOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 VerticalOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Controls.ContextMenu.VerticalOffset" />
      <MemberSignature Language="VB.NET" Value="Public Property VerticalOffset As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double VerticalOffset { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.VerticalOffset : double with get, set" Usage="System.Windows.Controls.ContextMenu.VerticalOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Layout")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Get or sets the vertical distance between the target origin and the popup alignment point.</summary>
        <value>The vertical distance between the target origin and the popup alignment point. For information about the target origin and popup alignment point, see [Popup Placement Behavior](~/docs/framework/wpf/controls/popup-placement-behavior.md). The default is 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 You can position a <xref:System.Windows.Controls.ContextMenu> by setting the <xref:System.Windows.Controls.ContextMenu.PlacementTarget%2A>, <xref:System.Windows.Controls.ContextMenu.PlacementRectangle%2A>, <xref:System.Windows.Controls.ContextMenu.Placement%2A>, <xref:System.Windows.Controls.ContextMenu.HorizontalOffset%2A>, and <xref:System.Windows.Controls.ContextMenu.VerticalOffsetProperty> properties.  These properties behave the same as they do for a <xref:System.Windows.Controls.Primitives.Popup>. For more information, see [Popup Placement Behavior](~/docs/framework/wpf/controls/popup-placement-behavior.md).  
  
<a name="dependencyPropertyInfo_VerticalOffset"></a>   
## Dependency Property Information  
  
|||  
|-|-|  
|Identifier field|<xref:System.Windows.Controls.ContextMenu.VerticalOffsetProperty>|  
|Metadata properties set to `true`|None|  
  
<a name="xamlAttributeUsage_VerticalOffset"></a>   
## XAML Attribute Usage  
  
```  
<object VerticalOffset="double"/>  
- or -  
<object VerticalOffset ="qualifiedDouble"/>  
```  
  
<a name="xamlValues_VerticalOffset"></a>   
## XAML Values  
 *double*  
 <xref:System.Double>  
  
 String representation of a <xref:System.Double> value. This is interpreted as a [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] measurement. Strings need not explicitly include decimal points. For instance, a value of `1` is acceptable. The same <xref:System.Double> range restrictions as mentioned in the Property Value section apply.  
  
 *qualifiedDouble*  
 A *double* value as described above, followed by one of the following unit declaration strings: `px`, `in`, `cm`, `pt`.  
  
 `px` (default) is [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` is inches; 1in==96px  
  
 `cm` is centimeters; 1cm==(96/2.54) px  
  
 `pt` is points; 1pt==(96/72) px  
  
> [!NOTE]
>  In many cases a double may be set to Auto, but a <xref:System.Windows.Controls.ContextMenu> does not appear if the offsets are set to Auto.  
  
   
  
## Examples  
 The following example shows how to use the <xref:System.Windows.Controls.ContextMenu.VerticalOffset%2A> property to cause a <xref:System.Windows.Controls.ContextMenu> to open at a specified location in relation to its button parent.  
  
 [!code-xaml[ContextMenu#ContextMenuProps](~/samples/snippets/csharp/VS_Snippets_Wpf/ContextMenu/CSharp/Pane1.xaml#contextmenuprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenuService" />
      </Docs>
    </Member>
    <Member MemberName="VerticalOffsetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VerticalOffsetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VerticalOffsetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Controls.ContextMenu.VerticalOffsetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VerticalOffsetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VerticalOffsetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable VerticalOffsetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Controls.ContextMenu.VerticalOffsetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifies the <see cref="P:System.Windows.Controls.ContextMenu.VerticalOffset" /> dependency property.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
