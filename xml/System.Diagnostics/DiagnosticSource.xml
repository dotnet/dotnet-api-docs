<Type Name="DiagnosticSource" FullName="System.Diagnostics.DiagnosticSource">
  <TypeSignature Language="C#" Value="public abstract class DiagnosticSource" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit DiagnosticSource extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.DiagnosticSource" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class DiagnosticSource" />
  <TypeSignature Language="C++ CLI" Value="public ref class DiagnosticSource abstract" />
  <TypeSignature Language="F#" Value="type DiagnosticSource = class" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.1</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.0.4.0</AssemblyVersion>
    <AssemblyVersion>4.0.5.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>An abstract class that allows code to be instrumented for production-time logging of rich data payloads for consumption within the process that was instrumented.</summary>
    <remarks>For more information, see [DiagnosticSource User's Guide](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md).</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected DiagnosticSource ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; DiagnosticSource();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes an instance of the <see cref="T:System.Diagnostics.DiagnosticSource" /> class.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public abstract bool IsEnabled (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnabled(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.IsEnabled(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function IsEnabled (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool IsEnabled(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member IsEnabled : string -&gt; bool" Usage="diagnosticSource.IsEnabled name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The name of the event being written.</param>
        <summary>Verifies if the notification event is enabled.</summary>
        <returns>
          <see langword="true" /> if the notification event is enabled, <see langword="false" /> otherwise.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

If there is expensive setup for the notification, you can call IsEnabled before performing this setup. Consumers should not assume that they only get notifications for which IsEnabled is true. However, it is optional for producers to call this API. The name should be the same as that passed to <see cref="M:System.Diagnostics.DiagnosticSource.Write(System.String,System.Object)" />.

           ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public virtual bool IsEnabled (string name, object arg1, object arg2 = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnabled(string name, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.IsEnabled(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnabled (name As String, arg1 As Object, Optional arg2 As Object = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member IsEnabled : string * obj * obj -&gt; bool&#xA;override this.IsEnabled : string * obj * obj -&gt; bool" Usage="diagnosticSource.IsEnabled (name, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
        <Parameter Name="arg1" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
        <Parameter Name="arg2" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="name">The name of the event being written.</param>
        <param name="arg1">An object that represents the additional context for IsEnabled. Consumers should expect to receive <see langword="null" /> which may indicate that producer called pure IsEnabled(string) to check if consumer wants to get notifications for such events at all. Based on that, producer may call IsEnabled(string, object, object) again with non-<see langword="null" /> context.</param>
        <param name="arg2">Optional. An object that represents the additional context for IsEnabled. <see langword="null" /> by default. Consumers should expect to receive <see langword="null" /> which may indicate that producer called pure IsEnabled(string) or producer passed all necessary context in <paramref name="arg1" />.</param>
        <summary>Verifies it the notification event is enabled.</summary>
        <returns>
          <see langword="true" /> if the notification event is enabled, <see langword="false" /> otherwise.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
          
If there is expensive setup for the notification, you can call this method and provide context before performing the setup.
          
           ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnActivityExport">
      <MemberSignature Language="C#" Value="public virtual void OnActivityExport (System.Diagnostics.Activity activity, object payload);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnActivityExport(class System.Diagnostics.Activity activity, object payload) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.OnActivityExport(System.Diagnostics.Activity,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnActivityExport (activity As Activity, payload As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnActivityExport(System::Diagnostics::Activity ^ activity, System::Object ^ payload);" />
      <MemberSignature Language="F#" Value="abstract member OnActivityExport : System.Diagnostics.Activity * obj -&gt; unit&#xA;override this.OnActivityExport : System.Diagnostics.Activity * obj -&gt; unit" Usage="diagnosticSource.OnActivityExport (activity, payload)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Diagnostics.Activity" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="payload" Type="System.Object" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="activity">The activity affected by an external event.</param>
        <param name="payload">An object that represents the outgoing request.</param>
        <summary>Transfers state from an activity to some event or operation, such as an outgoing HTTP request, that will occur outside the process.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

If an instrumentation site is at a location where activities leave the process (such as outgoing HTTP requests), that site will want to transfer state from the activity to the outgoing request.

To the extent possible, this should be done by the instrumentation site, because there is a contract between an <xref:System.Diagnostics.Activity> and the ougoing request logic at the instrumentation site.   However, the instrumentation site can't handle policy (for example, whether activity information should be disabled or written in an older format for compatibility reasons).
For this, the instrumentation site needs to call back out to the logging system and ask it to resolve policy. This is the purpose of the `OnActivityExport` method.

The `OnActivityExport` method is given the <xref:System.Diagnostics.Activity> as well as a payload object that represents the outgoing request. A <xref:System.Diagnostics.DiagnosticSource> subscriber then has the ability to update the outgoing request before it is sent.
 
Note that this method is rarely used at instrumentation sites (only those sites that are on an outgoing boundary of the process).   Moreover, typically the default policy that the instrumentation site performs (for example, to transfer all activity state in a 
particular outgoing convention) is likely to be fine. This method is only for cases where that is a problem. Thus, this method should be used very rarely and is mostly here for symetry with `OnActivityImport` and future-proofing.

Note that `payload` is typed as an <xref:System.Object> here, but any particular instrumentation site and subscriber should know the type of the payload and thus cast and decode it if necessary.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnActivityImport">
      <MemberSignature Language="C#" Value="public virtual void OnActivityImport (System.Diagnostics.Activity activity, object payload);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnActivityImport(class System.Diagnostics.Activity activity, object payload) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.OnActivityImport(System.Diagnostics.Activity,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnActivityImport (activity As Activity, payload As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnActivityImport(System::Diagnostics::Activity ^ activity, System::Object ^ payload);" />
      <MemberSignature Language="F#" Value="abstract member OnActivityImport : System.Diagnostics.Activity * obj -&gt; unit&#xA;override this.OnActivityImport : System.Diagnostics.Activity * obj -&gt; unit" Usage="diagnosticSource.OnActivityImport (activity, payload)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Diagnostics.Activity" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1" />
        <Parameter Name="payload" Type="System.Object" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="activity">The activity affected by an external event.</param>
        <param name="payload">A payload that represents the incoming request.</param>
        <summary>Transfers state to an activity from some event or operation, such as an incoming request, that occurred outside the process.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

If an instrumentation site creates a new activity in response to some event outside the process, such as an incomming HTTP request), the `OnActivityImport` method allows that site will want to create a new activity and transfer state from the incoming request to the activity. 

To the extent possible, this should be done by the instrumentation site, because there is a contract between the <xref:System.Diagnostics.Activity> and the incomming request logic at the instrumentation site.   However, the instrumentation site can't handle policy. (For example, if sampling is done, exactly which requests should be sampled?) In these cases, the instrumentation site needs to call back out to the logging system and ask it to resolve policy (for example, to decide if the activity's "sampling" bit should be set). This is the purpose of the `OnActivityImport` method. It is given the activity as well as a payload object that represents the incomming request. The subscribers to the <xref:System.Diagnostics.DiagnosticSource> then have the opportunity to update this activity as desired. 

This method is rarely used at instrumentation sites (only those sites that are on the boundary of the process), and the instrumetation site implements some default policy (it sets the activity in *some* way), and so it is not necessary to override this method if that default policy is fine. In other words, this method should be overridden in very rare (but often important) cases.

Note that `payload` is typed as <xref:System.Object> here, but any particular instrumentation site and subscriber will know the type of the payload and thus cast and decode it if necessary.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StartActivity">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Activity StartActivity (System.Diagnostics.Activity activity, object args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Activity StartActivity(class System.Diagnostics.Activity activity, object args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.StartActivity(System.Diagnostics.Activity,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartActivity (activity As Activity, args As Object) As Activity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Diagnostics::Activity ^ StartActivity(System::Diagnostics::Activity ^ activity, System::Object ^ args);" />
      <MemberSignature Language="F#" Value="member this.StartActivity : System.Diagnostics.Activity * obj -&gt; System.Diagnostics.Activity" Usage="diagnosticSource.StartActivity (activity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Activity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Diagnostics.Activity" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
        <Parameter Name="args" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="activity">The <see cref="T:System.Diagnostics.Activity" /> to be started.</param>
        <param name="args">An object that represent the value being passed as a payload for the event.</param>
        <summary>Starts an <see cref="T:System.Diagnostics.Activity" /> and writes a start event.
</summary>
        <returns>The started activity for convenient chaining.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
           
The <xref:System.Diagnostics.Activity> describes the logical operation, its context, and parent relation; the current <xref:System.Diagnostics.Activity> flows through the operation processing.

This method starts the given <xref:System.Diagnostics.Activity>, maintains a global <xref:System.Diagnostics.Activity.Current?displayProperty=nameWithType> and <xref:System.Diagnostics.Activity.Parent?displayProperty=nameWithType> activity for the given <xref:System.Diagnostics.Activity>, and notifies consumers that a new <xref:System.Diagnostics.Activity> was started. Consumers can access <xref:System.Diagnostics.Activity.Current?displayProperty=nameWithType> to add context and/or augment telemetry.

Producers may pass additional details to the consumer in the payload.

           ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StopActivity">
      <MemberSignature Language="C#" Value="public void StopActivity (System.Diagnostics.Activity activity, object args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StopActivity(class System.Diagnostics.Activity activity, object args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.StopActivity(System.Diagnostics.Activity,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StopActivity (activity As Activity, args As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StopActivity(System::Diagnostics::Activity ^ activity, System::Object ^ args);" />
      <MemberSignature Language="F#" Value="member this.StopActivity : System.Diagnostics.Activity * obj -&gt; unit" Usage="diagnosticSource.StopActivity (activity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Diagnostics.Activity" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
        <Parameter Name="args" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="activity">The activity to be stopped.</param>
        <param name="args">An object that represents the value passed as a payload for the event.</param>
        <summary>Stops the given <see cref="T:System.Diagnostics.Activity" />, maintains the global <see cref="P:System.Diagnostics.Activity.Current" /> activity, and notifies consumers that the <see cref="T:System.Diagnostics.Activity" /> was stopped. 
            
</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Producers may pass additional details to the consumer in the payload.

Consumers can access <xref:System.Diagnostics.Activity.Current?displayProperty=nameWithType> to add context and/or augment telemetry.


         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public abstract void Write (string name, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(string name, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.DiagnosticSource.Write(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Write (name As String, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Write(System::String ^ name, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member Write : string * obj -&gt; unit" Usage="diagnosticSource.Write (name, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.1</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.0.4.0</AssemblyVersion>
        <AssemblyVersion>4.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">The name of the event being written.</param>
        <param name="value">An object that represents the value being passed as a payload for the event. This is often an anonymous type which contains several sub-values.</param>
        <summary>Provides a generic way of logging complex payloads. 
</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Each notification is given a name that identifies it, as well as an object (typically an anonymous type) that provides arbitrary information to pass to the notification.  

`name` should be short. Don't use a fully qualified name unless you have to to avoid ambiguity, since `name` must be globally unique. Typically, *componentName.eventName*, where *componentName* and *eventName* are strings less than 10 characters, are a good compromise.

Notification names should not have `.` in them because component names have dots, and for them both to have dots leads to ambiguity. We suggest that you use `_` instead.

Assume that listeners will use string prefixing to filter groups. Therefore, having a hierarchy of component names is a good practice.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
