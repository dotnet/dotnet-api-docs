<Type Name="Meter" FullName="System.Diagnostics.Metrics.Meter">
  <TypeSignature Language="C#" Value="public class Meter : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Meter extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Metrics.Meter" />
  <TypeSignature Language="VB.NET" Value="Public Class Meter&#xA;Implements IDisposable" />
  <TypeSignature Language="F#" Value="type Meter = class&#xA;    interface IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Meter : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Meter is the class responsible for creating and tracking the Instruments.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Meter (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String)" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.Metrics.Meter : string -&gt; System.Diagnostics.Metrics.Meter" Usage="new System.Diagnostics.Metrics.Meter name" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Meter(System::String ^ name);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The Meter name.</param>
        <summary>Initializes a new instance of the Meter using the meter name.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Meter (string name, string? version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, string version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, version As String)" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.Metrics.Meter : string * string -&gt; System.Diagnostics.Metrics.Meter" Usage="new System.Diagnostics.Metrics.Meter (name, version)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Meter(System::String ^ name, System::String ^ version);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="version" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The Meter name.</param>
        <param name="version">The optional Meter version.</param>
        <summary>Initializes a new instance of the Meter using the meter name and version.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCounter&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.Counter&lt;T&gt; CreateCounter&lt;T&gt; (string name, string? unit = default, string? description = default) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.Counter`1&lt;!!T&gt; CreateCounter&lt;struct .ctor (class System.ValueType) T&gt;(string name, string unit, string description) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateCounter``1(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCounter(Of T As Structure) (name As String, Optional unit As String = Nothing, Optional description As String = Nothing) As Counter(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateCounter : string * string * string -&gt; System.Diagnostics.Metrics.Counter&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateCounter (name, unit, description)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.Counter&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="unit" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement.</typeparam>
        <param name="name">The instrument name. cannot be <see langword="null" />.</param>
        <param name="unit">Optional instrument unit of measurements.</param>
        <param name="description">Optional instrument description.</param>
        <summary>Create a metrics Counter object.</summary>
        <returns>A new counter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Counter is an Instrument which supports non-negative increments.
            Example uses for Counter: count the number of bytes received, count the number of requests completed, count the number of accounts created, count the number of checkpoints run, and count the number of HTTP 5xx errors.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateHistogram&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.Histogram&lt;T&gt; CreateHistogram&lt;T&gt; (string name, string? unit = default, string? description = default) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.Histogram`1&lt;!!T&gt; CreateHistogram&lt;struct .ctor (class System.ValueType) T&gt;(string name, string unit, string description) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateHistogram``1(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateHistogram(Of T As Structure) (name As String, Optional unit As String = Nothing, Optional description As String = Nothing) As Histogram(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateHistogram : string * string * string -&gt; System.Diagnostics.Metrics.Histogram&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateHistogram (name, unit, description)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.Histogram&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="unit" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement.</typeparam>
        <param name="name">The instrument name. cannot be <see langword="null" />.</param>
        <param name="unit">Optional instrument unit of measurements.</param>
        <param name="description">Optional instrument description.</param>
        <summary>Histogram is an Instrument which can be used to report arbitrary values that are likely to be statistically meaningful. It is intended for statistics such as histograms, summaries, and percentile.</summary>
        <returns>Returns a new Histogram.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Example uses for Histogram: the request duration and the size of the response payload.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObservableCounter&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.ObservableCounter&lt;T&gt; CreateObservableCounter&lt;T&gt; (string name, Func&lt;System.Collections.Generic.IEnumerable&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt;&gt; observeValues, string? unit = default, string? description = default) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.ObservableCounter`1&lt;!!T&gt; CreateObservableCounter&lt;struct .ctor (class System.ValueType) T&gt;(string name, class System.Func`1&lt;class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Diagnostics.Metrics.Measurement`1&lt;!!T&gt;&gt;&gt; observeValues, string unit, string description) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateObservableCounter``1(System.String,System.Func{System.Collections.Generic.IEnumerable{System.Diagnostics.Metrics.Measurement{``0}}},System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObservableCounter(Of T As Structure) (name As String, observeValues As Func(Of IEnumerable(Of Measurement(Of T))), Optional unit As String = Nothing, Optional description As String = Nothing) As ObservableCounter(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateObservableCounter : string * Func&lt;seq&lt;System.Diagnostics.Metrics.Measurement&lt;'T&gt;&gt;&gt; * string * string -&gt; System.Diagnostics.Metrics.ObservableCounter&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateObservableCounter (name, observeValues, unit, description)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.ObservableCounter&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="observeValues" Type="System.Func&lt;System.Collections.Generic.IEnumerable&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt;&gt;" />
        <Parameter Name="unit" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement.</typeparam>
        <param name="name">The instrument name. cannot be <see langword="null" />.</param>
        <param name="observeValues">The callback to call to get the measurements when the <see cref="M:System.Diagnostics.Metrics.ObservableCounter`1.Observe" /> is called by <see cref="M:System.Diagnostics.Metrics.MeterListener.RecordObservableInstruments" />.</param>
        <param name="unit">Optional instrument unit of measurements.</param>
        <param name="description">Optional instrument description.</param>
        <summary>ObservableCounter is an Instrument which reports monotonically increasing value(s) when the instrument is being observed.</summary>
        <returns>Returns a new ObservableCounter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Example uses for ObservableCounter: The number of page faults for each process.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObservableCounter&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.ObservableCounter&lt;T&gt; CreateObservableCounter&lt;T&gt; (string name, Func&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt; observeValue, string? unit = default, string? description = default) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.ObservableCounter`1&lt;!!T&gt; CreateObservableCounter&lt;struct .ctor (class System.ValueType) T&gt;(string name, class System.Func`1&lt;valuetype System.Diagnostics.Metrics.Measurement`1&lt;!!T&gt;&gt; observeValue, string unit, string description) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateObservableCounter``1(System.String,System.Func{System.Diagnostics.Metrics.Measurement{``0}},System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObservableCounter(Of T As Structure) (name As String, observeValue As Func(Of Measurement(Of T)), Optional unit As String = Nothing, Optional description As String = Nothing) As ObservableCounter(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateObservableCounter : string * Func&lt;System.Diagnostics.Metrics.Measurement&lt;'T&gt;&gt; * string * string -&gt; System.Diagnostics.Metrics.ObservableCounter&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateObservableCounter (name, observeValue, unit, description)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.ObservableCounter&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="observeValue" Type="System.Func&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt;" />
        <Parameter Name="unit" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement.</typeparam>
        <param name="name">The instrument name. cannot be <see langword="null" />.</param>
        <param name="observeValue">The callback to call to get the measurements when the <see cref="M:System.Diagnostics.Metrics.ObservableCounter`1.Observe" /> is called by <see cref="M:System.Diagnostics.Metrics.MeterListener.RecordObservableInstruments" /></param>
        <param name="unit">Optional instrument unit of measurements.</param>
        <param name="description">Optional instrument description.</param>
        <summary>ObservableCounter is an Instrument which reports monotonically increasing value(s) when the instrument is being observed.</summary>
        <returns>Returns a new ObservableCounter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Example uses for ObservableCounter: The number of page faults for each process.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObservableCounter&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.ObservableCounter&lt;T&gt; CreateObservableCounter&lt;T&gt; (string name, Func&lt;T&gt; observeValue, string? unit = default, string? description = default) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.ObservableCounter`1&lt;!!T&gt; CreateObservableCounter&lt;struct .ctor (class System.ValueType) T&gt;(string name, class System.Func`1&lt;!!T&gt; observeValue, string unit, string description) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateObservableCounter``1(System.String,System.Func{``0},System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObservableCounter(Of T As Structure) (name As String, observeValue As Func(Of T), Optional unit As String = Nothing, Optional description As String = Nothing) As ObservableCounter(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateObservableCounter : string * Func&lt;'T (requires 'T : struct)&gt; * string * string -&gt; System.Diagnostics.Metrics.ObservableCounter&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateObservableCounter (name, observeValue, unit, description)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.ObservableCounter&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="observeValue" Type="System.Func&lt;T&gt;" />
        <Parameter Name="unit" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement..</typeparam>
        <param name="name">The instrument name. cannot be <see langword="null" />.</param>
        <param name="observeValue">The callback to call to get the measurements when the <see cref="M:System.Diagnostics.Metrics.ObservableCounter`1.Observe" /> is called by <see cref="M:System.Diagnostics.Metrics.MeterListener.RecordObservableInstruments" />.</param>
        <param name="unit">Optional instrument unit of measurements.</param>
        <param name="description">Optional instrument description.</param>
        <summary>ObservableCounter is an Instrument which reports monotonically increasing value(s) when the instrument is being observed.</summary>
        <returns>Returns a new ObservableCounter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Example uses for ObservableCounter: The number of page faults for each process.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObservableGauge&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.ObservableGauge&lt;T&gt; CreateObservableGauge&lt;T&gt; (string name, Func&lt;System.Collections.Generic.IEnumerable&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt;&gt; observeValues, string? unit = default, string? description = default) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.ObservableGauge`1&lt;!!T&gt; CreateObservableGauge&lt;struct .ctor (class System.ValueType) T&gt;(string name, class System.Func`1&lt;class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Diagnostics.Metrics.Measurement`1&lt;!!T&gt;&gt;&gt; observeValues, string unit, string description) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateObservableGauge``1(System.String,System.Func{System.Collections.Generic.IEnumerable{System.Diagnostics.Metrics.Measurement{``0}}},System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObservableGauge(Of T As Structure) (name As String, observeValues As Func(Of IEnumerable(Of Measurement(Of T))), Optional unit As String = Nothing, Optional description As String = Nothing) As ObservableGauge(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateObservableGauge : string * Func&lt;seq&lt;System.Diagnostics.Metrics.Measurement&lt;'T&gt;&gt;&gt; * string * string -&gt; System.Diagnostics.Metrics.ObservableGauge&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateObservableGauge (name, observeValues, unit, description)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.ObservableGauge&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="observeValues" Type="System.Func&lt;System.Collections.Generic.IEnumerable&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt;&gt;" />
        <Parameter Name="unit" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement.</typeparam>
        <param name="name">The instrument name. cannot be <see langword="null" />.</param>
        <param name="observeValues">The callback to call to get the measurements when the <see cref="M:System.Diagnostics.Metrics.ObservableCounter`1.Observe" /> is called by <see cref="M:System.Diagnostics.Metrics.MeterListener.RecordObservableInstruments" />.</param>
        <param name="unit">Optional instrument unit of measurements.</param>
        <param name="description">Optional instrument description.</param>
        <summary>ObservableGauge is an asynchronous Instrument which reports non-additive value(s) (e.g. the room temperature - it makes no sense to report the temperature value from multiple rooms and sum them up) when the instrument is being observed.</summary>
        <returns>Returns a new ObservableGauge.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObservableGauge&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.ObservableGauge&lt;T&gt; CreateObservableGauge&lt;T&gt; (string name, Func&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt; observeValue, string? unit = default, string? description = default) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.ObservableGauge`1&lt;!!T&gt; CreateObservableGauge&lt;struct .ctor (class System.ValueType) T&gt;(string name, class System.Func`1&lt;valuetype System.Diagnostics.Metrics.Measurement`1&lt;!!T&gt;&gt; observeValue, string unit, string description) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateObservableGauge``1(System.String,System.Func{System.Diagnostics.Metrics.Measurement{``0}},System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObservableGauge(Of T As Structure) (name As String, observeValue As Func(Of Measurement(Of T)), Optional unit As String = Nothing, Optional description As String = Nothing) As ObservableGauge(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateObservableGauge : string * Func&lt;System.Diagnostics.Metrics.Measurement&lt;'T&gt;&gt; * string * string -&gt; System.Diagnostics.Metrics.ObservableGauge&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateObservableGauge (name, observeValue, unit, description)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.ObservableGauge&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="observeValue" Type="System.Func&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt;" />
        <Parameter Name="unit" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement.</typeparam>
        <param name="name">The instrument name. cannot be <see langword="null" />.</param>
        <param name="observeValue">The callback to call to get the measurements when the <see cref="M:System.Diagnostics.Metrics.ObservableCounter`1.Observe" /> is called by <see cref="M:System.Diagnostics.Metrics.MeterListener.RecordObservableInstruments" />.</param>
        <param name="unit">Optional instrument unit of measurements.</param>
        <param name="description">Optional instrument description.</param>
        <summary>ObservableGauge is an asynchronous Instrument which reports non-additive value(s) (e.g. the room temperature - it makes no sense to report the temperature value from multiple rooms and sum them up) when the instrument is being observed.</summary>
        <returns>Returns a new ObservableGauge.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObservableGauge&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.ObservableGauge&lt;T&gt; CreateObservableGauge&lt;T&gt; (string name, Func&lt;T&gt; observeValue, string? unit = default, string? description = default) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.ObservableGauge`1&lt;!!T&gt; CreateObservableGauge&lt;struct .ctor (class System.ValueType) T&gt;(string name, class System.Func`1&lt;!!T&gt; observeValue, string unit, string description) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateObservableGauge``1(System.String,System.Func{``0},System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObservableGauge(Of T As Structure) (name As String, observeValue As Func(Of T), Optional unit As String = Nothing, Optional description As String = Nothing) As ObservableGauge(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateObservableGauge : string * Func&lt;'T (requires 'T : struct)&gt; * string * string -&gt; System.Diagnostics.Metrics.ObservableGauge&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateObservableGauge (name, observeValue, unit, description)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.ObservableGauge&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="observeValue" Type="System.Func&lt;T&gt;" />
        <Parameter Name="unit" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement.</typeparam>
        <param name="name">The instrument name. cannot be <see langword="null" />.</param>
        <param name="observeValue">The callback to call to get the measurements when the <see cref="M:System.Diagnostics.Metrics.ObservableCounter`1.Observe" /> is called by <see cref="M:System.Diagnostics.Metrics.MeterListener.RecordObservableInstruments" />.</param>
        <param name="unit">Optional instrument unit of measurements.</param>
        <param name="description">Optional instrument description.</param>
        <summary>ObservableGauge is an asynchronous Instrument which reports non-additive value(s) (e.g. the room temperature - it makes no sense to report the temperature value from multiple rooms and sum them up) when the instrument is being observed.</summary>
        <returns>Returns a new ObservableGauge.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="meter.Dispose " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dispose the Meter which will disable all instruments created by this meter.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Metrics.Meter.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Diagnostics.Metrics.Meter.Name" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the Meter name.</summary>
        <value>The Meter name</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public string? Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Version" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Metrics.Meter.Version" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Version As String" />
      <MemberSignature Language="F#" Value="member this.Version : string" Usage="System.Diagnostics.Metrics.Meter.Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Version { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the Meter Version.</summary>
        <value>The Meter version.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
