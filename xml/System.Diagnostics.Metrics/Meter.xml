<Type Name="Meter" FullName="System.Diagnostics.Metrics.Meter">
  <TypeSignature Language="C#" Value="public class Meter : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Meter extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Metrics.Meter" />
  <TypeSignature Language="VB.NET" Value="Public Class Meter&#xA;Implements IDisposable" />
  <TypeSignature Language="F#" Value="type Meter = class&#xA;    interface IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Meter : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="net-8.0">
      <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="net-8.0">
      <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Meter is the class responsible for creating and tracking the Instruments.</summary>
    <remarks>To be added.</remarks>
    <related type="Article" href="/dotnet/core/diagnostics/metrics-instrumentation">Tutorial: Create metrics</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Meter (System.Diagnostics.Metrics.MeterOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Diagnostics.Metrics.MeterOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.#ctor(System.Diagnostics.Metrics.MeterOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (options As MeterOptions)" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.Metrics.Meter : System.Diagnostics.Metrics.MeterOptions -&gt; System.Diagnostics.Metrics.Meter" Usage="new System.Diagnostics.Metrics.Meter options" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Meter(System::Diagnostics::Metrics::MeterOptions ^ options);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="options" Type="System.Diagnostics.Metrics.MeterOptions" Index="0" FrameworkAlternate="net-8.0" />
      </Parameters>
      <Docs>
        <param name="options">The options object that is used to create a meter using its properties.</param>
        <summary>Initialize a new instance of the Meter using the <see cref="T:System.Diagnostics.Metrics.MeterOptions" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Meter (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String)" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.Metrics.Meter : string -&gt; System.Diagnostics.Metrics.Meter" Usage="new System.Diagnostics.Metrics.Meter name" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Meter(System::String ^ name);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The Meter name.</param>
        <summary>Initializes a new instance of <see cref="T:System.Diagnostics.Metrics.Meter" /> using the specified meter name.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Meter (string name, string? version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, string version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, version As String)" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.Metrics.Meter : string * string -&gt; System.Diagnostics.Metrics.Meter" Usage="new System.Diagnostics.Metrics.Meter (name, version)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Meter(System::String ^ name, System::String ^ version);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="version" Type="System.String">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="name">The Meter name.</param>
        <param name="version">The optional Meter version.</param>
        <summary>Initializes a new instance of <see cref="T:System.Diagnostics.Metrics.Meter" /> using the specified meter name and version.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Meter (string name, string? version, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object?&gt;&gt;? tags, object? scope = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, string version, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; tags, object scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.#ctor(System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, version As String, tags As IEnumerable(Of KeyValuePair(Of String, Object)), Optional scope As Object = Nothing)" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.Metrics.Meter : string * string * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; * obj -&gt; System.Diagnostics.Metrics.Meter" Usage="new System.Diagnostics.Metrics.Meter (name, version, tags, scope)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="version" Type="System.String" Index="1" FrameworkAlternate="net-8.0" />
        <Parameter Name="tags" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;" Index="2" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 0, 1, 2 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 0, 1, 2 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="scope" Type="System.Object" Index="3" FrameworkAlternate="net-8.0" />
      </Parameters>
      <Docs>
        <param name="name">The Meter name.</param>
        <param name="version">The optional Meter version.</param>
        <param name="tags">The optional Meter tags.</param>
        <param name="scope">The optional Meter scope.</param>
        <summary>Initializes a new instance of the Meter using the meter name and version.</summary>
        <remarks>You can use the scope object to link several Meters with a particular scope. For instance, a dependency injection container can choose to associate all Meters that are created within the container with its own scope. If the scope object is <see langword="null" />, it indicates that the Meter is not linked to any particular scope.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCounter&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.Counter&lt;T&gt; CreateCounter&lt;T&gt; (string name, string? unit = default, string? description = default) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.Counter`1&lt;!!T&gt; CreateCounter&lt;struct .ctor (class System.ValueType) T&gt;(string name, string unit, string description) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateCounter``1(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCounter(Of T As Structure) (name As String, Optional unit As String = Nothing, Optional description As String = Nothing) As Counter(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateCounter : string * string * string -&gt; System.Diagnostics.Metrics.Counter&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateCounter (name, unit, description)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.Counter&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="unit" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement.</typeparam>
        <param name="name">The instrument name. Cannot be <see langword="null" />.</param>
        <param name="unit">Optional instrument unit of measurements.</param>
        <param name="description">Optional instrument description.</param>
        <summary>Create a metrics Counter object.</summary>
        <returns>A new counter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Counter is an instrument that supports non-negative increments. Example uses for Counter:

- Count the number of bytes received.
- Count the number of requests completed.
- Count the number of accounts created.
- Count the number of checkpoints run.
- Count the number of HTTP 5xx errors.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCounter&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.Counter&lt;T&gt; CreateCounter&lt;T&gt; (string name, string? unit, string? description, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object?&gt;&gt; tags) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.Counter`1&lt;!!T&gt; CreateCounter&lt;struct .ctor (class System.ValueType) T&gt;(string name, string unit, string description, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; tags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateCounter``1(System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateCounter(Of T As Structure) (name As String, unit As String, description As String, tags As IEnumerable(Of KeyValuePair(Of String, Object))) As Counter(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateCounter : string * string * string * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; -&gt; System.Diagnostics.Metrics.Counter&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateCounter (name, unit, description, tags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class System::Diagnostics::Metrics::Counter&lt;T&gt; ^ CreateCounter(System::String ^ name, System::String ^ unit, System::String ^ description, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ tags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.Counter&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="unit" Type="System.String" Index="1" FrameworkAlternate="net-8.0" />
        <Parameter Name="description" Type="System.String" Index="2" FrameworkAlternate="net-8.0" />
        <Parameter Name="tags" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;" Index="3" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 1, 2 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 1, 2 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement.</typeparam>
        <param name="name">The instrument name. It cannot be <see langword="null" />.</param>
        <param name="unit">An optional instrument unit of measurements.</param>
        <param name="description">An optional instrument description.</param>
        <param name="tags">The tags to attach to the counter.</param>
        <summary>Creates a metrics Counter object.</summary>
        <returns>A new counter.</returns>
        <remarks>
          <para>Counter is an Instrument that supports non-negative increments.</para>
          <para>Example uses for Counter:</para>
          <ul>
            <li>Count the number of bytes received.</li>
            <li>Count the number of requests completed.</li>
            <li>Count the number of accounts created.</li>
            <li>Count the number of checkpoints run.</li>
            <li>Count the number of HTTP 5xx errors.</li>
          </ul>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateHistogram&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.Histogram&lt;T&gt; CreateHistogram&lt;T&gt; (string name, string? unit = default, string? description = default) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.Histogram`1&lt;!!T&gt; CreateHistogram&lt;struct .ctor (class System.ValueType) T&gt;(string name, string unit, string description) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateHistogram``1(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateHistogram(Of T As Structure) (name As String, Optional unit As String = Nothing, Optional description As String = Nothing) As Histogram(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateHistogram : string * string * string -&gt; System.Diagnostics.Metrics.Histogram&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateHistogram (name, unit, description)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.Histogram&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="unit" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement.</typeparam>
        <param name="name">The instrument name. Cannot be <see langword="null" />.</param>
        <param name="unit">Optional instrument unit of measurements.</param>
        <param name="description">Optional instrument description.</param>
        <summary>Creates a Histogram, which is an instrument that can be used to report arbitrary values that are likely to be statistically meaningful. It is intended for statistics such as histograms, summaries, and percentiles.</summary>
        <returns>A new histogram.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Example uses for Histogram: The request duration and the size of the response payload.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateHistogram&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.Histogram&lt;T&gt; CreateHistogram&lt;T&gt; (string name, string? unit, string? description, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object?&gt;&gt; tags) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.Histogram`1&lt;!!T&gt; CreateHistogram&lt;struct .ctor (class System.ValueType) T&gt;(string name, string unit, string description, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; tags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateHistogram``1(System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateHistogram(Of T As Structure) (name As String, unit As String, description As String, tags As IEnumerable(Of KeyValuePair(Of String, Object))) As Histogram(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateHistogram : string * string * string * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; -&gt; System.Diagnostics.Metrics.Histogram&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateHistogram (name, unit, description, tags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class System::Diagnostics::Metrics::Histogram&lt;T&gt; ^ CreateHistogram(System::String ^ name, System::String ^ unit, System::String ^ description, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ tags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.Histogram&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="unit" Type="System.String" Index="1" FrameworkAlternate="net-8.0" />
        <Parameter Name="description" Type="System.String" Index="2" FrameworkAlternate="net-8.0" />
        <Parameter Name="tags" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;" Index="3" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 1, 2 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 1, 2 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement.</typeparam>
        <param name="name">The instrument name. It cannot be <see langword="null" />.</param>
        <param name="unit">An optional instrument unit of measurements.</param>
        <param name="description">An optional instrument description.</param>
        <param name="tags">The tags to attach to the counter.</param>
        <summary>Creates an Histogram instance, which is an Instrument that can be used to report arbitrary values that are likely to be statistically meaningful. It is intended for statistics such as histograms, summaries, and percentile.</summary>
        <returns>A new histogram.</returns>
        <remarks>Example uses for Histogram: the request duration and the size of the response payload.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObservableCounter&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.ObservableCounter&lt;T&gt; CreateObservableCounter&lt;T&gt; (string name, Func&lt;System.Collections.Generic.IEnumerable&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt;&gt; observeValues, string? unit = default, string? description = default) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.ObservableCounter`1&lt;!!T&gt; CreateObservableCounter&lt;struct .ctor (class System.ValueType) T&gt;(string name, class System.Func`1&lt;class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Diagnostics.Metrics.Measurement`1&lt;!!T&gt;&gt;&gt; observeValues, string unit, string description) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateObservableCounter``1(System.String,System.Func{System.Collections.Generic.IEnumerable{System.Diagnostics.Metrics.Measurement{``0}}},System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObservableCounter(Of T As Structure) (name As String, observeValues As Func(Of IEnumerable(Of Measurement(Of T))), Optional unit As String = Nothing, Optional description As String = Nothing) As ObservableCounter(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateObservableCounter : string * Func&lt;seq&lt;System.Diagnostics.Metrics.Measurement&lt;'T&gt;&gt;&gt; * string * string -&gt; System.Diagnostics.Metrics.ObservableCounter&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateObservableCounter (name, observeValues, unit, description)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.ObservableCounter&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="observeValues" Type="System.Func&lt;System.Collections.Generic.IEnumerable&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt;&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 1, 0, 0 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 1, 0, 0 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="unit" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement.</typeparam>
        <param name="name">The instrument name. Cannot be <see langword="null" />.</param>
        <param name="observeValues">The callback to call to get the measurements when <code>ObservableCounter{T}.Observe()</code> is called by <see cref="M:System.Diagnostics.Metrics.MeterListener.RecordObservableInstruments" />.</param>
        <param name="unit">Optional instrument unit of measurements.</param>
        <param name="description">Optional instrument description.</param>
        <summary>Creates an ObservableCounter, which is an instrument that reports monotonically increasing values when the instrument is being observed.</summary>
        <returns>A new observable counter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Example uses for ObservableCounter: The number of page faults for each process.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObservableCounter&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.ObservableCounter&lt;T&gt; CreateObservableCounter&lt;T&gt; (string name, Func&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt; observeValue, string? unit = default, string? description = default) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.ObservableCounter`1&lt;!!T&gt; CreateObservableCounter&lt;struct .ctor (class System.ValueType) T&gt;(string name, class System.Func`1&lt;valuetype System.Diagnostics.Metrics.Measurement`1&lt;!!T&gt;&gt; observeValue, string unit, string description) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateObservableCounter``1(System.String,System.Func{System.Diagnostics.Metrics.Measurement{``0}},System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObservableCounter(Of T As Structure) (name As String, observeValue As Func(Of Measurement(Of T)), Optional unit As String = Nothing, Optional description As String = Nothing) As ObservableCounter(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateObservableCounter : string * Func&lt;System.Diagnostics.Metrics.Measurement&lt;'T&gt;&gt; * string * string -&gt; System.Diagnostics.Metrics.ObservableCounter&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateObservableCounter (name, observeValue, unit, description)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.ObservableCounter&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="observeValue" Type="System.Func&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 0 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 0 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="unit" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement.</typeparam>
        <param name="name">The instrument name. Cannot be <see langword="null" />.</param>
        <param name="observeValue">The callback to call to get the measurements when <code>ObservableCounter{T}.Observe()</code> is called by <see cref="M:System.Diagnostics.Metrics.MeterListener.RecordObservableInstruments" /></param>
        <param name="unit">Optional instrument unit of measurements.</param>
        <param name="description">Optional instrument description.</param>
        <summary>Creates an ObservableCounter, which is an instrument that reports monotonically increasing values when the instrument is being observed.</summary>
        <returns>A new observable counter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Example uses for ObservableCounter: The number of page faults for each process.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObservableCounter&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.ObservableCounter&lt;T&gt; CreateObservableCounter&lt;T&gt; (string name, Func&lt;T&gt; observeValue, string? unit = default, string? description = default) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.ObservableCounter`1&lt;!!T&gt; CreateObservableCounter&lt;struct .ctor (class System.ValueType) T&gt;(string name, class System.Func`1&lt;!!T&gt; observeValue, string unit, string description) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateObservableCounter``1(System.String,System.Func{``0},System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObservableCounter(Of T As Structure) (name As String, observeValue As Func(Of T), Optional unit As String = Nothing, Optional description As String = Nothing) As ObservableCounter(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateObservableCounter : string * Func&lt;'T (requires 'T : struct)&gt; * string * string -&gt; System.Diagnostics.Metrics.ObservableCounter&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateObservableCounter (name, observeValue, unit, description)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.ObservableCounter&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="observeValue" Type="System.Func&lt;T&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="unit" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement..</typeparam>
        <param name="name">The instrument name. Cannot be <see langword="null" />.</param>
        <param name="observeValue">The callback to call to get the measurements when <code>ObservableCounter{T}.Observe()</code> is called by <see cref="M:System.Diagnostics.Metrics.MeterListener.RecordObservableInstruments" />.</param>
        <param name="unit">Optional instrument unit of measurements.</param>
        <param name="description">Optional instrument description.</param>
        <summary>Creates an ObservableCounter, which is an instrument that reports monotonically increasing values when the instrument is being observed.</summary>
        <returns>A new observable counter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Example uses for ObservableCounter: The number of page faults for each process.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObservableCounter&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.ObservableCounter&lt;T&gt; CreateObservableCounter&lt;T&gt; (string name, Func&lt;System.Collections.Generic.IEnumerable&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt;&gt; observeValues, string? unit, string? description, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object?&gt;&gt; tags) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.ObservableCounter`1&lt;!!T&gt; CreateObservableCounter&lt;struct .ctor (class System.ValueType) T&gt;(string name, class System.Func`1&lt;class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Diagnostics.Metrics.Measurement`1&lt;!!T&gt;&gt;&gt; observeValues, string unit, string description, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; tags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateObservableCounter``1(System.String,System.Func{System.Collections.Generic.IEnumerable{System.Diagnostics.Metrics.Measurement{``0}}},System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObservableCounter(Of T As Structure) (name As String, observeValues As Func(Of IEnumerable(Of Measurement(Of T))), unit As String, description As String, tags As IEnumerable(Of KeyValuePair(Of String, Object))) As ObservableCounter(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateObservableCounter : string * Func&lt;seq&lt;System.Diagnostics.Metrics.Measurement&lt;'T&gt;&gt;&gt; * string * string * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; -&gt; System.Diagnostics.Metrics.ObservableCounter&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateObservableCounter (name, observeValues, unit, description, tags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class System::Diagnostics::Metrics::ObservableCounter&lt;T&gt; ^ CreateObservableCounter(System::String ^ name, Func&lt;System::Collections::Generic::IEnumerable&lt;System::Diagnostics::Metrics::Measurement&lt;T&gt;&gt; ^&gt; ^ observeValues, System::String ^ unit, System::String ^ description, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ tags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.ObservableCounter&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="observeValues" Type="System.Func&lt;System.Collections.Generic.IEnumerable&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt;&gt;" Index="1" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 1, 0, 0 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 1, 0, 0 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="unit" Type="System.String" Index="2" FrameworkAlternate="net-8.0" />
        <Parameter Name="description" Type="System.String" Index="3" FrameworkAlternate="net-8.0" />
        <Parameter Name="tags" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;" Index="4" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 1, 2 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 1, 2 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement.</typeparam>
        <param name="name">The instrument name. It cannot be <see langword="null" />.</param>
        <param name="observeValues">The callback to call to get the measurements when the <see cref="M:System.Diagnostics.Metrics.ObservableInstrument`1.Observe" /> is called by <see cref="M:System.Diagnostics.Metrics.MeterListener.RecordObservableInstruments" />.</param>
        <param name="unit">An optional instrument unit of measurements.</param>
        <param name="description">An optional instrument description.</param>
        <param name="tags">The tags to attach to the counter.</param>
        <summary>Creates an ObservableCounter instance, which is an Instrument that reports monotonically increasing value(s) when the instrument is being observed.</summary>
        <returns>A new observable counter.</returns>
        <remarks>Example uses for ObservableCounter: The number of page faults for each process.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObservableCounter&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.ObservableCounter&lt;T&gt; CreateObservableCounter&lt;T&gt; (string name, Func&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt; observeValue, string? unit, string? description, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object?&gt;&gt; tags) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.ObservableCounter`1&lt;!!T&gt; CreateObservableCounter&lt;struct .ctor (class System.ValueType) T&gt;(string name, class System.Func`1&lt;valuetype System.Diagnostics.Metrics.Measurement`1&lt;!!T&gt;&gt; observeValue, string unit, string description, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; tags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateObservableCounter``1(System.String,System.Func{System.Diagnostics.Metrics.Measurement{``0}},System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObservableCounter(Of T As Structure) (name As String, observeValue As Func(Of Measurement(Of T)), unit As String, description As String, tags As IEnumerable(Of KeyValuePair(Of String, Object))) As ObservableCounter(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateObservableCounter : string * Func&lt;System.Diagnostics.Metrics.Measurement&lt;'T&gt;&gt; * string * string * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; -&gt; System.Diagnostics.Metrics.ObservableCounter&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateObservableCounter (name, observeValue, unit, description, tags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class System::Diagnostics::Metrics::ObservableCounter&lt;T&gt; ^ CreateObservableCounter(System::String ^ name, Func&lt;System::Diagnostics::Metrics::Measurement&lt;T&gt;&gt; ^ observeValue, System::String ^ unit, System::String ^ description, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ tags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.ObservableCounter&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="observeValue" Type="System.Func&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt;" Index="1" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 0 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 0 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="unit" Type="System.String" Index="2" FrameworkAlternate="net-8.0" />
        <Parameter Name="description" Type="System.String" Index="3" FrameworkAlternate="net-8.0" />
        <Parameter Name="tags" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;" Index="4" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 1, 2 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 1, 2 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement.</typeparam>
        <param name="name">The instrument name. It cannot be <see langword="null" />.</param>
        <param name="observeValue">The callback to call to get the measurements when the <see cref="M:System.Diagnostics.Metrics.ObservableInstrument`1.Observe" /> is called by <see cref="M:System.Diagnostics.Metrics.MeterListener.RecordObservableInstruments" /></param>
        <param name="unit">An optional instrument unit of measurements.</param>
        <param name="description">An optional instrument description.</param>
        <param name="tags">The tags to attach to the counter.</param>
        <summary>Creates an ObservableCounter instance, which is an Instrument that reports monotonically increasing value(s) when the instrument is being observed.</summary>
        <returns>A new observable counter.</returns>
        <remarks>Example uses for ObservableCounter: The number of page faults for each process.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObservableCounter&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.ObservableCounter&lt;T&gt; CreateObservableCounter&lt;T&gt; (string name, Func&lt;T&gt; observeValue, string? unit, string? description, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object?&gt;&gt; tags) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.ObservableCounter`1&lt;!!T&gt; CreateObservableCounter&lt;struct .ctor (class System.ValueType) T&gt;(string name, class System.Func`1&lt;!!T&gt; observeValue, string unit, string description, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; tags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateObservableCounter``1(System.String,System.Func{``0},System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObservableCounter(Of T As Structure) (name As String, observeValue As Func(Of T), unit As String, description As String, tags As IEnumerable(Of KeyValuePair(Of String, Object))) As ObservableCounter(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateObservableCounter : string * Func&lt;'T (requires 'T : struct)&gt; * string * string * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; -&gt; System.Diagnostics.Metrics.ObservableCounter&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateObservableCounter (name, observeValue, unit, description, tags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class System::Diagnostics::Metrics::ObservableCounter&lt;T&gt; ^ CreateObservableCounter(System::String ^ name, Func&lt;T&gt; ^ observeValue, System::String ^ unit, System::String ^ description, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ tags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.ObservableCounter&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="observeValue" Type="System.Func&lt;T&gt;" Index="1" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="unit" Type="System.String" Index="2" FrameworkAlternate="net-8.0" />
        <Parameter Name="description" Type="System.String" Index="3" FrameworkAlternate="net-8.0" />
        <Parameter Name="tags" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;" Index="4" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 1, 2 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 1, 2 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement.</typeparam>
        <param name="name">The instrument name. It cannot be <see langword="null" />.</param>
        <param name="observeValue">The callback to call to get the measurements when the <see cref="M:System.Diagnostics.Metrics.ObservableInstrument`1.Observe" /> is called by <see cref="M:System.Diagnostics.Metrics.MeterListener.RecordObservableInstruments" />.</param>
        <param name="unit">An optional instrument unit of measurements.</param>
        <param name="description">An optional instrument description.</param>
        <param name="tags">The tags to attach to the counter.</param>
        <summary>Creates an ObservableCounter instance, which is an Instrument that reports monotonically increasing value(s) when the instrument is being observed.</summary>
        <returns>A new observable counter.</returns>
        <remarks>Example uses for ObservableCounter: The number of page faults for each process.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObservableGauge&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.ObservableGauge&lt;T&gt; CreateObservableGauge&lt;T&gt; (string name, Func&lt;System.Collections.Generic.IEnumerable&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt;&gt; observeValues, string? unit = default, string? description = default) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.ObservableGauge`1&lt;!!T&gt; CreateObservableGauge&lt;struct .ctor (class System.ValueType) T&gt;(string name, class System.Func`1&lt;class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Diagnostics.Metrics.Measurement`1&lt;!!T&gt;&gt;&gt; observeValues, string unit, string description) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateObservableGauge``1(System.String,System.Func{System.Collections.Generic.IEnumerable{System.Diagnostics.Metrics.Measurement{``0}}},System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObservableGauge(Of T As Structure) (name As String, observeValues As Func(Of IEnumerable(Of Measurement(Of T))), Optional unit As String = Nothing, Optional description As String = Nothing) As ObservableGauge(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateObservableGauge : string * Func&lt;seq&lt;System.Diagnostics.Metrics.Measurement&lt;'T&gt;&gt;&gt; * string * string -&gt; System.Diagnostics.Metrics.ObservableGauge&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateObservableGauge (name, observeValues, unit, description)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.ObservableGauge&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="observeValues" Type="System.Func&lt;System.Collections.Generic.IEnumerable&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt;&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 1, 0, 0 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 1, 0, 0 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="unit" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement.</typeparam>
        <param name="name">The instrument name. Cannot be <see langword="null" />.</param>
        <param name="observeValues">The callback to call to get the measurements when <code>ObservableCounter{T}.Observe()</code> is called by <see cref="M:System.Diagnostics.Metrics.MeterListener.RecordObservableInstruments" />.</param>
        <param name="unit">Optional instrument unit of measurements.</param>
        <param name="description">Optional instrument description.</param>
        <summary>Creates an ObservableGauge, which is an asynchronous instrument that reports non-additive values when the instrument is being observed.</summary>
        <returns>A new observable gauge.</returns>
        <remarks>An example of a non-additive value is the room temperature; that is, it doesn't make sense to report the temperature value from multiple rooms and sum them up.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObservableGauge&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.ObservableGauge&lt;T&gt; CreateObservableGauge&lt;T&gt; (string name, Func&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt; observeValue, string? unit = default, string? description = default) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.ObservableGauge`1&lt;!!T&gt; CreateObservableGauge&lt;struct .ctor (class System.ValueType) T&gt;(string name, class System.Func`1&lt;valuetype System.Diagnostics.Metrics.Measurement`1&lt;!!T&gt;&gt; observeValue, string unit, string description) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateObservableGauge``1(System.String,System.Func{System.Diagnostics.Metrics.Measurement{``0}},System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObservableGauge(Of T As Structure) (name As String, observeValue As Func(Of Measurement(Of T)), Optional unit As String = Nothing, Optional description As String = Nothing) As ObservableGauge(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateObservableGauge : string * Func&lt;System.Diagnostics.Metrics.Measurement&lt;'T&gt;&gt; * string * string -&gt; System.Diagnostics.Metrics.ObservableGauge&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateObservableGauge (name, observeValue, unit, description)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.ObservableGauge&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="observeValue" Type="System.Func&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 0 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 0 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="unit" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement.</typeparam>
        <param name="name">The instrument name. Cannot be <see langword="null" />.</param>
        <param name="observeValue">The callback to call to get the measurements when <code>ObservableCounter{T}.Observe()</code> is called by <see cref="M:System.Diagnostics.Metrics.MeterListener.RecordObservableInstruments" />.</param>
        <param name="unit">Optional instrument unit of measurements.</param>
        <param name="description">Optional instrument description.</param>
        <summary>Creates an ObservableGauge, which is an asynchronous instrument that reports non-additive values when the instrument is being observed.</summary>
        <returns>A new observable gauge.</returns>
        <remarks>An example of a non-additive value is the room temperature; that is, it doesn't make sense to report the temperature value from multiple rooms and sum them up.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObservableGauge&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.ObservableGauge&lt;T&gt; CreateObservableGauge&lt;T&gt; (string name, Func&lt;T&gt; observeValue, string? unit = default, string? description = default) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.ObservableGauge`1&lt;!!T&gt; CreateObservableGauge&lt;struct .ctor (class System.ValueType) T&gt;(string name, class System.Func`1&lt;!!T&gt; observeValue, string unit, string description) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateObservableGauge``1(System.String,System.Func{``0},System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObservableGauge(Of T As Structure) (name As String, observeValue As Func(Of T), Optional unit As String = Nothing, Optional description As String = Nothing) As ObservableGauge(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateObservableGauge : string * Func&lt;'T (requires 'T : struct)&gt; * string * string -&gt; System.Diagnostics.Metrics.ObservableGauge&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateObservableGauge (name, observeValue, unit, description)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.ObservableGauge&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="observeValue" Type="System.Func&lt;T&gt;">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="unit" Type="System.String" />
        <Parameter Name="description" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement.</typeparam>
        <param name="name">The instrument name. Cannot be <see langword="null" />.</param>
        <param name="observeValue">The callback to call to get the measurements when <code>ObservableCounter{T}.Observe()</code> is called by <see cref="M:System.Diagnostics.Metrics.MeterListener.RecordObservableInstruments" />.</param>
        <param name="unit">Optional instrument unit of measurements.</param>
        <param name="description">Optional instrument description.</param>
        <summary>Creates an ObservableGauge, which is an asynchronous instrument that reports non-additive values when the instrument is being observed.</summary>
        <returns>A new observable gauge.</returns>
        <remarks>An example of a non-additive value is the room temperature; that is, it doesn't make sense to report the temperature value from multiple rooms and sum them up.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObservableGauge&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.ObservableGauge&lt;T&gt; CreateObservableGauge&lt;T&gt; (string name, Func&lt;System.Collections.Generic.IEnumerable&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt;&gt; observeValues, string? unit, string? description, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object?&gt;&gt; tags) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.ObservableGauge`1&lt;!!T&gt; CreateObservableGauge&lt;struct .ctor (class System.ValueType) T&gt;(string name, class System.Func`1&lt;class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Diagnostics.Metrics.Measurement`1&lt;!!T&gt;&gt;&gt; observeValues, string unit, string description, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; tags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateObservableGauge``1(System.String,System.Func{System.Collections.Generic.IEnumerable{System.Diagnostics.Metrics.Measurement{``0}}},System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObservableGauge(Of T As Structure) (name As String, observeValues As Func(Of IEnumerable(Of Measurement(Of T))), unit As String, description As String, tags As IEnumerable(Of KeyValuePair(Of String, Object))) As ObservableGauge(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateObservableGauge : string * Func&lt;seq&lt;System.Diagnostics.Metrics.Measurement&lt;'T&gt;&gt;&gt; * string * string * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; -&gt; System.Diagnostics.Metrics.ObservableGauge&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateObservableGauge (name, observeValues, unit, description, tags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class System::Diagnostics::Metrics::ObservableGauge&lt;T&gt; ^ CreateObservableGauge(System::String ^ name, Func&lt;System::Collections::Generic::IEnumerable&lt;System::Diagnostics::Metrics::Measurement&lt;T&gt;&gt; ^&gt; ^ observeValues, System::String ^ unit, System::String ^ description, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ tags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.ObservableGauge&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="observeValues" Type="System.Func&lt;System.Collections.Generic.IEnumerable&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt;&gt;" Index="1" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 1, 0, 0 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 1, 0, 0 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="unit" Type="System.String" Index="2" FrameworkAlternate="net-8.0" />
        <Parameter Name="description" Type="System.String" Index="3" FrameworkAlternate="net-8.0" />
        <Parameter Name="tags" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;" Index="4" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 1, 2 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 1, 2 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement.</typeparam>
        <param name="name">The instrument name. It cannot be <see langword="null" />.</param>
        <param name="observeValues">The callback to call to get the measurements when the <see cref="M:System.Diagnostics.Metrics.ObservableInstrument`1.Observe" /> is called by <see cref="M:System.Diagnostics.Metrics.MeterListener.RecordObservableInstruments" />.</param>
        <param name="unit">An optional instrument unit of measurements.</param>
        <param name="description">An optional instrument description.</param>
        <param name="tags">The tags to attach to the counter.</param>
        <summary>Creates an ObservableGauge instance, which is an asynchronous Instrument that reports non-additive value(s) when the instrument is being observed.</summary>
        <returns>A new observable gauge.</returns>
        <remarks>For example: The room temperature - it makes no sense to report the temperature value from multiple rooms and sum them up.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObservableGauge&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.ObservableGauge&lt;T&gt; CreateObservableGauge&lt;T&gt; (string name, Func&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt; observeValue, string? unit, string? description, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object?&gt;&gt; tags) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.ObservableGauge`1&lt;!!T&gt; CreateObservableGauge&lt;struct .ctor (class System.ValueType) T&gt;(string name, class System.Func`1&lt;valuetype System.Diagnostics.Metrics.Measurement`1&lt;!!T&gt;&gt; observeValue, string unit, string description, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; tags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateObservableGauge``1(System.String,System.Func{System.Diagnostics.Metrics.Measurement{``0}},System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObservableGauge(Of T As Structure) (name As String, observeValue As Func(Of Measurement(Of T)), unit As String, description As String, tags As IEnumerable(Of KeyValuePair(Of String, Object))) As ObservableGauge(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateObservableGauge : string * Func&lt;System.Diagnostics.Metrics.Measurement&lt;'T&gt;&gt; * string * string * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; -&gt; System.Diagnostics.Metrics.ObservableGauge&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateObservableGauge (name, observeValue, unit, description, tags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class System::Diagnostics::Metrics::ObservableGauge&lt;T&gt; ^ CreateObservableGauge(System::String ^ name, Func&lt;System::Diagnostics::Metrics::Measurement&lt;T&gt;&gt; ^ observeValue, System::String ^ unit, System::String ^ description, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ tags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.ObservableGauge&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="observeValue" Type="System.Func&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt;" Index="1" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 0 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 0 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="unit" Type="System.String" Index="2" FrameworkAlternate="net-8.0" />
        <Parameter Name="description" Type="System.String" Index="3" FrameworkAlternate="net-8.0" />
        <Parameter Name="tags" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;" Index="4" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 1, 2 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 1, 2 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement.</typeparam>
        <param name="name">The instrument name. cannot be <see langword="null" />.</param>
        <param name="observeValue">The callback to call to get the measurements when the <see cref="M:System.Diagnostics.Metrics.ObservableInstrument`1.Observe" /> is called by <see cref="M:System.Diagnostics.Metrics.MeterListener.RecordObservableInstruments" />.</param>
        <param name="unit">Optional instrument unit of measurements.</param>
        <param name="description">Optional instrument description.</param>
        <param name="tags">tags to attach to the counter.</param>
        <summary>ObservableGauge is an asynchronous Instrument which reports non-additive value(s) (e.g. the room temperature - it makes no sense to report the temperature value from multiple rooms and sum them up) when the instrument is being observed.</summary>
        <returns>A new observable gauge.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObservableGauge&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.ObservableGauge&lt;T&gt; CreateObservableGauge&lt;T&gt; (string name, Func&lt;T&gt; observeValue, string? unit, string? description, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object?&gt;&gt; tags) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.ObservableGauge`1&lt;!!T&gt; CreateObservableGauge&lt;struct .ctor (class System.ValueType) T&gt;(string name, class System.Func`1&lt;!!T&gt; observeValue, string unit, string description, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; tags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateObservableGauge``1(System.String,System.Func{``0},System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObservableGauge(Of T As Structure) (name As String, observeValue As Func(Of T), unit As String, description As String, tags As IEnumerable(Of KeyValuePair(Of String, Object))) As ObservableGauge(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateObservableGauge : string * Func&lt;'T (requires 'T : struct)&gt; * string * string * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; -&gt; System.Diagnostics.Metrics.ObservableGauge&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateObservableGauge (name, observeValue, unit, description, tags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class System::Diagnostics::Metrics::ObservableGauge&lt;T&gt; ^ CreateObservableGauge(System::String ^ name, Func&lt;T&gt; ^ observeValue, System::String ^ unit, System::String ^ description, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ tags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.ObservableGauge&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="observeValue" Type="System.Func&lt;T&gt;" Index="1" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="unit" Type="System.String" Index="2" FrameworkAlternate="net-8.0" />
        <Parameter Name="description" Type="System.String" Index="3" FrameworkAlternate="net-8.0" />
        <Parameter Name="tags" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;" Index="4" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 1, 2 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 1, 2 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement.</typeparam>
        <param name="name">The instrument name. cannot be <see langword="null" />.</param>
        <param name="observeValue">The callback to call to get the measurements when the <see cref="M:System.Diagnostics.Metrics.ObservableInstrument`1.Observe" /> is called by <see cref="M:System.Diagnostics.Metrics.MeterListener.RecordObservableInstruments" />.</param>
        <param name="unit">Optional instrument unit of measurements.</param>
        <param name="description">Optional instrument description.</param>
        <param name="tags">tags to attach to the counter.</param>
        <summary>ObservableGauge is an asynchronous Instrument which reports non-additive value(s) (e.g. the room temperature - it makes no sense to report the temperature value from multiple rooms and sum them up) when the instrument is being observed.</summary>
        <returns>A new observable gauge.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObservableUpDownCounter&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.ObservableUpDownCounter&lt;T&gt; CreateObservableUpDownCounter&lt;T&gt; (string name, Func&lt;System.Collections.Generic.IEnumerable&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt;&gt; observeValues, string? unit = default, string? description = default) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.ObservableUpDownCounter`1&lt;!!T&gt; CreateObservableUpDownCounter&lt;struct .ctor (class System.ValueType) T&gt;(string name, class System.Func`1&lt;class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Diagnostics.Metrics.Measurement`1&lt;!!T&gt;&gt;&gt; observeValues, string unit, string description) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateObservableUpDownCounter``1(System.String,System.Func{System.Collections.Generic.IEnumerable{System.Diagnostics.Metrics.Measurement{``0}}},System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObservableUpDownCounter(Of T As Structure) (name As String, observeValues As Func(Of IEnumerable(Of Measurement(Of T))), Optional unit As String = Nothing, Optional description As String = Nothing) As ObservableUpDownCounter(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateObservableUpDownCounter : string * Func&lt;seq&lt;System.Diagnostics.Metrics.Measurement&lt;'T&gt;&gt;&gt; * string * string -&gt; System.Diagnostics.Metrics.ObservableUpDownCounter&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateObservableUpDownCounter (name, observeValues, unit, description)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.ObservableUpDownCounter&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="net-7.0;net-8.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="observeValues" Type="System.Func&lt;System.Collections.Generic.IEnumerable&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt;&gt;" Index="1" FrameworkAlternate="net-7.0;net-8.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 1, 0, 0 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 1, 0, 0 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="unit" Type="System.String" Index="2" FrameworkAlternate="net-7.0;net-8.0" />
        <Parameter Name="description" Type="System.String" Index="3" FrameworkAlternate="net-7.0;net-8.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement.</typeparam>
        <param name="name">The instrument name. Cannot be <see langword="null" />.</param>
        <param name="observeValues">The callback to call to get the measurements when the <see cref="M:System.Diagnostics.Metrics.ObservableInstrument`1.Observe" /> is called by <see cref="M:System.Diagnostics.Metrics.MeterListener.RecordObservableInstruments" />.</param>
        <param name="unit">Optional instrument unit of measurements.</param>
        <param name="description">Optional instrument description.</param>
        <summary>Creates an ObservableUpDownCounter object. ObservableUpDownCounter is an Instrument that reports increasing or decreasing values when the instrument is being observed.</summary>
        <returns>A new observable up down counter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Example uses for ObservableUpDownCounter: the process heap size or the approximate number of items in a lock-free circular buffer.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObservableUpDownCounter&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.ObservableUpDownCounter&lt;T&gt; CreateObservableUpDownCounter&lt;T&gt; (string name, Func&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt; observeValue, string? unit = default, string? description = default) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.ObservableUpDownCounter`1&lt;!!T&gt; CreateObservableUpDownCounter&lt;struct .ctor (class System.ValueType) T&gt;(string name, class System.Func`1&lt;valuetype System.Diagnostics.Metrics.Measurement`1&lt;!!T&gt;&gt; observeValue, string unit, string description) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateObservableUpDownCounter``1(System.String,System.Func{System.Diagnostics.Metrics.Measurement{``0}},System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObservableUpDownCounter(Of T As Structure) (name As String, observeValue As Func(Of Measurement(Of T)), Optional unit As String = Nothing, Optional description As String = Nothing) As ObservableUpDownCounter(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateObservableUpDownCounter : string * Func&lt;System.Diagnostics.Metrics.Measurement&lt;'T&gt;&gt; * string * string -&gt; System.Diagnostics.Metrics.ObservableUpDownCounter&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateObservableUpDownCounter (name, observeValue, unit, description)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.ObservableUpDownCounter&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="net-7.0;net-8.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="observeValue" Type="System.Func&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt;" Index="1" FrameworkAlternate="net-7.0;net-8.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 0 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 0 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="unit" Type="System.String" Index="2" FrameworkAlternate="net-7.0;net-8.0" />
        <Parameter Name="description" Type="System.String" Index="3" FrameworkAlternate="net-7.0;net-8.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement.</typeparam>
        <param name="name">The instrument name. Cannot be <see langword="null" />.</param>
        <param name="observeValue">The callback to call to get the measurements when the <see cref="M:System.Diagnostics.Metrics.ObservableInstrument`1.Observe" /> is called by <see cref="M:System.Diagnostics.Metrics.MeterListener.RecordObservableInstruments" /></param>
        <param name="unit">Optional instrument unit of measurements.</param>
        <param name="description">Optional instrument description.</param>
        <summary>Creates an ObservableUpDownCounter object. ObservableUpDownCounter is an Instrument that reports increasing or decreasing values when the instrument is being observed.</summary>
        <returns>A new observable up down counter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Example uses for ObservableUpDownCounter: the process heap size or the approximate number of items in a lock-free circular buffer.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObservableUpDownCounter&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.ObservableUpDownCounter&lt;T&gt; CreateObservableUpDownCounter&lt;T&gt; (string name, Func&lt;T&gt; observeValue, string? unit = default, string? description = default) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.ObservableUpDownCounter`1&lt;!!T&gt; CreateObservableUpDownCounter&lt;struct .ctor (class System.ValueType) T&gt;(string name, class System.Func`1&lt;!!T&gt; observeValue, string unit, string description) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateObservableUpDownCounter``1(System.String,System.Func{``0},System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObservableUpDownCounter(Of T As Structure) (name As String, observeValue As Func(Of T), Optional unit As String = Nothing, Optional description As String = Nothing) As ObservableUpDownCounter(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateObservableUpDownCounter : string * Func&lt;'T (requires 'T : struct)&gt; * string * string -&gt; System.Diagnostics.Metrics.ObservableUpDownCounter&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateObservableUpDownCounter (name, observeValue, unit, description)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.ObservableUpDownCounter&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="net-7.0;net-8.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="observeValue" Type="System.Func&lt;T&gt;" Index="1" FrameworkAlternate="net-7.0;net-8.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="unit" Type="System.String" Index="2" FrameworkAlternate="net-7.0;net-8.0" />
        <Parameter Name="description" Type="System.String" Index="3" FrameworkAlternate="net-7.0;net-8.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement.</typeparam>
        <param name="name">The instrument name. Cannot be <see langword="null" />.</param>
        <param name="observeValue">The callback to call to get the measurements when the <see cref="M:System.Diagnostics.Metrics.ObservableInstrument`1.Observe" /> is called by <see cref="M:System.Diagnostics.Metrics.MeterListener.RecordObservableInstruments" />.</param>
        <param name="unit">Optional instrument unit of measurements.</param>
        <param name="description">Optional instrument description.</param>
        <summary>Creates an ObservableUpDownCounter object. ObservableUpDownCounter is an Instrument that reports increasing or decreasing values when the instrument is being observed.</summary>
        <returns>A new observable up down counter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Example uses for ObservableUpDownCounter: the process heap size or the approximate number of items in a lock-free circular buffer.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObservableUpDownCounter&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.ObservableUpDownCounter&lt;T&gt; CreateObservableUpDownCounter&lt;T&gt; (string name, Func&lt;System.Collections.Generic.IEnumerable&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt;&gt; observeValues, string? unit, string? description, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object?&gt;&gt; tags) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.ObservableUpDownCounter`1&lt;!!T&gt; CreateObservableUpDownCounter&lt;struct .ctor (class System.ValueType) T&gt;(string name, class System.Func`1&lt;class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Diagnostics.Metrics.Measurement`1&lt;!!T&gt;&gt;&gt; observeValues, string unit, string description, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; tags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateObservableUpDownCounter``1(System.String,System.Func{System.Collections.Generic.IEnumerable{System.Diagnostics.Metrics.Measurement{``0}}},System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObservableUpDownCounter(Of T As Structure) (name As String, observeValues As Func(Of IEnumerable(Of Measurement(Of T))), unit As String, description As String, tags As IEnumerable(Of KeyValuePair(Of String, Object))) As ObservableUpDownCounter(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateObservableUpDownCounter : string * Func&lt;seq&lt;System.Diagnostics.Metrics.Measurement&lt;'T&gt;&gt;&gt; * string * string * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; -&gt; System.Diagnostics.Metrics.ObservableUpDownCounter&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateObservableUpDownCounter (name, observeValues, unit, description, tags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class System::Diagnostics::Metrics::ObservableUpDownCounter&lt;T&gt; ^ CreateObservableUpDownCounter(System::String ^ name, Func&lt;System::Collections::Generic::IEnumerable&lt;System::Diagnostics::Metrics::Measurement&lt;T&gt;&gt; ^&gt; ^ observeValues, System::String ^ unit, System::String ^ description, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ tags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.ObservableUpDownCounter&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="observeValues" Type="System.Func&lt;System.Collections.Generic.IEnumerable&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt;&gt;" Index="1" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 1, 0, 0 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 1, 0, 0 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="unit" Type="System.String" Index="2" FrameworkAlternate="net-8.0" />
        <Parameter Name="description" Type="System.String" Index="3" FrameworkAlternate="net-8.0" />
        <Parameter Name="tags" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;" Index="4" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 1, 2 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 1, 2 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement.</typeparam>
        <param name="name">The instrument name. Cannot be <see langword="null" />.</param>
        <param name="observeValues">The callback to call to get the measurements when the <see cref="M:System.Diagnostics.Metrics.ObservableInstrument`1.Observe" /> is called by <see cref="M:System.Diagnostics.Metrics.MeterListener.RecordObservableInstruments" />.</param>
        <param name="unit">Optional instrument unit of measurements.</param>
        <param name="description">Optional instrument description.</param>
        <param name="tags">tags to attach to the counter.</param>
        <summary>Create an ObservableUpDownCounter object. ObservableUpDownCounter is an Instrument which reports increasing or decreasing value(s) when the instrument is being observed.</summary>
        <returns>A new observable up down counter.</returns>
        <remarks>Example uses for ObservableUpDownCounter: the process heap size or the approximate number of items in a lock-free circular buffer.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObservableUpDownCounter&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.ObservableUpDownCounter&lt;T&gt; CreateObservableUpDownCounter&lt;T&gt; (string name, Func&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt; observeValue, string? unit, string? description, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object?&gt;&gt; tags) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.ObservableUpDownCounter`1&lt;!!T&gt; CreateObservableUpDownCounter&lt;struct .ctor (class System.ValueType) T&gt;(string name, class System.Func`1&lt;valuetype System.Diagnostics.Metrics.Measurement`1&lt;!!T&gt;&gt; observeValue, string unit, string description, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; tags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateObservableUpDownCounter``1(System.String,System.Func{System.Diagnostics.Metrics.Measurement{``0}},System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObservableUpDownCounter(Of T As Structure) (name As String, observeValue As Func(Of Measurement(Of T)), unit As String, description As String, tags As IEnumerable(Of KeyValuePair(Of String, Object))) As ObservableUpDownCounter(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateObservableUpDownCounter : string * Func&lt;System.Diagnostics.Metrics.Measurement&lt;'T&gt;&gt; * string * string * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; -&gt; System.Diagnostics.Metrics.ObservableUpDownCounter&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateObservableUpDownCounter (name, observeValue, unit, description, tags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class System::Diagnostics::Metrics::ObservableUpDownCounter&lt;T&gt; ^ CreateObservableUpDownCounter(System::String ^ name, Func&lt;System::Diagnostics::Metrics::Measurement&lt;T&gt;&gt; ^ observeValue, System::String ^ unit, System::String ^ description, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ tags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.ObservableUpDownCounter&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="observeValue" Type="System.Func&lt;System.Diagnostics.Metrics.Measurement&lt;T&gt;&gt;" Index="1" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 0 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 0 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="unit" Type="System.String" Index="2" FrameworkAlternate="net-8.0" />
        <Parameter Name="description" Type="System.String" Index="3" FrameworkAlternate="net-8.0" />
        <Parameter Name="tags" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;" Index="4" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 1, 2 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 1, 2 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement.</typeparam>
        <param name="name">The instrument name. Cannot be <see langword="null" />.</param>
        <param name="observeValue">The callback to call to get the measurements when the <see cref="M:System.Diagnostics.Metrics.ObservableInstrument`1.Observe" /> is called by <see cref="M:System.Diagnostics.Metrics.MeterListener.RecordObservableInstruments" /></param>
        <param name="unit">Optional instrument unit of measurements.</param>
        <param name="description">Optional instrument description.</param>
        <param name="tags">tags to attach to the counter.</param>
        <summary>Create an ObservableUpDownCounter object. ObservableUpDownCounter is an Instrument which reports increasing or decreasing value(s) when the instrument is being observed.</summary>
        <returns>A new observable up down counter.</returns>
        <remarks>Example uses for ObservableUpDownCounter: the process heap size or the approximate number of items in a lock-free circular buffer.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateObservableUpDownCounter&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.ObservableUpDownCounter&lt;T&gt; CreateObservableUpDownCounter&lt;T&gt; (string name, Func&lt;T&gt; observeValue, string? unit, string? description, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object?&gt;&gt; tags) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.ObservableUpDownCounter`1&lt;!!T&gt; CreateObservableUpDownCounter&lt;struct .ctor (class System.ValueType) T&gt;(string name, class System.Func`1&lt;!!T&gt; observeValue, string unit, string description, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; tags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateObservableUpDownCounter``1(System.String,System.Func{``0},System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObservableUpDownCounter(Of T As Structure) (name As String, observeValue As Func(Of T), unit As String, description As String, tags As IEnumerable(Of KeyValuePair(Of String, Object))) As ObservableUpDownCounter(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateObservableUpDownCounter : string * Func&lt;'T (requires 'T : struct)&gt; * string * string * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; -&gt; System.Diagnostics.Metrics.ObservableUpDownCounter&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateObservableUpDownCounter (name, observeValue, unit, description, tags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class System::Diagnostics::Metrics::ObservableUpDownCounter&lt;T&gt; ^ CreateObservableUpDownCounter(System::String ^ name, Func&lt;T&gt; ^ observeValue, System::String ^ unit, System::String ^ description, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ tags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.ObservableUpDownCounter&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="observeValue" Type="System.Func&lt;T&gt;" Index="1" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="unit" Type="System.String" Index="2" FrameworkAlternate="net-8.0" />
        <Parameter Name="description" Type="System.String" Index="3" FrameworkAlternate="net-8.0" />
        <Parameter Name="tags" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;" Index="4" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 1, 2 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 1, 2 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement.</typeparam>
        <param name="name">The instrument name. Cannot be <see langword="null" />.</param>
        <param name="observeValue">The callback to call to get the measurements when the <see cref="M:System.Diagnostics.Metrics.ObservableInstrument`1.Observe" /> is called by <see cref="M:System.Diagnostics.Metrics.MeterListener.RecordObservableInstruments" />.</param>
        <param name="unit">Optional instrument unit of measurements.</param>
        <param name="description">Optional instrument description.</param>
        <param name="tags">tags to attach to the counter.</param>
        <summary>Create an ObservableUpDownCounter object. ObservableUpDownCounter is an Instrument which reports increasing or decreasing value(s) when the instrument is being observed.</summary>
        <returns>A new observable up down counter.</returns>
        <remarks>Example uses for ObservableUpDownCounter: the process heap size or the approximate number of items in a lock-free circular buffer.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateUpDownCounter&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.UpDownCounter&lt;T&gt; CreateUpDownCounter&lt;T&gt; (string name, string? unit = default, string? description = default) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.UpDownCounter`1&lt;!!T&gt; CreateUpDownCounter&lt;struct .ctor (class System.ValueType) T&gt;(string name, string unit, string description) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateUpDownCounter``1(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateUpDownCounter(Of T As Structure) (name As String, Optional unit As String = Nothing, Optional description As String = Nothing) As UpDownCounter(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateUpDownCounter : string * string * string -&gt; System.Diagnostics.Metrics.UpDownCounter&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateUpDownCounter (name, unit, description)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.UpDownCounter&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="net-7.0;net-8.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="unit" Type="System.String" Index="1" FrameworkAlternate="net-7.0;net-8.0" />
        <Parameter Name="description" Type="System.String" Index="2" FrameworkAlternate="net-7.0;net-8.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement.</typeparam>
        <param name="name">The instrument name. Cannot be <see langword="null" />.</param>
        <param name="unit">Optional instrument unit of measurements.</param>
        <param name="description">Optional instrument description.</param>
        <summary>Create a metrics UpDownCounter object.</summary>
        <returns>A new up down counter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

UpDownCounter is an Instrument which supports reporting positive or negative metric values.
            Example uses for UpDownCounter: reporting the change in active requests or queue size.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateUpDownCounter&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Metrics.UpDownCounter&lt;T&gt; CreateUpDownCounter&lt;T&gt; (string name, string? unit, string? description, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object?&gt;&gt; tags) where T : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Metrics.UpDownCounter`1&lt;!!T&gt; CreateUpDownCounter&lt;struct .ctor (class System.ValueType) T&gt;(string name, string unit, string description, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; tags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.CreateUpDownCounter``1(System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateUpDownCounter(Of T As Structure) (name As String, unit As String, description As String, tags As IEnumerable(Of KeyValuePair(Of String, Object))) As UpDownCounter(Of T)" />
      <MemberSignature Language="F#" Value="member this.CreateUpDownCounter : string * string * string * seq&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt; -&gt; System.Diagnostics.Metrics.UpDownCounter&lt;'T (requires 'T : struct)&gt; (requires 'T : struct)" Usage="meter.CreateUpDownCounter (name, unit, description, tags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : value class System::Diagnostics::Metrics::UpDownCounter&lt;T&gt; ^ CreateUpDownCounter(System::String ^ name, System::String ^ unit, System::String ^ description, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ tags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Metrics.UpDownCounter&lt;T&gt;</ReturnType>
        <Attributes>
          <Attribute>
            <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0 })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="unit" Type="System.String" Index="1" FrameworkAlternate="net-8.0" />
        <Parameter Name="description" Type="System.String" Index="2" FrameworkAlternate="net-8.0" />
        <Parameter Name="tags" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;" Index="3" FrameworkAlternate="net-8.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 1, 2 })]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 1, 0, 1, 2 })&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="T">The numerical type of the measurement.</typeparam>
        <param name="name">The instrument name. Cannot be <see langword="null" />.</param>
        <param name="unit">Optional instrument unit of measurements.</param>
        <param name="description">Optional instrument description.</param>
        <param name="tags">tags to attach to the counter.</param>
        <summary>Create a metrics UpDownCounter object.</summary>
        <returns>A new up down counter.</returns>
        <remarks>UpDownCounter is an Instrument which supports reporting positive or negative metric values.
 Example uses for UpDownCounter: reporting the change in active requests or queue size.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="meter.Dispose " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Dispose the Meter which will disable all instruments created by this meter.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Metrics.Meter.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="meter.Dispose disposing" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="net-8.0" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> if called from Dispose(), <see langword="false" /> if called from a finalizer.</param>
        <summary>Dispose the Meter which will disable all instruments created by this meter.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Metrics.Meter.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Diagnostics.Metrics.Meter.Name" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-8.0">
          <AttributeName Language="C#">[get: System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the Meter name.</summary>
        <value>The Meter name</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Scope">
      <MemberSignature Language="C#" Value="public object? Scope { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Scope" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Metrics.Meter.Scope" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Scope As Object" />
      <MemberSignature Language="F#" Value="member this.Scope : obj" Usage="System.Diagnostics.Metrics.Meter.Scope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Scope { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the Meter scope object.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tags">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object?&gt;&gt;? Tags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; Tags" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Metrics.Meter.Tags" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Tags As IEnumerable(Of KeyValuePair(Of String, Object))" />
      <MemberSignature Language="F#" Value="member this.Tags : seq&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt;" Usage="System.Diagnostics.Metrics.Meter.Tags" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ Tags { System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 0, 1, 2 })]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(new System.Byte[] { 2, 0, 1, 2 })&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns the tags associated with the Meter.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public string? Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Version" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Metrics.Meter.Version" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Version As String" />
      <MemberSignature Language="F#" Value="member this.Version : string" Usage="System.Diagnostics.Metrics.Meter.Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Version { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.DiagnosticSource</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the Meter version.</summary>
        <value>The Meter version.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
