<Type Name="ExceptionHandling" FullName="System.Runtime.ExceptionServices.ExceptionHandling">
  <TypeSignature Language="C#" Value="public static class ExceptionHandling" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ExceptionHandling extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.ExceptionServices.ExceptionHandling" />
  <TypeSignature Language="VB.NET" Value="Public Class ExceptionHandling" />
  <TypeSignature Language="F#" Value="type ExceptionHandling = class" />
  <TypeSignature Language="C++ CLI" Value="public ref class ExceptionHandling abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>To be added.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="RaiseAppDomainUnhandledExceptionEvent">
      <MemberSignature Language="C#" Value="public static void RaiseAppDomainUnhandledExceptionEvent (object exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RaiseAppDomainUnhandledExceptionEvent(object exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.ExceptionServices.ExceptionHandling.RaiseAppDomainUnhandledExceptionEvent(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RaiseAppDomainUnhandledExceptionEvent (exception As Object)" />
      <MemberSignature Language="F#" Value="static member RaiseAppDomainUnhandledExceptionEvent : obj -&gt; unit" Usage="System.Runtime.ExceptionServices.ExceptionHandling.RaiseAppDomainUnhandledExceptionEvent exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RaiseAppDomainUnhandledExceptionEvent(System::Object ^ exception);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="exception">The exception to pass to event handlers.</param>
        <summary>Raises the <see cref="E:System.AppDomain.UnhandledException" /> event.</summary>
        <remarks>
          <para>This method will raise the <see cref="E:System.AppDomain.UnhandledException" /> event and then return.</para>
          <para>It will not raise the the handler registered with <see cref="M:System.Runtime.ExceptionServices.ExceptionHandling.SetUnhandledExceptionHandler(System.Func{System.Exception,System.Boolean})" />.</para>
          <para>This API is thread safe and can be called from multiple threads. However, only one thread will trigger the event handlers, while other threads will wait indefinitely without raising the event.</para>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetUnhandledExceptionHandler">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionHandler (Func&lt;Exception,bool&gt; handler);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionHandler(class System.Func`2&lt;class System.Exception, bool&gt; handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.ExceptionServices.ExceptionHandling.SetUnhandledExceptionHandler(System.Func{System.Exception,System.Boolean})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionHandler (handler As Func(Of Exception, Boolean))" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionHandler : Func&lt;Exception, bool&gt; -&gt; unit" Usage="System.Runtime.ExceptionServices.ExceptionHandling.SetUnhandledExceptionHandler handler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionHandler(Func&lt;Exception ^, bool&gt; ^ handler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handler" Type="System.Func&lt;System.Exception,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <param name="handler">To be added.</param>
        <summary>Sets a handler for unhandled exceptions.</summary>
        <remarks>
          <para>The handler will be called when an unhandled exception occurs.</para>
          <para>The handler should return <see langword="true" /> if the exception was handled, or <see langword="false" /> if it was not.</para>
          <para>If the handler returns <see langword="false" />, the exception will continue to propagate as unhandled.</para>
          <para>The intent of this handler is to allow the user to handle unhandled exceptions gracefully when the runtime is being used in certain scenarios. Scenarios such as REPLs or game scripting that host plug-ins are not able to handle unhandled exceptions thrown by those plug-ins.</para>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="handler" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">A handler has already been set.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
