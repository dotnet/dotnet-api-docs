<Type Name="INumberBase&lt;TSelf&gt;" FullName="System.Numerics.INumberBase&lt;TSelf&gt;">
  <TypeSignature Language="C#" Value="public interface INumberBase&lt;TSelf&gt; : IEquatable&lt;TSelf&gt;, IParsable&lt;TSelf&gt;, ISpanFormattable, ISpanParsable&lt;TSelf&gt;, System.Numerics.IAdditionOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.IAdditiveIdentity&lt;TSelf,TSelf&gt;, System.Numerics.IDecrementOperators&lt;TSelf&gt;, System.Numerics.IDivisionOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.IEqualityOperators&lt;TSelf,TSelf,bool&gt;, System.Numerics.IIncrementOperators&lt;TSelf&gt;, System.Numerics.IMultiplicativeIdentity&lt;TSelf,TSelf&gt;, System.Numerics.IMultiplyOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.ISubtractionOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.IUnaryNegationOperators&lt;TSelf,TSelf&gt;, System.Numerics.IUnaryPlusOperators&lt;TSelf,TSelf&gt; where TSelf : INumberBase&lt;TSelf&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract INumberBase`1&lt;(class System.Numerics.INumberBase`1&lt;!TSelf&gt;) TSelf&gt; implements class System.IEquatable`1&lt;!TSelf&gt;, class System.IFormattable, class System.IParsable`1&lt;!TSelf&gt;, class System.ISpanFormattable, class System.ISpanParsable`1&lt;!TSelf&gt;, class System.Numerics.IAdditionOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!TSelf, !TSelf&gt;, class System.Numerics.IDecrementOperators`1&lt;!TSelf&gt;, class System.Numerics.IDivisionOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.IEqualityOperators`3&lt;!TSelf, !TSelf, bool&gt;, class System.Numerics.IIncrementOperators`1&lt;!TSelf&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!TSelf, !TSelf&gt;, class System.Numerics.IMultiplyOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.ISubtractionOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.IUnaryNegationOperators`2&lt;!TSelf, !TSelf&gt;, class System.Numerics.IUnaryPlusOperators`2&lt;!TSelf, !TSelf&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.INumberBase`1" />
  <TypeSignature Language="VB.NET" Value="Public Interface INumberBase(Of TSelf)&#xA;Implements IAdditionOperators(Of TSelf, TSelf, TSelf), IAdditiveIdentity(Of TSelf, TSelf), IDecrementOperators(Of TSelf), IDivisionOperators(Of TSelf, TSelf, TSelf), IEqualityOperators(Of TSelf, TSelf, Boolean), IEquatable(Of TSelf), IIncrementOperators(Of TSelf), IMultiplicativeIdentity(Of TSelf, TSelf), IMultiplyOperators(Of TSelf, TSelf, TSelf), IParsable(Of TSelf), ISpanFormattable, ISpanParsable(Of TSelf), ISubtractionOperators(Of TSelf, TSelf, TSelf), IUnaryNegationOperators(Of TSelf, TSelf), IUnaryPlusOperators(Of TSelf, TSelf)" />
  <TypeSignature Language="F#" Value="type INumberBase&lt;'Self (requires 'Self :&gt; INumberBase&lt;'Self&gt;)&gt; = interface&#xA;    interface IEquatable&lt;'Self (requires 'Self :&gt; INumberBase&lt;'Self&gt;)&gt;&#xA;    interface IFormattable&#xA;    interface IParsable&lt;'Self (requires 'Self :&gt; INumberBase&lt;'Self&gt;)&gt;&#xA;    interface ISpanFormattable&#xA;    interface ISpanParsable&lt;'Self (requires 'Self :&gt; INumberBase&lt;'Self&gt;)&gt;&#xA;    interface IAdditionOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; INumberBase&lt;'Self&gt; and 'Self :&gt; INumberBase&lt;'Self&gt; and 'Self :&gt; INumberBase&lt;'Self&gt;)&gt;&#xA;    interface IAdditiveIdentity&lt;'Self, 'Self (requires 'Self :&gt; INumberBase&lt;'Self&gt; and 'Self :&gt; INumberBase&lt;'Self&gt;)&gt;&#xA;    interface IDecrementOperators&lt;'Self (requires 'Self :&gt; INumberBase&lt;'Self&gt;)&gt;&#xA;    interface IDivisionOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; INumberBase&lt;'Self&gt; and 'Self :&gt; INumberBase&lt;'Self&gt; and 'Self :&gt; INumberBase&lt;'Self&gt;)&gt;&#xA;    interface IEqualityOperators&lt;'Self, 'Self, bool (requires 'Self :&gt; INumberBase&lt;'Self&gt; and 'Self :&gt; INumberBase&lt;'Self&gt;)&gt;&#xA;    interface IIncrementOperators&lt;'Self (requires 'Self :&gt; INumberBase&lt;'Self&gt;)&gt;&#xA;    interface IMultiplicativeIdentity&lt;'Self, 'Self (requires 'Self :&gt; INumberBase&lt;'Self&gt; and 'Self :&gt; INumberBase&lt;'Self&gt;)&gt;&#xA;    interface IMultiplyOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; INumberBase&lt;'Self&gt; and 'Self :&gt; INumberBase&lt;'Self&gt; and 'Self :&gt; INumberBase&lt;'Self&gt;)&gt;&#xA;    interface ISubtractionOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; INumberBase&lt;'Self&gt; and 'Self :&gt; INumberBase&lt;'Self&gt; and 'Self :&gt; INumberBase&lt;'Self&gt;)&gt;&#xA;    interface IUnaryNegationOperators&lt;'Self, 'Self (requires 'Self :&gt; INumberBase&lt;'Self&gt; and 'Self :&gt; INumberBase&lt;'Self&gt;)&gt;&#xA;    interface IUnaryPlusOperators&lt;'Self, 'Self (requires 'Self :&gt; INumberBase&lt;'Self&gt; and 'Self :&gt; INumberBase&lt;'Self&gt;)&gt;" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TSelf&gt;&#xA; where TSelf : INumberBase&lt;TSelf&gt;public interface class INumberBase : IEquatable&lt;TSelf&gt;, IParsable&lt;TSelf&gt;, ISpanFormattable, ISpanParsable&lt;TSelf&gt;, System::Numerics::IAdditionOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::IAdditiveIdentity&lt;TSelf, TSelf&gt;, System::Numerics::IDecrementOperators&lt;TSelf&gt;, System::Numerics::IDivisionOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::IEqualityOperators&lt;TSelf, TSelf, bool&gt;, System::Numerics::IIncrementOperators&lt;TSelf&gt;, System::Numerics::IMultiplicativeIdentity&lt;TSelf, TSelf&gt;, System::Numerics::IMultiplyOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::ISubtractionOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::IUnaryNegationOperators&lt;TSelf, TSelf&gt;, System::Numerics::IUnaryPlusOperators&lt;TSelf, TSelf&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TSelf">
      <Constraints>
        <InterfaceName>System.Numerics.INumberBase&lt;TSelf&gt;</InterfaceName>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IParsable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ISpanFormattable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ISpanParsable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IAdditionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IAdditiveIdentity&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IDecrementOperators&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IDivisionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IEqualityOperators&lt;TSelf,TSelf,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IIncrementOperators&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IMultiplyOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.ISubtractionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IUnaryNegationOperators&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IUnaryPlusOperators&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <typeparam name="TSelf">The type that implements the interface.</typeparam>
    <summary>Defines the base of other number types.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static TSelf Abs (TSelf value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf Abs(!TSelf value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.Abs(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As TSelf) As TSelf" />
      <MemberSignature Language="F#" Value="static member Abs : 'Self -&gt; 'Self" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.Abs value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TSelf Abs(TSelf value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="value">The value for which to get its absolute.</param>
        <summary>Computes the absolute of a value.</summary>
        <returns>The absolute of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OverflowException">The absolute of <paramref name="value" /> is not representable by <typeparamref name="TSelf" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateChecked&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="public static override TSelf CreateChecked&lt;TOther&gt; (TOther value) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf CreateChecked&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.CreateChecked``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Overrides Function CreateChecked(Of TOther As INumberBase(Of TOther)) (value As TOther) As TSelf" />
      <MemberSignature Language="F#" Value="static member CreateChecked : 'Other -&gt; 'Self (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.CreateChecked value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static override TSelf CreateChecked(TOther value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type of <paramref name="value" />.</typeparam>
        <param name="value">The value that's used to create the instance of <typeparamref name="TSelf" />.</param>
        <summary>Creates an instance of the current type from a value, throwing an overflow exception for any values that fall outside the representable range of the current type.</summary>
        <returns>An instance of <typeparamref name="TSelf" /> created from <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <typeparamref name="TOther" /> is not supported.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> is not representable by <typeparamref name="TSelf" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateSaturating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="public static override TSelf CreateSaturating&lt;TOther&gt; (TOther value) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf CreateSaturating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.CreateSaturating``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Overrides Function CreateSaturating(Of TOther As INumberBase(Of TOther)) (value As TOther) As TSelf" />
      <MemberSignature Language="F#" Value="static member CreateSaturating : 'Other -&gt; 'Self (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.CreateSaturating value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static override TSelf CreateSaturating(TOther value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type of <paramref name="value" />.</typeparam>
        <param name="value">The value which is used to create the instance of <typeparamref name="TSelf" />.</param>
        <summary>Creates an instance of the current type from a value, saturating any values that fall outside the representable range of the current type.</summary>
        <returns>An instance of <typeparamref name="TSelf" /> created from <paramref name="value" />, saturating if <paramref name="value" /> falls outside the representable range of <typeparamref name="TSelf" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <typeparamref name="TOther" /> is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateTruncating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="public static override TSelf CreateTruncating&lt;TOther&gt; (TOther value) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf CreateTruncating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.CreateTruncating``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Overrides Function CreateTruncating(Of TOther As INumberBase(Of TOther)) (value As TOther) As TSelf" />
      <MemberSignature Language="F#" Value="static member CreateTruncating : 'Other -&gt; 'Self (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.CreateTruncating value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static override TSelf CreateTruncating(TOther value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type of <paramref name="value" />.</typeparam>
        <param name="value">The value which is used to create the instance of <typeparamref name="TSelf" />.</param>
        <summary>Creates an instance of the current type from a value, truncating any values that fall outside the representable range of the current type.</summary>
        <returns>An instance of <typeparamref name="TSelf" /> created from <paramref name="value" />, truncating if <paramref name="value" /> falls outside the representable range of <typeparamref name="TSelf" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <typeparamref name="TOther" /> is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsCanonical">
      <MemberSignature Language="C#" Value="public static bool IsCanonical (TSelf value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual bool IsCanonical(!TSelf value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.IsCanonical(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsCanonical (value As TSelf) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsCanonical : 'Self -&gt; bool" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.IsCanonical value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsCanonical(TSelf value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is in its canonical representation.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is in its canonical representation; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsComplexNumber">
      <MemberSignature Language="C#" Value="public static bool IsComplexNumber (TSelf value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual bool IsComplexNumber(!TSelf value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.IsComplexNumber(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsComplexNumber (value As TSelf) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsComplexNumber : 'Self -&gt; bool" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.IsComplexNumber value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsComplexNumber(TSelf value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents a complex number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is a complex number; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This function returns `false` for a complex number `a + bi` where `b` is zero.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEvenInteger">
      <MemberSignature Language="C#" Value="public static bool IsEvenInteger (TSelf value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual bool IsEvenInteger(!TSelf value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.IsEvenInteger(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEvenInteger (value As TSelf) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsEvenInteger : 'Self -&gt; bool" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.IsEvenInteger value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEvenInteger(TSelf value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents an even integral number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an even integer; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This method correctly handles floating-point values and so `2.0` will return `true` while `2.2` will return `false`.

A return value of `false` does not imply that <xref:System.Numerics.INumberBase%601.IsOddInteger(%600)> will return `true`. A number with a fractional portion, for example, `3.3`, is not even or odd.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (TSelf value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual bool IsFinite(!TSelf value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.IsFinite(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (value As TSelf) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsFinite : 'Self -&gt; bool" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.IsFinite value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(TSelf value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is finite.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is finite; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

A return value of `false` does not imply that <xref:System.Numerics.INumberBase%601.IsInfinity(%600)> will return `true`. `NaN` is not finite or infinite.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImaginaryNumber">
      <MemberSignature Language="C#" Value="public static bool IsImaginaryNumber (TSelf value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual bool IsImaginaryNumber(!TSelf value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.IsImaginaryNumber(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsImaginaryNumber (value As TSelf) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsImaginaryNumber : 'Self -&gt; bool" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.IsImaginaryNumber value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsImaginaryNumber(TSelf value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents an imaginary number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an imaginary number; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This function returns `false` for a complex number `a + bi` where `a` is non-zero.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (TSelf value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual bool IsInfinity(!TSelf value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.IsInfinity(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (value As TSelf) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsInfinity : 'Self -&gt; bool" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.IsInfinity value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(TSelf value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is infinite.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is infinite; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

A return value of `false` does not imply that <xref:System.Numerics.INumberBase%601.IsFinite(%600)> will return `true`. `NaN` is not finite or infinite.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInteger">
      <MemberSignature Language="C#" Value="public static bool IsInteger (TSelf value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual bool IsInteger(!TSelf value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.IsInteger(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInteger (value As TSelf) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsInteger : 'Self -&gt; bool" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.IsInteger value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInteger(TSelf value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents an integral number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an integer; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This method correctly handles floating-point values and so `2.0` and `3.0` will return `true` while `2.2` and `3.3` will return `false`.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (TSelf value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual bool IsNaN(!TSelf value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.IsNaN(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (value As TSelf) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsNaN : 'Self -&gt; bool" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.IsNaN value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(TSelf value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is NaN.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is NaN; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (TSelf value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual bool IsNegative(!TSelf value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.IsNegative(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (value As TSelf) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsNegative : 'Self -&gt; bool" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.IsNegative value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(TSelf value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is negative.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is negative; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

A return value of `false` does not imply that <xref:System.Numerics.INumberBase%601.IsPositive(%600)> will return `true`. A complex number, `a + bi` for non-zero `b`, is not positive or negative

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (TSelf value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual bool IsNegativeInfinity(!TSelf value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.IsNegativeInfinity(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinity (value As TSelf) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsNegativeInfinity : 'Self -&gt; bool" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.IsNegativeInfinity value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(TSelf value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is negative infinity.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is negative infinity; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNormal">
      <MemberSignature Language="C#" Value="public static bool IsNormal (TSelf value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual bool IsNormal(!TSelf value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.IsNormal(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormal (value As TSelf) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsNormal : 'Self -&gt; bool" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.IsNormal value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(TSelf value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is normal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is normal; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOddInteger">
      <MemberSignature Language="C#" Value="public static bool IsOddInteger (TSelf value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual bool IsOddInteger(!TSelf value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.IsOddInteger(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsOddInteger (value As TSelf) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsOddInteger : 'Self -&gt; bool" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.IsOddInteger value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsOddInteger(TSelf value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents an odd integral number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an odd integer; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This method correctly handles floating-point values and so `3.0` will return `true` while `3.3` will return `false`.

A return value of `false` does not imply that <xref:System.Numerics.INumberBase%601.IsEvenInteger(%600)> will return `true`. A number with a fractional portion, for example, `3.3`, is not even or odd.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositive">
      <MemberSignature Language="C#" Value="public static bool IsPositive (TSelf value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual bool IsPositive(!TSelf value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.IsPositive(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositive (value As TSelf) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsPositive : 'Self -&gt; bool" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.IsPositive value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositive(TSelf value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is positive.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is positive; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

A return value of `false` does not imply that <xref:System.Numerics.INumberBase%601.IsNegative(%600)> will return `true`. A complex number, `a + bi` for non-zero `b`, is not positive or negative

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (TSelf value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual bool IsPositiveInfinity(!TSelf value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.IsPositiveInfinity(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinity (value As TSelf) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsPositiveInfinity : 'Self -&gt; bool" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.IsPositiveInfinity value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(TSelf value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is positive infinity.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is positive infinity; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRealNumber">
      <MemberSignature Language="C#" Value="public static bool IsRealNumber (TSelf value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual bool IsRealNumber(!TSelf value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.IsRealNumber(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsRealNumber (value As TSelf) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsRealNumber : 'Self -&gt; bool" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.IsRealNumber value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsRealNumber(TSelf value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents a real number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is a real number; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This function returns `true` for a complex number `a + bi` where `b` is zero.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal">
      <MemberSignature Language="C#" Value="public static bool IsSubnormal (TSelf value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual bool IsSubnormal(!TSelf value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.IsSubnormal(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormal (value As TSelf) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsSubnormal : 'Self -&gt; bool" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.IsSubnormal value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(TSelf value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is subnormal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is subnormal; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsZero">
      <MemberSignature Language="C#" Value="public static bool IsZero (TSelf value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual bool IsZero(!TSelf value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.IsZero(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsZero (value As TSelf) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsZero : 'Self -&gt; bool" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.IsZero value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsZero(TSelf value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is zero.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is zero; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This function treats both positive and negative zero as zero and so will return `true` for `+0.0` and `-0.0`.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude">
      <MemberSignature Language="C#" Value="public static TSelf MaxMagnitude (TSelf x, TSelf y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf MaxMagnitude(!TSelf x, !TSelf y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.MaxMagnitude(`0,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MaxMagnitude (x As TSelf, y As TSelf) As TSelf" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : 'Self * 'Self -&gt; 'Self" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.MaxMagnitude (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TSelf MaxMagnitude(TSelf x, TSelf y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="TSelf" />
        <Parameter Name="y" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is greater.</summary>
        <returns>
          <paramref name="x" /> if it is greater than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For <xref:System.Numerics.IFloatingPointIeee754%601> this method matches the IEEE 754:2019 `maximumMagnitude` function. This requires NaN inputs to be propagated back to the caller and for `-0.0` to be treated as less than `+0.0`.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitudeNumber">
      <MemberSignature Language="C#" Value="public static TSelf MaxMagnitudeNumber (TSelf x, TSelf y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf MaxMagnitudeNumber(!TSelf x, !TSelf y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.MaxMagnitudeNumber(`0,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MaxMagnitudeNumber (x As TSelf, y As TSelf) As TSelf" />
      <MemberSignature Language="F#" Value="static member MaxMagnitudeNumber : 'Self * 'Self -&gt; 'Self" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.MaxMagnitudeNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TSelf MaxMagnitudeNumber(TSelf x, TSelf y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="TSelf" />
        <Parameter Name="y" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which has the greater magnitude and returning the other value if an input is <c>NaN</c>.</summary>
        <returns>
          <paramref name="x" /> if it is greater than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For <xref:System.Numerics.IFloatingPointIeee754%601> this method matches the IEEE 754:2019 `maximumMagnitudeNumber` function. This requires NaN inputs to not be propagated back to the caller and for `-0.0` to be treated as less than `+0.0`.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude">
      <MemberSignature Language="C#" Value="public static TSelf MinMagnitude (TSelf x, TSelf y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf MinMagnitude(!TSelf x, !TSelf y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.MinMagnitude(`0,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MinMagnitude (x As TSelf, y As TSelf) As TSelf" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : 'Self * 'Self -&gt; 'Self" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.MinMagnitude (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TSelf MinMagnitude(TSelf x, TSelf y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="TSelf" />
        <Parameter Name="y" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is lesser.</summary>
        <returns>
          <paramref name="x" /> if it is less than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For <xref:System.Numerics.IFloatingPointIeee754%601> this method matches the IEEE 754:2019 `minimumMagnitude` function. This requires NaN inputs to be propagated back to the caller and for `-0.0` to be treated as less than `+0.0`.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitudeNumber">
      <MemberSignature Language="C#" Value="public static TSelf MinMagnitudeNumber (TSelf x, TSelf y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf MinMagnitudeNumber(!TSelf x, !TSelf y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.MinMagnitudeNumber(`0,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MinMagnitudeNumber (x As TSelf, y As TSelf) As TSelf" />
      <MemberSignature Language="F#" Value="static member MinMagnitudeNumber : 'Self * 'Self -&gt; 'Self" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.MinMagnitudeNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TSelf MinMagnitudeNumber(TSelf x, TSelf y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="TSelf" />
        <Parameter Name="y" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which has the lesser magnitude and returning the other value if an input is <c>NaN</c>.</summary>
        <returns>
          <paramref name="x" /> if it is less than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For <xref:System.Numerics.IFloatingPointIeee754%601> this method matches the IEEE 754:2019 `minimumMagnitudeNumber` function. This requires NaN inputs to not be propagated back to the caller and for `-0.0` to be treated as less than `+0.0`.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static TSelf One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property !TSelf One" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.INumberBase`1.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property One As TSelf" />
      <MemberSignature Language="F#" Value="static member One : 'Self" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.One" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property TSelf One { TSelf get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value <c>1</c> for the type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static TSelf Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider? provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider) As TSelf" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; 'Self" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.Parse (s, style, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TSelf Parse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">The span of characters to parse.</param>
        <param name="style">A bitwise combination of number styles that can be present in <paramref name="s" />.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <summary>Parses a span of characters into a value.</summary>
        <returns>The result of parsing <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> is not a supported <see cref="T:System.Globalization.NumberStyles" /> value.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> is not in the correct format.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> is not representable by <typeparamref name="TSelf" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static TSelf Parse (string s, System.Globalization.NumberStyles style, IFormatProvider? provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As TSelf" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; 'Self" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.Parse (s, style, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TSelf Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">The string to parse.</param>
        <param name="style">A bitwise combination of number styles that can be present in <paramref name="s" />.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <summary>Parses a string into a value.</summary>
        <returns>The result of parsing <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> is not a supported <see cref="T:System.Globalization.NumberStyles" /> value.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> is not in the correct format.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> is not representable by <typeparamref name="TSelf" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Radix">
      <MemberSignature Language="C#" Value="public static int Radix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 Radix" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.INumberBase`1.Radix" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Radix As Integer" />
      <MemberSignature Language="F#" Value="static member Radix : int" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.Radix" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int Radix { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the radix, or base, for the type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryConvertFromChecked&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="protected static bool TryConvertFromChecked&lt;TOther&gt; (TOther value, out TSelf result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig virtual bool TryConvertFromChecked&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value, [out] !TSelf&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.TryConvertFromChecked``1(``0,`0@)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function TryConvertFromChecked(Of TOther As INumberBase(Of TOther)) (value As TOther, ByRef result As TSelf) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryConvertFromChecked : 'Other * 'Self -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.TryConvertFromChecked (value, result)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool TryConvertFromChecked(TOther value, [Runtime::InteropServices::Out] TSelf % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" />
        <Parameter Name="result" Type="TSelf" RefType="out">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type of <paramref name="value" />.</typeparam>
        <param name="value">The value that's used to create the instance of <typeparamref name="TSelf" />.</param>
        <param name="result">When this method returns, contains an instance of <typeparamref name="TSelf" /> converted from <paramref name="value" />.</param>
        <summary>Tries to convert a value to an instance of the the current type, throwing an overflow exception for any values that fall outside the representable range of the current type.</summary>
        <returns>
          <see langword="false" /> if <typeparamref name="TOther" /> is not supported; otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> is not representable by <typeparamref name="TSelf" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryConvertFromSaturating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="protected static bool TryConvertFromSaturating&lt;TOther&gt; (TOther value, out TSelf result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig virtual bool TryConvertFromSaturating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value, [out] !TSelf&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.TryConvertFromSaturating``1(``0,`0@)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function TryConvertFromSaturating(Of TOther As INumberBase(Of TOther)) (value As TOther, ByRef result As TSelf) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryConvertFromSaturating : 'Other * 'Self -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.TryConvertFromSaturating (value, result)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool TryConvertFromSaturating(TOther value, [Runtime::InteropServices::Out] TSelf % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" />
        <Parameter Name="result" Type="TSelf" RefType="out">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type of <paramref name="value" />.</typeparam>
        <param name="value">The value which is used to create the instance of <typeparamref name="TSelf" />.</param>
        <param name="result">When this method returns, contains an instance of <typeparamref name="TSelf" /> converted from <paramref name="value" />.</param>
        <summary>Tries to convert a value to an instance of the the current type, saturating any values that fall outside the representable range of the current type.</summary>
        <returns>
          <see langword="false" /> if <typeparamref name="TOther" /> is not supported; otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryConvertFromTruncating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="protected static bool TryConvertFromTruncating&lt;TOther&gt; (TOther value, out TSelf result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig virtual bool TryConvertFromTruncating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value, [out] !TSelf&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.TryConvertFromTruncating``1(``0,`0@)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function TryConvertFromTruncating(Of TOther As INumberBase(Of TOther)) (value As TOther, ByRef result As TSelf) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryConvertFromTruncating : 'Other * 'Self -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.TryConvertFromTruncating (value, result)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool TryConvertFromTruncating(TOther value, [Runtime::InteropServices::Out] TSelf % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" />
        <Parameter Name="result" Type="TSelf" RefType="out">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type of <paramref name="value" />.</typeparam>
        <param name="value">The value which is used to create the instance of <typeparamref name="TSelf" />.</param>
        <param name="result">When this method returns, contains an instance of <typeparamref name="TSelf" /> converted from <paramref name="value" />.</param>
        <summary>Tries to convert a value to an instance of the the current type, truncating any values that fall outside the representable range of the current type.</summary>
        <returns>
          <see langword="false" /> if <typeparamref name="TOther" /> is not supported; otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryConvertToChecked&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="protected static bool TryConvertToChecked&lt;TOther&gt; (TSelf value, out TOther result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig virtual bool TryConvertToChecked&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!TSelf value, [out] !!TOther&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.TryConvertToChecked``1(`0,``0@)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function TryConvertToChecked(Of TOther As INumberBase(Of TOther)) (value As TSelf, ByRef result As TOther) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryConvertToChecked : 'Self * 'Other -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.TryConvertToChecked (value, result)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool TryConvertToChecked(TSelf value, [Runtime::InteropServices::Out] TOther % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
        <Parameter Name="result" Type="TOther" RefType="out">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type to which <paramref name="value" /> should be converted.</typeparam>
        <param name="value">The value which is used to create the instance of <typeparamref name="TOther" />.</param>
        <param name="result">When this method returns, contains an instance of <typeparamref name="TOther" /> converted from <paramref name="value" />.</param>
        <summary>Tries to convert an instance of the the current type to another type, throwing an overflow exception for any values that fall outside the representable range of the current type.</summary>
        <returns>
          <see langword="false" /> if <typeparamref name="TOther" /> is not supported; otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> is not representable by <typeparamref name="TOther" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryConvertToSaturating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="protected static bool TryConvertToSaturating&lt;TOther&gt; (TSelf value, out TOther result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig virtual bool TryConvertToSaturating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!TSelf value, [out] !!TOther&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.TryConvertToSaturating``1(`0,``0@)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function TryConvertToSaturating(Of TOther As INumberBase(Of TOther)) (value As TSelf, ByRef result As TOther) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryConvertToSaturating : 'Self * 'Other -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.TryConvertToSaturating (value, result)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool TryConvertToSaturating(TSelf value, [Runtime::InteropServices::Out] TOther % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
        <Parameter Name="result" Type="TOther" RefType="out">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type to which <paramref name="value" /> should be converted.</typeparam>
        <param name="value">The value which is used to create the instance of <typeparamref name="TOther" />.</param>
        <param name="result">When this method returns, contains an instance of <typeparamref name="TOther" /> converted from <paramref name="value" />.</param>
        <summary>Tries to convert an instance of the the current type to another type, saturating any values that fall outside the representable range of the current type.</summary>
        <returns>
          <see langword="false" /> if <typeparamref name="TOther" /> is not supported; otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryConvertToTruncating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="protected static bool TryConvertToTruncating&lt;TOther&gt; (TSelf value, out TOther result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig virtual bool TryConvertToTruncating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!TSelf value, [out] !!TOther&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.TryConvertToTruncating``1(`0,``0@)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function TryConvertToTruncating(Of TOther As INumberBase(Of TOther)) (value As TSelf, ByRef result As TOther) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryConvertToTruncating : 'Self * 'Other -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.TryConvertToTruncating (value, result)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool TryConvertToTruncating(TSelf value, [Runtime::InteropServices::Out] TOther % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
        <Parameter Name="result" Type="TOther" RefType="out">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type to which <paramref name="value" /> should be converted.</typeparam>
        <param name="value">The value which is used to create the instance of <typeparamref name="TOther" />.</param>
        <param name="result">When this method returns, contains an instance of <typeparamref name="TOther" /> converted from <paramref name="value" />.</param>
        <summary>Tries to convert an instance of the the current type to another type, truncating any values that fall outside the representable range of the current type.</summary>
        <returns>
          <see langword="false" /> if <typeparamref name="TOther" /> is not supported; otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider? provider, out TSelf result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] !TSelf&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As TSelf) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider * 'Self -&gt; bool" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.TryParse (s, style, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] TSelf % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="TSelf" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">The span of characters to parse.</param>
        <param name="style">A bitwise combination of number styles that can be present in <paramref name="s" />.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <param name="result">On return, contains the result of succesfully parsing <paramref name="s" /> or an undefined value on failure.</param>
        <summary>Tries to parse a span of characters into a value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was successfully parsed; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> is not a supported <see cref="T:System.Globalization.NumberStyles" /> value.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string? s, System.Globalization.NumberStyles style, IFormatProvider? provider, out TSelf result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] !TSelf&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumberBase`1.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As TSelf) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider * 'Self -&gt; bool" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.TryParse (s, style, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] TSelf % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="TSelf" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">The string to parse.</param>
        <param name="style">A bitwise combination of number styles that can be present in <paramref name="s" />.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <param name="result">On return, contains the result of succesfully parsing <paramref name="s" /> or an undefined value on failure.</param>
        <summary>Tries to parse a string into a value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was successfully parsed; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> is not a supported <see cref="T:System.Globalization.NumberStyles" /> value.</exception>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static TSelf Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property !TSelf Zero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.INumberBase`1.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Zero As TSelf" />
      <MemberSignature Language="F#" Value="static member Zero : 'Self" Usage="System.Numerics.INumberBase&lt;'Self (requires 'Self :&gt; System.Numerics.INumberBase&lt;'Self&gt;)&gt;.Zero" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property TSelf Zero { TSelf get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value <c>0</c> for the type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
