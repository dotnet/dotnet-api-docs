<Type Name="IBinaryInteger&lt;TSelf&gt;" FullName="System.Numerics.IBinaryInteger&lt;TSelf&gt;">
  <TypeSignature Language="C#" Value="public interface IBinaryInteger&lt;TSelf&gt; : IComparable&lt;TSelf&gt;, IEquatable&lt;TSelf&gt;, IParsable&lt;TSelf&gt;, ISpanParsable&lt;TSelf&gt;, System.Numerics.IAdditionOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.IAdditiveIdentity&lt;TSelf,TSelf&gt;, System.Numerics.IBinaryNumber&lt;TSelf&gt;, System.Numerics.IBitwiseOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.IComparisonOperators&lt;TSelf,TSelf,bool&gt;, System.Numerics.IDecrementOperators&lt;TSelf&gt;, System.Numerics.IDivisionOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.IEqualityOperators&lt;TSelf,TSelf,bool&gt;, System.Numerics.IIncrementOperators&lt;TSelf&gt;, System.Numerics.IModulusOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.IMultiplicativeIdentity&lt;TSelf,TSelf&gt;, System.Numerics.IMultiplyOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.INumber&lt;TSelf&gt;, System.Numerics.INumberBase&lt;TSelf&gt;, System.Numerics.IShiftOperators&lt;TSelf,int,TSelf&gt;, System.Numerics.ISubtractionOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.IUnaryNegationOperators&lt;TSelf,TSelf&gt;, System.Numerics.IUnaryPlusOperators&lt;TSelf,TSelf&gt; where TSelf : IBinaryInteger&lt;TSelf&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IBinaryInteger`1&lt;(class System.Numerics.IBinaryInteger`1&lt;!TSelf&gt;) TSelf&gt; implements class System.IComparable, class System.IComparable`1&lt;!TSelf&gt;, class System.IEquatable`1&lt;!TSelf&gt;, class System.IFormattable, class System.IParsable`1&lt;!TSelf&gt;, class System.ISpanFormattable, class System.ISpanParsable`1&lt;!TSelf&gt;, class System.Numerics.IAdditionOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!TSelf, !TSelf&gt;, class System.Numerics.IBinaryNumber`1&lt;!TSelf&gt;, class System.Numerics.IBitwiseOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.IComparisonOperators`3&lt;!TSelf, !TSelf, bool&gt;, class System.Numerics.IDecrementOperators`1&lt;!TSelf&gt;, class System.Numerics.IDivisionOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.IEqualityOperators`3&lt;!TSelf, !TSelf, bool&gt;, class System.Numerics.IIncrementOperators`1&lt;!TSelf&gt;, class System.Numerics.IModulusOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!TSelf, !TSelf&gt;, class System.Numerics.IMultiplyOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.INumber`1&lt;!TSelf&gt;, class System.Numerics.INumberBase`1&lt;!TSelf&gt;, class System.Numerics.IShiftOperators`3&lt;!TSelf, int32, !TSelf&gt;, class System.Numerics.ISubtractionOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.IUnaryNegationOperators`2&lt;!TSelf, !TSelf&gt;, class System.Numerics.IUnaryPlusOperators`2&lt;!TSelf, !TSelf&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.IBinaryInteger`1" />
  <TypeSignature Language="VB.NET" Value="Public Interface IBinaryInteger(Of TSelf)&#xA;Implements IAdditionOperators(Of TSelf, TSelf, TSelf), IAdditiveIdentity(Of TSelf, TSelf), IBinaryNumber(Of TSelf), IBitwiseOperators(Of TSelf, TSelf, TSelf), IComparable(Of TSelf), IComparisonOperators(Of TSelf, TSelf, Boolean), IDecrementOperators(Of TSelf), IDivisionOperators(Of TSelf, TSelf, TSelf), IEqualityOperators(Of TSelf, TSelf, Boolean), IEquatable(Of TSelf), IIncrementOperators(Of TSelf), IModulusOperators(Of TSelf, TSelf, TSelf), IMultiplicativeIdentity(Of TSelf, TSelf), IMultiplyOperators(Of TSelf, TSelf, TSelf), INumber(Of TSelf), INumberBase(Of TSelf), IParsable(Of TSelf), IShiftOperators(Of TSelf, Integer, TSelf), ISpanParsable(Of TSelf), ISubtractionOperators(Of TSelf, TSelf, TSelf), IUnaryNegationOperators(Of TSelf, TSelf), IUnaryPlusOperators(Of TSelf, TSelf)" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="F#" Value="type IBinaryInteger&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt; = interface&#xA;    interface IComparable&#xA;    interface IComparable&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IEquatable&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IFormattable&#xA;    interface IParsable&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface ISpanFormattable&#xA;    interface ISpanParsable&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IAdditionOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IAdditiveIdentity&lt;'Self, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IBinaryNumber&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IBitwiseOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IComparisonOperators&lt;'Self, 'Self, bool (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IEqualityOperators&lt;'Self, 'Self, bool (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IDecrementOperators&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IDivisionOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IIncrementOperators&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IModulusOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IMultiplicativeIdentity&lt;'Self, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IMultiplyOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface INumber&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface INumberBase&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface ISubtractionOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IUnaryNegationOperators&lt;'Self, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IUnaryPlusOperators&lt;'Self, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IShiftOperators&lt;'Self, int, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TSelf&gt;&#xA; where TSelf : IBinaryInteger&lt;TSelf&gt;public interface class IBinaryInteger : IComparable&lt;TSelf&gt;, IEquatable&lt;TSelf&gt;, IParsable&lt;TSelf&gt;, ISpanParsable&lt;TSelf&gt;, System::Numerics::IAdditionOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::IAdditiveIdentity&lt;TSelf, TSelf&gt;, System::Numerics::IBinaryNumber&lt;TSelf&gt;, System::Numerics::IBitwiseOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::IComparisonOperators&lt;TSelf, TSelf, bool&gt;, System::Numerics::IDecrementOperators&lt;TSelf&gt;, System::Numerics::IDivisionOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::IEqualityOperators&lt;TSelf, TSelf, bool&gt;, System::Numerics::IIncrementOperators&lt;TSelf&gt;, System::Numerics::IModulusOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::IMultiplicativeIdentity&lt;TSelf, TSelf&gt;, System::Numerics::IMultiplyOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::INumber&lt;TSelf&gt;, System::Numerics::INumberBase&lt;TSelf&gt;, System::Numerics::IShiftOperators&lt;TSelf, int, TSelf&gt;, System::Numerics::ISubtractionOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::IUnaryNegationOperators&lt;TSelf, TSelf&gt;, System::Numerics::IUnaryPlusOperators&lt;TSelf, TSelf&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="C#" Value="public interface IBinaryInteger&lt;TSelf&gt; : IComparable&lt;TSelf&gt;, IEquatable&lt;TSelf&gt;, IParsable&lt;TSelf&gt;, ISpanParsable&lt;TSelf&gt;, IUtf8SpanParsable&lt;TSelf&gt;, System.Numerics.IAdditionOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.IAdditiveIdentity&lt;TSelf,TSelf&gt;, System.Numerics.IBinaryNumber&lt;TSelf&gt;, System.Numerics.IBitwiseOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.IComparisonOperators&lt;TSelf,TSelf,bool&gt;, System.Numerics.IDecrementOperators&lt;TSelf&gt;, System.Numerics.IDivisionOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.IEqualityOperators&lt;TSelf,TSelf,bool&gt;, System.Numerics.IIncrementOperators&lt;TSelf&gt;, System.Numerics.IModulusOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.IMultiplicativeIdentity&lt;TSelf,TSelf&gt;, System.Numerics.IMultiplyOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.INumber&lt;TSelf&gt;, System.Numerics.INumberBase&lt;TSelf&gt;, System.Numerics.IShiftOperators&lt;TSelf,int,TSelf&gt;, System.Numerics.ISubtractionOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.IUnaryNegationOperators&lt;TSelf,TSelf&gt;, System.Numerics.IUnaryPlusOperators&lt;TSelf,TSelf&gt; where TSelf : IBinaryInteger&lt;TSelf&gt;" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract beforefieldinit IBinaryInteger`1&lt;(class System.Numerics.IBinaryInteger`1&lt;!TSelf&gt;) TSelf&gt; implements class System.IComparable, class System.IComparable`1&lt;!TSelf&gt;, class System.IEquatable`1&lt;!TSelf&gt;, class System.IFormattable, class System.IParsable`1&lt;!TSelf&gt;, class System.ISpanFormattable, class System.ISpanParsable`1&lt;!TSelf&gt;, class System.IUtf8SpanFormattable, class System.IUtf8SpanParsable`1&lt;!TSelf&gt;, class System.Numerics.IAdditionOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!TSelf, !TSelf&gt;, class System.Numerics.IBinaryNumber`1&lt;!TSelf&gt;, class System.Numerics.IBitwiseOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.IComparisonOperators`3&lt;!TSelf, !TSelf, bool&gt;, class System.Numerics.IDecrementOperators`1&lt;!TSelf&gt;, class System.Numerics.IDivisionOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.IEqualityOperators`3&lt;!TSelf, !TSelf, bool&gt;, class System.Numerics.IIncrementOperators`1&lt;!TSelf&gt;, class System.Numerics.IModulusOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!TSelf, !TSelf&gt;, class System.Numerics.IMultiplyOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.INumber`1&lt;!TSelf&gt;, class System.Numerics.INumberBase`1&lt;!TSelf&gt;, class System.Numerics.IShiftOperators`3&lt;!TSelf, int32, !TSelf&gt;, class System.Numerics.ISubtractionOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.IUnaryNegationOperators`2&lt;!TSelf, !TSelf&gt;, class System.Numerics.IUnaryPlusOperators`2&lt;!TSelf, !TSelf&gt;" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="VB.NET" Value="Public Interface IBinaryInteger(Of TSelf)&#xA;Implements IAdditionOperators(Of TSelf, TSelf, TSelf), IAdditiveIdentity(Of TSelf, TSelf), IBinaryNumber(Of TSelf), IBitwiseOperators(Of TSelf, TSelf, TSelf), IComparable(Of TSelf), IComparisonOperators(Of TSelf, TSelf, Boolean), IDecrementOperators(Of TSelf), IDivisionOperators(Of TSelf, TSelf, TSelf), IEqualityOperators(Of TSelf, TSelf, Boolean), IEquatable(Of TSelf), IIncrementOperators(Of TSelf), IModulusOperators(Of TSelf, TSelf, TSelf), IMultiplicativeIdentity(Of TSelf, TSelf), IMultiplyOperators(Of TSelf, TSelf, TSelf), INumber(Of TSelf), INumberBase(Of TSelf), IParsable(Of TSelf), IShiftOperators(Of TSelf, Integer, TSelf), ISpanParsable(Of TSelf), ISubtractionOperators(Of TSelf, TSelf, TSelf), IUnaryNegationOperators(Of TSelf, TSelf), IUnaryPlusOperators(Of TSelf, TSelf), IUtf8SpanParsable(Of TSelf)" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="F#" Value="type IBinaryInteger&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt; = interface&#xA;    interface IComparable&#xA;    interface IComparable&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IEquatable&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IFormattable&#xA;    interface IParsable&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface ISpanFormattable&#xA;    interface ISpanParsable&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IAdditionOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IAdditiveIdentity&lt;'Self, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IBinaryNumber&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IBitwiseOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IComparisonOperators&lt;'Self, 'Self, bool (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IEqualityOperators&lt;'Self, 'Self, bool (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IDecrementOperators&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IDivisionOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IIncrementOperators&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IModulusOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IMultiplicativeIdentity&lt;'Self, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IMultiplyOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface INumber&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface INumberBase&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface ISubtractionOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IUnaryNegationOperators&lt;'Self, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IUnaryPlusOperators&lt;'Self, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IUtf8SpanFormattable&#xA;    interface IUtf8SpanParsable&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IShiftOperators&lt;'Self, int, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;" FrameworkAlternate="net-8.0" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TSelf&gt;&#xA; where TSelf : IBinaryInteger&lt;TSelf&gt;public interface class IBinaryInteger : IComparable&lt;TSelf&gt;, IEquatable&lt;TSelf&gt;, IParsable&lt;TSelf&gt;, ISpanParsable&lt;TSelf&gt;, IUtf8SpanParsable&lt;TSelf&gt;, System::Numerics::IAdditionOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::IAdditiveIdentity&lt;TSelf, TSelf&gt;, System::Numerics::IBinaryNumber&lt;TSelf&gt;, System::Numerics::IBitwiseOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::IComparisonOperators&lt;TSelf, TSelf, bool&gt;, System::Numerics::IDecrementOperators&lt;TSelf&gt;, System::Numerics::IDivisionOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::IEqualityOperators&lt;TSelf, TSelf, bool&gt;, System::Numerics::IIncrementOperators&lt;TSelf&gt;, System::Numerics::IModulusOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::IMultiplicativeIdentity&lt;TSelf, TSelf&gt;, System::Numerics::IMultiplyOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::INumber&lt;TSelf&gt;, System::Numerics::INumberBase&lt;TSelf&gt;, System::Numerics::IShiftOperators&lt;TSelf, int, TSelf&gt;, System::Numerics::ISubtractionOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::IUnaryNegationOperators&lt;TSelf, TSelf&gt;, System::Numerics::IUnaryPlusOperators&lt;TSelf, TSelf&gt;" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="F#" Value="type IBinaryInteger&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt; = interface&#xA;    interface IComparable&#xA;    interface IComparable&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IEquatable&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IFormattable&#xA;    interface IParsable&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface ISpanFormattable&#xA;    interface ISpanParsable&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IAdditionOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IAdditiveIdentity&lt;'Self, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IBinaryNumber&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IBitwiseOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IComparisonOperators&lt;'Self, 'Self, bool (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IEqualityOperators&lt;'Self, 'Self, bool (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IDecrementOperators&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IDivisionOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IIncrementOperators&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IModulusOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IMultiplicativeIdentity&lt;'Self, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IMultiplyOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface INumber&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface INumberBase&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IUtf8SpanFormattable&#xA;    interface IUtf8SpanParsable&lt;'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface ISubtractionOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IUnaryNegationOperators&lt;'Self, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IUnaryPlusOperators&lt;'Self, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;&#xA;    interface IShiftOperators&lt;'Self, int, 'Self (requires 'Self :&gt; IBinaryInteger&lt;'Self&gt; and 'Self :&gt; IBinaryInteger&lt;'Self&gt;)&gt;" FrameworkAlternate="net-9.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>9.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TSelf">
      <Constraints>
        <InterfaceName>System.Numerics.IBinaryInteger&lt;TSelf&gt;</InterfaceName>
      </Constraints>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
    </TypeParameter>
  </TypeParameters>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IParsable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ISpanFormattable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ISpanParsable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IAdditionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IAdditiveIdentity&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IBinaryNumber&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IBitwiseOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IComparisonOperators&lt;TSelf,TSelf,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IDecrementOperators&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IDivisionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IEqualityOperators&lt;TSelf,TOther,TResult&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IEqualityOperators&lt;TSelf,TSelf,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IIncrementOperators&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IModulusOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IMultiplyOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.INumber&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.INumberBase&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IShiftOperators&lt;TSelf,System.Int32,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.ISubtractionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IUnaryNegationOperators&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IUnaryPlusOperators&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-8.0;net-9.0">
      <InterfaceName>System.IUtf8SpanFormattable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-8.0;net-9.0">
      <InterfaceName>System.IUtf8SpanParsable&lt;TSelf&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="net-8.0;net-9.0">
      <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TSelf">The type that implements the interface.</typeparam>
    <summary>Defines an integer type that is represented in a base-2 format.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static virtual (TSelf Quotient, TSelf Remainder) DivRem (TSelf left, TSelf right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual valuetype System.ValueTuple`2&lt;!TSelf, !TSelf&gt; DivRem(!TSelf left, !TSelf right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IBinaryInteger`1.DivRem(`0,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Overrides Function DivRem (left As TSelf, right As TSelf) As ValueTuple(Of TSelf, TSelf)" />
      <MemberSignature Language="F#" Value="static member DivRem : 'Self * 'Self -&gt; ValueTuple&lt;'Self, 'Self (requires 'Self :&gt; System.Numerics.IBinaryInteger&lt;'Self&gt; and 'Self :&gt; System.Numerics.IBinaryInteger&lt;'Self&gt;)&gt;" Usage="System.Numerics.IBinaryInteger&lt;'Self (requires 'Self :&gt; System.Numerics.IBinaryInteger&lt;'Self&gt;)&gt;.DivRem (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static override ValueTuple&lt;TSelf, TSelf&gt; DivRem(TSelf left, TSelf right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;TSelf,TSelf&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-7.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Quotient", "Remainder" })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Quotient", "Remainder" })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="TSelf" />
        <Parameter Name="right" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="left">The value which <paramref name="right" /> divides.</param>
        <param name="right">The value which divides <paramref name="left" />.</param>
        <summary>Computes the quotient and remainder of two values.</summary>
        <returns>The quotient and remainder of <paramref name="left" /> divided by <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IBinaryInteger`1.GetByteCount" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount () As Integer" />
      <MemberSignature Language="F#" Value="abstract member GetByteCount : unit -&gt; int" Usage="iBinaryInteger.GetByteCount " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetByteCount();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the number of bytes that will be written as part of <see cref="M:System.Numerics.IBinaryInteger`1.TryWriteLittleEndian(System.Span{System.Byte},System.Int32@)" />.</summary>
        <returns>The number of bytes that will be written as part of <see cref="M:System.Numerics.IBinaryInteger`1.TryWriteLittleEndian(System.Span{System.Byte},System.Int32@)" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetShortestBitLength">
      <MemberSignature Language="C#" Value="public int GetShortestBitLength ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetShortestBitLength() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IBinaryInteger`1.GetShortestBitLength" />
      <MemberSignature Language="VB.NET" Value="Public Function GetShortestBitLength () As Integer" />
      <MemberSignature Language="F#" Value="abstract member GetShortestBitLength : unit -&gt; int" Usage="iBinaryInteger.GetShortestBitLength " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetShortestBitLength();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the length, in bits, of the shortest two's complement representation of the current value.</summary>
        <returns>The length, in bits, of the shortest two's complement representation of the current value.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LeadingZeroCount">
      <MemberSignature Language="C#" Value="public static virtual TSelf LeadingZeroCount (TSelf value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf LeadingZeroCount(!TSelf value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IBinaryInteger`1.LeadingZeroCount(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Overrides Function LeadingZeroCount (value As TSelf) As TSelf" />
      <MemberSignature Language="F#" Value="static member LeadingZeroCount : 'Self -&gt; 'Self" Usage="System.Numerics.IBinaryInteger&lt;'Self (requires 'Self :&gt; System.Numerics.IBinaryInteger&lt;'Self&gt;)&gt;.LeadingZeroCount value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static override TSelf LeadingZeroCount(TSelf value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="value">The value whose leading zero bits are to be counted.</param>
        <summary>Computes the number of leading zero bits in a value.</summary>
        <returns>The number of leading zero bits in <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PopCount">
      <MemberSignature Language="C#" Value="public static abstract TSelf PopCount (TSelf value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf PopCount(!TSelf value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IBinaryInteger`1.PopCount(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PopCount (value As TSelf) As TSelf" />
      <MemberSignature Language="F#" Value="static member PopCount : 'Self -&gt; 'Self" Usage="System.Numerics.IBinaryInteger&lt;'Self (requires 'Self :&gt; System.Numerics.IBinaryInteger&lt;'Self&gt;)&gt;.PopCount value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TSelf PopCount(TSelf value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="value">The value whose set bits are to be counted.</param>
        <summary>Computes the number of bits that are set in a value.</summary>
        <returns>The number of set bits in <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadBigEndian">
      <MemberSignature Language="C#" Value="public static virtual TSelf ReadBigEndian (byte[] source, bool isUnsigned);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf ReadBigEndian(unsigned int8[] source, bool isUnsigned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IBinaryInteger`1.ReadBigEndian(System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Overrides Function ReadBigEndian (source As Byte(), isUnsigned As Boolean) As TSelf" />
      <MemberSignature Language="F#" Value="static member ReadBigEndian : byte[] * bool -&gt; 'Self" Usage="System.Numerics.IBinaryInteger&lt;'Self (requires 'Self :&gt; System.Numerics.IBinaryInteger&lt;'Self&gt;)&gt;.ReadBigEndian (source, isUnsigned)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static override TSelf ReadBigEndian(cli::array &lt;System::Byte&gt; ^ source, bool isUnsigned);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Byte[]" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">The array from which the two's complement number should be read.</param>
        <param name="isUnsigned">
          <see langword="true" /> if <paramref name="source" /> represents an unsigned two's complement number; otherwise, <see langword="false" /> to indicate it represents a signed two's complement number.</param>
        <summary>Reads a two's complement number from a given array, in big-endian format, and converts it to an instance of the current type.</summary>
        <returns>The value read from <paramref name="source" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="source" /> is not representable by <typeparamref name="TSelf" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBigEndian">
      <MemberSignature Language="C#" Value="public static virtual TSelf ReadBigEndian (ReadOnlySpan&lt;byte&gt; source, bool isUnsigned);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf ReadBigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, bool isUnsigned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IBinaryInteger`1.ReadBigEndian(System.ReadOnlySpan{System.Byte},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Overrides Function ReadBigEndian (source As ReadOnlySpan(Of Byte), isUnsigned As Boolean) As TSelf" />
      <MemberSignature Language="F#" Value="static member ReadBigEndian : ReadOnlySpan&lt;byte&gt; * bool -&gt; 'Self" Usage="System.Numerics.IBinaryInteger&lt;'Self (requires 'Self :&gt; System.Numerics.IBinaryInteger&lt;'Self&gt;)&gt;.ReadBigEndian (source, isUnsigned)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static override TSelf ReadBigEndian(ReadOnlySpan&lt;System::Byte&gt; source, bool isUnsigned);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">The array from which the two's complement number should be read.</param>
        <param name="isUnsigned">
          <see langword="true" /> if <paramref name="source" /> represents an unsigned two's complement number; otherwise, <see langword="false" /> to indicate it represents a signed two's complement number.</param>
        <summary>Reads a two's complement number from a given span, in big-endian format, and converts it to an instance of the current type.</summary>
        <returns>The value read from <paramref name="source" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="source" /> is not representable by <typeparamref name="TSelf" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBigEndian">
      <MemberSignature Language="C#" Value="public static virtual TSelf ReadBigEndian (byte[] source, int startIndex, bool isUnsigned);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf ReadBigEndian(unsigned int8[] source, int32 startIndex, bool isUnsigned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IBinaryInteger`1.ReadBigEndian(System.Byte[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Overrides Function ReadBigEndian (source As Byte(), startIndex As Integer, isUnsigned As Boolean) As TSelf" />
      <MemberSignature Language="F#" Value="static member ReadBigEndian : byte[] * int * bool -&gt; 'Self" Usage="System.Numerics.IBinaryInteger&lt;'Self (requires 'Self :&gt; System.Numerics.IBinaryInteger&lt;'Self&gt;)&gt;.ReadBigEndian (source, startIndex, isUnsigned)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static override TSelf ReadBigEndian(cli::array &lt;System::Byte&gt; ^ source, int startIndex, bool isUnsigned);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Byte[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">The array from which the two's complement number should be read.</param>
        <param name="startIndex">The starting index from which the value should be read.</param>
        <param name="isUnsigned">
          <see langword="true" /> if <paramref name="source" /> represents an unsigned two's complement number; otherwise, <see langword="false" /> to indicate it represents a signed two's complement number.</param>
        <summary>Reads a two's complement number from a given array, in big-endian format, and converts it to an instance of the current type.</summary>
        <returns>The value read from <paramref name="source" /> starting at <paramref name="startIndex" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="source" /> is not representable by <typeparamref name="TSelf" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLittleEndian">
      <MemberSignature Language="C#" Value="public static virtual TSelf ReadLittleEndian (byte[] source, bool isUnsigned);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf ReadLittleEndian(unsigned int8[] source, bool isUnsigned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IBinaryInteger`1.ReadLittleEndian(System.Byte[],System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Overrides Function ReadLittleEndian (source As Byte(), isUnsigned As Boolean) As TSelf" />
      <MemberSignature Language="F#" Value="static member ReadLittleEndian : byte[] * bool -&gt; 'Self" Usage="System.Numerics.IBinaryInteger&lt;'Self (requires 'Self :&gt; System.Numerics.IBinaryInteger&lt;'Self&gt;)&gt;.ReadLittleEndian (source, isUnsigned)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static override TSelf ReadLittleEndian(cli::array &lt;System::Byte&gt; ^ source, bool isUnsigned);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Byte[]" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">The array from which the two's complement number should be read.</param>
        <param name="isUnsigned">
          <see langword="true" /> if <paramref name="source" /> represents an unsigned two's complement number; otherwise, <see langword="false" /> to indicate it represents a signed two's complement number.</param>
        <summary>Reads a two's complement number from a given array, in little-endian format, and converts it to an instance of the current type.</summary>
        <returns>The value read from <paramref name="source" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="source" /> is not representable by <typeparamref name="TSelf" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLittleEndian">
      <MemberSignature Language="C#" Value="public static virtual TSelf ReadLittleEndian (ReadOnlySpan&lt;byte&gt; source, bool isUnsigned);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf ReadLittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, bool isUnsigned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IBinaryInteger`1.ReadLittleEndian(System.ReadOnlySpan{System.Byte},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Overrides Function ReadLittleEndian (source As ReadOnlySpan(Of Byte), isUnsigned As Boolean) As TSelf" />
      <MemberSignature Language="F#" Value="static member ReadLittleEndian : ReadOnlySpan&lt;byte&gt; * bool -&gt; 'Self" Usage="System.Numerics.IBinaryInteger&lt;'Self (requires 'Self :&gt; System.Numerics.IBinaryInteger&lt;'Self&gt;)&gt;.ReadLittleEndian (source, isUnsigned)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static override TSelf ReadLittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, bool isUnsigned);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">The array from which the two's complement number should be read.</param>
        <param name="isUnsigned">
          <see langword="true" /> if <paramref name="source" /> represents an unsigned two's complement number; otherwise, <see langword="false" /> to indicate it represents a signed two's complement number.</param>
        <summary>Reads a two's complement number from a given span, in little-endian format, and converts it to an instance of the current type.</summary>
        <returns>The value read from <paramref name="source" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="source" /> is not representable by <typeparamref name="TSelf" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLittleEndian">
      <MemberSignature Language="C#" Value="public static virtual TSelf ReadLittleEndian (byte[] source, int startIndex, bool isUnsigned);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf ReadLittleEndian(unsigned int8[] source, int32 startIndex, bool isUnsigned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IBinaryInteger`1.ReadLittleEndian(System.Byte[],System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Overrides Function ReadLittleEndian (source As Byte(), startIndex As Integer, isUnsigned As Boolean) As TSelf" />
      <MemberSignature Language="F#" Value="static member ReadLittleEndian : byte[] * int * bool -&gt; 'Self" Usage="System.Numerics.IBinaryInteger&lt;'Self (requires 'Self :&gt; System.Numerics.IBinaryInteger&lt;'Self&gt;)&gt;.ReadLittleEndian (source, startIndex, isUnsigned)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static override TSelf ReadLittleEndian(cli::array &lt;System::Byte&gt; ^ source, int startIndex, bool isUnsigned);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Byte[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">The array from which the two's complement number should be read.</param>
        <param name="startIndex">The starting index from which the value should be read.</param>
        <param name="isUnsigned">
          <see langword="true" /> if <paramref name="source" /> represents an unsigned two's complement number; otherwise, <see langword="false" /> to indicate it represents a signed two's complement number.</param>
        <summary>Reads a two's complement number from a given array, in little-endian format, and converts it to an instance of the current type.</summary>
        <returns>The value read from <paramref name="source" /> starting at <paramref name="startIndex" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="source" /> is not representable by <typeparamref name="TSelf" /></exception>
      </Docs>
    </Member>
    <Member MemberName="RotateLeft">
      <MemberSignature Language="C#" Value="public static virtual TSelf RotateLeft (TSelf value, int rotateAmount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf RotateLeft(!TSelf value, int32 rotateAmount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IBinaryInteger`1.RotateLeft(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Overrides Function RotateLeft (value As TSelf, rotateAmount As Integer) As TSelf" />
      <MemberSignature Language="F#" Value="static member RotateLeft : 'Self * int -&gt; 'Self" Usage="System.Numerics.IBinaryInteger&lt;'Self (requires 'Self :&gt; System.Numerics.IBinaryInteger&lt;'Self&gt;)&gt;.RotateLeft (value, rotateAmount)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static override TSelf RotateLeft(TSelf value, int rotateAmount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
        <Parameter Name="rotateAmount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The value which is rotated left by <paramref name="rotateAmount" />.</param>
        <param name="rotateAmount">The amount by which <paramref name="value" /> is rotated left.</param>
        <summary>Rotates a value left by a given amount.</summary>
        <returns>The result of rotating <paramref name="value" /> left by <paramref name="rotateAmount" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RotateRight">
      <MemberSignature Language="C#" Value="public static virtual TSelf RotateRight (TSelf value, int rotateAmount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf RotateRight(!TSelf value, int32 rotateAmount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IBinaryInteger`1.RotateRight(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Overrides Function RotateRight (value As TSelf, rotateAmount As Integer) As TSelf" />
      <MemberSignature Language="F#" Value="static member RotateRight : 'Self * int -&gt; 'Self" Usage="System.Numerics.IBinaryInteger&lt;'Self (requires 'Self :&gt; System.Numerics.IBinaryInteger&lt;'Self&gt;)&gt;.RotateRight (value, rotateAmount)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static override TSelf RotateRight(TSelf value, int rotateAmount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
        <Parameter Name="rotateAmount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The value which is rotated right by <paramref name="rotateAmount" />.</param>
        <param name="rotateAmount">The amount by which <paramref name="value" /> is rotated right.</param>
        <summary>Rotates a value right by a given amount.</summary>
        <returns>The result of rotating <paramref name="value" /> right by <paramref name="rotateAmount" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrailingZeroCount">
      <MemberSignature Language="C#" Value="public static abstract TSelf TrailingZeroCount (TSelf value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf TrailingZeroCount(!TSelf value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IBinaryInteger`1.TrailingZeroCount(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrailingZeroCount (value As TSelf) As TSelf" />
      <MemberSignature Language="F#" Value="static member TrailingZeroCount : 'Self -&gt; 'Self" Usage="System.Numerics.IBinaryInteger&lt;'Self (requires 'Self :&gt; System.Numerics.IBinaryInteger&lt;'Self&gt;)&gt;.TrailingZeroCount value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TSelf TrailingZeroCount(TSelf value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="value">The value whose trailing zero bits are to be counted.</param>
        <summary>Computes the number of trailing zero bits in a value.</summary>
        <returns>The number of trailing zero bits in <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadBigEndian">
      <MemberSignature Language="C#" Value="public static abstract bool TryReadBigEndian (ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out TSelf value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual bool TryReadBigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, bool isUnsigned, [out] !TSelf&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IBinaryInteger`1.TryReadBigEndian(System.ReadOnlySpan{System.Byte},System.Boolean,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadBigEndian (source As ReadOnlySpan(Of Byte), isUnsigned As Boolean, ByRef value As TSelf) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryReadBigEndian : ReadOnlySpan&lt;byte&gt; * bool * 'Self -&gt; bool" Usage="System.Numerics.IBinaryInteger&lt;'Self (requires 'Self :&gt; System.Numerics.IBinaryInteger&lt;'Self&gt;)&gt;.TryReadBigEndian (source, isUnsigned, value)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadBigEndian(ReadOnlySpan&lt;System::Byte&gt; source, bool isUnsigned, [Runtime::InteropServices::Out] TSelf % value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="value" Type="TSelf" RefType="out">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">The span from which the two's complement number should be read.</param>
        <param name="isUnsigned">
          <see langword="true" /> if <paramref name="source" /> represents an unsigned two's complement number; otherwise, <see langword="false" /> to indicate it represents a signed two's complement number.</param>
        <param name="value">On return, contains the value read from <paramref name="source" /> or <see langword="default" /> if a value could not be read.</param>
        <summary>Tries to read a two's complement number from a span, in big-endian format, and convert it to an instance of the current type.</summary>
        <returns>
          <see langword="true" /> if the value was successfully read from <paramref name="source" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReadLittleEndian">
      <MemberSignature Language="C#" Value="public static abstract bool TryReadLittleEndian (ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out TSelf value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual bool TryReadLittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, bool isUnsigned, [out] !TSelf&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IBinaryInteger`1.TryReadLittleEndian(System.ReadOnlySpan{System.Byte},System.Boolean,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryReadLittleEndian (source As ReadOnlySpan(Of Byte), isUnsigned As Boolean, ByRef value As TSelf) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryReadLittleEndian : ReadOnlySpan&lt;byte&gt; * bool * 'Self -&gt; bool" Usage="System.Numerics.IBinaryInteger&lt;'Self (requires 'Self :&gt; System.Numerics.IBinaryInteger&lt;'Self&gt;)&gt;.TryReadLittleEndian (source, isUnsigned, value)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryReadLittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, bool isUnsigned, [Runtime::InteropServices::Out] TSelf % value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="value" Type="TSelf" RefType="out">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(1)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(1)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="source">The span from which the two's complement number should be read.</param>
        <param name="isUnsigned">
          <see langword="true" /> if <paramref name="source" /> represents an unsigned two's complement number; otherwise, <see langword="false" /> to indicate it represents a signed two's complement number.</param>
        <param name="value">On return, contains the value read from <paramref name="source" /> or <see langword="default" /> if a value could not be read.</param>
        <summary>Tries to read a two's complement number from a span, in little-endian format, and convert it to an instance of the current type.</summary>
        <returns>
          <see langword="true" /> if the value was successfully read from <paramref name="source" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteBigEndian">
      <MemberSignature Language="C#" Value="public bool TryWriteBigEndian (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryWriteBigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IBinaryInteger`1.TryWriteBigEndian(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteBigEndian (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member TryWriteBigEndian : Span&lt;byte&gt; * int -&gt; bool" Usage="iBinaryInteger.TryWriteBigEndian (destination, bytesWritten)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryWriteBigEndian(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination">The span to which the current value should be written.</param>
        <param name="bytesWritten">When this method returns, contains the number of bytes written to <paramref name="destination" />.</param>
        <summary>Tries to write the current value, in big-endian format, to a given span.</summary>
        <returns>
          <see langword="true" /> if the value was successfully written to <paramref name="destination" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteLittleEndian">
      <MemberSignature Language="C#" Value="public bool TryWriteLittleEndian (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryWriteLittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IBinaryInteger`1.TryWriteLittleEndian(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteLittleEndian (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member TryWriteLittleEndian : Span&lt;byte&gt; * int -&gt; bool" Usage="iBinaryInteger.TryWriteLittleEndian (destination, bytesWritten)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryWriteLittleEndian(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination">The span to which the current value should be written.</param>
        <param name="bytesWritten">When this method returns, contains the number of bytes written to <paramref name="destination" />.</param>
        <summary>Tries to write the current value, in little-endian format, to a given span.</summary>
        <returns>
          <see langword="true" /> if the value was successfully written to <paramref name="destination" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteBigEndian">
      <MemberSignature Language="C#" Value="public virtual int WriteBigEndian (byte[] destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 WriteBigEndian(unsigned int8[] destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IBinaryInteger`1.WriteBigEndian(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteBigEndian (destination As Byte()) As Integer" />
      <MemberSignature Language="F#" Value="abstract member WriteBigEndian : byte[] -&gt; int&#xA;override this.WriteBigEndian : byte[] -&gt; int" Usage="iBinaryInteger.WriteBigEndian destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int WriteBigEndian(cli::array &lt;System::Byte&gt; ^ destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="destination">The array to which the current value should be written.</param>
        <summary>Writes the current value, in big-endian format, to a given array.</summary>
        <returns>The number of bytes written to <paramref name="destination" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteBigEndian">
      <MemberSignature Language="C#" Value="public virtual int WriteBigEndian (Span&lt;byte&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 WriteBigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IBinaryInteger`1.WriteBigEndian(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteBigEndian (destination As Span(Of Byte)) As Integer" />
      <MemberSignature Language="F#" Value="abstract member WriteBigEndian : Span&lt;byte&gt; -&gt; int&#xA;override this.WriteBigEndian : Span&lt;byte&gt; -&gt; int" Usage="iBinaryInteger.WriteBigEndian destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int WriteBigEndian(Span&lt;System::Byte&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">The span to which the current value should be written.</param>
        <summary>Writes the current value, in big-endian format, to a given span.</summary>
        <returns>The number of bytes written to <paramref name="destination" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteBigEndian">
      <MemberSignature Language="C#" Value="public virtual int WriteBigEndian (byte[] destination, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 WriteBigEndian(unsigned int8[] destination, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IBinaryInteger`1.WriteBigEndian(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteBigEndian (destination As Byte(), startIndex As Integer) As Integer" />
      <MemberSignature Language="F#" Value="abstract member WriteBigEndian : byte[] * int -&gt; int&#xA;override this.WriteBigEndian : byte[] * int -&gt; int" Usage="iBinaryInteger.WriteBigEndian (destination, startIndex)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int WriteBigEndian(cli::array &lt;System::Byte&gt; ^ destination, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Byte[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination">The array to which the current value should be written.</param>
        <param name="startIndex">The starting index at which the value should be written.</param>
        <summary>Writes the current value, in big-endian format, to a given array.</summary>
        <returns>The number of bytes written to <paramref name="destination" /> starting at <paramref name="startIndex" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteLittleEndian">
      <MemberSignature Language="C#" Value="public virtual int WriteLittleEndian (byte[] destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 WriteLittleEndian(unsigned int8[] destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IBinaryInteger`1.WriteLittleEndian(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteLittleEndian (destination As Byte()) As Integer" />
      <MemberSignature Language="F#" Value="abstract member WriteLittleEndian : byte[] -&gt; int&#xA;override this.WriteLittleEndian : byte[] -&gt; int" Usage="iBinaryInteger.WriteLittleEndian destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int WriteLittleEndian(cli::array &lt;System::Byte&gt; ^ destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="destination">The array to which the current value should be written.</param>
        <summary>Writes the current value, in little-endian format, to a given array.</summary>
        <returns>The number of bytes written to <paramref name="destination" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteLittleEndian">
      <MemberSignature Language="C#" Value="public virtual int WriteLittleEndian (Span&lt;byte&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 WriteLittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IBinaryInteger`1.WriteLittleEndian(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteLittleEndian (destination As Span(Of Byte)) As Integer" />
      <MemberSignature Language="F#" Value="abstract member WriteLittleEndian : Span&lt;byte&gt; -&gt; int&#xA;override this.WriteLittleEndian : Span&lt;byte&gt; -&gt; int" Usage="iBinaryInteger.WriteLittleEndian destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int WriteLittleEndian(Span&lt;System::Byte&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">The span to which the current value should be written.</param>
        <summary>Writes the current value, in little-endian format, to a given span.</summary>
        <returns>The number of bytes written to <paramref name="destination" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteLittleEndian">
      <MemberSignature Language="C#" Value="public virtual int WriteLittleEndian (byte[] destination, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 WriteLittleEndian(unsigned int8[] destination, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IBinaryInteger`1.WriteLittleEndian(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteLittleEndian (destination As Byte(), startIndex As Integer) As Integer" />
      <MemberSignature Language="F#" Value="abstract member WriteLittleEndian : byte[] * int -&gt; int&#xA;override this.WriteLittleEndian : byte[] * int -&gt; int" Usage="iBinaryInteger.WriteLittleEndian (destination, startIndex)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int WriteLittleEndian(cli::array &lt;System::Byte&gt; ^ destination, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Byte[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination">The array to which the current value should be written.</param>
        <param name="startIndex">The starting index at which the value should be written.</param>
        <summary>Writes the current value, in little-endian format, to a specified array starting at a specified index.</summary>
        <returns>The number of bytes written to <paramref name="destination" /> starting at <paramref name="startIndex" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
