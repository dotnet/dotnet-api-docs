<Type Name="IFloatingPoint&lt;TSelf&gt;" FullName="System.Numerics.IFloatingPoint&lt;TSelf&gt;">
  <TypeSignature Language="C#" Value="public interface IFloatingPoint&lt;TSelf&gt; : IComparable&lt;TSelf&gt;, IEquatable&lt;TSelf&gt;, IParsable&lt;TSelf&gt;, ISpanParsable&lt;TSelf&gt;, System.Numerics.IAdditionOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.IAdditiveIdentity&lt;TSelf,TSelf&gt;, System.Numerics.IComparisonOperators&lt;TSelf,TSelf,bool&gt;, System.Numerics.IDecrementOperators&lt;TSelf&gt;, System.Numerics.IDivisionOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.IEqualityOperators&lt;TSelf,TSelf,bool&gt;, System.Numerics.IFloatingPointConstants&lt;TSelf&gt;, System.Numerics.IIncrementOperators&lt;TSelf&gt;, System.Numerics.IModulusOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.IMultiplicativeIdentity&lt;TSelf,TSelf&gt;, System.Numerics.IMultiplyOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.INumber&lt;TSelf&gt;, System.Numerics.INumberBase&lt;TSelf&gt;, System.Numerics.ISignedNumber&lt;TSelf&gt;, System.Numerics.ISubtractionOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.IUnaryNegationOperators&lt;TSelf,TSelf&gt;, System.Numerics.IUnaryPlusOperators&lt;TSelf,TSelf&gt; where TSelf : IFloatingPoint&lt;TSelf&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IFloatingPoint`1&lt;(class System.Numerics.IFloatingPoint`1&lt;!TSelf&gt;) TSelf&gt; implements class System.IComparable, class System.IComparable`1&lt;!TSelf&gt;, class System.IEquatable`1&lt;!TSelf&gt;, class System.IFormattable, class System.IParsable`1&lt;!TSelf&gt;, class System.ISpanFormattable, class System.ISpanParsable`1&lt;!TSelf&gt;, class System.Numerics.IAdditionOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!TSelf, !TSelf&gt;, class System.Numerics.IComparisonOperators`3&lt;!TSelf, !TSelf, bool&gt;, class System.Numerics.IDecrementOperators`1&lt;!TSelf&gt;, class System.Numerics.IDivisionOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.IEqualityOperators`3&lt;!TSelf, !TSelf, bool&gt;, class System.Numerics.IFloatingPointConstants`1&lt;!TSelf&gt;, class System.Numerics.IIncrementOperators`1&lt;!TSelf&gt;, class System.Numerics.IModulusOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!TSelf, !TSelf&gt;, class System.Numerics.IMultiplyOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.INumber`1&lt;!TSelf&gt;, class System.Numerics.INumberBase`1&lt;!TSelf&gt;, class System.Numerics.ISignedNumber`1&lt;!TSelf&gt;, class System.Numerics.ISubtractionOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.IUnaryNegationOperators`2&lt;!TSelf, !TSelf&gt;, class System.Numerics.IUnaryPlusOperators`2&lt;!TSelf, !TSelf&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.IFloatingPoint`1" />
  <TypeSignature Language="VB.NET" Value="Public Interface IFloatingPoint(Of TSelf)&#xA;Implements IAdditionOperators(Of TSelf, TSelf, TSelf), IAdditiveIdentity(Of TSelf, TSelf), IComparable(Of TSelf), IComparisonOperators(Of TSelf, TSelf, Boolean), IDecrementOperators(Of TSelf), IDivisionOperators(Of TSelf, TSelf, TSelf), IEqualityOperators(Of TSelf, TSelf, Boolean), IEquatable(Of TSelf), IFloatingPointConstants(Of TSelf), IIncrementOperators(Of TSelf), IModulusOperators(Of TSelf, TSelf, TSelf), IMultiplicativeIdentity(Of TSelf, TSelf), IMultiplyOperators(Of TSelf, TSelf, TSelf), INumber(Of TSelf), INumberBase(Of TSelf), IParsable(Of TSelf), ISignedNumber(Of TSelf), ISpanParsable(Of TSelf), ISubtractionOperators(Of TSelf, TSelf, TSelf), IUnaryNegationOperators(Of TSelf, TSelf), IUnaryPlusOperators(Of TSelf, TSelf)" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="F#" Value="type IFloatingPoint&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt; = interface&#xA;    interface IComparable&#xA;    interface IComparable&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IEquatable&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IFormattable&#xA;    interface IParsable&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface ISpanFormattable&#xA;    interface ISpanParsable&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IAdditionOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IAdditiveIdentity&lt;'Self, 'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IComparisonOperators&lt;'Self, 'Self, bool (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IEqualityOperators&lt;'Self, 'Self, bool (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IDecrementOperators&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IDivisionOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IFloatingPointConstants&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface INumberBase&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IIncrementOperators&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IMultiplicativeIdentity&lt;'Self, 'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IMultiplyOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface ISubtractionOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IUnaryNegationOperators&lt;'Self, 'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IUnaryPlusOperators&lt;'Self, 'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IModulusOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface INumber&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface ISignedNumber&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TSelf&gt;&#xA; where TSelf : IFloatingPoint&lt;TSelf&gt;public interface class IFloatingPoint : IComparable&lt;TSelf&gt;, IEquatable&lt;TSelf&gt;, IParsable&lt;TSelf&gt;, ISpanParsable&lt;TSelf&gt;, System::Numerics::IAdditionOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::IAdditiveIdentity&lt;TSelf, TSelf&gt;, System::Numerics::IComparisonOperators&lt;TSelf, TSelf, bool&gt;, System::Numerics::IDecrementOperators&lt;TSelf&gt;, System::Numerics::IDivisionOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::IEqualityOperators&lt;TSelf, TSelf, bool&gt;, System::Numerics::IFloatingPointConstants&lt;TSelf&gt;, System::Numerics::IIncrementOperators&lt;TSelf&gt;, System::Numerics::IModulusOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::IMultiplicativeIdentity&lt;TSelf, TSelf&gt;, System::Numerics::IMultiplyOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::INumber&lt;TSelf&gt;, System::Numerics::INumberBase&lt;TSelf&gt;, System::Numerics::ISignedNumber&lt;TSelf&gt;, System::Numerics::ISubtractionOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::IUnaryNegationOperators&lt;TSelf, TSelf&gt;, System::Numerics::IUnaryPlusOperators&lt;TSelf, TSelf&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="C#" Value="public interface IFloatingPoint&lt;TSelf&gt; : IComparable&lt;TSelf&gt;, IEquatable&lt;TSelf&gt;, IParsable&lt;TSelf&gt;, ISpanParsable&lt;TSelf&gt;, IUtf8SpanParsable&lt;TSelf&gt;, System.Numerics.IAdditionOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.IAdditiveIdentity&lt;TSelf,TSelf&gt;, System.Numerics.IComparisonOperators&lt;TSelf,TSelf,bool&gt;, System.Numerics.IDecrementOperators&lt;TSelf&gt;, System.Numerics.IDivisionOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.IEqualityOperators&lt;TSelf,TSelf,bool&gt;, System.Numerics.IFloatingPointConstants&lt;TSelf&gt;, System.Numerics.IIncrementOperators&lt;TSelf&gt;, System.Numerics.IModulusOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.IMultiplicativeIdentity&lt;TSelf,TSelf&gt;, System.Numerics.IMultiplyOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.INumber&lt;TSelf&gt;, System.Numerics.INumberBase&lt;TSelf&gt;, System.Numerics.ISignedNumber&lt;TSelf&gt;, System.Numerics.ISubtractionOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.IUnaryNegationOperators&lt;TSelf,TSelf&gt;, System.Numerics.IUnaryPlusOperators&lt;TSelf,TSelf&gt; where TSelf : IFloatingPoint&lt;TSelf&gt;" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract beforefieldinit IFloatingPoint`1&lt;(class System.Numerics.IFloatingPoint`1&lt;!TSelf&gt;) TSelf&gt; implements class System.IComparable, class System.IComparable`1&lt;!TSelf&gt;, class System.IEquatable`1&lt;!TSelf&gt;, class System.IFormattable, class System.IParsable`1&lt;!TSelf&gt;, class System.ISpanFormattable, class System.ISpanParsable`1&lt;!TSelf&gt;, class System.IUtf8SpanFormattable, class System.IUtf8SpanParsable`1&lt;!TSelf&gt;, class System.Numerics.IAdditionOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!TSelf, !TSelf&gt;, class System.Numerics.IComparisonOperators`3&lt;!TSelf, !TSelf, bool&gt;, class System.Numerics.IDecrementOperators`1&lt;!TSelf&gt;, class System.Numerics.IDivisionOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.IEqualityOperators`3&lt;!TSelf, !TSelf, bool&gt;, class System.Numerics.IFloatingPointConstants`1&lt;!TSelf&gt;, class System.Numerics.IIncrementOperators`1&lt;!TSelf&gt;, class System.Numerics.IModulusOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!TSelf, !TSelf&gt;, class System.Numerics.IMultiplyOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.INumber`1&lt;!TSelf&gt;, class System.Numerics.INumberBase`1&lt;!TSelf&gt;, class System.Numerics.ISignedNumber`1&lt;!TSelf&gt;, class System.Numerics.ISubtractionOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.IUnaryNegationOperators`2&lt;!TSelf, !TSelf&gt;, class System.Numerics.IUnaryPlusOperators`2&lt;!TSelf, !TSelf&gt;" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="VB.NET" Value="Public Interface IFloatingPoint(Of TSelf)&#xA;Implements IAdditionOperators(Of TSelf, TSelf, TSelf), IAdditiveIdentity(Of TSelf, TSelf), IComparable(Of TSelf), IComparisonOperators(Of TSelf, TSelf, Boolean), IDecrementOperators(Of TSelf), IDivisionOperators(Of TSelf, TSelf, TSelf), IEqualityOperators(Of TSelf, TSelf, Boolean), IEquatable(Of TSelf), IFloatingPointConstants(Of TSelf), IIncrementOperators(Of TSelf), IModulusOperators(Of TSelf, TSelf, TSelf), IMultiplicativeIdentity(Of TSelf, TSelf), IMultiplyOperators(Of TSelf, TSelf, TSelf), INumber(Of TSelf), INumberBase(Of TSelf), IParsable(Of TSelf), ISignedNumber(Of TSelf), ISpanParsable(Of TSelf), ISubtractionOperators(Of TSelf, TSelf, TSelf), IUnaryNegationOperators(Of TSelf, TSelf), IUnaryPlusOperators(Of TSelf, TSelf), IUtf8SpanParsable(Of TSelf)" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="F#" Value="type IFloatingPoint&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt; = interface&#xA;    interface IComparable&#xA;    interface IComparable&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IEquatable&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IFormattable&#xA;    interface IParsable&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface ISpanFormattable&#xA;    interface ISpanParsable&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IAdditionOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IAdditiveIdentity&lt;'Self, 'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IComparisonOperators&lt;'Self, 'Self, bool (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IEqualityOperators&lt;'Self, 'Self, bool (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IDecrementOperators&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IDivisionOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IFloatingPointConstants&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface INumberBase&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IIncrementOperators&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IMultiplicativeIdentity&lt;'Self, 'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IMultiplyOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface ISubtractionOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IUnaryNegationOperators&lt;'Self, 'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IUnaryPlusOperators&lt;'Self, 'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IUtf8SpanFormattable&#xA;    interface IUtf8SpanParsable&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IModulusOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface INumber&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface ISignedNumber&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;" FrameworkAlternate="net-8.0" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TSelf&gt;&#xA; where TSelf : IFloatingPoint&lt;TSelf&gt;public interface class IFloatingPoint : IComparable&lt;TSelf&gt;, IEquatable&lt;TSelf&gt;, IParsable&lt;TSelf&gt;, ISpanParsable&lt;TSelf&gt;, IUtf8SpanParsable&lt;TSelf&gt;, System::Numerics::IAdditionOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::IAdditiveIdentity&lt;TSelf, TSelf&gt;, System::Numerics::IComparisonOperators&lt;TSelf, TSelf, bool&gt;, System::Numerics::IDecrementOperators&lt;TSelf&gt;, System::Numerics::IDivisionOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::IEqualityOperators&lt;TSelf, TSelf, bool&gt;, System::Numerics::IFloatingPointConstants&lt;TSelf&gt;, System::Numerics::IIncrementOperators&lt;TSelf&gt;, System::Numerics::IModulusOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::IMultiplicativeIdentity&lt;TSelf, TSelf&gt;, System::Numerics::IMultiplyOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::INumber&lt;TSelf&gt;, System::Numerics::INumberBase&lt;TSelf&gt;, System::Numerics::ISignedNumber&lt;TSelf&gt;, System::Numerics::ISubtractionOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::IUnaryNegationOperators&lt;TSelf, TSelf&gt;, System::Numerics::IUnaryPlusOperators&lt;TSelf, TSelf&gt;" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="F#" Value="type IFloatingPoint&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt; = interface&#xA;    interface IComparable&#xA;    interface IComparable&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IEquatable&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IFormattable&#xA;    interface IParsable&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface ISpanFormattable&#xA;    interface ISpanParsable&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IAdditionOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IAdditiveIdentity&lt;'Self, 'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IComparisonOperators&lt;'Self, 'Self, bool (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IEqualityOperators&lt;'Self, 'Self, bool (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IDecrementOperators&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IDivisionOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IFloatingPointConstants&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IUtf8SpanFormattable&#xA;    interface IUtf8SpanParsable&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IIncrementOperators&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IMultiplicativeIdentity&lt;'Self, 'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IMultiplyOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface INumberBase&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface ISubtractionOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IUnaryNegationOperators&lt;'Self, 'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IUnaryPlusOperators&lt;'Self, 'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface IModulusOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt; and 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface INumber&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;&#xA;    interface ISignedNumber&lt;'Self (requires 'Self :&gt; IFloatingPoint&lt;'Self&gt;)&gt;" FrameworkAlternate="net-9.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>9.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TSelf">
      <Constraints>
        <InterfaceName>System.Numerics.IFloatingPoint&lt;TSelf&gt;</InterfaceName>
      </Constraints>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
    </TypeParameter>
  </TypeParameters>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IParsable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ISpanFormattable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ISpanParsable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IAdditionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IAdditiveIdentity&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IComparisonOperators&lt;TSelf,TSelf,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IDecrementOperators&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IDivisionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IEqualityOperators&lt;TSelf,TOther,TResult&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IEqualityOperators&lt;TSelf,TSelf,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IFloatingPointConstants&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IIncrementOperators&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IModulusOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IMultiplyOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.INumber&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.INumberBase&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.ISignedNumber&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.ISubtractionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IUnaryNegationOperators&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IUnaryPlusOperators&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-8.0;net-9.0">
      <InterfaceName>System.IUtf8SpanFormattable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-8.0;net-9.0">
      <InterfaceName>System.IUtf8SpanParsable&lt;TSelf&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="net-8.0;net-9.0">
      <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TSelf">The type that implements the interface.</typeparam>
    <summary>Defines a floating-point type.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Ceiling">
      <MemberSignature Language="C#" Value="public static virtual TSelf Ceiling (TSelf x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf Ceiling(!TSelf x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IFloatingPoint`1.Ceiling(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Overrides Function Ceiling (x As TSelf) As TSelf" />
      <MemberSignature Language="F#" Value="static member Ceiling : 'Self -&gt; 'Self" Usage="System.Numerics.IFloatingPoint&lt;'Self (requires 'Self :&gt; System.Numerics.IFloatingPoint&lt;'Self&gt;)&gt;.Ceiling x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static override TSelf Ceiling(TSelf x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="x">The value whose ceiling is to be computed.</param>
        <summary>Computes the ceiling of a value.</summary>
        <returns>The ceiling of <paramref name="x" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertToInteger&lt;TInteger&gt;">
      <MemberSignature Language="C#" Value="public static virtual TInteger ConvertToInteger&lt;TInteger&gt; (TSelf value) where TInteger : System.Numerics.IBinaryInteger&lt;TInteger&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !!TInteger ConvertToInteger&lt;(class System.Numerics.IBinaryInteger`1&lt;!!TInteger&gt;) TInteger&gt;(!TSelf value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IFloatingPoint`1.ConvertToInteger``1(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Overrides Function ConvertToInteger(Of TInteger As IBinaryInteger(Of TInteger)) (value As TSelf) As TInteger" />
      <MemberSignature Language="F#" Value="static member ConvertToInteger : 'Self -&gt; 'Integer (requires 'Integer :&gt; System.Numerics.IBinaryInteger&lt;'Integer&gt;)" Usage="System.Numerics.IFloatingPoint&lt;'Self (requires 'Self :&gt; System.Numerics.IFloatingPoint&lt;'Self&gt;)&gt;.ConvertToInteger value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInteger&gt;&#xA; where TInteger : System::Numerics::IBinaryInteger&lt;TInteger&gt; static override TInteger ConvertToInteger(TSelf value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TInteger</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInteger">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;TInteger&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TSelf" Index="0" FrameworkAlternate="net-9.0" />
      </Parameters>
      <Docs>
        <typeparam name="TInteger">The integer type to which <paramref name="value" /> is converted.</typeparam>
        <param name="value">The value to be converted.</param>
        <summary>Converts a value to a specified integer type using saturation on overflow</summary>
        <returns>An instance of <typeparamref name="TInteger" /> created from <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertToIntegerNative&lt;TInteger&gt;">
      <MemberSignature Language="C#" Value="public static virtual TInteger ConvertToIntegerNative&lt;TInteger&gt; (TSelf value) where TInteger : System.Numerics.IBinaryInteger&lt;TInteger&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !!TInteger ConvertToIntegerNative&lt;(class System.Numerics.IBinaryInteger`1&lt;!!TInteger&gt;) TInteger&gt;(!TSelf value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IFloatingPoint`1.ConvertToIntegerNative``1(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Overrides Function ConvertToIntegerNative(Of TInteger As IBinaryInteger(Of TInteger)) (value As TSelf) As TInteger" />
      <MemberSignature Language="F#" Value="static member ConvertToIntegerNative : 'Self -&gt; 'Integer (requires 'Integer :&gt; System.Numerics.IBinaryInteger&lt;'Integer&gt;)" Usage="System.Numerics.IFloatingPoint&lt;'Self (requires 'Self :&gt; System.Numerics.IFloatingPoint&lt;'Self&gt;)&gt;.ConvertToIntegerNative value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInteger&gt;&#xA; where TInteger : System::Numerics::IBinaryInteger&lt;TInteger&gt; static override TInteger ConvertToIntegerNative(TSelf value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TInteger</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInteger">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
          <Constraints>
            <InterfaceName>System.Numerics.IBinaryInteger&lt;TInteger&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TSelf" Index="0" FrameworkAlternate="net-9.0" />
      </Parameters>
      <Docs>
        <typeparam name="TInteger">The integer type to which <paramref name="value" /> is converted.</typeparam>
        <param name="value">The value to be converted.</param>
        <summary>Converts a value to a specified integer type using platform specific behavior on overflow.</summary>
        <returns>An instance of <typeparamref name="TInteger" /> created from <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Floor">
      <MemberSignature Language="C#" Value="public static virtual TSelf Floor (TSelf x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf Floor(!TSelf x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IFloatingPoint`1.Floor(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Overrides Function Floor (x As TSelf) As TSelf" />
      <MemberSignature Language="F#" Value="static member Floor : 'Self -&gt; 'Self" Usage="System.Numerics.IFloatingPoint&lt;'Self (requires 'Self :&gt; System.Numerics.IFloatingPoint&lt;'Self&gt;)&gt;.Floor x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static override TSelf Floor(TSelf x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="x">The value whose floor is to be computed.</param>
        <summary>Computes the floor of a value.</summary>
        <returns>The floor of <paramref name="x" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExponentByteCount">
      <MemberSignature Language="C#" Value="public int GetExponentByteCount ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetExponentByteCount() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IFloatingPoint`1.GetExponentByteCount" />
      <MemberSignature Language="VB.NET" Value="Public Function GetExponentByteCount () As Integer" />
      <MemberSignature Language="F#" Value="abstract member GetExponentByteCount : unit -&gt; int" Usage="iFloatingPoint.GetExponentByteCount " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetExponentByteCount();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the number of bytes that will be written as part of <see cref="M:System.Numerics.IFloatingPoint`1.TryWriteExponentLittleEndian(System.Span{System.Byte},System.Int32@)" />.</summary>
        <returns>The number of bytes that will be written as part of <see cref="M:System.Numerics.IFloatingPoint`1.TryWriteExponentLittleEndian(System.Span{System.Byte},System.Int32@)" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExponentShortestBitLength">
      <MemberSignature Language="C#" Value="public int GetExponentShortestBitLength ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetExponentShortestBitLength() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IFloatingPoint`1.GetExponentShortestBitLength" />
      <MemberSignature Language="VB.NET" Value="Public Function GetExponentShortestBitLength () As Integer" />
      <MemberSignature Language="F#" Value="abstract member GetExponentShortestBitLength : unit -&gt; int" Usage="iFloatingPoint.GetExponentShortestBitLength " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetExponentShortestBitLength();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the length, in bits, of the shortest two's complement representation of the current exponent.</summary>
        <returns>The length, in bits, of the shortest two's complement representation of the current exponent.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSignificandBitLength">
      <MemberSignature Language="C#" Value="public int GetSignificandBitLength ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetSignificandBitLength() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IFloatingPoint`1.GetSignificandBitLength" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSignificandBitLength () As Integer" />
      <MemberSignature Language="F#" Value="abstract member GetSignificandBitLength : unit -&gt; int" Usage="iFloatingPoint.GetSignificandBitLength " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetSignificandBitLength();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the length, in bits, of the current significand.</summary>
        <returns>The length, in bits, of the current significand.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSignificandByteCount">
      <MemberSignature Language="C#" Value="public int GetSignificandByteCount ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetSignificandByteCount() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IFloatingPoint`1.GetSignificandByteCount" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSignificandByteCount () As Integer" />
      <MemberSignature Language="F#" Value="abstract member GetSignificandByteCount : unit -&gt; int" Usage="iFloatingPoint.GetSignificandByteCount " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetSignificandByteCount();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the number of bytes that will be written as part of <see cref="M:System.Numerics.IFloatingPoint`1.TryWriteSignificandLittleEndian(System.Span{System.Byte},System.Int32@)" />.</summary>
        <returns>The number of bytes that will be written as part of <see cref="M:System.Numerics.IFloatingPoint`1.TryWriteSignificandLittleEndian(System.Span{System.Byte},System.Int32@)" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static virtual TSelf Round (TSelf x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf Round(!TSelf x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IFloatingPoint`1.Round(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Overrides Function Round (x As TSelf) As TSelf" />
      <MemberSignature Language="F#" Value="static member Round : 'Self -&gt; 'Self" Usage="System.Numerics.IFloatingPoint&lt;'Self (requires 'Self :&gt; System.Numerics.IFloatingPoint&lt;'Self&gt;)&gt;.Round x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static override TSelf Round(TSelf x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="x">The value to round.</param>
        <summary>Rounds a value to the nearest integer using the default rounding mode (<see cref="F:System.MidpointRounding.ToEven" />).</summary>
        <returns>The result of rounding <paramref name="x" /> to the nearest integer using the default rounding mode.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static virtual TSelf Round (TSelf x, int digits);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf Round(!TSelf x, int32 digits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IFloatingPoint`1.Round(`0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Overrides Function Round (x As TSelf, digits As Integer) As TSelf" />
      <MemberSignature Language="F#" Value="static member Round : 'Self * int -&gt; 'Self" Usage="System.Numerics.IFloatingPoint&lt;'Self (requires 'Self :&gt; System.Numerics.IFloatingPoint&lt;'Self&gt;)&gt;.Round (x, digits)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static override TSelf Round(TSelf x, int digits);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="TSelf" />
        <Parameter Name="digits" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">The value to round.</param>
        <param name="digits">The number of fractional digits to which <paramref name="x" /> should be rounded.</param>
        <summary>Rounds a value to a specified number of fractional-digits using the default rounding mode (<see cref="F:System.MidpointRounding.ToEven" />).</summary>
        <returns>The result of rounding <paramref name="x" /> to <paramref name="digits" /> fractional-digits using the default rounding mode.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static virtual TSelf Round (TSelf x, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf Round(!TSelf x, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IFloatingPoint`1.Round(`0,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Overrides Function Round (x As TSelf, mode As MidpointRounding) As TSelf" />
      <MemberSignature Language="F#" Value="static member Round : 'Self * MidpointRounding -&gt; 'Self" Usage="System.Numerics.IFloatingPoint&lt;'Self (requires 'Self :&gt; System.Numerics.IFloatingPoint&lt;'Self&gt;)&gt;.Round (x, mode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static override TSelf Round(TSelf x, MidpointRounding mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="TSelf" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="x">The value to round.</param>
        <param name="mode">The mode under which <paramref name="x" /> should be rounded.</param>
        <summary>Rounds a value to the nearest integer using the specified rounding mode.</summary>
        <returns>The result of rounding <paramref name="x" /> to the nearest integer using <paramref name="mode" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static abstract TSelf Round (TSelf x, int digits, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf Round(!TSelf x, int32 digits, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IFloatingPoint`1.Round(`0,System.Int32,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (x As TSelf, digits As Integer, mode As MidpointRounding) As TSelf" />
      <MemberSignature Language="F#" Value="static member Round : 'Self * int * MidpointRounding -&gt; 'Self" Usage="System.Numerics.IFloatingPoint&lt;'Self (requires 'Self :&gt; System.Numerics.IFloatingPoint&lt;'Self&gt;)&gt;.Round (x, digits, mode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TSelf Round(TSelf x, int digits, MidpointRounding mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="TSelf" />
        <Parameter Name="digits" Type="System.Int32" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="x">The value to round.</param>
        <param name="digits">The number of fractional digits to which <paramref name="x" /> should be rounded.</param>
        <param name="mode">The mode under which <paramref name="x" /> should be rounded.</param>
        <summary>Rounds a value to a specified number of fractional digits using the specified rounding mode.</summary>
        <returns>The result of rounding <paramref name="x" /> to <paramref name="digits" /> fractional-digits using <paramref name="mode" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Truncate">
      <MemberSignature Language="C#" Value="public static virtual TSelf Truncate (TSelf x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf Truncate(!TSelf x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IFloatingPoint`1.Truncate(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Overrides Function Truncate (x As TSelf) As TSelf" />
      <MemberSignature Language="F#" Value="static member Truncate : 'Self -&gt; 'Self" Usage="System.Numerics.IFloatingPoint&lt;'Self (requires 'Self :&gt; System.Numerics.IFloatingPoint&lt;'Self&gt;)&gt;.Truncate x" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static override TSelf Truncate(TSelf x);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="x">The value to truncate.</param>
        <summary>Truncates a value.</summary>
        <returns>The truncation of <paramref name="x" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteExponentBigEndian">
      <MemberSignature Language="C#" Value="public bool TryWriteExponentBigEndian (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryWriteExponentBigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IFloatingPoint`1.TryWriteExponentBigEndian(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteExponentBigEndian (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member TryWriteExponentBigEndian : Span&lt;byte&gt; * int -&gt; bool" Usage="iFloatingPoint.TryWriteExponentBigEndian (destination, bytesWritten)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryWriteExponentBigEndian(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination">The span to which the current exponent should be written.</param>
        <param name="bytesWritten">When this method returns, contains the number of bytes written to <paramref name="destination" />.</param>
        <summary>Tries to write the current exponent, in big-endian format, to a given span.</summary>
        <returns>
          <see langword="true" /> if the exponent was succesfully written to <paramref name="destination" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteExponentLittleEndian">
      <MemberSignature Language="C#" Value="public bool TryWriteExponentLittleEndian (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryWriteExponentLittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IFloatingPoint`1.TryWriteExponentLittleEndian(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteExponentLittleEndian (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member TryWriteExponentLittleEndian : Span&lt;byte&gt; * int -&gt; bool" Usage="iFloatingPoint.TryWriteExponentLittleEndian (destination, bytesWritten)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryWriteExponentLittleEndian(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination">The span to which the current exponent should be written.</param>
        <param name="bytesWritten">When this method returns, contains the number of bytes written to <paramref name="destination" />.</param>
        <summary>Tries to write the current exponent, in little-endian format, to a given span.</summary>
        <returns>
          <see langword="true" /> if the exponent was succesfully written to <paramref name="destination" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteSignificandBigEndian">
      <MemberSignature Language="C#" Value="public bool TryWriteSignificandBigEndian (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryWriteSignificandBigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IFloatingPoint`1.TryWriteSignificandBigEndian(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteSignificandBigEndian (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member TryWriteSignificandBigEndian : Span&lt;byte&gt; * int -&gt; bool" Usage="iFloatingPoint.TryWriteSignificandBigEndian (destination, bytesWritten)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryWriteSignificandBigEndian(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination">The span to which the current significand should be written.</param>
        <param name="bytesWritten">When this method returns, contains the number of bytes written to <paramref name="destination" />.</param>
        <summary>Tries to write the current significand, in big-endian format, to a given span.</summary>
        <returns>
          <see langword="true" /> if the significand was succesfully written to <paramref name="destination" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryWriteSignificandLittleEndian">
      <MemberSignature Language="C#" Value="public bool TryWriteSignificandLittleEndian (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryWriteSignificandLittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IFloatingPoint`1.TryWriteSignificandLittleEndian(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteSignificandLittleEndian (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member TryWriteSignificandLittleEndian : Span&lt;byte&gt; * int -&gt; bool" Usage="iFloatingPoint.TryWriteSignificandLittleEndian (destination, bytesWritten)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryWriteSignificandLittleEndian(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="destination">The span to which the current significand should be written.</param>
        <param name="bytesWritten">When this method returns, contains the number of bytes written to <paramref name="destination" />.</param>
        <summary>Tries to write the current significand, in little-endian format, to a given span.</summary>
        <returns>
          <see langword="true" /> if the significand was succesfully written to <paramref name="destination" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteExponentBigEndian">
      <MemberSignature Language="C#" Value="public virtual int WriteExponentBigEndian (byte[] destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 WriteExponentBigEndian(unsigned int8[] destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IFloatingPoint`1.WriteExponentBigEndian(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteExponentBigEndian (destination As Byte()) As Integer" />
      <MemberSignature Language="F#" Value="abstract member WriteExponentBigEndian : byte[] -&gt; int&#xA;override this.WriteExponentBigEndian : byte[] -&gt; int" Usage="iFloatingPoint.WriteExponentBigEndian destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int WriteExponentBigEndian(cli::array &lt;System::Byte&gt; ^ destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="destination">The array to which the current exponent should be written.</param>
        <summary>Writes the current exponent, in big-endian format, to a given array.</summary>
        <returns>The number of bytes written to <paramref name="destination" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteExponentBigEndian">
      <MemberSignature Language="C#" Value="public virtual int WriteExponentBigEndian (Span&lt;byte&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 WriteExponentBigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IFloatingPoint`1.WriteExponentBigEndian(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteExponentBigEndian (destination As Span(Of Byte)) As Integer" />
      <MemberSignature Language="F#" Value="abstract member WriteExponentBigEndian : Span&lt;byte&gt; -&gt; int&#xA;override this.WriteExponentBigEndian : Span&lt;byte&gt; -&gt; int" Usage="iFloatingPoint.WriteExponentBigEndian destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int WriteExponentBigEndian(Span&lt;System::Byte&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">The span to which the current exponent should be written.</param>
        <summary>Writes the current exponent, in big-endian format, to a given span.</summary>
        <returns>The number of bytes written to <paramref name="destination" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteExponentBigEndian">
      <MemberSignature Language="C#" Value="public virtual int WriteExponentBigEndian (byte[] destination, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 WriteExponentBigEndian(unsigned int8[] destination, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IFloatingPoint`1.WriteExponentBigEndian(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteExponentBigEndian (destination As Byte(), startIndex As Integer) As Integer" />
      <MemberSignature Language="F#" Value="abstract member WriteExponentBigEndian : byte[] * int -&gt; int&#xA;override this.WriteExponentBigEndian : byte[] * int -&gt; int" Usage="iFloatingPoint.WriteExponentBigEndian (destination, startIndex)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int WriteExponentBigEndian(cli::array &lt;System::Byte&gt; ^ destination, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Byte[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination">The array to which the current exponent should be written.</param>
        <param name="startIndex">The starting index at which the exponent should be written.</param>
        <summary>Writes the current exponent, in big-endian format, to a given array.</summary>
        <returns>The number of bytes written to <paramref name="destination" /> starting at <paramref name="startIndex" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteExponentLittleEndian">
      <MemberSignature Language="C#" Value="public virtual int WriteExponentLittleEndian (byte[] destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 WriteExponentLittleEndian(unsigned int8[] destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IFloatingPoint`1.WriteExponentLittleEndian(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteExponentLittleEndian (destination As Byte()) As Integer" />
      <MemberSignature Language="F#" Value="abstract member WriteExponentLittleEndian : byte[] -&gt; int&#xA;override this.WriteExponentLittleEndian : byte[] -&gt; int" Usage="iFloatingPoint.WriteExponentLittleEndian destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int WriteExponentLittleEndian(cli::array &lt;System::Byte&gt; ^ destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="destination">The array to which the current exponent should be written.</param>
        <summary>Writes the current exponent, in little-endian format, to a given array.</summary>
        <returns>The number of bytes written to <paramref name="destination" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteExponentLittleEndian">
      <MemberSignature Language="C#" Value="public virtual int WriteExponentLittleEndian (Span&lt;byte&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 WriteExponentLittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IFloatingPoint`1.WriteExponentLittleEndian(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteExponentLittleEndian (destination As Span(Of Byte)) As Integer" />
      <MemberSignature Language="F#" Value="abstract member WriteExponentLittleEndian : Span&lt;byte&gt; -&gt; int&#xA;override this.WriteExponentLittleEndian : Span&lt;byte&gt; -&gt; int" Usage="iFloatingPoint.WriteExponentLittleEndian destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int WriteExponentLittleEndian(Span&lt;System::Byte&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">The span to which the current exponent should be written.</param>
        <summary>Writes the current exponent, in little-endian format, to a given span.</summary>
        <returns>The number of bytes written to <paramref name="destination" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteExponentLittleEndian">
      <MemberSignature Language="C#" Value="public virtual int WriteExponentLittleEndian (byte[] destination, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 WriteExponentLittleEndian(unsigned int8[] destination, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IFloatingPoint`1.WriteExponentLittleEndian(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteExponentLittleEndian (destination As Byte(), startIndex As Integer) As Integer" />
      <MemberSignature Language="F#" Value="abstract member WriteExponentLittleEndian : byte[] * int -&gt; int&#xA;override this.WriteExponentLittleEndian : byte[] * int -&gt; int" Usage="iFloatingPoint.WriteExponentLittleEndian (destination, startIndex)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int WriteExponentLittleEndian(cli::array &lt;System::Byte&gt; ^ destination, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Byte[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination">The array to which the current exponent should be written.</param>
        <param name="startIndex">The starting index at which the exponent should be written.</param>
        <summary>Writes the current exponent, in little-endian format, to a given array.</summary>
        <returns>The number of bytes written to <paramref name="destination" /> starting at <paramref name="startIndex" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteSignificandBigEndian">
      <MemberSignature Language="C#" Value="public virtual int WriteSignificandBigEndian (byte[] destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 WriteSignificandBigEndian(unsigned int8[] destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IFloatingPoint`1.WriteSignificandBigEndian(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteSignificandBigEndian (destination As Byte()) As Integer" />
      <MemberSignature Language="F#" Value="abstract member WriteSignificandBigEndian : byte[] -&gt; int&#xA;override this.WriteSignificandBigEndian : byte[] -&gt; int" Usage="iFloatingPoint.WriteSignificandBigEndian destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int WriteSignificandBigEndian(cli::array &lt;System::Byte&gt; ^ destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="destination">The array to which the current significand should be written.</param>
        <summary>Writes the current significand, in big-endian format, to a given array.</summary>
        <returns>The number of bytes written to <paramref name="destination" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteSignificandBigEndian">
      <MemberSignature Language="C#" Value="public virtual int WriteSignificandBigEndian (Span&lt;byte&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 WriteSignificandBigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IFloatingPoint`1.WriteSignificandBigEndian(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteSignificandBigEndian (destination As Span(Of Byte)) As Integer" />
      <MemberSignature Language="F#" Value="abstract member WriteSignificandBigEndian : Span&lt;byte&gt; -&gt; int&#xA;override this.WriteSignificandBigEndian : Span&lt;byte&gt; -&gt; int" Usage="iFloatingPoint.WriteSignificandBigEndian destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int WriteSignificandBigEndian(Span&lt;System::Byte&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">The span to which the current significand should be written.</param>
        <summary>Writes the current significand, in big-endian format, to a given span.</summary>
        <returns>The number of bytes written to <paramref name="destination" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteSignificandBigEndian">
      <MemberSignature Language="C#" Value="public virtual int WriteSignificandBigEndian (byte[] destination, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 WriteSignificandBigEndian(unsigned int8[] destination, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IFloatingPoint`1.WriteSignificandBigEndian(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteSignificandBigEndian (destination As Byte(), startIndex As Integer) As Integer" />
      <MemberSignature Language="F#" Value="abstract member WriteSignificandBigEndian : byte[] * int -&gt; int&#xA;override this.WriteSignificandBigEndian : byte[] * int -&gt; int" Usage="iFloatingPoint.WriteSignificandBigEndian (destination, startIndex)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int WriteSignificandBigEndian(cli::array &lt;System::Byte&gt; ^ destination, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Byte[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination">The array to which the current significand should be written.</param>
        <param name="startIndex">The starting index at which the significand should be written.</param>
        <summary>Writes the current significand, in big-endian format, to a given array.</summary>
        <returns>The number of bytes written to <paramref name="destination" /> starting at <paramref name="startIndex" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteSignificandLittleEndian">
      <MemberSignature Language="C#" Value="public virtual int WriteSignificandLittleEndian (byte[] destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 WriteSignificandLittleEndian(unsigned int8[] destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IFloatingPoint`1.WriteSignificandLittleEndian(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteSignificandLittleEndian (destination As Byte()) As Integer" />
      <MemberSignature Language="F#" Value="abstract member WriteSignificandLittleEndian : byte[] -&gt; int&#xA;override this.WriteSignificandLittleEndian : byte[] -&gt; int" Usage="iFloatingPoint.WriteSignificandLittleEndian destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int WriteSignificandLittleEndian(cli::array &lt;System::Byte&gt; ^ destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="destination">The array to which the current significand should be written.</param>
        <summary>Writes the current significand, in little-endian format, to a given array.</summary>
        <returns>The number of bytes written to <paramref name="destination" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteSignificandLittleEndian">
      <MemberSignature Language="C#" Value="public virtual int WriteSignificandLittleEndian (Span&lt;byte&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 WriteSignificandLittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IFloatingPoint`1.WriteSignificandLittleEndian(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteSignificandLittleEndian (destination As Span(Of Byte)) As Integer" />
      <MemberSignature Language="F#" Value="abstract member WriteSignificandLittleEndian : Span&lt;byte&gt; -&gt; int&#xA;override this.WriteSignificandLittleEndian : Span&lt;byte&gt; -&gt; int" Usage="iFloatingPoint.WriteSignificandLittleEndian destination" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int WriteSignificandLittleEndian(Span&lt;System::Byte&gt; destination);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(0)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(0)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">The span to which the current significand should be written.</param>
        <summary>Writes the current significand, in little-endian format, to a given span.</summary>
        <returns>The number of bytes written to <paramref name="destination" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteSignificandLittleEndian">
      <MemberSignature Language="C#" Value="public virtual int WriteSignificandLittleEndian (byte[] destination, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 WriteSignificandLittleEndian(unsigned int8[] destination, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.IFloatingPoint`1.WriteSignificandLittleEndian(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function WriteSignificandLittleEndian (destination As Byte(), startIndex As Integer) As Integer" />
      <MemberSignature Language="F#" Value="abstract member WriteSignificandLittleEndian : byte[] * int -&gt; int&#xA;override this.WriteSignificandLittleEndian : byte[] * int -&gt; int" Usage="iFloatingPoint.WriteSignificandLittleEndian (destination, startIndex)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int WriteSignificandLittleEndian(cli::array &lt;System::Byte&gt; ^ destination, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Byte[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination">The array to which the current significand should be written.</param>
        <param name="startIndex">The starting index at which the significand should be written.</param>
        <summary>Writes the current significand, in little-endian format, to a given array.</summary>
        <returns>The number of bytes written to <paramref name="destination" /> starting at <paramref name="startIndex" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
