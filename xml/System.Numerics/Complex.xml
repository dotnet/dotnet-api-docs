<Type Name="Complex" FullName="System.Numerics.Complex">
  <TypeSignature Language="C#" Value="public struct Complex : IEquatable&lt;System.Numerics.Complex&gt;, IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Complex extends System.ValueType implements class System.IEquatable`1&lt;valuetype System.Numerics.Complex&gt;, class System.IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Complex" />
  <TypeSignature Language="VB.NET" Value="Public Structure Complex&#xA;Implements IEquatable(Of Complex), IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="F#" Value="type Complex = struct&#xA;    interface IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="C++ CLI" Value="public value class Complex : IEquatable&lt;System::Numerics::Complex&gt;, IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="C#" Value="public readonly struct Complex : IEquatable&lt;System.Numerics.Complex&gt;, IFormattable" FrameworkAlternate="net-6.0" />
  <TypeSignature Language="C#" Value="public readonly struct Complex : IEquatable&lt;System.Numerics.Complex&gt;, IParsable&lt;System.Numerics.Complex&gt;, ISpanParsable&lt;System.Numerics.Complex&gt;, System.Numerics.IAdditionOperators&lt;System.Numerics.Complex,System.Numerics.Complex,System.Numerics.Complex&gt;, System.Numerics.IAdditiveIdentity&lt;System.Numerics.Complex,System.Numerics.Complex&gt;, System.Numerics.IDecrementOperators&lt;System.Numerics.Complex&gt;, System.Numerics.IDivisionOperators&lt;System.Numerics.Complex,System.Numerics.Complex,System.Numerics.Complex&gt;, System.Numerics.IEqualityOperators&lt;System.Numerics.Complex,System.Numerics.Complex,bool&gt;, System.Numerics.IIncrementOperators&lt;System.Numerics.Complex&gt;, System.Numerics.IMultiplicativeIdentity&lt;System.Numerics.Complex,System.Numerics.Complex&gt;, System.Numerics.IMultiplyOperators&lt;System.Numerics.Complex,System.Numerics.Complex,System.Numerics.Complex&gt;, System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;, System.Numerics.ISignedNumber&lt;System.Numerics.Complex&gt;, System.Numerics.ISubtractionOperators&lt;System.Numerics.Complex,System.Numerics.Complex,System.Numerics.Complex&gt;, System.Numerics.IUnaryNegationOperators&lt;System.Numerics.Complex,System.Numerics.Complex&gt;, System.Numerics.IUnaryPlusOperators&lt;System.Numerics.Complex,System.Numerics.Complex&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Complex extends System.ValueType implements class System.IEquatable`1&lt;valuetype System.Numerics.Complex&gt;, class System.IFormattable, class System.IParsable`1&lt;valuetype System.Numerics.Complex&gt;, class System.ISpanFormattable, class System.ISpanParsable`1&lt;valuetype System.Numerics.Complex&gt;, class System.Numerics.IAdditionOperators`3&lt;valuetype System.Numerics.Complex, valuetype System.Numerics.Complex, valuetype System.Numerics.Complex&gt;, class System.Numerics.IAdditiveIdentity`2&lt;valuetype System.Numerics.Complex, valuetype System.Numerics.Complex&gt;, class System.Numerics.IDecrementOperators`1&lt;valuetype System.Numerics.Complex&gt;, class System.Numerics.IDivisionOperators`3&lt;valuetype System.Numerics.Complex, valuetype System.Numerics.Complex, valuetype System.Numerics.Complex&gt;, class System.Numerics.IEqualityOperators`3&lt;valuetype System.Numerics.Complex, valuetype System.Numerics.Complex, bool&gt;, class System.Numerics.IIncrementOperators`1&lt;valuetype System.Numerics.Complex&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;valuetype System.Numerics.Complex, valuetype System.Numerics.Complex&gt;, class System.Numerics.IMultiplyOperators`3&lt;valuetype System.Numerics.Complex, valuetype System.Numerics.Complex, valuetype System.Numerics.Complex&gt;, class System.Numerics.INumberBase`1&lt;valuetype System.Numerics.Complex&gt;, class System.Numerics.ISignedNumber`1&lt;valuetype System.Numerics.Complex&gt;, class System.Numerics.ISubtractionOperators`3&lt;valuetype System.Numerics.Complex, valuetype System.Numerics.Complex, valuetype System.Numerics.Complex&gt;, class System.Numerics.IUnaryNegationOperators`2&lt;valuetype System.Numerics.Complex, valuetype System.Numerics.Complex&gt;, class System.Numerics.IUnaryPlusOperators`2&lt;valuetype System.Numerics.Complex, valuetype System.Numerics.Complex&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="VB.NET" Value="Public Structure Complex&#xA;Implements IAdditionOperators(Of Complex, Complex, Complex), IAdditiveIdentity(Of Complex, Complex), IDecrementOperators(Of Complex), IDivisionOperators(Of Complex, Complex, Complex), IEqualityOperators(Of Complex, Complex, Boolean), IEquatable(Of Complex), IIncrementOperators(Of Complex), IMultiplicativeIdentity(Of Complex, Complex), IMultiplyOperators(Of Complex, Complex, Complex), INumberBase(Of Complex), IParsable(Of Complex), ISignedNumber(Of Complex), ISpanParsable(Of Complex), ISubtractionOperators(Of Complex, Complex, Complex), IUnaryNegationOperators(Of Complex, Complex), IUnaryPlusOperators(Of Complex, Complex)" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="F#" Value="type Complex = struct&#xA;    interface IFormattable&#xA;    interface IParsable&lt;Complex&gt;&#xA;    interface ISpanFormattable&#xA;    interface ISpanParsable&lt;Complex&gt;&#xA;    interface IAdditionOperators&lt;Complex, Complex, Complex&gt;&#xA;    interface IAdditiveIdentity&lt;Complex, Complex&gt;&#xA;    interface IDecrementOperators&lt;Complex&gt;&#xA;    interface IDivisionOperators&lt;Complex, Complex, Complex&gt;&#xA;    interface IEqualityOperators&lt;Complex, Complex, bool&gt;&#xA;    interface IIncrementOperators&lt;Complex&gt;&#xA;    interface IMultiplicativeIdentity&lt;Complex, Complex&gt;&#xA;    interface IMultiplyOperators&lt;Complex, Complex, Complex&gt;&#xA;    interface INumberBase&lt;Complex&gt;&#xA;    interface ISubtractionOperators&lt;Complex, Complex, Complex&gt;&#xA;    interface IUnaryNegationOperators&lt;Complex, Complex&gt;&#xA;    interface IUnaryPlusOperators&lt;Complex, Complex&gt;&#xA;    interface ISignedNumber&lt;Complex&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="C++ CLI" Value="public value class Complex : IEquatable&lt;System::Numerics::Complex&gt;, IParsable&lt;System::Numerics::Complex&gt;, ISpanParsable&lt;System::Numerics::Complex&gt;, System::Numerics::IAdditionOperators&lt;System::Numerics::Complex, System::Numerics::Complex, System::Numerics::Complex&gt;, System::Numerics::IAdditiveIdentity&lt;System::Numerics::Complex, System::Numerics::Complex&gt;, System::Numerics::IDecrementOperators&lt;System::Numerics::Complex&gt;, System::Numerics::IDivisionOperators&lt;System::Numerics::Complex, System::Numerics::Complex, System::Numerics::Complex&gt;, System::Numerics::IEqualityOperators&lt;System::Numerics::Complex, System::Numerics::Complex, bool&gt;, System::Numerics::IIncrementOperators&lt;System::Numerics::Complex&gt;, System::Numerics::IMultiplicativeIdentity&lt;System::Numerics::Complex, System::Numerics::Complex&gt;, System::Numerics::IMultiplyOperators&lt;System::Numerics::Complex, System::Numerics::Complex, System::Numerics::Complex&gt;, System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;, System::Numerics::ISignedNumber&lt;System::Numerics::Complex&gt;, System::Numerics::ISubtractionOperators&lt;System::Numerics::Complex, System::Numerics::Complex, System::Numerics::Complex&gt;, System::Numerics::IUnaryNegationOperators&lt;System::Numerics::Complex, System::Numerics::Complex&gt;, System::Numerics::IUnaryPlusOperators&lt;System::Numerics::Complex, System::Numerics::Complex&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="C#" Value="public readonly struct Complex : IEquatable&lt;System.Numerics.Complex&gt;, IParsable&lt;System.Numerics.Complex&gt;, ISpanParsable&lt;System.Numerics.Complex&gt;, IUtf8SpanParsable&lt;System.Numerics.Complex&gt;, System.Numerics.IAdditionOperators&lt;System.Numerics.Complex,System.Numerics.Complex,System.Numerics.Complex&gt;, System.Numerics.IAdditiveIdentity&lt;System.Numerics.Complex,System.Numerics.Complex&gt;, System.Numerics.IDecrementOperators&lt;System.Numerics.Complex&gt;, System.Numerics.IDivisionOperators&lt;System.Numerics.Complex,System.Numerics.Complex,System.Numerics.Complex&gt;, System.Numerics.IEqualityOperators&lt;System.Numerics.Complex,System.Numerics.Complex,bool&gt;, System.Numerics.IIncrementOperators&lt;System.Numerics.Complex&gt;, System.Numerics.IMultiplicativeIdentity&lt;System.Numerics.Complex,System.Numerics.Complex&gt;, System.Numerics.IMultiplyOperators&lt;System.Numerics.Complex,System.Numerics.Complex,System.Numerics.Complex&gt;, System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;, System.Numerics.ISignedNumber&lt;System.Numerics.Complex&gt;, System.Numerics.ISubtractionOperators&lt;System.Numerics.Complex,System.Numerics.Complex,System.Numerics.Complex&gt;, System.Numerics.IUnaryNegationOperators&lt;System.Numerics.Complex,System.Numerics.Complex&gt;, System.Numerics.IUnaryPlusOperators&lt;System.Numerics.Complex,System.Numerics.Complex&gt;" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Complex extends System.ValueType implements class System.IEquatable`1&lt;valuetype System.Numerics.Complex&gt;, class System.IFormattable, class System.IParsable`1&lt;valuetype System.Numerics.Complex&gt;, class System.ISpanFormattable, class System.ISpanParsable`1&lt;valuetype System.Numerics.Complex&gt;, class System.IUtf8SpanFormattable, class System.IUtf8SpanParsable`1&lt;valuetype System.Numerics.Complex&gt;, class System.Numerics.IAdditionOperators`3&lt;valuetype System.Numerics.Complex, valuetype System.Numerics.Complex, valuetype System.Numerics.Complex&gt;, class System.Numerics.IAdditiveIdentity`2&lt;valuetype System.Numerics.Complex, valuetype System.Numerics.Complex&gt;, class System.Numerics.IDecrementOperators`1&lt;valuetype System.Numerics.Complex&gt;, class System.Numerics.IDivisionOperators`3&lt;valuetype System.Numerics.Complex, valuetype System.Numerics.Complex, valuetype System.Numerics.Complex&gt;, class System.Numerics.IEqualityOperators`3&lt;valuetype System.Numerics.Complex, valuetype System.Numerics.Complex, bool&gt;, class System.Numerics.IIncrementOperators`1&lt;valuetype System.Numerics.Complex&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;valuetype System.Numerics.Complex, valuetype System.Numerics.Complex&gt;, class System.Numerics.IMultiplyOperators`3&lt;valuetype System.Numerics.Complex, valuetype System.Numerics.Complex, valuetype System.Numerics.Complex&gt;, class System.Numerics.INumberBase`1&lt;valuetype System.Numerics.Complex&gt;, class System.Numerics.ISignedNumber`1&lt;valuetype System.Numerics.Complex&gt;, class System.Numerics.ISubtractionOperators`3&lt;valuetype System.Numerics.Complex, valuetype System.Numerics.Complex, valuetype System.Numerics.Complex&gt;, class System.Numerics.IUnaryNegationOperators`2&lt;valuetype System.Numerics.Complex, valuetype System.Numerics.Complex&gt;, class System.Numerics.IUnaryPlusOperators`2&lt;valuetype System.Numerics.Complex, valuetype System.Numerics.Complex&gt;" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="VB.NET" Value="Public Structure Complex&#xA;Implements IAdditionOperators(Of Complex, Complex, Complex), IAdditiveIdentity(Of Complex, Complex), IDecrementOperators(Of Complex), IDivisionOperators(Of Complex, Complex, Complex), IEqualityOperators(Of Complex, Complex, Boolean), IEquatable(Of Complex), IIncrementOperators(Of Complex), IMultiplicativeIdentity(Of Complex, Complex), IMultiplyOperators(Of Complex, Complex, Complex), INumberBase(Of Complex), IParsable(Of Complex), ISignedNumber(Of Complex), ISpanParsable(Of Complex), ISubtractionOperators(Of Complex, Complex, Complex), IUnaryNegationOperators(Of Complex, Complex), IUnaryPlusOperators(Of Complex, Complex), IUtf8SpanParsable(Of Complex)" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="F#" Value="type Complex = struct&#xA;    interface IFormattable&#xA;    interface IParsable&lt;Complex&gt;&#xA;    interface ISpanFormattable&#xA;    interface ISpanParsable&lt;Complex&gt;&#xA;    interface IAdditionOperators&lt;Complex, Complex, Complex&gt;&#xA;    interface IAdditiveIdentity&lt;Complex, Complex&gt;&#xA;    interface IDecrementOperators&lt;Complex&gt;&#xA;    interface IDivisionOperators&lt;Complex, Complex, Complex&gt;&#xA;    interface IEqualityOperators&lt;Complex, Complex, bool&gt;&#xA;    interface IIncrementOperators&lt;Complex&gt;&#xA;    interface IMultiplicativeIdentity&lt;Complex, Complex&gt;&#xA;    interface IMultiplyOperators&lt;Complex, Complex, Complex&gt;&#xA;    interface INumberBase&lt;Complex&gt;&#xA;    interface ISubtractionOperators&lt;Complex, Complex, Complex&gt;&#xA;    interface IUnaryNegationOperators&lt;Complex, Complex&gt;&#xA;    interface IUnaryPlusOperators&lt;Complex, Complex&gt;&#xA;    interface IUtf8SpanFormattable&#xA;    interface IUtf8SpanParsable&lt;Complex&gt;&#xA;    interface ISignedNumber&lt;Complex&gt;" FrameworkAlternate="net-8.0" />
  <TypeSignature Language="C++ CLI" Value="public value class Complex : IEquatable&lt;System::Numerics::Complex&gt;, IParsable&lt;System::Numerics::Complex&gt;, ISpanParsable&lt;System::Numerics::Complex&gt;, IUtf8SpanParsable&lt;System::Numerics::Complex&gt;, System::Numerics::IAdditionOperators&lt;System::Numerics::Complex, System::Numerics::Complex, System::Numerics::Complex&gt;, System::Numerics::IAdditiveIdentity&lt;System::Numerics::Complex, System::Numerics::Complex&gt;, System::Numerics::IDecrementOperators&lt;System::Numerics::Complex&gt;, System::Numerics::IDivisionOperators&lt;System::Numerics::Complex, System::Numerics::Complex, System::Numerics::Complex&gt;, System::Numerics::IEqualityOperators&lt;System::Numerics::Complex, System::Numerics::Complex, bool&gt;, System::Numerics::IIncrementOperators&lt;System::Numerics::Complex&gt;, System::Numerics::IMultiplicativeIdentity&lt;System::Numerics::Complex, System::Numerics::Complex&gt;, System::Numerics::IMultiplyOperators&lt;System::Numerics::Complex, System::Numerics::Complex, System::Numerics::Complex&gt;, System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;, System::Numerics::ISignedNumber&lt;System::Numerics::Complex&gt;, System::Numerics::ISubtractionOperators&lt;System::Numerics::Complex, System::Numerics::Complex, System::Numerics::Complex&gt;, System::Numerics::IUnaryNegationOperators&lt;System::Numerics::Complex, System::Numerics::Complex&gt;, System::Numerics::IUnaryPlusOperators&lt;System::Numerics::Complex, System::Numerics::Complex&gt;" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="F#" Value="type Complex = struct&#xA;    interface IFormattable&#xA;    interface IParsable&lt;Complex&gt;&#xA;    interface ISpanFormattable&#xA;    interface ISpanParsable&lt;Complex&gt;&#xA;    interface IAdditionOperators&lt;Complex, Complex, Complex&gt;&#xA;    interface IAdditiveIdentity&lt;Complex, Complex&gt;&#xA;    interface IDecrementOperators&lt;Complex&gt;&#xA;    interface IDivisionOperators&lt;Complex, Complex, Complex&gt;&#xA;    interface IEqualityOperators&lt;Complex, Complex, bool&gt;&#xA;    interface IIncrementOperators&lt;Complex&gt;&#xA;    interface IMultiplicativeIdentity&lt;Complex, Complex&gt;&#xA;    interface IMultiplyOperators&lt;Complex, Complex, Complex&gt;&#xA;    interface INumberBase&lt;Complex&gt;&#xA;    interface IUtf8SpanFormattable&#xA;    interface IUtf8SpanParsable&lt;Complex&gt;&#xA;    interface ISubtractionOperators&lt;Complex, Complex, Complex&gt;&#xA;    interface IUnaryNegationOperators&lt;Complex, Complex&gt;&#xA;    interface IUnaryPlusOperators&lt;Complex, Complex&gt;&#xA;    interface ISignedNumber&lt;Complex&gt;" FrameworkAlternate="net-9.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Complex extends System.ValueType implements class System.IEquatable`1&lt;valuetype System.Numerics.Complex&gt;, class System.IFormattable" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>9.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="System.Numerics" FromVersion="4.0.0.0" To="System.Runtime.Numerics" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime.Numerics" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime.Numerics" ToVersion="6.0.0.0" FrameworkAlternate="net-6.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime.Numerics" ToVersion="7.0.0.0" FrameworkAlternate="net-7.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime.Numerics" ToVersion="8.0.0.0" FrameworkAlternate="net-8.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime.Numerics" ToVersion="9.0.0.0" FrameworkAlternate="net-9.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.IEquatable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.IParsable&lt;System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.IParsable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.ISpanFormattable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.ISpanParsable&lt;System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.ISpanParsable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IAdditionOperators&lt;System.Numerics.Complex,System.Numerics.Complex,System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IAdditionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IAdditiveIdentity&lt;System.Numerics.Complex,System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IAdditiveIdentity&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IDecrementOperators&lt;System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IDecrementOperators&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IDivisionOperators&lt;System.Numerics.Complex,System.Numerics.Complex,System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IDivisionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IEqualityOperators&lt;System.Numerics.Complex,System.Numerics.Complex,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IEqualityOperators&lt;TSelf,TSelf,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IIncrementOperators&lt;System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IIncrementOperators&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;System.Numerics.Complex,System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IMultiplyOperators&lt;System.Numerics.Complex,System.Numerics.Complex,System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IMultiplyOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.INumberBase&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.ISignedNumber&lt;System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.ISubtractionOperators&lt;System.Numerics.Complex,System.Numerics.Complex,System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.ISubtractionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IUnaryNegationOperators&lt;System.Numerics.Complex,System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IUnaryNegationOperators&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IUnaryPlusOperators&lt;System.Numerics.Complex,System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IUnaryPlusOperators&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-8.0;net-9.0">
      <InterfaceName>System.IUtf8SpanFormattable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-8.0;net-9.0">
      <InterfaceName>System.IUtf8SpanParsable&lt;System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-8.0;net-9.0">
      <InterfaceName>System.IUtf8SpanParsable&lt;TSelf&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0">
      <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a complex number.</summary>
    <remarks>For more information about this API, see <see href="/dotnet/fundamentals/runtime-libraries/system-numerics-complex">Supplemental API remarks for Complex</see>.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Complex (double real, double imaginary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 real, float64 imaginary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (real As Double, imaginary As Double)" />
      <MemberSignature Language="F#" Value="new System.Numerics.Complex : double * double -&gt; System.Numerics.Complex" Usage="new System.Numerics.Complex (real, imaginary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Complex(double real, double imaginary);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="real" Type="System.Double" />
        <Parameter Name="imaginary" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="real">The real part of the complex number.</param>
        <param name="imaginary">The imaginary part of the complex number.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Numerics.Complex" /> structure using the specified real and imaginary values.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The `real` or `imaginary` arguments may lose precision if they are data types that require an explicit cast to <xref:System.Double>.

## Examples
 The following example instantiates two complex numbers, and then uses them in addition, subtraction, multiplication, and division operations.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/.ctor/ctor1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/.ctor/ctor1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.ctor/vb/ctor1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Complex) As Double" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.Complex -&gt; double" Usage="System.Numerics.Complex.Abs value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Abs(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">A complex number.</param>
        <summary>Gets the absolute value (or magnitude) of a complex number.</summary>
        <returns>The absolute value of <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The absolute value of a complex number is equivalent to its <xref:System.Numerics.Complex.Magnitude%2A> property. The absolute value of a complex number `a + bi` is calculated as follows:

- If `b = 0`, the result is `a`.
- If `a > b`, the result is $a \times \sqrt{1 + \frac{b^2}{a^2}}$.
- If `b > a`, the result is $b \times \sqrt{1 + \frac{a^2}{b^2}}$.

 If the calculation of the absolute value results in an overflow, the method returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>. If either the <xref:System.Numerics.Complex.Real%2A> or <xref:System.Numerics.Complex.Imaginary%2A> property is <xref:System.Double.NaN?displayProperty=nameWithType> and the other property is neither <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> nor <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Double.NaN?displayProperty=nameWithType>.

## Examples
 The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Abs/abs1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Abs/abs1.fs" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Acos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Acos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (value As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member Acos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Acos value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Acos(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">A complex number that represents a cosine.</param>
        <summary>Returns the angle that is the arc cosine of the specified complex number.</summary>
        <returns>The angle, measured in radians, which is the arc cosine of <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Numerics.Complex.Acos%2A> method for complex numbers corresponds to the <xref:System.Math.Acos%2A?displayProperty=nameWithType> method for real numbers.

 The <xref:System.Numerics.Complex.Acos%2A> method uses the following formula:

 `(-ImaginaryOne) * Log(value + ImaginaryOne * Sqrt(One - value * value))`

## Examples
 The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method. It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Acos/acos1.cs" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Acos/acos1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Acos(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <Docs>
        <summary>Adds a specified number to another specified number, where at least one of them is a complex number, and the other could be a double-precision real number.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Numerics.Complex.Add%2A> methods allow performing addition operations that involve complex numbers.

 If the method call results in an overflow in either the real or imaginary component, the value of the component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.

 Languages that don't support custom operators can use the <xref:System.Numerics.Complex.Add%2A> method to perform addition with complex numbers.

 The <xref:System.Numerics.Complex.Add%2A> methods that receive one double are more efficient than the methods that receive two complex numbers.

## Examples

 The following example illustrates addition with complex numbers.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Add/add1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Add/add1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add1.vb" id="Snippet1":::
          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member Add : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Add (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(double left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The double-precision real value to add.</param>
        <param name="right">The complex value to add.</param>
        <summary>Adds a double-precision real number to a complex number and returns the result.</summary>
        <returns>The sum of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks

The addition of a real number (which can be regarded as the complex number `a + 0i`) and a complex number (`c + di`) takes the following form:

$(a + c) + di$
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Add (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(System::Numerics::Complex left, double right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The complex value to add.</param>
        <param name="right">The double-precision real value to add.</param>
        <summary>Adds a complex number to a double-precision real number and returns the result.</summary>
        <returns>The sum of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
The addition of a complex number (`a + bi`) and a real number (which can be regarded as the complex number `c + 0i`) takes the following form:

$(a + c) + bi$
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Add (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">The first complex number to add.</param>
        <param name="right">The second complex number to add.</param>
        <summary>Adds two complex numbers and returns the result.</summary>
        <returns>The sum of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The addition of a complex number, `a + bi`, and a second complex number, `c + di`, takes the following form:

 $(a + c) + (b + d)i$

 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Asin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Asin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Asin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (value As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member Asin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Asin value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Asin(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">A complex number.</param>
        <summary>Returns the angle that is the arc sine of the specified complex number.</summary>
        <returns>The angle which is the arc sine of <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Numerics.Complex.Asin%2A> method for complex numbers corresponds to the <xref:System.Math.Asin%2A?displayProperty=nameWithType> method for real numbers.

 The <xref:System.Numerics.Complex.Asin%2A> method uses the following formula:

`-ImaginaryOne * Log(ImaginaryOne * value + Sqrt(One - value * value))`

## Examples
 The following example illustrates the <xref:System.Numerics.Complex.Asin%2A> method. It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Asin/asin1.cs" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Asin/asin1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Asin(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Atan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Atan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (value As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member Atan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Atan value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Atan(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">A complex number.</param>
        <summary>Returns the angle that is the arc tangent of the specified complex number.</summary>
        <returns>The angle that is the arc tangent of <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Numerics.Complex.Atan%2A> method for complex numbers corresponds to the <xref:System.Math.Atan%2A?displayProperty=nameWithType> method for real numbers.

 The <xref:System.Numerics.Complex.Atan%2A> method uses the following formula:

`(ImaginaryOne / new Complex(2.0, 0.0)) * (Log(One - ImaginaryOne * value) - Log(One + ImaginaryOne * value))`

## Examples
 The following example illustrates the <xref:System.Numerics.Complex.Atan%2A> method. It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Atan/atan1.cs" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Atan/atan1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Atan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Conjugate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Conjugate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Conjugate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Conjugate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Conjugate (value As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member Conjugate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Conjugate value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Conjugate(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">A complex number.</param>
        <summary>Computes the conjugate of a complex number and returns the result.</summary>
        <returns>The conjugate of <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The conjugate of a complex number inverts the sign of the imaginary component; that is, it applies unary negation to the imaginary component. If `a + bi` is a complex number, its conjugate is `a - bi`.

## Examples
 The following example displays the conjugate of two complex numbers.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Conjugate/conjugate1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Conjugate/conjugate1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.conjugate/vb/conjugate1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (value As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member Cos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cos value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cos(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">A complex number.</param>
        <summary>Returns the cosine of the specified complex number.</summary>
        <returns>The cosine of <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Numerics.Complex.Cos%2A> method for complex numbers corresponds to the <xref:System.Math.Cos%2A?displayProperty=nameWithType> method for real numbers.

 The <xref:System.Numerics.Complex.Cos%2A> method calculates the cosine of the complex number `a + bi` as `x + yi`, where:

- `x` is $\cos a \times \cosh b$
- `y` is $-(\sin a \times \sinh b)$

## Examples
 The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method. It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Acos/acos1.cs" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Acos/acos1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Cos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cosh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cosh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cosh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (value As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member Cosh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cosh value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cosh(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">A complex number.</param>
        <summary>Returns the hyperbolic cosine of the specified complex number.</summary>
        <returns>The hyperbolic cosine of <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Numerics.Complex.Cosh%2A> method for complex numbers corresponds to the <xref:System.Math.Cosh%2A?displayProperty=nameWithType> method for real numbers.

 The <xref:System.Numerics.Complex.Cosh%2A> method calculates the hyperbolic cosine of the complex number `a + bi` as `x + yi`, where:

- `x` is $\cosh a \times \cos b$
- `y` is $\sinh a \times \sin b$

 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Cosh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="CreateChecked&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex CreateChecked&lt;TOther&gt; (TOther value) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex CreateChecked&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.CreateChecked``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateChecked(Of TOther As INumberBase(Of TOther)) (value As TOther) As Complex" />
      <MemberSignature Language="F#" Value="static member CreateChecked : 'Other -&gt; System.Numerics.Complex (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.Numerics.Complex.CreateChecked value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static System::Numerics::Complex CreateChecked(TOther value) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::CreateChecked;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.CreateChecked``1(``0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type of <paramref name="value" />.</typeparam>
        <param name="value">The value that's used to create the instance of <typeparamref name="TSelf" />.</param>
        <summary>Creates an instance of the current type from a value, throwing an overflow exception for any values that fall outside the representable range of the current type.</summary>
        <returns>An instance of <typeparamref name="TSelf" /> created from <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.CreateChecked``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSaturating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex CreateSaturating&lt;TOther&gt; (TOther value) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex CreateSaturating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.CreateSaturating``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSaturating(Of TOther As INumberBase(Of TOther)) (value As TOther) As Complex" />
      <MemberSignature Language="F#" Value="static member CreateSaturating : 'Other -&gt; System.Numerics.Complex (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.Numerics.Complex.CreateSaturating value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static System::Numerics::Complex CreateSaturating(TOther value) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::CreateSaturating;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.CreateSaturating``1(``0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type of <paramref name="value" />.</typeparam>
        <param name="value">The value that's used to create the instance of <typeparamref name="TSelf" />.</param>
        <summary>Creates an instance of the current type from a value, saturating any values that fall outside the representable range of the current type.</summary>
        <returns>An instance of <typeparamref name="TSelf" /> created from <paramref name="value" />, saturating if <paramref name="value" /> falls outside the representable range of <typeparamref name="TSelf" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.CreateSaturating``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="CreateTruncating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex CreateTruncating&lt;TOther&gt; (TOther value) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex CreateTruncating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.CreateTruncating``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateTruncating(Of TOther As INumberBase(Of TOther)) (value As TOther) As Complex" />
      <MemberSignature Language="F#" Value="static member CreateTruncating : 'Other -&gt; System.Numerics.Complex (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.Numerics.Complex.CreateTruncating value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static System::Numerics::Complex CreateTruncating(TOther value) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::CreateTruncating;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.CreateTruncating``1(``0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type of <paramref name="value" />.</typeparam>
        <param name="value">The value that's used to create the instance of <typeparamref name="TSelf" />.</param>
        <summary>Creates an instance of the current type from a value, truncating any values that fall outside the representable range of the current type.</summary>
        <returns>An instance of <typeparamref name="TSelf" /> created from <paramref name="value" />, truncating if <paramref name="value" /> falls outside the representable range of <typeparamref name="TSelf" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.CreateTruncating``1(``0)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Divide">
      <Docs>
        <summary>Divides a specified number by another specified number, where at least one of them is a complex number, and the other could be a double-precision real number.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Numerics.Complex.Divide%2A> methods allow performing division operations that involve complex numbers.

 If the calculation of the quotient results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.

 The <xref:System.Numerics.Complex.Divide%2A> method can be used by Languages that don't support custom operators. Its behavior is identical to division using the division operator.

 The <xref:System.Numerics.Complex.Divide%2A> methods that receive one double are more efficient than the methods that receive two complex numbers.

## Examples
 The following example divides a complex number by each element in an array of complex numbers.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Divide/divide1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Divide/divide1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide1.vb" id="Snippet1":::

          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (double dividend, System.Numerics.Complex divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(float64 dividend, valuetype System.Numerics.Complex divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Double, divisor As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member Divide : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Divide (dividend, divisor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(double dividend, System::Numerics::Complex divisor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="divisor" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="dividend">The double-precision real number to be divided.</param>
        <param name="divisor">The complex number to divide by.</param>
        <summary>Divides one double-precision real number by a complex number and returns the result.</summary>
        <returns>The quotient of the division.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 The division of a real number (which can be regarded as the complex number `a + 0i`) and a complex number (`c + di`) takes the following form:

$\frac{ac}{c^2 + d^2} + (\frac{ad}{c^2 + d^2})i$

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (System.Numerics.Complex dividend, double divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(valuetype System.Numerics.Complex dividend, float64 divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Complex, divisor As Double) As Complex" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Divide (dividend, divisor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(System::Numerics::Complex dividend, double divisor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="divisor" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="dividend">The complex number to be divided.</param>
        <param name="divisor">The double-precision real number to divide by.</param>
        <summary>Divides one complex number by a double-precision real number and returns the result.</summary>
        <returns>The quotient of the division.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 The division of a complex number (`a + bi`) and a real number (which can be regarded as the complex number `c + 0i`) takes the following form:

$\frac{ac}{c^2} + (\frac{bc}{c^2})i$

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (System.Numerics.Complex dividend, System.Numerics.Complex divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(valuetype System.Numerics.Complex dividend, valuetype System.Numerics.Complex divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Complex, divisor As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Divide (dividend, divisor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(System::Numerics::Complex dividend, System::Numerics::Complex divisor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.Complex" />
        <Parameter Name="divisor" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="dividend">The complex number to be divided.</param>
        <param name="divisor">The complex number to divide by.</param>
        <summary>Divides one complex number by another and returns the result.</summary>
        <returns>The quotient of the division.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The division of a complex number, `a + bi`, by a second complex number, `c + di`, takes the following form:

$\frac{ac + bd}{c^2 + d^2} + (\frac{bc - ad}{c^2 + d^2})i$

 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a value that indicates whether two complex numbers are equal.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As Complex) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.Complex -&gt; bool" Usage="complex.Equals value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">The complex number to compare.</param>
        <summary>Returns a value that indicates whether the current instance and a specified complex number have the same value.</summary>
        <returns>
          <see langword="true" /> if this complex number and <paramref name="value" /> have the same value; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method provides the <xref:System.IEquatable%601> implementation for the <xref:System.Numerics.Complex> structure. It performs slightly better than <xref:System.Numerics.Complex.Equals%28System.Object%29> method because it does not have to convert its parameter to a complex number.

 Two complex numbers are equal if their real parts are equal and their imaginary parts are equal. The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method is equivalent to the following expression:

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Equals/equals1.cs" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Equals/equals1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components. The following example reports that <c>(3.33333, 0.142857)</c> and <c>(10/3, 1/7)</c> are not equal.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Equals/precision1.cs" id="Snippet4":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Equals/precision1.fs" id="Snippet4":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb" id="Snippet4":::

 One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality. If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision, and, therefore, the values are likely to be equal. The following example uses this technique to compare the two complex values that the previous code example found to be unequal. It finds the two complex numbers to be equal.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Equals/precision1.cs" id="Snippet5":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Equals/precision1.fs" id="Snippet5":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb" id="Snippet5":::</para>
        </block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="complex.Equals obj" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="C#" Value="public override bool Equals (object? obj);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object">
          <Attributes>
            <Attribute FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="obj">The object to compare.</param>
        <summary>Returns a value that indicates whether the current instance and a specified object have the same value.</summary>
        <returns>
          <see langword="true" /> if the <paramref name="obj" /> parameter is a <see cref="T:System.Numerics.Complex" /> object or a type capable of implicit conversion to a <see cref="T:System.Numerics.Complex" /> object, and its value is equal to the current <see cref="T:System.Numerics.Complex" /> object; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Two complex numbers are equal if their real parts are equal and their imaginary parts are equal. The <xref:System.Numerics.Complex.Equals%28System.Object%29> method is equivalent to the following expression:

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Equals/equals1.cs" id="Snippet2":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Equals/equals1.fs" id="Snippet2":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb" id="Snippet2":::

 If the `obj` parameter is not a <xref:System.Numerics.Complex> object, but it is a data type for which an implicit conversion is defined, the <xref:System.Numerics.Complex.Equals%28System.Object%29> method converts `obj` to a <xref:System.Numerics.Complex> object whose real part is equal to the value of `obj` and whose imaginary part is equal to zero before it performs the comparison. The following example illustrates this by finding that a complex number and a double-precision floating-point value are equal.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Equals/equals3.cs" id="Snippet6":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Equals/equals3.fs" id="Snippet6":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals3.vb" id="Snippet6":::

 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components. The problem can be accentuated if <paramref name="obj" /> must be converted to a <see cref="T:System.Double" /> before performing the comparison. The following example compares a complex number whose real component appears to be equal to a <see cref="T:System.Single" /> value with that <see cref="T:System.Single" /> value. As the output shows, the comparison for equality returns <see langword="False" />.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Equals/equals4.cs" id="Snippet8":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Equals/equals4.fs" id="Snippet8":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb" id="Snippet8":::

 One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality. If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision and, therefore, the values are likely to be equal. The following example uses this technique to compare the two values that the previous code example found to be unequal. It now finds them to be equal.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Equals/precision2.cs" id="Snippet7":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Equals/precision2.fs" id="Snippet7":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb" id="Snippet7":::</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Exp (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Exp(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (value As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member Exp : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Exp value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Exp(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">A complex number that specifies a power.</param>
        <summary>Returns <see langword="e" /> raised to the power specified by a complex number.</summary>
        <returns>The number <see langword="e" /> raised to the power <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Use the <xref:System.Numerics.Complex.Pow%2A> method to calculate the powers of other bases.

 The <xref:System.Numerics.Complex.Exp%2A> method for complex numbers corresponds to the <xref:System.Math.Exp%2A?displayProperty=nameWithType> method for real numbers. <xref:System.Numerics.Complex.Exp%2A> is the inverse of <xref:System.Numerics.Complex.Log%2A>.

## Examples
 The following example illustrates the <xref:System.Numerics.Complex.Exp%2A> method. It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Exp/log1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Exp/log1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Exp(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="FromPolarCoordinates">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex FromPolarCoordinates (double magnitude, double phase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex FromPolarCoordinates(float64 magnitude, float64 phase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromPolarCoordinates (magnitude As Double, phase As Double) As Complex" />
      <MemberSignature Language="F#" Value="static member FromPolarCoordinates : double * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.FromPolarCoordinates (magnitude, phase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex FromPolarCoordinates(double magnitude, double phase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="magnitude" Type="System.Double" />
        <Parameter Name="phase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="magnitude">The magnitude, which is the distance from the origin (the intersection of the x-axis and the y-axis) to the number.</param>
        <param name="phase">The phase, which is the angle from the line to the horizontal axis, measured in radians.</param>
        <summary>Creates a complex number from a point's polar coordinates.</summary>
        <returns>A complex number.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method instantiates a complex number based on its polar coordinates.

 Because there are multiple representations of a point on a complex plane, the return value of the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method is normalized. The magnitude is normalized to a positive number, and the phase is normalized to a value in the range of -<xref:System.Math.PI> to <xref:System.Math.PI>. As a result, the values of the <xref:System.Numerics.Complex.Phase%2A> and <xref:System.Numerics.Complex.Magnitude%2A> properties of the resulting complex number might not equal the original values of the `magnitude` and `phase` parameters.

 To convert a value from degrees to radians for the `phase` parameter, multiply it by $\frac{\pi}{180}$.

## Examples
 The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/FromPolarCoordinates/phase1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/FromPolarCoordinates/phase1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="complex.GetHashCode " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the hash code for the current <see cref="T:System.Numerics.Complex" /> object.</summary>
        <returns>A 32-bit signed integer hash code.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Imaginary">
      <MemberSignature Language="C#" Value="public double Imaginary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Imaginary" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Imaginary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Imaginary As Double" />
      <MemberSignature Language="F#" Value="member this.Imaginary : double" Usage="System.Numerics.Complex.Imaginary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Imaginary { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the imaginary component of the current <see cref="T:System.Numerics.Complex" /> object.</summary>
        <value>The imaginary component of a complex number.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Given a complex number `a + bi`, the <xref:System.Numerics.Complex.Imaginary%2A> property returns the value of `b`.

## Examples
 The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form `a + bi`.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Imaginary/real1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Imaginary/real1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Real" />
      </Docs>
    </Member>
    <Member MemberName="ImaginaryOne">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex ImaginaryOne;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex ImaginaryOne" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.ImaginaryOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ImaginaryOne As Complex " />
      <MemberSignature Language="F#" Value=" staticval mutable ImaginaryOne : System.Numerics.Complex" Usage="System.Numerics.Complex.ImaginaryOne" />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex ImaginaryOne;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to one.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.ImaginaryOne> property. It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to one. As the output from the example shows, the two values are equal.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/ImaginaryOne/imaginaryone1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/ImaginaryOne/imaginaryone1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/vb/imaginaryone1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.One" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <Member MemberName="Infinity">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex Infinity" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.Infinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Infinity As Complex " />
      <MemberSignature Language="F#" Value=" staticval mutable Infinity : System.Numerics.Complex" Usage="System.Numerics.Complex.Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex Infinity;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents infinity as a complex number.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsComplexNumber">
      <MemberSignature Language="C#" Value="public static bool IsComplexNumber (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsComplexNumber(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.IsComplexNumber(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsComplexNumber (value As Complex) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsComplexNumber : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.IsComplexNumber value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsComplexNumber(System::Numerics::Complex value) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::IsComplexNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsComplexNumber(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents a complex value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is a complex number; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This function returns `false` for a complex number `a + bi` where `b` is zero.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.IsComplexNumber(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IsEvenInteger">
      <MemberSignature Language="C#" Value="public static bool IsEvenInteger (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEvenInteger(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.IsEvenInteger(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEvenInteger (value As Complex) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsEvenInteger : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.IsEvenInteger value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEvenInteger(System::Numerics::Complex value) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::IsEvenInteger;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsEvenInteger(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents an even integral number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an even integer; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This method correctly handles floating-point values and so `2.0` returns `true` while `2.2` returns `false`.

A return value of `false` does not imply that <xref:System.Numerics.INumberBase%601.IsOddInteger(%600)> will return `true`. A number with a fractional portion, for example, `3.3`, is not even or odd.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.IsEvenInteger(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.IsFinite(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (value As Complex) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsFinite : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.IsFinite value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(System::Numerics::Complex value);" FrameworkAlternate="net-5.0;net-6.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(System::Numerics::Complex value) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::IsFinite;" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0;net-8.0;net-9.0">M:System.Numerics.INumberBase`1.IsFinite(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">A complex number.</param>
        <summary>Determines whether the specified complex number is finite.</summary>
        <returns>
          <see langword="true" /> if both, the real and imaginary parts are finite (zero, subnormal or normal); otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImaginaryNumber">
      <MemberSignature Language="C#" Value="public static bool IsImaginaryNumber (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsImaginaryNumber(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.IsImaginaryNumber(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsImaginaryNumber (value As Complex) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsImaginaryNumber : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.IsImaginaryNumber value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsImaginaryNumber(System::Numerics::Complex value) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::IsImaginaryNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsImaginaryNumber(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents an imaginary number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an imaginary number; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This function returns `false` for a complex number `a + bi` where `a` is non-zero.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.IsImaginaryNumber(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.IsInfinity(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (value As Complex) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsInfinity : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.IsInfinity value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(System::Numerics::Complex value);" FrameworkAlternate="net-5.0;net-6.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(System::Numerics::Complex value) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::IsInfinity;" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0;net-8.0;net-9.0">M:System.Numerics.INumberBase`1.IsInfinity(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">A complex number.</param>
        <summary>Returns a value indicating whether the specified complex number evaluates to infinity.</summary>
        <returns>
          <see langword="true" /> if either, the real or imaginary part are <see cref="F:System.Double.PositiveInfinity" /> or <see cref="F:System.Double.NegativeInfinity" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInteger">
      <MemberSignature Language="C#" Value="public static bool IsInteger (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInteger(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.IsInteger(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInteger (value As Complex) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsInteger : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.IsInteger value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInteger(System::Numerics::Complex value) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::IsInteger;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsInteger(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents an integral value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an integer; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This method correctly handles floating-point values and so `2.0` and `3.0` will return `true` while `2.2` and `3.3` will return `false`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.IsInteger(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.IsNaN(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (value As Complex) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsNaN : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.IsNaN value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(System::Numerics::Complex value);" FrameworkAlternate="net-5.0;net-6.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(System::Numerics::Complex value) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::IsNaN;" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0;net-8.0;net-9.0">M:System.Numerics.INumberBase`1.IsNaN(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">A complex number.</param>
        <summary>Returns a value that indicates whether the specified complex instance is not a number (NaN).</summary>
        <returns>
          <see langword="true" /> if the specified value is not finite or infinite; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegative(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.IsNegative(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (value As Complex) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsNegative : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.IsNegative value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(System::Numerics::Complex value) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::IsNegative;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsNegative(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is negative.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is negative; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

A return value of `false` does not imply that <xref:System.Numerics.INumberBase%601.IsPositive(%600)> will return `true`. A complex number, `a + bi` for non-zero `b`, is not positive or negative.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.IsNegative(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.IsNegativeInfinity(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinity (value As Complex) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsNegativeInfinity : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.IsNegativeInfinity value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(System::Numerics::Complex value) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::IsNegativeInfinity;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsNegativeInfinity(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is negative infinity.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is negative infinity; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.IsNegativeInfinity(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IsNormal">
      <MemberSignature Language="C#" Value="public static bool IsNormal (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormal(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.IsNormal(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormal (value As Complex) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsNormal : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.IsNormal value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(System::Numerics::Complex value) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::IsNormal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsNormal(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is normal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is normal; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.IsNormal(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IsOddInteger">
      <MemberSignature Language="C#" Value="public static bool IsOddInteger (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsOddInteger(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.IsOddInteger(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsOddInteger (value As Complex) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsOddInteger : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.IsOddInteger value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsOddInteger(System::Numerics::Complex value) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::IsOddInteger;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsOddInteger(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents an odd integral number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an odd integer; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This method correctly handles floating-point values and so `3.0` will return `true` while `3.3` will return `false`.

A return value of `false` does not imply that <xref:System.Numerics.INumberBase%601.IsEvenInteger(%600)> will return `true`. A number with a fractional portion, for example, `3.3`, is not even or odd.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.IsOddInteger(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IsPositive">
      <MemberSignature Language="C#" Value="public static bool IsPositive (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositive(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.IsPositive(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositive (value As Complex) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsPositive : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.IsPositive value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositive(System::Numerics::Complex value) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::IsPositive;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsPositive(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is positive.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is positive; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

A return value of `false` does not imply that <xref:System.Numerics.INumberBase%601.IsNegative(%600)> will return `true`. A complex number, `a + bi` for non-zero `b`, is not positive or negative.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.IsPositive(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.IsPositiveInfinity(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinity (value As Complex) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsPositiveInfinity : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.IsPositiveInfinity value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(System::Numerics::Complex value) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::IsPositiveInfinity;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsPositiveInfinity(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is positive infinity.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is positive infinity; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.IsPositiveInfinity(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IsRealNumber">
      <MemberSignature Language="C#" Value="public static bool IsRealNumber (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsRealNumber(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.IsRealNumber(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsRealNumber (value As Complex) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsRealNumber : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.IsRealNumber value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsRealNumber(System::Numerics::Complex value) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::IsRealNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsRealNumber(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents a real number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is a real number; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This function returns `true` for a complex number `a + bi` where `b` is zero.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.IsRealNumber(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal">
      <MemberSignature Language="C#" Value="public static bool IsSubnormal (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormal(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.IsSubnormal(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormal (value As Complex) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsSubnormal : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.IsSubnormal value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(System::Numerics::Complex value) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::IsSubnormal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsSubnormal(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is subnormal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is subnormal; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.IsSubnormal(`0)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the logarithm of a complex number.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">A complex number.</param>
        <summary>Returns the natural (base <see langword="e" />) logarithm of a specified complex number.</summary>
        <returns>The natural (base <see langword="e" />) logarithm of <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> method for real numbers.

## Examples
 The following example illustrates the <xref:System.Numerics.Complex.Log%2A> method. It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Exp/log1.cs" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Exp/log1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Log(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex, baseValue As Double) As Complex" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log (value, baseValue)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value, double baseValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">A complex number.</param>
        <param name="baseValue">The base of the logarithm.</param>
        <summary>Returns the logarithm of a specified complex number in a specified base.</summary>
        <returns>The logarithm of <paramref name="value" /> in base <paramref name="baseValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> method for real numbers.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log10 (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log10(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log10(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log10 value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log10(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">A complex number.</param>
        <summary>Returns the base-10 logarithm of a specified complex number.</summary>
        <returns>The base-10 logarithm of <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Numerics.Complex.Log10%2A> method for complex numbers corresponds to the <xref:System.Math.Log10%2A?displayProperty=nameWithType> method for real numbers.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Magnitude">
      <MemberSignature Language="C#" Value="public double Magnitude { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Magnitude" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Magnitude" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Magnitude As Double" />
      <MemberSignature Language="F#" Value="member this.Magnitude : double" Usage="System.Numerics.Complex.Magnitude" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Magnitude { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the magnitude (or absolute value) of a complex number.</summary>
        <value>The magnitude of the current instance.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Numerics.Complex.Magnitude%2A> property is equivalent to the absolute value of a complex number. It specifies the distance from the origin (the intersection of the x-axis and the y-axis in the Cartesian coordinate system) to the two-dimensional point represented by a complex number. The absolute value is calculated as follows:

 $| a + bi | = \sqrt{a \times a + b \times b}$

 If the calculation of the absolute value results in an overflow, this property returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.

 The <xref:System.Numerics.Complex.Magnitude%2A> and the <xref:System.Numerics.Complex.Phase%2A> properties define the position of a point that represents a complex number in the polar coordinate system.

 You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.

## Examples
 The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Abs/abs1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Abs/abs1.fs" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex MaxMagnitude (System.Numerics.Complex x, System.Numerics.Complex y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex MaxMagnitude(valuetype System.Numerics.Complex x, valuetype System.Numerics.Complex y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.MaxMagnitude(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MaxMagnitude (x As Complex, y As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.MaxMagnitude (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex MaxMagnitude(System::Numerics::Complex x, System::Numerics::Complex y) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::MaxMagnitude;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.MaxMagnitude(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is greater.</summary>
        <returns>
          <paramref name="x" /> if it is greater than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For <xref:System.Numerics.IFloatingPointIeee754%601> this method matches the IEEE 754:2019 `maximumMagnitude` function. This requires NaN inputs to be propagated back to the caller and for `-0.0` to be treated as less than `+0.0`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.MaxMagnitude(`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex MinMagnitude (System.Numerics.Complex x, System.Numerics.Complex y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex MinMagnitude(valuetype System.Numerics.Complex x, valuetype System.Numerics.Complex y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.MinMagnitude(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MinMagnitude (x As Complex, y As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.MinMagnitude (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex MinMagnitude(System::Numerics::Complex x, System::Numerics::Complex y) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::MinMagnitude;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.MinMagnitude(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is lesser.</summary>
        <returns>
          <paramref name="x" /> if it is less than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For <xref:System.Numerics.IFloatingPointIeee754%601> this method matches the IEEE 754:2019 `minimumMagnitude` function. This requires NaN inputs to be propagated back to the caller and for `-0.0` to be treated as less than `+0.0`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.MinMagnitude(`0,`0)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Multiply">
      <Docs>
        <summary>Multiplies a specified number by another specified number, where at least one of them is a complex number, and the other could be a double-precision real number.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The <xref:System.Numerics.Complex.Multiply%2A> methods allow performing multiplication operations that involve complex numbers.

If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.

The <xref:System.Numerics.Complex.Multiply%2A> method is implemented for Languages that don't support custom operators. Its behavior is identical to multiplication using the multiplication operator.

## Examples

The following example multiples a complex number by each element in an array of complex numbers.

:::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Multiply/multiply1.cs" interactive="try-dotnet" id="Snippet1":::
:::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Multiply/multiply1.fs" id="Snippet1":::
:::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply1.vb" id="Snippet1":::

          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member Multiply : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Multiply (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(double left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The double-precision real number to multiply.</param>
        <param name="right">The complex number to multiply.</param>
        <summary>Returns the product of a double-precision real number and a complex number.</summary>
        <returns>The product of the <paramref name="left" /> and <paramref name="right" /> parameters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 The multiplication of a real number (which can be regarded as the complex number `a + 0i`) and a complex number (`c + di`) takes the following form:

$ac + adi$
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Multiply (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(System::Numerics::Complex left, double right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The complex number to multiply.</param>
        <param name="right">The double-precision real number to multiply.</param>
        <summary>Returns the product of a complex number and a double-precision real number.</summary>
        <returns>The product of the <paramref name="left" /> and <paramref name="right" /> parameters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The multiplication of a complex number (`a + bi`) and a real number (which can be regarded as the complex number `c + 0i`) takes the following form:

$ac + bci$
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Multiply (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">The first complex number to multiply.</param>
        <param name="right">The second complex number to multiply.</param>
        <summary>Returns the product of two complex numbers.</summary>
        <returns>The product of the <paramref name="left" /> and <paramref name="right" /> parameters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The multiplication of a complex number, `a + bi`, and a second complex number, `c + di`, takes the following form:

$(ac - bd) + (ad + bc)i$

 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex NaN" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NaN As Complex " />
      <MemberSignature Language="F#" Value=" staticval mutable NaN : System.Numerics.Complex" Usage="System.Numerics.Complex.NaN" />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex NaN;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Represents a complex instance that is not a number (NaN).</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Negate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Negate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Negate value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Negate(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">A complex number.</param>
        <summary>Returns the additive inverse of a specified complex number.</summary>
        <returns>The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The additive inverse of a complex number is a complex number that produces a value of <xref:System.Numerics.Complex.Zero> when it is added to the original complex number. This method returns a complex number in which the real and imaginary components of the original complex number are multiplied by -1.

 The <xref:System.Numerics.Complex.Negate%2A> method is implemented for Languages that don't support custom operators. Its behavior is identical to negation using the unary negation operator, <xref:System.Numerics.Complex.op_UnaryNegation%2A>.

## Examples
 The following example obtains the additive inverse of each element in an array of complex numbers.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Negate/negate1.cs" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Negate/negate1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex One;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex One" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly One As Complex " />
      <MemberSignature Language="F#" Value=" staticval mutable One : System.Numerics.Complex" Usage="System.Numerics.Complex.One" />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex One;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to one and an imaginary number equal to zero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.One> property. It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to one and an imaginary part equal to zero. As the output from the example shows, the two values are equal.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/One/one1.cs" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/One/one1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.one/vb/one1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Addition">
      <Docs>
        <summary>Adds a specified number to another specified number, where at least one of them is a complex number, and the other could be a double-precision real number.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The <xref:System.Numerics.Complex.op_Addition%2A> operator allows performing addition operations that involve complex numbers. It enables code such as the following:

:::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Add/add3.cs" id="Snippet3":::
:::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Add/add3.fs" id="Snippet3":::
:::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add3.vb" id="Snippet3":::

If the addition results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.

Languages that don't support custom operators can call the <xref:System.Numerics.Complex.Add%2A> equivalent group of methods instead.

The <xref:System.Numerics.Complex.op_Addition%2A> operators that receive one double are more efficient than the operators that receive two Complex numbers.

## Examples

The following example illustrates addition with complex numbers:

:::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Add/add2.cs" interactive="try-dotnet" id="Snippet2":::
:::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Add/add2.fs" id="Snippet2":::
:::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add2.vb" id="Snippet2":::

          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member ( + ) : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left + right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(double left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The double-precision real value to add.</param>
        <param name="right">The complex value to add.</param>
        <summary>Adds a double-precision real number to a complex number.</summary>
        <returns>The sum of <paramref name="left" /> and <paramref name="right" /> as a complex number.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The addition of a real number (which can be regarded as the complex number `a + 0i`) and a complex number (`c + di`) takes the following form:

$(a + c) + di$

Languages that don't support custom operators can call the <xref:System.Numerics.Complex.Add%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> equivalent method instead.

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="left + right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(System::Numerics::Complex left, double right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The complex value to add.</param>
        <param name="right">The double-precision real value to add.</param>
        <summary>Adds a complex number to a double-precision real number.</summary>
        <returns>The sum of <paramref name="left" /> and <paramref name="right" /> as a complex number.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The addition of a complex number (`a + bi`) and a real number (which can be regarded as the complex number `c + 0i`) takes the following form:

$(a + c) + bi$

Languages that don't support custom operators can call the <xref:System.Numerics.Complex.Add%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> equivalent method instead.

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left + right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(System::Numerics::Complex left, System::Numerics::Complex right);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(System::Numerics::Complex left, System::Numerics::Complex right) = System::Numerics::IAdditionOperators&lt;System::Numerics::Complex, System::Numerics::Complex, System::Numerics::Complex&gt;::op_Addition;" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0;net-8.0;net-9.0">M:System.Numerics.IAdditionOperators`3.op_Addition(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">The first complex value to add.</param>
        <param name="right">The second complex value to add.</param>
        <summary>Adds two complex numbers.</summary>
        <returns>The sum of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The addition of a complex number, `a + bi`, and a second complex number, `c + di`, takes the following form:

$(a + c) + (b + d)i$

Languages that don't support custom operators can call the <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> equivalent method instead.

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Decrement">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator -- (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Decrement(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Decrement(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Decrement (value As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member op_Decrement : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Decrement value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator --(System::Numerics::Complex value) = System::Numerics::IDecrementOperators&lt;System::Numerics::Complex&gt;::op_Decrement;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IDecrementOperators`1.op_Decrement(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to decrement.</param>
        <summary>Decrements a value.</summary>
        <returns>The result of decrementing <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IDecrementOperators`1.op_Decrement(`0)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Division">
      <Docs>
        <summary>Divides a specified number by another specified number, where at least one of them is a complex number, and the other could be a double-precision real number.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The <xref:System.Numerics.Complex.op_Division%2A> operator allows performing division operations that involve complex numbers. It enables code such as the following:

:::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Divide/divide2.cs" id="Snippet2":::
:::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Divide/divide2.fs" id="Snippet2":::
:::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide2.vb" id="Snippet2":::

If the division results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.

Languages that don't support custom operators and operator overloading can call the <xref:System.Numerics.Complex.Divide%2A> equivalent group of method instead.

The <xref:System.Numerics.Complex.op_Division%2A> operators that receive one double are more efficient than the operators that receive two Complex numbers.

          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member ( / ) : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left / right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(double left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The double-precision real value to be divided.</param>
        <param name="right">The complex value to divide by.</param>
        <summary>Divides a specified double-precision real number by a specified complex number.</summary>
        <returns>The result of dividing <paramref name="left" /> by <paramref name="right" />, as a complex number.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The division of a real number (which can be regarded as the complex number `a + 0i`) and a complex number (`c + di`) takes the following form:

$\frac{ac}{c^2 + d^2} + (\frac{ad}{c^2 + d^2})i$

Languages that don't support custom operators and operator overloading can call the <xref:System.Numerics.Complex.Divide%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> equivalent method instead.

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="left / right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(System::Numerics::Complex left, double right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The complex value to be divided.</param>
        <param name="right">The double-precision real value to divide by.</param>
        <summary>Divides a specified complex number by a specified double-precision real number.</summary>
        <returns>The result of dividing <paramref name="left" /> by <paramref name="right" />, as a complex number.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The division of a complex number (`a + bi`) and a real number (which can be regarded as the complex number `c + 0i`) takes the following form:

$\frac{ac}{c^2} + (\frac{bc}{c^2})i$

Languages that don't support custom operators and operator overloading can call the <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> equivalent method instead.

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left / right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(System::Numerics::Complex left, System::Numerics::Complex right);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(System::Numerics::Complex left, System::Numerics::Complex right) = System::Numerics::IDivisionOperators&lt;System::Numerics::Complex, System::Numerics::Complex, System::Numerics::Complex&gt;::op_Division;" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0;net-8.0;net-9.0">M:System.Numerics.IDivisionOperators`3.op_Division(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">The complex value to be divided.</param>
        <param name="right">The complex value to divide by.</param>
        <summary>Divides a specified complex number by another specified complex number.</summary>
        <returns>The result of dividing <paramref name="left" /> by <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The division of a complex number, `a + bi`, and a second complex number, `c + di`, takes the following form:

$\frac{ac + cd}{c^2 + d^2} + (\frac{bc - ad}{c^2 + d^2})i$

Languages that don't support custom operators and operator overloading can call the <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> equivalent method instead.

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="left = right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::Complex left, System::Numerics::Complex right);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::Complex left, System::Numerics::Complex right) = System::Numerics::IEqualityOperators&lt;System::Numerics::Complex, System::Numerics::Complex, bool&gt;::op_Equality;" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0;net-8.0;net-9.0">M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">The first complex number to compare.</param>
        <param name="right">The second complex number to compare.</param>
        <summary>Returns a value that indicates whether two complex numbers are equal.</summary>
        <returns>
          <see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the equality operator for <xref:System.Numerics.Complex> values. It enables code such as the following:

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Equals/eqoperator1.cs" id="Snippet9":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Equals/eqoperator1.fs" id="Snippet9":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/eqoperator1.vb" id="Snippet9":::

 Languages that don't support custom operators can call the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method instead.

 Two complex numbers are equal if their real parts are equal and their imaginary parts are equal. The <xref:System.Numerics.Complex.op_Equality%2A> method is equivalent to the following expression:

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Equals/equals1.cs" id="Snippet3":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Equals/equals1.fs" id="Snippet3":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb" id="Snippet3":::

 Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal. For more information and a possible workaround, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.

 The equivalent method for this operator is <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Defines an explicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</summary>
        <altmember cref="Overload:System.Numerics.Complex.op_Implicit" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Complex" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert to a complex number.</param>
        <summary>Defines an explicit conversion of a <see cref="T:System.Decimal" /> value to a complex number.</summary>
        <returns>A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object. Language compilers do not perform this conversion automatically because it can involve data loss. Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used. Otherwise, they display a compiler error.

 The conversion of a <xref:System.Decimal> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Decimal>.

## Examples
 The following example illustrates the explicit conversion of <xref:System.Decimal> values to <xref:System.Numerics.Complex> values.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/op_Explicit/explicit1.cs" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/op_Explicit/explicit1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (Int128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Int128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Int128)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Int128) As Complex" />
      <MemberSignature Language="F#" Value="static member op_Explicit : Int128 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(Int128 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int128" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a <see cref="T:System.Int128" /> value to a double-precision complex number.</summary>
        <returns>
          <paramref name="value" /> converted to a double-precision complex number.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Complex" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Numerics::BigInteger value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert to a complex number.</param>
        <summary>Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> value to a complex number.</summary>
        <returns>A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object. Language compilers do not perform this conversion automatically because it can involve data loss. Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used. Otherwise, they display a compiler error.

 The conversion of a <xref:System.Numerics.BigInteger> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Numerics.BigInteger>.

 If the conversion is unsuccessful because the <xref:System.Numerics.BigInteger> value is out of the range of the <xref:System.Double> type, the operation does not throw an <xref:System.OverflowException>. Instead, if `value` is less than <xref:System.Double.MinValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.NegativeInfinity>. If `value` is greater than <xref:System.Double.MaxValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.PositiveInfinity>.

## Examples
 The following example illustrates the explicit conversion of <xref:System.Numerics.BigInteger> values to <xref:System.Numerics.Complex> values.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/op_Explicit/explicit1.cs" id="Snippet2":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/op_Explicit/explicit1.fs" id="Snippet2":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb" id="Snippet2":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (UInt128 value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.UInt128 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.UInt128)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As UInt128) As Complex" />
      <MemberSignature Language="F#" Value="static member op_Explicit : UInt128 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(UInt128 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt128" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Explicitly converts a <see cref="T:System.UInt128" /> value to a double-precision complex number.</summary>
        <returns>
          <paramref name="value" /> converted to a double-precision complex number.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Defines an implicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Byte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As Complex" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::Byte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert to a complex number.</param>
        <summary>Defines an implicit conversion of an unsigned byte to a complex number.</summary>
        <returns>An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic). They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.

 This overload lets the compiler handle conversions from a <xref:System.Byte> value to a complex number, as the following example shows. Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Byte> value and whose imaginary part is equal to zero.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/op_Implicit/implicit1.cs" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/op_Implicit/implicit1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Char)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Char) As Complex" />
      <MemberSignature Language="F#" Value="static member op_Implicit : char -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Implicitly converts a <see cref="T:System.Char" /> value to a double-precision complex number.</summary>
        <returns>
          <paramref name="value" /> converted to a double-precision complex number.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Double)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Double) As Complex" />
      <MemberSignature Language="F#" Value="static member op_Implicit : double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert to a complex number.</param>
        <summary>Defines an implicit conversion of a double-precision floating-point number to a complex number.</summary>
        <returns>An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic). They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.

 This overload lets the compiler handle conversions from a <xref:System.Double> value to a complex number, as the following example shows. Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Double> value and whose imaginary part is equal to zero.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/op_Implicit/implicit1.cs" id="Snippet2":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/op_Implicit/implicit1.fs" id="Snippet2":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb" id="Snippet2":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (Half value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(valuetype System.Half value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Half)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Half) As Complex" />
      <MemberSignature Language="F#" Value="static member op_Implicit : Half -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(Half value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Half" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Implicitly converts a <see cref="T:System.Half" /> value to a double-precision complex number.</summary>
        <returns>
          <paramref name="value" /> converted to a double-precision complex number.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As Complex" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(short value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert to a complex number.</param>
        <summary>Defines an implicit conversion of a 16-bit signed integer to a complex number.</summary>
        <returns>An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic). They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.

 This overload lets the compiler handle conversions from a signed 16-bit integer to a complex number, as the following example shows. Note that the result of the conversion is a complex number whose real part is equal to the signed 16-bit integer and whose imaginary part is equal to zero.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/op_Implicit/implicit1.cs" id="Snippet3":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/op_Implicit/implicit1.fs" id="Snippet3":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb" id="Snippet3":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As Complex" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert to a complex number.</param>
        <summary>Defines an implicit conversion of a 32-bit signed integer to a complex number.</summary>
        <returns>An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic). They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.

 This overload lets the compiler handle conversions from a signed 32-bit integer to a complex number, as the following example shows. Note that the result of the conversion is a complex number whose real part is equal to the signed 32-bit integer and whose imaginary part is equal to zero.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/op_Implicit/implicit1.cs" id="Snippet4":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/op_Implicit/implicit1.fs" id="Snippet4":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb" id="Snippet4":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As Complex" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert to a complex number.</param>
        <summary>Defines an implicit conversion of a 64-bit signed integer to a complex number.</summary>
        <returns>An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic). They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.

 This overload lets the compiler handle conversions from a signed 64-bit integer to a complex number, as the following example shows. Note that the result of the conversion is a complex number whose real part is equal to the signed 64-bit integer and whose imaginary part is equal to zero.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/op_Implicit/implicit1.cs" id="Snippet5":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/op_Implicit/implicit1.fs" id="Snippet5":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb" id="Snippet5":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.IntPtr)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As IntPtr) As Complex" />
      <MemberSignature Language="F#" Value="static member op_Implicit : nativeint -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(IntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.IntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Implicitly converts a <see cref="T:System.IntPtr" /> value to a double-precision complex number.</summary>
        <returns>
          <paramref name="value" /> converted to a double-precision complex number.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.SByte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As Complex" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::SByte value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert to a complex number.</param>
        <summary>Defines an implicit conversion of a signed byte to a complex number.

This API is not CLS-compliant.</summary>
        <returns>An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic). They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.

 This overload lets the compiler handle conversions from a signed byte to a complex number, as the following example shows. Note that the result of the conversion is a complex number whose real part is equal to the signed byte and whose imaginary part is equal to zero.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/op_Implicit/implicit1.cs" id="Snippet6":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/op_Implicit/implicit1.fs" id="Snippet6":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb" id="Snippet6":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Single)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Single) As Complex" />
      <MemberSignature Language="F#" Value="static member op_Implicit : single -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert to a complex number.</param>
        <summary>Defines an implicit conversion of a single-precision floating-point number to a complex number.</summary>
        <returns>An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic). They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.

 This overload lets the compiler handle conversions from a <xref:System.Single> value to a complex number, as the following example shows. Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Single> value and whose imaginary part is equal to zero.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/op_Implicit/implicit1.cs" id="Snippet7":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/op_Implicit/implicit1.fs" id="Snippet7":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb" id="Snippet7":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As Complex" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt16 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert to a complex number.</param>
        <summary>Defines an implicit conversion of a 16-bit unsigned integer to a complex number.

This API is not CLS-compliant.</summary>
        <returns>An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic). They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.

 This overload lets the compiler handle conversions from an unsigned 16-bit integer to a complex number, as the following example shows. Note that the result of the conversion is a complex number whose real part is equal to the unsigned 16-bit integer and whose imaginary part is equal to zero.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/op_Implicit/implicit1.cs" id="Snippet8":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/op_Implicit/implicit1.fs" id="Snippet8":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb" id="Snippet8":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As Complex" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt32 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert to a complex number.</param>
        <summary>Defines an implicit conversion of a 32-bit unsigned integer to a complex number.

This API is not CLS-compliant.</summary>
        <returns>An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic). They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.

 This overload lets the compiler handle conversions from an unsigned 32-bit integer to a complex number, as the following example shows. Note that the result of the conversion is a complex number whose real part is equal to the unsigned 32-bit integer and whose imaginary part is equal to zero.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/op_Implicit/implicit1.cs" id="Snippet9":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/op_Implicit/implicit1.fs" id="Snippet9":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb" id="Snippet9":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As Complex" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt64 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert to a complex number.</param>
        <summary>Defines an implicit conversion of a 64-bit unsigned integer to a complex number.

This API is not CLS-compliant.</summary>
        <returns>An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic). They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.

 This overload lets the compiler handle conversions from an unsigned 64-bit integer to a complex number, as the following example shows. Note that the result of the conversion is a complex number whose real part is equal to the unsigned 64-bit integer and whose imaginary part is equal to zero.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/op_Implicit/implicit1.cs" id="Snippet10":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/op_Implicit/implicit1.fs" id="Snippet10":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb" id="Snippet10":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UIntPtr)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UIntPtr) As Complex" />
      <MemberSignature Language="F#" Value="static member op_Implicit : unativeint -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(UIntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UIntPtr" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <summary>Implicitly converts a <see cref="T:System.UIntPtr" /> value to a double-precision complex number.</summary>
        <returns>
          <paramref name="value" /> converted to a double-precision complex number.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Increment">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator ++ (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Increment(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Increment(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Increment (value As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member op_Increment : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Increment value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator ++(System::Numerics::Complex value) = System::Numerics::IIncrementOperators&lt;System::Numerics::Complex&gt;::op_Increment;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IIncrementOperators`1.op_Increment(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to increment.</param>
        <summary>Increments a value.</summary>
        <returns>The result of incrementing <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IIncrementOperators`1.op_Increment(`0)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.op_Inequality (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::Complex left, System::Numerics::Complex right);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::Complex left, System::Numerics::Complex right) = System::Numerics::IEqualityOperators&lt;System::Numerics::Complex, System::Numerics::Complex, bool&gt;::op_Inequality;" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0;net-8.0;net-9.0">M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">The first value to compare.</param>
        <param name="right">The second value to compare.</param>
        <summary>Returns a value that indicates whether two complex numbers are not equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the inequality operator for complex numbers. It enables code such as the following:

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/op_Inequality/inequality1.cs" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/op_Inequality/inequality1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.inequality/vb/inequality1.vb" id="Snippet1":::

 Languages that don't support custom operators can test for inequality by calling the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method and reversing its value.

 Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal. One possible workaround is to implement a comparison method that returns `true` only if the difference between the two real and imaginary parts of the complex numbers exceeds a certain threshold (such as .01% of the value of the real or imaginary component of one of the complex numbers). For more information, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.

 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Multiply">
      <Docs>
        <summary>Multiplies a specified number by another specified number, where at least one of them is a complex number, and the other could be a double-precision real number.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The <xref:System.Numerics.Complex.op_Multiply%2A> operator allows performing multiplication operations that involve complex numbers. It enables code such as the following:

:::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Multiply/multiply2.cs" id="Snippet2":::
:::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Multiply/multiply2.fs" id="Snippet2":::
:::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply2.vb" id="Snippet2":::

If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.

Languages that don't support custom operators can call the <xref:System.Numerics.Complex.Multiply%2A> equivalent group of methods instead.

The <xref:System.Numerics.Complex.op_Multiply%2A> operators that receive one double are more efficient than the operators that receive two Complex numbers.

          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member ( * ) : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left * right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(double left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The double-precision real value to multiply.</param>
        <param name="right">The complex value to multiply.</param>
        <summary>Multiplies a specified double-precision real number by a specified complex number.</summary>
        <returns>The product of <paramref name="left" /> and <paramref name="right" />, as a complex number.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The multiplication of a real number (which can be regarded as the complex number `a + 0i`) and a complex number (`c + di`) takes the following form:

$ac + adi$

Languages that don't support custom operators can call the <xref:System.Numerics.Complex.Multiply%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> equivalent method instead.

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="left * right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(System::Numerics::Complex left, double right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The complex value to multiply.</param>
        <param name="right">The double-precision real value to multiply.</param>
        <summary>Multiplies the specified complex number by a specified double-precision real number.</summary>
        <returns>The product of <paramref name="left" /> and <paramref name="right" />, as a complex number.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The multiplication of a complex number (`a + bi`) and a real number (which can be regarded as the complex number `c + 0i`) takes the following form:

$ac + bci$

Languages that don't support custom operators can call the <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> equivalent method instead.

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left * right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(System::Numerics::Complex left, System::Numerics::Complex right);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(System::Numerics::Complex left, System::Numerics::Complex right) = System::Numerics::IMultiplyOperators&lt;System::Numerics::Complex, System::Numerics::Complex, System::Numerics::Complex&gt;::op_Multiply;" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0;net-8.0;net-9.0">M:System.Numerics.IMultiplyOperators`3.op_Multiply(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">The first complex value to multiply.</param>
        <param name="right">The second complex value to multiply.</param>
        <summary>Multiplies two specified complex numbers.</summary>
        <returns>The product of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The multiplication of a complex number, `a + bi`, and a second complex number, `c + di`, takes the following form:

$(ac - bd) + (ad + bc)i$

Languages that don't support custom operators can call the <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> equivalent method instead.

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Subtraction">
      <Docs>
        <summary>Subtracts a specified number from another specified number, where at least one of them is a complex number, and the other could be a double-precision real number.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The <xref:System.Numerics.Complex.op_Subtraction%2A> operator allows performing subtraction operations that involve complex numbers. It enables code such as the following:

:::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/op_Subtraction/subtract2.cs" id="Snippet2":::
:::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/op_Subtraction/subtract2.fs" id="Snippet2":::
:::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract2.vb" id="Snippet2":::

If the subtraction results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.

Languages that don't support custom operators can call the <xref:System.Numerics.Complex.Subtract%2A> equivalent group of methods instead.

The <xref:System.Numerics.Complex.op_Addition%2A> operators that receive one double are more efficient than the operators that receive two Complex numbers.

          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member ( - ) : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left - right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(double left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The double-precision real value to subtract from (the minuend).</param>
        <param name="right">The complex value to subtract (the subtrahend).</param>
        <summary>Subtracts a complex number from a double-precision real number.</summary>
        <returns>The result of subtracting <paramref name="right" /> from <paramref name="left" />, as a complex number.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The subtraction of a complex number (`c + di`) from a real number (which can be regarded as the complex number `a + 0i`) takes the following form:

$(a - c) - di$

Languages that don't support custom operators can call the <xref:System.Numerics.Complex.Subtract%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> method instead.

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="left - right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex left, double right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The complex value to subtract from (the minuend).</param>
        <param name="right">The double-precision real value to subtract (the subtrahend).</param>
        <summary>Subtracts a double-precision real number from a complex number.</summary>
        <returns>The result of subtracting <paramref name="right" /> from <paramref name="left" />, as a complex number.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The subtraction of a real number (which can be regarded as the complex number `c + 0i`) from a complex number (`a + bi`) takes the following form:

$(a - c) + bi$

Languages that don't support custom operators can call the <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> method instead.

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left - right" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex left, System::Numerics::Complex right);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex left, System::Numerics::Complex right) = System::Numerics::ISubtractionOperators&lt;System::Numerics::Complex, System::Numerics::Complex, System::Numerics::Complex&gt;::op_Subtraction;" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0;net-8.0;net-9.0">M:System.Numerics.ISubtractionOperators`3.op_Subtraction(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">The value to subtract from (the minuend).</param>
        <param name="right">The value to subtract (the subtrahend).</param>
        <summary>Subtracts a complex number from another complex number.</summary>
        <returns>The result of subtracting <paramref name="right" /> from <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The subtraction of a complex number, `c + di`, from another complex number, `a + bi`, takes the following form:

$(a - c) + (b - d)i$

Languages that don't support custom operators can call the <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> method instead.

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_UnaryNegation(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="- value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex value);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex value) = System::Numerics::IUnaryNegationOperators&lt;System::Numerics::Complex, System::Numerics::Complex&gt;::op_UnaryNegation;" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0;net-8.0;net-9.0">M:System.Numerics.IUnaryNegationOperators`2.op_UnaryNegation(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">The value to negate.</param>
        <summary>Returns the additive inverse of a specified complex number.</summary>
        <returns>The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Numerics.Complex.op_UnaryNegation%2A> method defines the operation of the unary negation (additive inverse) operator for complex numbers. It enables code such as the following:

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Negate/negate2.cs" id="Snippet2":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Negate/negate2.fs" id="Snippet2":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate2.vb" id="Snippet2":::

 The resulting complex number produces a value of <xref:System.Numerics.Complex.Zero> when it is added to the original complex number. Languages that don't support custom operators can call the <xref:System.Numerics.Complex.Negate%2A> method instead.

 The equivalent method for this operator is <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_UnaryPlus(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_UnaryPlus(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (value As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member ( ~+ ) : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="+ value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(System::Numerics::Complex value) = System::Numerics::IUnaryPlusOperators&lt;System::Numerics::Complex, System::Numerics::Complex&gt;::op_UnaryPlus;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IUnaryPlusOperators`2.op_UnaryPlus(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value for which to compute the unary plus.</param>
        <summary>Computes the unary plus of a value.</summary>
        <returns>The unary plus of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IUnaryPlusOperators`2.op_UnaryPlus(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Parse (ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), provider As IFormatProvider) As Complex" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Parse (s, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Parse(ReadOnlySpan&lt;char&gt; s, IFormatProvider ^ provider) = ISpanParsable&lt;System::Numerics::Complex&gt;::Parse;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ISpanParsable`1.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="s">The span of characters to parse.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <summary>Parses a span of characters into a value.</summary>
        <returns>The result of parsing <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.ISpanParsable`1.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Parse (string s, IFormatProvider? provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Complex" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Parse (s, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Parse(System::String ^ s, IFormatProvider ^ provider) = IParsable&lt;System::Numerics::Complex&gt;::Parse;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IParsable`1.Parse(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="s">The string to parse.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <summary>Parses a string into a value.</summary>
        <returns>The result of parsing <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.IParsable`1.Parse(System.String,System.IFormatProvider)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider? provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider) As Complex" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Parse (s, style, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Parse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::Parse;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="s">The span of characters to parse.</param>
        <param name="style">A bitwise combination of number styles that can be present in <paramref name="s" />.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <summary>Parses a span of characters into a value.</summary>
        <returns>The result of parsing <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Parse (string s, System.Globalization.NumberStyles style, IFormatProvider? provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Complex" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Parse (s, style, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::Parse;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="s">The string to parse.</param>
        <param name="style">A bitwise combination of number styles that can be present in <paramref name="s" />.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <summary>Parses a string into a value.</summary>
        <returns>The result of parsing <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      </Docs>
    </Member>
    <Member MemberName="Phase">
      <MemberSignature Language="C#" Value="public double Phase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Phase" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Phase" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Phase As Double" />
      <MemberSignature Language="F#" Value="member this.Phase : double" Usage="System.Numerics.Complex.Phase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Phase { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the phase of a complex number.</summary>
        <value>The phase of a complex number, in radians.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 For a complex number `a + bi`, the phase is computed as `Atan(b, a)`.

 You can identify a complex number by its Cartesian coordinates on the complex plane or by its polar coordinates. The phase (argument) of a complex number is the angle to the real axis of a line drawn from the point of origin (the intersection of the x-axis and the y-axis) to the point represented by the complex number. The magnitude (represented by the <xref:System.Numerics.Complex.Magnitude%2A> property) is the distance from the point of origin to the point that is represented by the complex number.

 You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.

 To convert the phase from radians to degrees, multiply it by $\frac{180}{\pi}$.

## Examples
 The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates, and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/FromPolarCoordinates/phase1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/FromPolarCoordinates/phase1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pow">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a specified complex number raised to a specified power.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, double power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, float64 power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Double) As Complex" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, double power);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">A complex number to be raised to a power.</param>
        <param name="power">A double-precision floating-point number that specifies a power.</param>
        <summary>Returns a specified complex number raised to a power specified by a double-precision floating-point number.</summary>
        <returns>The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 If `value` is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>. For other values, if `power` is 0, the method returns <xref:System.Numerics.Complex.One?displayProperty=nameWithType>, and if `power` is 1, it returns `value`.

 This method corresponds to the <xref:System.Math.Pow%2A?displayProperty=nameWithType> method for primitive numeric types.

## Examples
 The following example illustrates exponentiation using a complex number and an exponent whose value ranges from -1 to 10.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Pow/pow1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Pow/pow1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.pow/vb/pow1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, System.Numerics.Complex power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, valuetype System.Numerics.Complex power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, System::Numerics::Complex power);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">A complex number to be raised to a power.</param>
        <param name="power">A complex number that specifies a power.</param>
        <summary>Returns a specified complex number raised to a power specified by a complex number.</summary>
        <returns>The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Real">
      <MemberSignature Language="C#" Value="public double Real { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Real" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Real" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Real As Double" />
      <MemberSignature Language="F#" Value="member this.Real : double" Usage="System.Numerics.Complex.Real" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Real { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the real component of the current <see cref="T:System.Numerics.Complex" /> object.</summary>
        <value>The real component of a complex number.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 Given a complex number `a + bi`, the <xref:System.Numerics.Complex.Real%2A> property returns the value of `a`.

## Examples
 The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form `a + bi`.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Imaginary/real1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Imaginary/real1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Imaginary" />
      </Docs>
    </Member>
    <Member MemberName="Reciprocal">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Reciprocal (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Reciprocal(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Reciprocal (value As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member Reciprocal : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Reciprocal value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Reciprocal(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">A complex number.</param>
        <summary>Returns the multiplicative inverse of a complex number.</summary>
        <returns>The reciprocal of <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The reciprocal, or multiplicative inverse, of a number `x` is a number `y` where `x * y` yields 1. The reciprocal of a complex number is the complex number that produces <xref:System.Numerics.Complex.One?displayProperty=nameWithType> when the two numbers are multiplied. If a complex number is represented by `a + bi`, its reciprocal is represented by the following expression:

$\frac{a}{a^2 + b^2} + -\frac{b}{a^2 + b^2}$

 If value is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>. Otherwise, it returns the result of the expression <xref:System.Numerics.Complex.One?displayProperty=nameWithType>/`value`.

## Examples
 The following example uses the <xref:System.Numerics.Complex.Reciprocal%2A> method to calculate the reciprocal values of several complex numbers. It also demonstrates that the result of multiplying a complex number by its reciprocal is <xref:System.Numerics.Complex.One?displayProperty=nameWithType>.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Reciprocal/reciprocal1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Reciprocal/reciprocal1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/vb/reciprocal1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (value As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member Sin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sin value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sin(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">A complex number.</param>
        <summary>Returns the sine of the specified complex number.</summary>
        <returns>The sine of <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Numerics.Complex.Sin%2A> method for complex numbers corresponds to the <xref:System.Math.Sin%2A?displayProperty=nameWithType> method for real numbers.

 The <xref:System.Numerics.Complex.Sin%2A> method calculates the sine of the complex number `a + bi` as `x + yi`, where:

- `x` is $\sin a \times \cosh b$
- `y` is $\cos a \times \sinh b$

## Examples
 The following example illustrates the <xref:System.Numerics.Complex.Sin%2A> method. It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Asin/asin1.cs" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Asin/asin1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Asin(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sinh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sinh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sinh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (value As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member Sinh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sinh value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sinh(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">A complex number.</param>
        <summary>Returns the hyperbolic sine of the specified complex number.</summary>
        <returns>The hyperbolic sine of <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Numerics.Complex.Sinh%2A> method for complex numbers corresponds to the <xref:System.Math.Sinh%2A?displayProperty=nameWithType> method for real numbers.

 The <xref:System.Numerics.Complex.Sinh%2A> method calculates the hyperbolic sine of the complex number `a + bi` as `x + yi`, where:

- `x` is $\sinh a \times \cos b$
- `y` is $\cosh a \times \sin b$

 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Sinh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sqrt (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sqrt(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sqrt(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (value As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member Sqrt : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sqrt value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sqrt(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">A complex number.</param>
        <summary>Returns the square root of a specified complex number.</summary>
        <returns>The square root of <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The square root of the complex number `value` is calculated by using the following formula:

`Complex.FromPolarCoordinates(Math.Sqrt(value.Magnitude), value.Phase/2.0)`

 The <xref:System.Numerics.Complex.Sqrt%2A> method for complex numbers corresponds to the <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> method for real numbers.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Subtract">
      <Docs>
        <summary>Subtracts a specified number from another specified number, where at least one of them is a complex number, and the other could be a double-precision real number, and returns the result.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The <xref:System.Numerics.Complex.Subtract%2A> method allows subtraction operations that involve complex numbers.

If the subtraction results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.

Languages that support custom operators can use the <xref:System.Numerics.Complex.op_Subtraction%2A> equivalent group of operators too.

The <xref:System.Numerics.Complex.Subtract%2A> methods that receive one double are more efficient than the method that receive two Complex numbers.

## Examples

The following example subtracts each complex number in an array from a complex number:

:::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/op_Subtraction/subtract1.cs" interactive="try-dotnet" id="Snippet1":::
:::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/op_Subtraction/subtract1.fs" id="Snippet1":::
:::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract1.vb" id="Snippet1":::

          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member Subtract : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Subtract (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(double left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The double-precision real value to subtract from (the minuend).</param>
        <param name="right">The complex value to subtract (the subtrahend).</param>
        <summary>Subtracts one complex number from a double-precision real number and returns the result.</summary>
        <returns>The result of subtracting <paramref name="right" /> from <paramref name="left" />, as a complex number.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The subtraction of a complex number (`c + di`) from a real number (which can be regarded as the complex number `a + 0i`) takes the following form:

$(a - c) - di$

Languages that support custom operators can use the <xref:System.Numerics.Complex.op_Subtraction%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> equivalent operator too.

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Subtract (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(System::Numerics::Complex left, double right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The complex value to subtract from (the minuend).</param>
        <param name="right">The double-precision real value to subtract (the subtrahend).</param>
        <summary>Subtracts one double-precision real number from a complex number and returns the result.</summary>
        <returns>The result of subtracting <paramref name="right" /> from <paramref name="left" />, as a complex number.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The subtraction of a real number (which can be regarded as the complex number `c + 0i`) from a complex number (`a + bi`) takes the following form:

$(a - c) + bi$

Languages that support custom operators can use the <xref:System.Numerics.Complex.op_Subtraction%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> equivalent operator too.

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Subtract (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left">The value to subtract from (the minuend).</param>
        <param name="right">The value to subtract (the subtrahend).</param>
        <summary>Subtracts one complex number from another and returns the result.</summary>
        <returns>The result of subtracting <paramref name="right" /> from <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The subtraction of a complex number, `c + di`, from another complex number, `a + bi`, takes the following form:

$(a - c) + (b - d)i$

Languages that support custom operators can use the <xref:System.Numerics.Complex.op_Subtraction%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> equivalent operator too.

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IAdditiveIdentity&lt;System.Numerics.Complex,System.Numerics.Complex&gt;.AdditiveIdentity">
      <MemberSignature Language="C#" Value="static System.Numerics.Complex System.Numerics.IAdditiveIdentity&lt;System.Numerics.Complex,System.Numerics.Complex&gt;.AdditiveIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.Complex System.Numerics.IAdditiveIdentity&lt;System.Numerics.Complex,System.Numerics.Complex&gt;.AdditiveIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.System#Numerics#IAdditiveIdentity&lt;System#Numerics#Complex,System#Numerics#Complex&gt;#AdditiveIdentity" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property AdditiveIdentity As Complex Implements IAdditiveIdentity(Of Complex, Complex).AdditiveIdentity" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IAdditiveIdentity&lt;System.Numerics.Complex,System.Numerics.Complex&gt;.AdditiveIdentity : System.Numerics.Complex" Usage="System.Numerics.IAdditiveIdentity&lt;System.Numerics.Complex,System.Numerics.Complex&gt;.AdditiveIdentity" />
      <MemberSignature Language="C++ CLI" Value="static property System::Numerics::Complex System::Numerics::IAdditiveIdentity&lt;System::Numerics::Complex,System::Numerics::Complex&gt;::AdditiveIdentity { System::Numerics::Complex get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IAdditiveIdentity`2.AdditiveIdentity</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the additive identity of the current type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IMultiplicativeIdentity&lt;System.Numerics.Complex,System.Numerics.Complex&gt;.MultiplicativeIdentity">
      <MemberSignature Language="C#" Value="static System.Numerics.Complex System.Numerics.IMultiplicativeIdentity&lt;System.Numerics.Complex,System.Numerics.Complex&gt;.MultiplicativeIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.Complex System.Numerics.IMultiplicativeIdentity&lt;System.Numerics.Complex,System.Numerics.Complex&gt;.MultiplicativeIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.System#Numerics#IMultiplicativeIdentity&lt;System#Numerics#Complex,System#Numerics#Complex&gt;#MultiplicativeIdentity" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property MultiplicativeIdentity As Complex Implements IMultiplicativeIdentity(Of Complex, Complex).MultiplicativeIdentity" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IMultiplicativeIdentity&lt;System.Numerics.Complex,System.Numerics.Complex&gt;.MultiplicativeIdentity : System.Numerics.Complex" Usage="System.Numerics.IMultiplicativeIdentity&lt;System.Numerics.Complex,System.Numerics.Complex&gt;.MultiplicativeIdentity" />
      <MemberSignature Language="C++ CLI" Value="static property System::Numerics::Complex System::Numerics::IMultiplicativeIdentity&lt;System::Numerics::Complex,System::Numerics::Complex&gt;::MultiplicativeIdentity { System::Numerics::Complex get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IMultiplicativeIdentity`2.MultiplicativeIdentity</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the multiplicative identity of the current type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.Abs">
      <MemberSignature Language="C#" Value="static System.Numerics.Complex INumberBase&lt;Complex&gt;.Abs (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig valuetype System.Numerics.Complex System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.Abs(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.System#Numerics#INumberBase&lt;System#Numerics#Complex&gt;#Abs(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function Abs (value As Complex) As Complex Implements INumberBase(Of Complex).Abs" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.Abs : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.Abs value" />
      <MemberSignature Language="C++ CLI" Value=" static System::Numerics::Complex System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.Abs(System::Numerics::Complex value) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::Abs;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.Abs(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value for which to get its absolute.</param>
        <summary>Computes the absolute of a value.</summary>
        <returns>The absolute of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.IsCanonical">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;Complex&gt;.IsCanonical (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.IsCanonical(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.System#Numerics#INumberBase&lt;System#Numerics#Complex&gt;#IsCanonical(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsCanonical (value As Complex) As Boolean Implements INumberBase(Of Complex).IsCanonical" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.IsCanonical : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.IsCanonical value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.IsCanonical(System::Numerics::Complex value) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::IsCanonical;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsCanonical(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is in its canonical representation.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is in its canonical representation; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.IsZero">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;Complex&gt;.IsZero (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.IsZero(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.System#Numerics#INumberBase&lt;System#Numerics#Complex&gt;#IsZero(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsZero (value As Complex) As Boolean Implements INumberBase(Of Complex).IsZero" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.IsZero : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.IsZero value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.IsZero(System::Numerics::Complex value) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::IsZero;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsZero(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is zero.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is zero; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.MaxMagnitudeNumber">
      <MemberSignature Language="C#" Value="static System.Numerics.Complex INumberBase&lt;Complex&gt;.MaxMagnitudeNumber (System.Numerics.Complex x, System.Numerics.Complex y);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig valuetype System.Numerics.Complex System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.MaxMagnitudeNumber(valuetype System.Numerics.Complex x, valuetype System.Numerics.Complex y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.System#Numerics#INumberBase&lt;System#Numerics#Complex&gt;#MaxMagnitudeNumber(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function MaxMagnitudeNumber (x As Complex, y As Complex) As Complex Implements INumberBase(Of Complex).MaxMagnitudeNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.MaxMagnitudeNumber : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.MaxMagnitudeNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value=" static System::Numerics::Complex System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.MaxMagnitudeNumber(System::Numerics::Complex x, System::Numerics::Complex y) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::MaxMagnitudeNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.MaxMagnitudeNumber(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which has the greater magnitude and returning the other value if an input is <c>NaN</c>.</summary>
        <returns>
          <paramref name="x" /> if it is greater than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.MinMagnitudeNumber">
      <MemberSignature Language="C#" Value="static System.Numerics.Complex INumberBase&lt;Complex&gt;.MinMagnitudeNumber (System.Numerics.Complex x, System.Numerics.Complex y);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig valuetype System.Numerics.Complex System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.MinMagnitudeNumber(valuetype System.Numerics.Complex x, valuetype System.Numerics.Complex y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.System#Numerics#INumberBase&lt;System#Numerics#Complex&gt;#MinMagnitudeNumber(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function MinMagnitudeNumber (x As Complex, y As Complex) As Complex Implements INumberBase(Of Complex).MinMagnitudeNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.MinMagnitudeNumber : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.MinMagnitudeNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value=" static System::Numerics::Complex System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.MinMagnitudeNumber(System::Numerics::Complex x, System::Numerics::Complex y) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::MinMagnitudeNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.MinMagnitudeNumber(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which has the lesser magnitude and returning the other value if an input is <c>NaN</c>.</summary>
        <returns>
          <paramref name="x" /> if it is less than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.MultiplyAddEstimate">
      <MemberSignature Language="C#" Value="static System.Numerics.Complex INumberBase&lt;Complex&gt;.MultiplyAddEstimate (System.Numerics.Complex left, System.Numerics.Complex right, System.Numerics.Complex addend);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig valuetype System.Numerics.Complex System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.MultiplyAddEstimate(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right, valuetype System.Numerics.Complex addend) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.System#Numerics#INumberBase&lt;System#Numerics#Complex&gt;#MultiplyAddEstimate(System.Numerics.Complex,System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function MultiplyAddEstimate (left As Complex, right As Complex, addend As Complex) As Complex Implements INumberBase(Of Complex).MultiplyAddEstimate" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.MultiplyAddEstimate : System.Numerics.Complex * System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.MultiplyAddEstimate (left, right, addend)" />
      <MemberSignature Language="C++ CLI" Value=" static System::Numerics::Complex System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.MultiplyAddEstimate(System::Numerics::Complex left, System::Numerics::Complex right, System::Numerics::Complex addend) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::MultiplyAddEstimate;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.MultiplyAddEstimate(`0,`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="net-9.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="net-9.0" />
        <Parameter Name="addend" Type="System.Numerics.Complex" Index="2" FrameworkAlternate="net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to be multiplied with <paramref name="right" />.</param>
        <param name="right">The value to be multiplied with <paramref name="left" />.</param>
        <param name="addend">The value to be added to the result of <paramref name="left" /> multiplied by <paramref name="right" />.</param>
        <summary>Computes an estimate of (<paramref name="left" /> * <paramref name="right" />) + <paramref name="addend" />.</summary>
        <returns>An estimate of (<paramref name="left" /> * <paramref name="right" />) + <paramref name="addend" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.One">
      <MemberSignature Language="C#" Value="static System.Numerics.Complex System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.Complex System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.One" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.System#Numerics#INumberBase&lt;System#Numerics#Complex&gt;#One" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property One As Complex Implements INumberBase(Of Complex).One" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.One : System.Numerics.Complex" Usage="System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.One" />
      <MemberSignature Language="C++ CLI" Value="static property System::Numerics::Complex System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::One { System::Numerics::Complex get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.INumberBase`1.One</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value <c>1</c> for the type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.Radix">
      <MemberSignature Language="C#" Value="static int System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.Radix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.Radix" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.System#Numerics#INumberBase&lt;System#Numerics#Complex&gt;#Radix" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property Radix As Integer Implements INumberBase(Of Complex).Radix" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.Radix : int" Usage="System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.Radix" />
      <MemberSignature Language="C++ CLI" Value="static property int System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::Radix { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.INumberBase`1.Radix</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the radix, or base, for the type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.TryConvertToChecked&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;Complex&gt;.TryConvertToChecked&lt;TOther&gt; (System.Numerics.Complex value, out TOther result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.TryConvertToChecked&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(valuetype System.Numerics.Complex value, [out] !!TOther&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.System#Numerics#INumberBase&lt;System#Numerics#Complex&gt;#TryConvertToChecked``1(System.Numerics.Complex,``0@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertToChecked(Of TOther As INumberBase(Of TOther)) (value As Complex, ByRef result As TOther) As Boolean Implements INumberBase(Of Complex).TryConvertToChecked" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.TryConvertToChecked : System.Numerics.Complex * 'Other -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.Numerics.Complex.System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.TryConvertToChecked (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.TryConvertToChecked(System::Numerics::Complex value, [Runtime::InteropServices::Out] TOther % result) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::TryConvertToChecked;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.TryConvertToChecked``1(`0,``0@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="TOther" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type to which <paramref name="value" /> should be converted.</typeparam>
        <param name="value">The value which is used to create the instance of <typeparamref name="TOther" />.</param>
        <param name="result">When this method returns, contains an instance of <typeparamref name="TOther" /> converted from <paramref name="value" />.</param>
        <summary>Tries to convert an instance of the the current type to another type, throwing an overflow exception for any values that fall outside the representable range of the current type.</summary>
        <returns>
          <see langword="false" /> if <typeparamref name="TOther" /> is not supported; otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.TryConvertToSaturating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;Complex&gt;.TryConvertToSaturating&lt;TOther&gt; (System.Numerics.Complex value, out TOther result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.TryConvertToSaturating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(valuetype System.Numerics.Complex value, [out] !!TOther&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.System#Numerics#INumberBase&lt;System#Numerics#Complex&gt;#TryConvertToSaturating``1(System.Numerics.Complex,``0@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertToSaturating(Of TOther As INumberBase(Of TOther)) (value As Complex, ByRef result As TOther) As Boolean Implements INumberBase(Of Complex).TryConvertToSaturating" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.TryConvertToSaturating : System.Numerics.Complex * 'Other -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.Numerics.Complex.System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.TryConvertToSaturating (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.TryConvertToSaturating(System::Numerics::Complex value, [Runtime::InteropServices::Out] TOther % result) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::TryConvertToSaturating;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.TryConvertToSaturating``1(`0,``0@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="TOther" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type to which <paramref name="value" /> should be converted.</typeparam>
        <param name="value">The value which is used to create the instance of <typeparamref name="TOther" />.</param>
        <param name="result">When this method returns, contains an instance of <typeparamref name="TOther" /> converted from <paramref name="value" />.</param>
        <summary>Tries to convert an instance of the the current type to another type, saturating any values that fall outside the representable range of the current type.</summary>
        <returns>
          <see langword="false" /> if <typeparamref name="TOther" /> is not supported; otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.TryConvertToTruncating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;Complex&gt;.TryConvertToTruncating&lt;TOther&gt; (System.Numerics.Complex value, out TOther result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.TryConvertToTruncating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(valuetype System.Numerics.Complex value, [out] !!TOther&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.System#Numerics#INumberBase&lt;System#Numerics#Complex&gt;#TryConvertToTruncating``1(System.Numerics.Complex,``0@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertToTruncating(Of TOther As INumberBase(Of TOther)) (value As Complex, ByRef result As TOther) As Boolean Implements INumberBase(Of Complex).TryConvertToTruncating" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.TryConvertToTruncating : System.Numerics.Complex * 'Other -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.Numerics.Complex.System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.TryConvertToTruncating (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.TryConvertToTruncating(System::Numerics::Complex value, [Runtime::InteropServices::Out] TOther % result) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::TryConvertToTruncating;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.TryConvertToTruncating``1(`0,``0@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="TOther" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type to which <paramref name="value" /> should be converted.</typeparam>
        <param name="value">The value which is used to create the instance of <typeparamref name="TOther" />.</param>
        <param name="result">When this method returns, contains an instance of <typeparamref name="TOther" /> converted from <paramref name="value" />.</param>
        <summary>Tries to convert an instance of the the current type to another type, truncating any values that fall outside the representable range of the current type.</summary>
        <returns>
          <see langword="false" /> if <typeparamref name="TOther" /> is not supported; otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.TryConvertFromChecked&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;Complex&gt;.TryConvertFromChecked&lt;TOther&gt; (TOther value, out System.Numerics.Complex result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.TryConvertFromChecked&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value, [out] valuetype System.Numerics.Complex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.System#Numerics#INumberBase&lt;System#Numerics#Complex&gt;#TryConvertFromChecked``1(``0,System.Numerics.Complex@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertFromChecked(Of TOther As INumberBase(Of TOther)) (value As TOther, ByRef result As Complex) As Boolean Implements INumberBase(Of Complex).TryConvertFromChecked" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.TryConvertFromChecked : 'Other * Complex -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.Numerics.Complex.System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.TryConvertFromChecked (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.TryConvertFromChecked(TOther value, [Runtime::InteropServices::Out] System::Numerics::Complex % result) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::TryConvertFromChecked;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.Numerics.Complex" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">To be added.</typeparam>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.TryConvertFromSaturating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;Complex&gt;.TryConvertFromSaturating&lt;TOther&gt; (TOther value, out System.Numerics.Complex result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.TryConvertFromSaturating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value, [out] valuetype System.Numerics.Complex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.System#Numerics#INumberBase&lt;System#Numerics#Complex&gt;#TryConvertFromSaturating``1(``0,System.Numerics.Complex@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertFromSaturating(Of TOther As INumberBase(Of TOther)) (value As TOther, ByRef result As Complex) As Boolean Implements INumberBase(Of Complex).TryConvertFromSaturating" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.TryConvertFromSaturating : 'Other * Complex -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.Numerics.Complex.System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.TryConvertFromSaturating (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.TryConvertFromSaturating(TOther value, [Runtime::InteropServices::Out] System::Numerics::Complex % result) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::TryConvertFromSaturating;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.Numerics.Complex" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">To be added.</typeparam>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.TryConvertFromTruncating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;Complex&gt;.TryConvertFromTruncating&lt;TOther&gt; (TOther value, out System.Numerics.Complex result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.TryConvertFromTruncating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value, [out] valuetype System.Numerics.Complex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.System#Numerics#INumberBase&lt;System#Numerics#Complex&gt;#TryConvertFromTruncating``1(``0,System.Numerics.Complex@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertFromTruncating(Of TOther As INumberBase(Of TOther)) (value As TOther, ByRef result As Complex) As Boolean Implements INumberBase(Of Complex).TryConvertFromTruncating" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.TryConvertFromTruncating : 'Other * Complex -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.Numerics.Complex.System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.TryConvertFromTruncating (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.TryConvertFromTruncating(TOther value, [Runtime::InteropServices::Out] System::Numerics::Complex % result) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::TryConvertFromTruncating;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.Numerics.Complex" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">To be added.</typeparam>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.Zero">
      <MemberSignature Language="C#" Value="static System.Numerics.Complex System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.Complex System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.Zero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.System#Numerics#INumberBase&lt;System#Numerics#Complex&gt;#Zero" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property Zero As Complex Implements INumberBase(Of Complex).Zero" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.Zero : System.Numerics.Complex" Usage="System.Numerics.INumberBase&lt;System.Numerics.Complex&gt;.Zero" />
      <MemberSignature Language="C++ CLI" Value="static property System::Numerics::Complex System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::Zero { System::Numerics::Complex get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.INumberBase`1.Zero</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value <c>0</c> for the type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.ISignedNumber&lt;System.Numerics.Complex&gt;.NegativeOne">
      <MemberSignature Language="C#" Value="static System.Numerics.Complex System.Numerics.ISignedNumber&lt;System.Numerics.Complex&gt;.NegativeOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.Complex System.Numerics.ISignedNumber&lt;System.Numerics.Complex&gt;.NegativeOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.System#Numerics#ISignedNumber&lt;System#Numerics#Complex&gt;#NegativeOne" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property NegativeOne As Complex Implements ISignedNumber(Of Complex).NegativeOne" />
      <MemberSignature Language="F#" Value="static member System.Numerics.ISignedNumber&lt;System.Numerics.Complex&gt;.NegativeOne : System.Numerics.Complex" Usage="System.Numerics.ISignedNumber&lt;System.Numerics.Complex&gt;.NegativeOne" />
      <MemberSignature Language="C++ CLI" Value="static property System::Numerics::Complex System::Numerics::ISignedNumber&lt;System::Numerics::Complex&gt;::NegativeOne { System::Numerics::Complex get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.ISignedNumber`1.NegativeOne</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value <c>-1</c> for the type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (value As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member Tan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tan value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tan(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">A complex number.</param>
        <summary>Returns the tangent of the specified complex number.</summary>
        <returns>The tangent of <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Numerics.Complex.Tan%2A> method for complex numbers corresponds to the <xref:System.Math.Tan%2A?displayProperty=nameWithType> method for real numbers.

 The <xref:System.Numerics.Complex.Tan%2A> method uses the following formula to calculate the tangent of the complex number `value`:

`Sin(value)/Cos(value)`

## Examples
 The following example illustrates the <xref:System.Numerics.Complex.Tan%2A> method. It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Atan/atan1.cs" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Atan/atan1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Tan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tanh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tanh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tanh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (value As Complex) As Complex" />
      <MemberSignature Language="F#" Value="static member Tanh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tanh value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tanh(System::Numerics::Complex value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value">A complex number.</param>
        <summary>Returns the hyperbolic tangent of the specified complex number.</summary>
        <returns>The hyperbolic tangent of <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Numerics.Complex.Tanh%2A> method for complex numbers corresponds to the <xref:System.Math.Tanh%2A?displayProperty=nameWithType> method for real numbers.

 The <xref:System.Numerics.Complex.Tanh%2A> method uses the following formula to calculate the hyperbolic tangent of the complex number `value`:

`Sinh(value)/Cosh(value)`

 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Tanh(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converts the value of a complex number to its equivalent string representation.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="complex.ToString " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converts the value of the current complex number to its equivalent string representation in Cartesian form.</summary>
        <returns>The string representation of the current instance in Cartesian form.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The default string representation of a complex number displays the number using its Cartesian coordinates in the form `<a; b>` (or `(a, b)` in .NET 7 and earlier versions), where *a* is the real part of the complex number, and *b* is its imaginary part. Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the current system culture.

## Examples
 The following example displays the string representation of several complex numbers. The output uses the formatting conventions of the English - United States ("en-US") culture, which, in this case, is the current system culture.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/ToString/tostring1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/ToString/tostring1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="complex.ToString provider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider? provider);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">An object that supplies culture-specific formatting information.</param>
        <summary>Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified culture-specific formatting information.</summary>
        <returns>The string representation of the current instance in Cartesian form, as specified by <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `<a; b>` (or `(a, b)` in .NET 7 and earlier versions), where *a* is the real part of the complex number, and *b* is its imaginary part. Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the culture defined by `provider`.

 The `provider` parameter is an <xref:System.IFormatProvider> implementation. Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string. If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.

 The `provider` parameter can be one of the following:

-   A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information
-   The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.
-   A custom object that implements the <xref:System.IFormatProvider> interface. Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.

## Examples
 The following example displays the string representation of several complex numbers. The result uses the formatting conventions of the English - United States ("en-US") and French - France ("fr-FR") cultures.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/ToString/tostring2.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/ToString/tostring2.fs" id="Snippet2":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring2.vb" id="Snippet2":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="complex.ToString format" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="C#" Value="public string ToString (string? format);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String">
          <Attributes>
            <Attribute FrameworkAlternate="net-7.0;net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">A standard or custom numeric format string.</param>
        <summary>Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format for its real and imaginary parts.</summary>
        <returns>The string representation of the current instance in Cartesian form.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `<a; b>` (or `(a, b)` in .NET 7 and earlier versions), where *a* is the real part of the complex number, and *b* is its imaginary part. Both *a* and *b* are formatted using the format string specified by `format`. The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers. If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G"). If `format` is any other value, the method throws a <xref:System.FormatException>.

.NET provides extensive formatting support, which is described in greater detail in the following articles:

- For more information about numeric format strings, see [Standard Numeric Format Strings](/dotnet/standard/base-types/standard-numeric-format-strings) and [Custom Numeric Format Strings](/dotnet/standard/base-types/custom-numeric-format-strings).
- For more information about formatting in .NET, see [Formatting Types](/dotnet/standard/base-types/formatting-types).

 The format of the returned string is determined by the <xref:System.Globalization.NumberFormatInfo> object for the current culture. Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string. To provide formatting information for cultures other than the current culture, call the <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> overload.

## Examples
 The following example initializes a complex number and displays it using several standard format strings.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/ToString/tostring3.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/ToString/tostring3.fs" id="Snippet3":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring3.vb" id="Snippet3":::

 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> is not a valid format string.</exception>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">Standard Numeric Format Strings</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">Custom Numeric Format Strings</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="complex.ToString (format, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="C#" Value="public string ToString (string? format, IFormatProvider? provider);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String">
          <Attributes>
            <Attribute FrameworkAlternate="net-7.0;net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">A standard or custom numeric format string.</param>
        <param name="provider">An object that supplies culture-specific formatting information.</param>
        <summary>Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format and culture-specific format information for its real and imaginary parts.</summary>
        <returns>The string representation of the current instance in Cartesian form, as specified by <paramref name="format" /> and <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `<a; b>` (or `(a, b)` in .NET 7 and earlier versions), where *a* is the real part of the complex number, and *b* is its imaginary part. Both *a* and *b* are formatted using the format string specified by `format`. The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers. If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G"). If `format` is any other value, the method throws a <xref:System.FormatException>.

.NET provides extensive formatting support, which is described in greater detail in the following articles:

- For more information about numeric format strings, see [Standard Numeric Format Strings](/dotnet/standard/base-types/standard-numeric-format-strings) and [Custom Numeric Format Strings](/dotnet/standard/base-types/custom-numeric-format-strings).
- For more information about formatting in .NET, see [Formatting Types](/dotnet/standard/base-types/formatting-types).

 The `provider` parameter is an <xref:System.IFormatProvider> implementation. Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string. Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string. If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.

 The `provider` parameter can be one of the following:

- A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information
- The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.
- A custom object that implements the <xref:System.IFormatProvider> interface. Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.

## Examples
 The following example creates an array of complex numbers, and displays each using several standard format strings as well as <xref:System.Globalization.CultureInfo> objects that represent the English - United States ("en-US") and French - France ("fr-FR") cultures.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/ToString/tostring4.cs" interactive="try-dotnet" id="Snippet4":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/ToString/tostring4.fs" id="Snippet4":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring4.vb" id="Snippet4":::

 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> is not a valid format string.</exception>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">Standard Numeric Format Strings</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">Custom Numeric Format Strings</related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;byte&gt; utf8Destination, out int bytesWritten, ReadOnlySpan&lt;char&gt; format = default, IFormatProvider? provider = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryFormat(valuetype System.Span`1&lt;unsigned int8&gt; utf8Destination, [out] int32&amp; bytesWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.TryFormat(System.Span{System.Byte},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (utf8Destination As Span(Of Byte), ByRef bytesWritten As Integer, Optional format As ReadOnlySpan(Of Char) = Nothing, Optional provider As IFormatProvider = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member TryFormat : Span&lt;byte&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool&#xA;override this.TryFormat : Span&lt;byte&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="complex.TryFormat (utf8Destination, bytesWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.System#IUtf8SpanFormattable#TryFormat(System.Span{System.Byte},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="utf8Destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format, IFormatProvider? provider);" FrameworkAlternate="net-7.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, format As ReadOnlySpan(Of Char), provider As IFormatProvider) As Boolean" FrameworkAlternate="net-7.0" />
      <MemberSignature Language="F#" Value="abstract member TryFormat : Span&lt;char&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool&#xA;override this.TryFormat : Span&lt;char&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="complex.TryFormat (destination, charsWritten, format, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryFormat(Span&lt;char&gt; destination, [Runtime::InteropServices::Out] int % charsWritten, ReadOnlySpan&lt;char&gt; format, IFormatProvider ^ provider);" FrameworkAlternate="net-7.0" />
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default, IFormatProvider? provider = default);" FrameworkAlternate="net-8.0;net-9.0" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = Nothing, Optional provider As IFormatProvider = Nothing) As Boolean" FrameworkAlternate="net-8.0;net-9.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ISpanFormattable.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="destination">The span in which to write this instance's value formatted as a span of characters.</param>
        <param name="charsWritten">When this method returns, contains the number of characters that were written in <paramref name="destination" />.</param>
        <param name="format">A span containing the characters that represent a standard or custom format string that defines the acceptable format for <paramref name="destination" />.</param>
        <param name="provider">An optional object that supplies culture-specific formatting information for <paramref name="destination" />.</param>
        <summary>Tries to format the value of the current instance into the provided span of characters.</summary>
        <returns>
          <see langword="true" /> if the formatting was successful; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

An implementation of this interface should produce the same string of characters as an implementation of <xref:System.IFormattable.ToString(System.String,System.IFormatProvider)> on the same type. `TryFormat` should return `false` only if there's not enough space in the destination buffer. Any other failures should throw an exception.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.ISpanFormattable.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider, out System.Numerics.Complex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, class System.IFormatProvider provider, [out] valuetype System.Numerics.Complex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Numerics.Complex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), provider As IFormatProvider, ByRef result As Complex) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * IFormatProvider * Complex -&gt; bool" Usage="System.Numerics.Complex.TryParse (s, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::Complex % result) = ISpanParsable&lt;System::Numerics::Complex&gt;::TryParse;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="result" Type="System.Numerics.Complex" RefType="out" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="s">The span of characters to parse.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <param name="result">When this method returns, contains the result of successfully parsing <paramref name="s" />, or an undefined value on failure.</param>
        <summary>Tries to parse a span of characters into a value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was successfully parsed; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.ISpanParsable`1.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,`0@)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string? s, IFormatProvider? provider, out System.Numerics.Complex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, class System.IFormatProvider provider, [out] valuetype System.Numerics.Complex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.TryParse(System.String,System.IFormatProvider,System.Numerics.Complex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, provider As IFormatProvider, ByRef result As Complex) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : string * IFormatProvider * Complex -&gt; bool" Usage="System.Numerics.Complex.TryParse (s, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::Complex % result) = IParsable&lt;System::Numerics::Complex&gt;::TryParse;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.Numerics.Complex" RefType="out" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="s">The string to parse.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <param name="result">When this method returns, contains the result of successfully parsing <paramref name="s" /> or an undefined value on failure.</param>
        <summary>Tries to parse a string into a value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was successfully parsed; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.IParsable`1.TryParse(System.String,System.IFormatProvider,`0@)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider? provider, out System.Numerics.Complex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.Complex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.Complex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Complex) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider * Complex -&gt; bool" Usage="System.Numerics.Complex.TryParse (s, style, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::Complex % result) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::TryParse;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="result" Type="System.Numerics.Complex" RefType="out" Index="3" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="s">The span of characters to parse.</param>
        <param name="style">A bitwise combination of number styles that can be present in <paramref name="s" />.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <param name="result">On return, contains the result of succesfully parsing <paramref name="s" /> or an undefined value on failure.</param>
        <summary>Tries to parse a span of characters into a value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was successfully parsed; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,`0@)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string? s, System.Globalization.NumberStyles style, IFormatProvider? provider, out System.Numerics.Complex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.Complex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.Complex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Complex) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider * Complex -&gt; bool" Usage="System.Numerics.Complex.TryParse (s, style, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::Complex % result) = System::Numerics::INumberBase&lt;System::Numerics::Complex&gt;::TryParse;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.Numerics.Complex" RefType="out" Index="3" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="s">The string to parse.</param>
        <param name="style">A bitwise combination of number styles that can be present in <paramref name="s" />.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <param name="result">On return, contains the result of succesfully parsing <paramref name="s" /> or an undefined value on failure.</param>
        <summary>Tries to parse a string into a value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was successfully parsed; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,`0@)" />
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex Zero" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Zero As Complex " />
      <MemberSignature Language="F#" Value=" staticval mutable Zero : System.Numerics.Complex" Usage="System.Numerics.Complex.Zero" />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex Zero;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to zero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Numerics.Complex.Zero> property is most frequently used to compare a <xref:System.Numerics.Complex> value to zero.

## Examples
 The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.Zero> property. It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to zero. As the output from the example shows, the two values are equal.

 :::code language="csharp" source="~/snippets/csharp/System.Numerics/Complex/Zero/zero1.cs" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/System.Numerics/Complex/Zero/zero1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.zero/vb/zero1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.One" />
      </Docs>
    </Member>
  </Members>
</Type>
