<Type Name="INumber&lt;TSelf&gt;" FullName="System.Numerics.INumber&lt;TSelf&gt;">
  <TypeSignature Language="C#" Value="public interface INumber&lt;TSelf&gt; : IComparable&lt;TSelf&gt;, IEquatable&lt;TSelf&gt;, IParsable&lt;TSelf&gt;, ISpanParsable&lt;TSelf&gt;, System.Numerics.IAdditionOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.IAdditiveIdentity&lt;TSelf,TSelf&gt;, System.Numerics.IComparisonOperators&lt;TSelf,TSelf&gt;, System.Numerics.IDecrementOperators&lt;TSelf&gt;, System.Numerics.IDivisionOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.IEqualityOperators&lt;TSelf,TSelf&gt;, System.Numerics.IIncrementOperators&lt;TSelf&gt;, System.Numerics.IModulusOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.IMultiplicativeIdentity&lt;TSelf,TSelf&gt;, System.Numerics.IMultiplyOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.INumberBase&lt;TSelf&gt;, System.Numerics.ISubtractionOperators&lt;TSelf,TSelf,TSelf&gt;, System.Numerics.IUnaryNegationOperators&lt;TSelf,TSelf&gt;, System.Numerics.IUnaryPlusOperators&lt;TSelf,TSelf&gt; where TSelf : INumber&lt;TSelf&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract INumber`1&lt;(class System.Numerics.INumber`1&lt;!TSelf&gt;) TSelf&gt; implements class System.IComparable, class System.IComparable`1&lt;!TSelf&gt;, class System.IEquatable`1&lt;!TSelf&gt;, class System.IFormattable, class System.IParsable`1&lt;!TSelf&gt;, class System.ISpanFormattable, class System.ISpanParsable`1&lt;!TSelf&gt;, class System.Numerics.IAdditionOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.IAdditiveIdentity`2&lt;!TSelf, !TSelf&gt;, class System.Numerics.IComparisonOperators`2&lt;!TSelf, !TSelf&gt;, class System.Numerics.IDecrementOperators`1&lt;!TSelf&gt;, class System.Numerics.IDivisionOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.IEqualityOperators`2&lt;!TSelf, !TSelf&gt;, class System.Numerics.IIncrementOperators`1&lt;!TSelf&gt;, class System.Numerics.IModulusOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;!TSelf, !TSelf&gt;, class System.Numerics.IMultiplyOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.INumberBase`1&lt;!TSelf&gt;, class System.Numerics.ISubtractionOperators`3&lt;!TSelf, !TSelf, !TSelf&gt;, class System.Numerics.IUnaryNegationOperators`2&lt;!TSelf, !TSelf&gt;, class System.Numerics.IUnaryPlusOperators`2&lt;!TSelf, !TSelf&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.INumber`1" />
  <TypeSignature Language="VB.NET" Value="Public Interface INumber(Of TSelf)&#xA;Implements IAdditionOperators(Of TSelf, TSelf, TSelf), IAdditiveIdentity(Of TSelf, TSelf), IComparable(Of TSelf), IComparisonOperators(Of TSelf, TSelf), IDecrementOperators(Of TSelf), IDivisionOperators(Of TSelf, TSelf, TSelf), IEqualityOperators(Of TSelf, TSelf), IEquatable(Of TSelf), IIncrementOperators(Of TSelf), IModulusOperators(Of TSelf, TSelf, TSelf), IMultiplicativeIdentity(Of TSelf, TSelf), IMultiplyOperators(Of TSelf, TSelf, TSelf), INumberBase(Of TSelf), IParsable(Of TSelf), ISpanParsable(Of TSelf), ISubtractionOperators(Of TSelf, TSelf, TSelf), IUnaryNegationOperators(Of TSelf, TSelf), IUnaryPlusOperators(Of TSelf, TSelf)" />
  <TypeSignature Language="F#" Value="type INumber&lt;'Self (requires 'Self :&gt; INumber&lt;'Self&gt;)&gt; = interface&#xA;    interface IComparable&#xA;    interface IComparable&lt;'Self (requires 'Self :&gt; INumber&lt;'Self&gt;)&gt;&#xA;    interface IEquatable&lt;'Self (requires 'Self :&gt; INumber&lt;'Self&gt;)&gt;&#xA;    interface IFormattable&#xA;    interface IParsable&lt;'Self (requires 'Self :&gt; INumber&lt;'Self&gt;)&gt;&#xA;    interface ISpanFormattable&#xA;    interface ISpanParsable&lt;'Self (requires 'Self :&gt; INumber&lt;'Self&gt;)&gt;&#xA;    interface IAdditionOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; INumber&lt;'Self&gt; and 'Self :&gt; INumber&lt;'Self&gt; and 'Self :&gt; INumber&lt;'Self&gt;)&gt;&#xA;    interface IAdditiveIdentity&lt;'Self, 'Self (requires 'Self :&gt; INumber&lt;'Self&gt; and 'Self :&gt; INumber&lt;'Self&gt;)&gt;&#xA;    interface IComparisonOperators&lt;'Self, 'Self (requires 'Self :&gt; INumber&lt;'Self&gt; and 'Self :&gt; INumber&lt;'Self&gt;)&gt;&#xA;    interface IEqualityOperators&lt;'Self, 'Self (requires 'Self :&gt; INumber&lt;'Self&gt; and 'Self :&gt; INumber&lt;'Self&gt;)&gt;&#xA;    interface IDecrementOperators&lt;'Self (requires 'Self :&gt; INumber&lt;'Self&gt;)&gt;&#xA;    interface IDivisionOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; INumber&lt;'Self&gt; and 'Self :&gt; INumber&lt;'Self&gt; and 'Self :&gt; INumber&lt;'Self&gt;)&gt;&#xA;    interface IIncrementOperators&lt;'Self (requires 'Self :&gt; INumber&lt;'Self&gt;)&gt;&#xA;    interface IModulusOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; INumber&lt;'Self&gt; and 'Self :&gt; INumber&lt;'Self&gt; and 'Self :&gt; INumber&lt;'Self&gt;)&gt;&#xA;    interface IMultiplicativeIdentity&lt;'Self, 'Self (requires 'Self :&gt; INumber&lt;'Self&gt; and 'Self :&gt; INumber&lt;'Self&gt;)&gt;&#xA;    interface IMultiplyOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; INumber&lt;'Self&gt; and 'Self :&gt; INumber&lt;'Self&gt; and 'Self :&gt; INumber&lt;'Self&gt;)&gt;&#xA;    interface INumberBase&lt;'Self (requires 'Self :&gt; INumber&lt;'Self&gt;)&gt;&#xA;    interface ISubtractionOperators&lt;'Self, 'Self, 'Self (requires 'Self :&gt; INumber&lt;'Self&gt; and 'Self :&gt; INumber&lt;'Self&gt; and 'Self :&gt; INumber&lt;'Self&gt;)&gt;&#xA;    interface IUnaryNegationOperators&lt;'Self, 'Self (requires 'Self :&gt; INumber&lt;'Self&gt; and 'Self :&gt; INumber&lt;'Self&gt;)&gt;&#xA;    interface IUnaryPlusOperators&lt;'Self, 'Self (requires 'Self :&gt; INumber&lt;'Self&gt; and 'Self :&gt; INumber&lt;'Self&gt;)&gt;" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TSelf&gt;&#xA; where TSelf : INumber&lt;TSelf&gt;public interface class INumber : IComparable&lt;TSelf&gt;, IEquatable&lt;TSelf&gt;, IParsable&lt;TSelf&gt;, ISpanParsable&lt;TSelf&gt;, System::Numerics::IAdditionOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::IAdditiveIdentity&lt;TSelf, TSelf&gt;, System::Numerics::IComparisonOperators&lt;TSelf, TSelf&gt;, System::Numerics::IDecrementOperators&lt;TSelf&gt;, System::Numerics::IDivisionOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::IEqualityOperators&lt;TSelf, TSelf&gt;, System::Numerics::IIncrementOperators&lt;TSelf&gt;, System::Numerics::IModulusOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::IMultiplicativeIdentity&lt;TSelf, TSelf&gt;, System::Numerics::IMultiplyOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::INumberBase&lt;TSelf&gt;, System::Numerics::ISubtractionOperators&lt;TSelf, TSelf, TSelf&gt;, System::Numerics::IUnaryNegationOperators&lt;TSelf, TSelf&gt;, System::Numerics::IUnaryPlusOperators&lt;TSelf, TSelf&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TSelf">
      <Constraints>
        <InterfaceName>System.Numerics.INumber&lt;TSelf&gt;</InterfaceName>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;TOther&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;TOther&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IParsable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ISpanFormattable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ISpanParsable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IAdditionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IAdditiveIdentity&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IComparisonOperators&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IDecrementOperators&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IDivisionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IEqualityOperators&lt;TSelf,TOther&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IEqualityOperators&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IIncrementOperators&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IModulusOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IMultiplyOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.INumberBase&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.ISubtractionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IUnaryNegationOperators&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Numerics.IUnaryPlusOperators&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <typeparam name="TSelf">The type that implements the interface.</typeparam>
    <summary>Defines a number type.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static TSelf Abs (TSelf value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf Abs(!TSelf value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumber`1.Abs(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As TSelf) As TSelf" />
      <MemberSignature Language="F#" Value="static member Abs : 'Self -&gt; 'Self" Usage="System.Numerics.INumber&lt;'Self (requires 'Self :&gt; System.Numerics.INumber&lt;'Self&gt;)&gt;.Abs value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TSelf Abs(TSelf value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="value">The value to get the absolute of.</param>
        <summary>Computes the absolute of a value.</summary>
        <returns>The absolute of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OverflowException">The absolute of <paramref name="value" /> is not representable by <typeparamref name="TSelf" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static override TSelf Clamp (TSelf value, TSelf min, TSelf max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf Clamp(!TSelf value, !TSelf min, !TSelf max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumber`1.Clamp(`0,`0,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Overrides Function Clamp (value As TSelf, min As TSelf, max As TSelf) As TSelf" />
      <MemberSignature Language="F#" Value="static member Clamp : 'Self * 'Self * 'Self -&gt; 'Self" Usage="System.Numerics.INumber&lt;'Self (requires 'Self :&gt; System.Numerics.INumber&lt;'Self&gt;)&gt;.Clamp (value, min, max)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static override TSelf Clamp(TSelf value, TSelf min, TSelf max);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
        <Parameter Name="min" Type="TSelf" />
        <Parameter Name="max" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="value">The value to clamp.</param>
        <param name="min">The inclusive minimum to which <paramref name="value" /> should clamp.</param>
        <param name="max">The inclusive maximum to which <paramref name="value" /> should clamp.</param>
        <summary>Clamps a value to an inclusive minimum and maximum value.</summary>
        <returns>The result of clamping <paramref name="value" /> to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="min" /> is greater than <paramref name="max" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopySign">
      <MemberSignature Language="C#" Value="public static override TSelf CopySign (TSelf value, TSelf sign);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf CopySign(!TSelf value, !TSelf sign) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumber`1.CopySign(`0,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Overrides Function CopySign (value As TSelf, sign As TSelf) As TSelf" />
      <MemberSignature Language="F#" Value="static member CopySign : 'Self * 'Self -&gt; 'Self" Usage="System.Numerics.INumber&lt;'Self (requires 'Self :&gt; System.Numerics.INumber&lt;'Self&gt;)&gt;.CopySign (value, sign)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static override TSelf CopySign(TSelf value, TSelf sign);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
        <Parameter Name="sign" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="value">The value whose magnitude is used in the result.</param>
        <param name="sign">The value whose sign is used in the result.</param>
        <summary>Copies the sign of a value to the sign of another value..</summary>
        <returns>A value with the magnitude of <paramref name="value" /> and the sign of <paramref name="sign" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateChecked&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="public static TSelf CreateChecked&lt;TOther&gt; (TOther value) where TOther : System.Numerics.INumber&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf CreateChecked&lt;(class System.Numerics.INumber`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumber`1.CreateChecked``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateChecked(Of TOther As INumber(Of TOther)) (value As TOther) As TSelf" />
      <MemberSignature Language="F#" Value="static member CreateChecked : 'Other -&gt; 'Self (requires 'Other :&gt; System.Numerics.INumber&lt;'Other&gt;)" Usage="System.Numerics.INumber&lt;'Self (requires 'Self :&gt; System.Numerics.INumber&lt;'Self&gt;)&gt;.CreateChecked value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumber&lt;TOther&gt; static TSelf CreateChecked(TOther value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type of <paramref name="value" />.</typeparam>
        <param name="value">The value which is used to create the instance of <typeparamref name="TSelf" />.</param>
        <summary>Creates an instance of the current type from a value, throwing an overflow exception for any values that fall outside the representable range of the current type.</summary>
        <returns>An instance of <typeparamref name="TSelf" /> created from <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <typeparamref name="TOther" /> is not supported.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> is not representable by <typeparamref name="TSelf" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateSaturating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="public static TSelf CreateSaturating&lt;TOther&gt; (TOther value) where TOther : System.Numerics.INumber&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf CreateSaturating&lt;(class System.Numerics.INumber`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumber`1.CreateSaturating``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSaturating(Of TOther As INumber(Of TOther)) (value As TOther) As TSelf" />
      <MemberSignature Language="F#" Value="static member CreateSaturating : 'Other -&gt; 'Self (requires 'Other :&gt; System.Numerics.INumber&lt;'Other&gt;)" Usage="System.Numerics.INumber&lt;'Self (requires 'Self :&gt; System.Numerics.INumber&lt;'Self&gt;)&gt;.CreateSaturating value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumber&lt;TOther&gt; static TSelf CreateSaturating(TOther value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type of <paramref name="value" />.</typeparam>
        <param name="value">The value which is used to create the instance of <typeparamref name="TSelf" />.</param>
        <summary>Creates an instance of the current type from a value, saturating any values that fall outside the representable range of the current type.</summary>
        <returns>An instance of <typeparamref name="TSelf" /> created from <paramref name="value" />, saturating if <paramref name="value" /> falls outside the representable range of <typeparamref name="TSelf" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <typeparamref name="TOther" /> is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateTruncating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="public static TSelf CreateTruncating&lt;TOther&gt; (TOther value) where TOther : System.Numerics.INumber&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf CreateTruncating&lt;(class System.Numerics.INumber`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumber`1.CreateTruncating``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateTruncating(Of TOther As INumber(Of TOther)) (value As TOther) As TSelf" />
      <MemberSignature Language="F#" Value="static member CreateTruncating : 'Other -&gt; 'Self (requires 'Other :&gt; System.Numerics.INumber&lt;'Other&gt;)" Usage="System.Numerics.INumber&lt;'Self (requires 'Self :&gt; System.Numerics.INumber&lt;'Self&gt;)&gt;.CreateTruncating value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumber&lt;TOther&gt; static TSelf CreateTruncating(TOther value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type of <paramref name="value" />.</typeparam>
        <param name="value">The value which is used to create the instance of <typeparamref name="TSelf" />.</param>
        <summary>Creates an instance of the current type from a value, truncating any values that fall outside the representable range of the current type.</summary>
        <returns>An instance of <typeparamref name="TSelf" /> created from <paramref name="value" />, truncating if <paramref name="value" /> falls outside the representable range of <typeparamref name="TSelf" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <typeparamref name="TOther" /> is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (TSelf value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual bool IsNegative(!TSelf value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumber`1.IsNegative(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (value As TSelf) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsNegative : 'Self -&gt; bool" Usage="System.Numerics.INumber&lt;'Self (requires 'Self :&gt; System.Numerics.INumber&lt;'Self&gt;)&gt;.IsNegative value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(TSelf value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is negative.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is negative; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static override TSelf Max (TSelf x, TSelf y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf Max(!TSelf x, !TSelf y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumber`1.Max(`0,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Overrides Function Max (x As TSelf, y As TSelf) As TSelf" />
      <MemberSignature Language="F#" Value="static member Max : 'Self * 'Self -&gt; 'Self" Usage="System.Numerics.INumber&lt;'Self (requires 'Self :&gt; System.Numerics.INumber&lt;'Self&gt;)&gt;.Max (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static override TSelf Max(TSelf x, TSelf y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="TSelf" />
        <Parameter Name="y" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is greater.</summary>
        <returns>
          <paramref name="x" /> if it is greater than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For <xref:System.Numerics.IFloatingPoint%601>, this method matches the IEEE 754:2019 `maximum` function. This requires NaN inputs to be propagated back to the caller and for `-0.0` to be treated as less than `+0.0`.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude">
      <MemberSignature Language="C#" Value="public static TSelf MaxMagnitude (TSelf x, TSelf y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf MaxMagnitude(!TSelf x, !TSelf y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumber`1.MaxMagnitude(`0,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MaxMagnitude (x As TSelf, y As TSelf) As TSelf" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : 'Self * 'Self -&gt; 'Self" Usage="System.Numerics.INumber&lt;'Self (requires 'Self :&gt; System.Numerics.INumber&lt;'Self&gt;)&gt;.MaxMagnitude (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TSelf MaxMagnitude(TSelf x, TSelf y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="TSelf" />
        <Parameter Name="y" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is greater.</summary>
        <returns>
          <paramref name="x" /> if it is greater than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For <xref:System.Numerics.IFloatingPointIeee754%601>, this method matches the IEEE 754:2019 `maximumMagnitude` function. This requires NaN inputs to not be propagated back to the caller and for `-0.0` to be treated as less than `+0.0`.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNumber">
      <MemberSignature Language="C#" Value="public static override TSelf MaxNumber (TSelf x, TSelf y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf MaxNumber(!TSelf x, !TSelf y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumber`1.MaxNumber(`0,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Overrides Function MaxNumber (x As TSelf, y As TSelf) As TSelf" />
      <MemberSignature Language="F#" Value="static member MaxNumber : 'Self * 'Self -&gt; 'Self" Usage="System.Numerics.INumber&lt;'Self (requires 'Self :&gt; System.Numerics.INumber&lt;'Self&gt;)&gt;.MaxNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static override TSelf MaxNumber(TSelf x, TSelf y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="TSelf" />
        <Parameter Name="y" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is greater and returning the other value if an input is <c>NaN</c>.</summary>
        <returns>
          <paramref name="x" /> if it is greater than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For <xref:System.Numerics.IFloatingPoint%601> this method matches the IEEE 754:2019 `maximumNumber` function. This requires NaN inputs to not be propagated back to the caller and for `-0.0` to be treated as less than `+0.0`.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static override TSelf Min (TSelf x, TSelf y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf Min(!TSelf x, !TSelf y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumber`1.Min(`0,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Overrides Function Min (x As TSelf, y As TSelf) As TSelf" />
      <MemberSignature Language="F#" Value="static member Min : 'Self * 'Self -&gt; 'Self" Usage="System.Numerics.INumber&lt;'Self (requires 'Self :&gt; System.Numerics.INumber&lt;'Self&gt;)&gt;.Min (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static override TSelf Min(TSelf x, TSelf y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="TSelf" />
        <Parameter Name="y" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is lesser.</summary>
        <returns>
          <paramref name="x" /> if it is less than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For <xref:System.Numerics.IFloatingPoint%601>, this method matches the IEEE 754:2019 `minimum` function. This requires NaN inputs to be propagated back to the caller and for `-0.0` to be treated as less than `+0.0`.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude">
      <MemberSignature Language="C#" Value="public static TSelf MinMagnitude (TSelf x, TSelf y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf MinMagnitude(!TSelf x, !TSelf y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumber`1.MinMagnitude(`0,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MinMagnitude (x As TSelf, y As TSelf) As TSelf" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : 'Self * 'Self -&gt; 'Self" Usage="System.Numerics.INumber&lt;'Self (requires 'Self :&gt; System.Numerics.INumber&lt;'Self&gt;)&gt;.MinMagnitude (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TSelf MinMagnitude(TSelf x, TSelf y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="TSelf" />
        <Parameter Name="y" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is lesser.</summary>
        <returns>
          <paramref name="x" /> if it is less than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For <xref:System.Numerics.IFloatingPointIeee754%601>, this method matches the IEEE 754:2019 `minimumMagnitude` function. This requires NaN inputs to not be propagated back to the caller and for `-0.0` to be treated as less than `+0.0`.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinNumber">
      <MemberSignature Language="C#" Value="public static override TSelf MinNumber (TSelf x, TSelf y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf MinNumber(!TSelf x, !TSelf y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumber`1.MinNumber(`0,`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Overrides Function MinNumber (x As TSelf, y As TSelf) As TSelf" />
      <MemberSignature Language="F#" Value="static member MinNumber : 'Self * 'Self -&gt; 'Self" Usage="System.Numerics.INumber&lt;'Self (requires 'Self :&gt; System.Numerics.INumber&lt;'Self&gt;)&gt;.MinNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static override TSelf MinNumber(TSelf x, TSelf y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="TSelf" />
        <Parameter Name="y" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is lesser and returning the other value if an input is <c>NaN</c>.</summary>
        <returns>
          <paramref name="x" /> if it is less than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For <xref:System.Numerics.IFloatingPoint%601> this method matches the IEEE 754:2019 `minimumNumber` function. This requires NaN inputs to not be propagated back to the caller and for `-0.0` to be treated as less than `+0.0`.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static TSelf Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider? provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumber`1.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider) As TSelf" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; 'Self" Usage="System.Numerics.INumber&lt;'Self (requires 'Self :&gt; System.Numerics.INumber&lt;'Self&gt;)&gt;.Parse (s, style, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TSelf Parse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">The span of characters to parse.</param>
        <param name="style">A bitwise combination of number styles that can be present in <paramref name="s" />.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <summary>Parses a span of characters into a value.</summary>
        <returns>The result of parsing <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> is not a supported <see cref="T:System.Globalization.NumberStyles" /> value.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> is not in the correct format.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> is not representable by <typeparamref name="TSelf" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static TSelf Parse (string s, System.Globalization.NumberStyles style, IFormatProvider? provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual !TSelf Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumber`1.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As TSelf" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; 'Self" Usage="System.Numerics.INumber&lt;'Self (requires 'Self :&gt; System.Numerics.INumber&lt;'Self&gt;)&gt;.Parse (s, style, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TSelf Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSelf</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">The string to parse.</param>
        <param name="style">A bitwise combination of number styles that can be present in <paramref name="s" />.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <summary>Parses a string into a value.</summary>
        <returns>The result of parsing <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> is not a supported <see cref="T:System.Globalization.NumberStyles" /> value.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> is not in the correct format.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> is not representable by <typeparamref name="TSelf" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static override int Sign (TSelf value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual int32 Sign(!TSelf value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumber`1.Sign(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Overrides Function Sign (value As TSelf) As Integer" />
      <MemberSignature Language="F#" Value="static member Sign : 'Self -&gt; int" Usage="System.Numerics.INumber&lt;'Self (requires 'Self :&gt; System.Numerics.INumber&lt;'Self&gt;)&gt;.Sign value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static override int Sign(TSelf value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="TSelf" />
      </Parameters>
      <Docs>
        <param name="value">The value whose sign is to be computed.</param>
        <summary>Computes the sign of a value.</summary>
        <returns>A positive value if <paramref name="value" /> is positive, <see cref="P:System.Numerics.INumberBase`1.Zero" /> if <paramref name="value" /> is zero, and a negative value if <paramref name="value" /> is negative.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

It is recommended that a function return `1`, `0`, and `-1`, respectively.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="public static bool TryCreate&lt;TOther&gt; (TOther value, out TSelf result) where TOther : System.Numerics.INumber&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual bool TryCreate&lt;(class System.Numerics.INumber`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value, [out] !TSelf&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumber`1.TryCreate``1(``0,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate(Of TOther As INumber(Of TOther)) (value As TOther, ByRef result As TSelf) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryCreate : 'Other * 'Self -&gt; bool (requires 'Other :&gt; System.Numerics.INumber&lt;'Other&gt;)" Usage="System.Numerics.INumber&lt;'Self (requires 'Self :&gt; System.Numerics.INumber&lt;'Self&gt;)&gt;.TryCreate (value, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumber&lt;TOther&gt; static bool TryCreate(TOther value, [Runtime::InteropServices::Out] TSelf % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumber&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" />
        <Parameter Name="result" Type="TSelf" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type of <paramref name="value" />.</typeparam>
        <param name="value">The value which is used to create the instance of <typeparamref name="TSelf" />.</param>
        <param name="result">When this method returns, contains the result of successfully creating an instance of <typeparamref name="TSelf" /> from <paramref name="value" />, or an undefined value on failure.</param>
        <summary>Tries to create an instance of the current type from a value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> an instance of the current type was succesfully created from <paramref name="value" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <typeparamref name="TOther" /> is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider? provider, out TSelf result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] !TSelf&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumber`1.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As TSelf) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider * 'Self -&gt; bool" Usage="System.Numerics.INumber&lt;'Self (requires 'Self :&gt; System.Numerics.INumber&lt;'Self&gt;)&gt;.TryParse (s, style, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] TSelf % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="TSelf" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">The span of characters to parse.</param>
        <param name="style">A bitwise combination of number styles that can be present in <paramref name="s" />.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <param name="result">When this method returns, contains the result of successfully parsing <paramref name="s" />, or an undefined value on failure.</param>
        <summary>Tries to parses a span of characters into a value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was successfully parsed; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> is not a supported <see cref="T:System.Globalization.NumberStyles" /> value.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string? s, System.Globalization.NumberStyles style, IFormatProvider? provider, out TSelf result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig virtual bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] !TSelf&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.INumber`1.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As TSelf) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider * 'Self -&gt; bool" Usage="System.Numerics.INumber&lt;'Self (requires 'Self :&gt; System.Numerics.INumber&lt;'Self&gt;)&gt;.TryParse (s, style, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] TSelf % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="TSelf" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">The string to parse.</param>
        <param name="style">A bitwise combination of number styles that can be present in <paramref name="s" />.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <param name="result">When this method returns, contains the result of successfully parsing <paramref name="s" />, or an undefined value on failure.</param>
        <summary>Tries to parses a string into a value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was successfully parsed; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> is not a supported <see cref="T:System.Globalization.NumberStyles" /> value.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
