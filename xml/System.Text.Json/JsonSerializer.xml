<Type Name="JsonSerializer" FullName="System.Text.Json.JsonSerializer">
  <TypeSignature Language="C#" Value="public static class JsonSerializer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit JsonSerializer extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Text.Json.JsonSerializer" />
  <TypeSignature Language="VB.NET" Value="Public Class JsonSerializer" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
  <TypeSignature Language="F#" Value="type JsonSerializer = class" />
  <TypeSignature Language="C++ CLI" Value="public ref class JsonSerializer abstract sealed" />
  <TypeSignature Language="VB.NET" Value="Public Module JsonSerializer" FrameworkAlternate="net-6.0;net-7.0" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Json</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Provides functionality to serialize objects or value types to JSON and to deserialize JSON into objects or value types.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks

For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to).

 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public static object? Deserialize (System.IO.Stream utf8Json, Type returnType, System.Text.Json.JsonSerializerOptions? options = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Deserialize(class System.IO.Stream utf8Json, class System.Type returnType, class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize(System.IO.Stream,System.Type,System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Deserialize (utf8Json As Stream, returnType As Type, Optional options As JsonSerializerOptions = Nothing) As Object" />
      <MemberSignature Language="F#" Value="static member Deserialize : System.IO.Stream * Type * System.Text.Json.JsonSerializerOptions -&gt; obj" Usage="System.Text.Json.JsonSerializer.Deserialize (utf8Json, returnType, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Json" Type="System.IO.Stream" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <param name="utf8Json">JSON data to parse.</param>
        <param name="returnType">The type of the object to convert to and return.</param>
        <param name="options">Options to control the behavior during reading.</param>
        <summary>Reads the UTF-8 encoded text representing a single JSON value into a <paramref name="returnType" />.
            The Stream will be read to completion.</summary>
        <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="utf8Json" /> or <paramref name="returnType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.Json.JsonException">The JSON is invalid, the <paramref name="returnType" /> is not compatible with the JSON, or there is remaining data in the Stream.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <paramref name="returnType" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public static object? Deserialize (System.IO.Stream utf8Json, Type returnType, System.Text.Json.Serialization.JsonSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Deserialize(class System.IO.Stream utf8Json, class System.Type returnType, class System.Text.Json.Serialization.JsonSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize(System.IO.Stream,System.Type,System.Text.Json.Serialization.JsonSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function Deserialize (utf8Json As Stream, returnType As Type, context As JsonSerializerContext) As Object" />
      <MemberSignature Language="F#" Value="static member Deserialize : System.IO.Stream * Type * System.Text.Json.Serialization.JsonSerializerContext -&gt; obj" Usage="System.Text.Json.JsonSerializer.Deserialize (utf8Json, returnType, context)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Deserialize(System::IO::Stream ^ utf8Json, Type ^ returnType, System::Text::Json::Serialization::JsonSerializerContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Json" Type="System.IO.Stream" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="context" Type="System.Text.Json.Serialization.JsonSerializerContext" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <param name="utf8Json">JSON data to parse.</param>
        <param name="returnType">The type of the object to convert to and return.</param>
        <param name="context">A metadata provider for serializable types.</param>
        <summary>Reads the UTF-8 encoded text representing a single JSON value into a <paramref name="returnType" />.
            The Stream will be read to completion.</summary>
        <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="utf8Json" />, <paramref name="returnType" />, or <paramref name="context" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.Json.JsonException">The JSON is invalid, the <paramref name="returnType" /> is not compatible with the JSON, or there is remaining data in the Stream.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <paramref name="returnType" /> or its serializable members.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Text.Json.Serialization.JsonSerializerContext.GetTypeInfo(System.Type)" /> method on the provided <paramref name="context" /> did not return a compatible <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> for <paramref name="returnType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public static object? Deserialize (ReadOnlySpan&lt;byte&gt; utf8Json, Type returnType, System.Text.Json.JsonSerializerOptions? options = default);" FrameworkAlternate="net-5.0;net-6.0;net-7.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Deserialize(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Json, class System.Type returnType, class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize(System.ReadOnlySpan{System.Byte},System.Type,System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Deserialize (utf8Json As ReadOnlySpan(Of Byte), returnType As Type, Optional options As JsonSerializerOptions = Nothing) As Object" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="F#" Value="static member Deserialize : ReadOnlySpan&lt;byte&gt; * Type * System.Text.Json.JsonSerializerOptions -&gt; obj" Usage="System.Text.Json.JsonSerializer.Deserialize (utf8Json, returnType, options)" />
      <MemberSignature Language="VB.NET" Value="Public Function Deserialize (utf8Json As ReadOnlySpan(Of Byte), returnType As Type, Optional options As JsonSerializerOptions = Nothing) As Object" FrameworkAlternate="net-6.0;net-7.0" />
      <MemberSignature Language="C#" Value="public static object Deserialize (ReadOnlySpan&lt;byte&gt; utf8Json, Type returnType, System.Text.Json.JsonSerializerOptions options = default);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Json" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="returnType" Type="System.Type">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
      </Parameters>
      <Docs>
        <param name="utf8Json">The JSON text to parse.</param>
        <param name="returnType">The type of the object to convert to and return.</param>
        <param name="options">Options to control the behavior during parsing.</param>
        <summary>Parses the UTF-8 encoded text representing a single JSON value into an instance of a specified type.</summary>
        <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to).

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="returnType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.Json.JsonException">The JSON is invalid.

-or-

<typeparamref name="returnType" /> is not compatible with the JSON.

-or-

There is remaining data in the span beyond a single JSON value.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="System.Text.Json.Serialization.JsonConverter" /> for <paramref name="returnType" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public static object? Deserialize (ReadOnlySpan&lt;byte&gt; utf8Json, Type returnType, System.Text.Json.Serialization.JsonSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Deserialize(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Json, class System.Type returnType, class System.Text.Json.Serialization.JsonSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize(System.ReadOnlySpan{System.Byte},System.Type,System.Text.Json.Serialization.JsonSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function Deserialize (utf8Json As ReadOnlySpan(Of Byte), returnType As Type, context As JsonSerializerContext) As Object" />
      <MemberSignature Language="F#" Value="static member Deserialize : ReadOnlySpan&lt;byte&gt; * Type * System.Text.Json.Serialization.JsonSerializerContext -&gt; obj" Usage="System.Text.Json.JsonSerializer.Deserialize (utf8Json, returnType, context)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Deserialize(ReadOnlySpan&lt;System::Byte&gt; utf8Json, Type ^ returnType, System::Text::Json::Serialization::JsonSerializerContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Json" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="context" Type="System.Text.Json.Serialization.JsonSerializerContext" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <param name="utf8Json">JSON text to parse.</param>
        <param name="returnType">The type of the object to convert to and return.</param>
        <param name="context">A metadata provider for serializable types.</param>
        <summary>Parses the UTF-8 encoded text representing a single JSON value into a <paramref name="returnType" />.</summary>
        <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="returnType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.Json.JsonException">The JSON is invalid, <paramref name="returnType" /> is not compatible with the JSON, or there is remaining data in the Stream.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <paramref name="returnType" /> or its serializable members.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Text.Json.Serialization.JsonSerializerContext.GetTypeInfo(System.Type)" /> method on the provided <paramref name="context" /> did not return a compatible <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> for <paramref name="returnType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public static object? Deserialize (ReadOnlySpan&lt;char&gt; json, Type returnType, System.Text.Json.JsonSerializerOptions? options = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Deserialize(valuetype System.ReadOnlySpan`1&lt;char&gt; json, class System.Type returnType, class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize(System.ReadOnlySpan{System.Char},System.Type,System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Deserialize (json As ReadOnlySpan(Of Char), returnType As Type, Optional options As JsonSerializerOptions = Nothing) As Object" />
      <MemberSignature Language="F#" Value="static member Deserialize : ReadOnlySpan&lt;char&gt; * Type * System.Text.Json.JsonSerializerOptions -&gt; obj" Usage="System.Text.Json.JsonSerializer.Deserialize (json, returnType, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="json" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-6.0;net-7.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-7.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("Json")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("Json")&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <param name="json">The JSON text to parse.</param>
        <param name="returnType">The type of the object to convert to and return.</param>
        <param name="options">Options to control the behavior during parsing.</param>
        <summary>Parses the text representing a single JSON value into an instance of a specified type.</summary>
        <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Using a UTF-16 span is not as efficient as using the
             UTF-8 methods since the implementation natively uses UTF-8.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="returnType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.Json.JsonException">The JSON is invalid.

-or-

<paramref name="returnType" /> is not compatible with the JSON.

-or-

There is remaining data in the span beyond a single JSON value.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <paramref name="returnType" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public static object? Deserialize (ReadOnlySpan&lt;char&gt; json, Type returnType, System.Text.Json.Serialization.JsonSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Deserialize(valuetype System.ReadOnlySpan`1&lt;char&gt; json, class System.Type returnType, class System.Text.Json.Serialization.JsonSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize(System.ReadOnlySpan{System.Char},System.Type,System.Text.Json.Serialization.JsonSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function Deserialize (json As ReadOnlySpan(Of Char), returnType As Type, context As JsonSerializerContext) As Object" />
      <MemberSignature Language="F#" Value="static member Deserialize : ReadOnlySpan&lt;char&gt; * Type * System.Text.Json.Serialization.JsonSerializerContext -&gt; obj" Usage="System.Text.Json.JsonSerializer.Deserialize (json, returnType, context)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Deserialize(ReadOnlySpan&lt;char&gt; json, Type ^ returnType, System::Text::Json::Serialization::JsonSerializerContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="json" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-6.0;net-7.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-7.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("Json")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("Json")&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="context" Type="System.Text.Json.Serialization.JsonSerializerContext" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <param name="json">JSON text to parse.</param>
        <param name="returnType">The type of the object to convert to and return.</param>
        <param name="context">A metadata provider for serializable types.</param>
        <summary>Parses the text representing a single JSON value into a <paramref name="returnType" />.</summary>
        <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Using a <xref:System.String> is not as efficient as using the
             UTF-8 methods since the implementation natively uses UTF-8.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="json" /> or <paramref name="returnType" /> is <see langword="null" />.

-or-

<paramref name="context" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.Json.JsonException">The JSON is invalid.

-or-

<paramref name="returnType" /> is not compatible with the JSON.

-or-

There is remaining data in the string beyond a single JSON value.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <paramref name="returnType" /> or its serializable members.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Text.Json.Serialization.JsonSerializerContext.GetTypeInfo(System.Type)" /> method of the provided <paramref name="context" /> returns <see langword="null" /> for the type to convert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public static object? Deserialize (string json, Type returnType, System.Text.Json.JsonSerializerOptions? options = default);" FrameworkAlternate="net-5.0;net-6.0;net-7.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Deserialize(string json, class System.Type returnType, class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize(System.String,System.Type,System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Deserialize (json As String, returnType As Type, Optional options As JsonSerializerOptions = Nothing) As Object" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="F#" Value="static member Deserialize : string * Type * System.Text.Json.JsonSerializerOptions -&gt; obj" Usage="System.Text.Json.JsonSerializer.Deserialize (json, returnType, options)" />
      <MemberSignature Language="VB.NET" Value="Public Function Deserialize (json As String, returnType As Type, Optional options As JsonSerializerOptions = Nothing) As Object" FrameworkAlternate="net-6.0;net-7.0" />
      <MemberSignature Language="C#" Value="public static object Deserialize (string json, Type returnType, System.Text.Json.JsonSerializerOptions options = default);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="json" Type="System.String">
          <Attributes>
            <Attribute FrameworkAlternate="net-7.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("Json")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("Json")&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="returnType" Type="System.Type">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
      </Parameters>
      <Docs>
        <param name="json">The JSON text to parse.</param>
        <param name="returnType">The type of the object to convert to and return.</param>
        <param name="options">Options to control the behavior during parsing.</param>
        <summary>Parses the text representing a single JSON value into an instance of a specified type.</summary>
        <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Using a <xref:System.String> is not as efficient as using the
UTF-8 methods since the implementation natively uses UTF-8.

For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to).

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="json" /> or <paramref name="returnType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.Json.JsonException">The JSON is invalid.

-or-

<typeparamref name="TValue" /> is not compatible with the JSON.

-or-

There is remaining data in the string beyond a single JSON value.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="System.Text.Json.Serialization.JsonConverter" /> for <paramref name="returnType" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public static object? Deserialize (string json, Type returnType, System.Text.Json.Serialization.JsonSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Deserialize(string json, class System.Type returnType, class System.Text.Json.Serialization.JsonSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize(System.String,System.Type,System.Text.Json.Serialization.JsonSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function Deserialize (json As String, returnType As Type, context As JsonSerializerContext) As Object" />
      <MemberSignature Language="F#" Value="static member Deserialize : string * Type * System.Text.Json.Serialization.JsonSerializerContext -&gt; obj" Usage="System.Text.Json.JsonSerializer.Deserialize (json, returnType, context)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Deserialize(System::String ^ json, Type ^ returnType, System::Text::Json::Serialization::JsonSerializerContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="json" Type="System.String" Index="0" FrameworkAlternate="net-6.0;net-7.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-7.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("Json")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("Json")&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="context" Type="System.Text.Json.Serialization.JsonSerializerContext" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <param name="json">JSON text to parse.</param>
        <param name="returnType">The type of the object to convert to and return.</param>
        <param name="context">A metadata provider for serializable types.</param>
        <summary>Parses the text representing a single JSON value into a <paramref name="returnType" />.</summary>
        <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Using a <xref:System.String> is not as efficient as using the
             UTF-8 methods since the implementation natively uses UTF-8.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="json" /> or <paramref name="returnType" /> is <see langword="null" />.

-or-

<paramref name="context" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.Json.JsonException">The JSON is invalid.

-or-

<paramref name="returnType" /> is not compatible with the JSON.

-or-

There is remaining data in the string beyond a single JSON value.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <paramref name="returnType" /> or its serializable members.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Text.Json.Serialization.JsonSerializerContext.GetTypeInfo(System.Type)" /> method of the provided <paramref name="context" /> returns <see langword="null" /> for the type to convert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public static object? Deserialize (this System.Text.Json.JsonDocument document, Type returnType, System.Text.Json.JsonSerializerOptions? options = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Deserialize(class System.Text.Json.JsonDocument document, class System.Type returnType, class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize(System.Text.Json.JsonDocument,System.Type,System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Deserialize (document As JsonDocument, returnType As Type, Optional options As JsonSerializerOptions = Nothing) As Object" />
      <MemberSignature Language="F#" Value="static member Deserialize : System.Text.Json.JsonDocument * Type * System.Text.Json.JsonSerializerOptions -&gt; obj" Usage="System.Text.Json.JsonSerializer.Deserialize (document, returnType, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Text.Json.JsonDocument" RefType="this" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <param name="document">The <see cref="T:System.Text.Json.JsonDocument" /> to convert.</param>
        <param name="returnType">The type of the object to convert to and return.</param>
        <param name="options">Options to control the behavior during parsing.</param>
        <summary>Converts the <see cref="T:System.Text.Json.JsonDocument" /> representing a single JSON value into a <paramref name="returnType" />.</summary>
        <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="document" /> or <paramref name="returnType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.Json.JsonException">
          <paramref name="returnType" /> is not compatible with the JSON.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <paramref name="returnType" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public static object? Deserialize (this System.Text.Json.JsonDocument document, Type returnType, System.Text.Json.Serialization.JsonSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Deserialize(class System.Text.Json.JsonDocument document, class System.Type returnType, class System.Text.Json.Serialization.JsonSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize(System.Text.Json.JsonDocument,System.Type,System.Text.Json.Serialization.JsonSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Deserialize (document As JsonDocument, returnType As Type, context As JsonSerializerContext) As Object" />
      <MemberSignature Language="F#" Value="static member Deserialize : System.Text.Json.JsonDocument * Type * System.Text.Json.Serialization.JsonSerializerContext -&gt; obj" Usage="System.Text.Json.JsonSerializer.Deserialize (document, returnType, context)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Object ^ Deserialize(System::Text::Json::JsonDocument ^ document, Type ^ returnType, System::Text::Json::Serialization::JsonSerializerContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Text.Json.JsonDocument" RefType="this" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="context" Type="System.Text.Json.Serialization.JsonSerializerContext" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <param name="document">The <see cref="T:System.Text.Json.JsonDocument" /> to convert.</param>
        <param name="returnType">The type of the object to convert to and return.</param>
        <param name="context">A metadata provider for serializable types.</param>
        <summary>Converts the <see cref="T:System.Text.Json.JsonDocument" /> representing a single JSON value into a <paramref name="returnType" />.</summary>
        <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="document" /> is <see langword="null" />.

-or-

<paramref name="returnType" /> is <see langword="null" />.

-or-

<paramref name="context" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.Json.JsonException">The JSON is invalid.

-or-

<paramref name="returnType" /> is not compatible with the JSON.

-or-

There is remaining data in the string beyond a single JSON value.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <paramref name="returnType" /> or its serializable members.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Text.Json.Serialization.JsonSerializerContext.GetTypeInfo(System.Type)" /> method of the provided <paramref name="context" /> returns <see langword="null" /> for the type to convert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public static object? Deserialize (this System.Text.Json.JsonElement element, Type returnType, System.Text.Json.JsonSerializerOptions? options = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Deserialize(valuetype System.Text.Json.JsonElement element, class System.Type returnType, class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize(System.Text.Json.JsonElement,System.Type,System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Deserialize (element As JsonElement, returnType As Type, Optional options As JsonSerializerOptions = Nothing) As Object" />
      <MemberSignature Language="F#" Value="static member Deserialize : System.Text.Json.JsonElement * Type * System.Text.Json.JsonSerializerOptions -&gt; obj" Usage="System.Text.Json.JsonSerializer.Deserialize (element, returnType, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Text.Json.JsonElement" RefType="this" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <param name="element">The <see cref="T:System.Text.Json.JsonElement" /> to convert.</param>
        <param name="returnType">The type of the object to convert to and return.</param>
        <param name="options">Options to control the behavior during parsing.</param>
        <summary>Converts the <see cref="T:System.Text.Json.JsonElement" /> representing a single JSON value into a <paramref name="returnType" />.</summary>
        <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="returnType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.Json.JsonException">
          <paramref name="returnType" /> is not compatible with the JSON.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <paramref name="returnType" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public static object? Deserialize (this System.Text.Json.JsonElement element, Type returnType, System.Text.Json.Serialization.JsonSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Deserialize(valuetype System.Text.Json.JsonElement element, class System.Type returnType, class System.Text.Json.Serialization.JsonSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize(System.Text.Json.JsonElement,System.Type,System.Text.Json.Serialization.JsonSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Deserialize (element As JsonElement, returnType As Type, context As JsonSerializerContext) As Object" />
      <MemberSignature Language="F#" Value="static member Deserialize : System.Text.Json.JsonElement * Type * System.Text.Json.Serialization.JsonSerializerContext -&gt; obj" Usage="System.Text.Json.JsonSerializer.Deserialize (element, returnType, context)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Object ^ Deserialize(System::Text::Json::JsonElement element, Type ^ returnType, System::Text::Json::Serialization::JsonSerializerContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Text.Json.JsonElement" RefType="this" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="context" Type="System.Text.Json.Serialization.JsonSerializerContext" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <param name="element">The <see cref="T:System.Text.Json.JsonElement" /> to convert.</param>
        <param name="returnType">The type of the object to convert to and return.</param>
        <param name="context">A metadata provider for serializable types.</param>
        <summary>Converts the <see cref="T:System.Text.Json.JsonElement" /> representing a single JSON value into a <paramref name="returnType" />.</summary>
        <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="returnType" /> is <see langword="null" />.

-or-

<paramref name="context" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.Json.JsonException">The JSON is invalid.

-or-

<paramref name="returnType" /> is not compatible with the JSON.

-or-

There is remaining data in the string beyond a single JSON value.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <paramref name="returnType" /> or its serializable members.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Text.Json.Serialization.JsonSerializerContext.GetTypeInfo(System.Type)" /> method of the provided <paramref name="context" /> returns <see langword="null" /> for the type to convert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public static object? Deserialize (this System.Text.Json.Nodes.JsonNode? node, Type returnType, System.Text.Json.JsonSerializerOptions? options = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Deserialize(class System.Text.Json.Nodes.JsonNode node, class System.Type returnType, class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize(System.Text.Json.Nodes.JsonNode,System.Type,System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Deserialize (node As JsonNode, returnType As Type, Optional options As JsonSerializerOptions = Nothing) As Object" />
      <MemberSignature Language="F#" Value="static member Deserialize : System.Text.Json.Nodes.JsonNode * Type * System.Text.Json.JsonSerializerOptions -&gt; obj" Usage="System.Text.Json.JsonSerializer.Deserialize (node, returnType, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Text.Json.Nodes.JsonNode" RefType="this" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <param name="node">The <see cref="T:System.Text.Json.Nodes.JsonNode" /> to convert.</param>
        <param name="returnType">The type of the object to convert to and return.</param>
        <param name="options">Options to control the behavior during parsing.</param>
        <summary>Converts the <see cref="T:System.Text.Json.Nodes.JsonNode" /> representing a single JSON value into a <paramref name="returnType" />.</summary>
        <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Text.Json.JsonException">
          <paramref name="returnType" /> is not compatible with the JSON.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <paramref name="returnType" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public static object? Deserialize (this System.Text.Json.Nodes.JsonNode? node, Type returnType, System.Text.Json.Serialization.JsonSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Deserialize(class System.Text.Json.Nodes.JsonNode node, class System.Type returnType, class System.Text.Json.Serialization.JsonSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize(System.Text.Json.Nodes.JsonNode,System.Type,System.Text.Json.Serialization.JsonSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Deserialize (node As JsonNode, returnType As Type, context As JsonSerializerContext) As Object" />
      <MemberSignature Language="F#" Value="static member Deserialize : System.Text.Json.Nodes.JsonNode * Type * System.Text.Json.Serialization.JsonSerializerContext -&gt; obj" Usage="System.Text.Json.JsonSerializer.Deserialize (node, returnType, context)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static System::Object ^ Deserialize(System::Text::Json::Nodes::JsonNode ^ node, Type ^ returnType, System::Text::Json::Serialization::JsonSerializerContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Text.Json.Nodes.JsonNode" RefType="this" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="context" Type="System.Text.Json.Serialization.JsonSerializerContext" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <param name="node">The <see cref="T:System.Text.Json.Nodes.JsonNode" /> to convert.</param>
        <param name="returnType">The type of the object to convert to and return.</param>
        <param name="context">A metadata provider for serializable types.</param>
        <summary>Converts the <see cref="T:System.Text.Json.Nodes.JsonNode" /> representing a single JSON value into a <paramref name="returnType" />.</summary>
        <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="returnType" /> is <see langword="null" />.

-or-

<paramref name="context" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.Json.JsonException">The JSON is invalid.

-or-

<paramref name="returnType" /> is not compatible with the JSON.

-or-

There is remaining data in the string beyond a single JSON value.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <paramref name="returnType" /> or its serializable members.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Text.Json.Serialization.JsonSerializerContext.GetTypeInfo(System.Type)" /> method of the provided <paramref name="context" /> returns <see langword="null" /> for the type to convert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public static object? Deserialize (ref System.Text.Json.Utf8JsonReader reader, Type returnType, System.Text.Json.JsonSerializerOptions? options = default);" FrameworkAlternate="net-5.0;net-6.0;net-7.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Deserialize(valuetype System.Text.Json.Utf8JsonReader&amp; reader, class System.Type returnType, class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Deserialize (ByRef reader As Utf8JsonReader, returnType As Type, Optional options As JsonSerializerOptions = Nothing) As Object" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="F#" Value="static member Deserialize : Utf8JsonReader * Type * System.Text.Json.JsonSerializerOptions -&gt; obj" Usage="System.Text.Json.JsonSerializer.Deserialize (reader, returnType, options)" />
      <MemberSignature Language="VB.NET" Value="Public Function Deserialize (ByRef reader As Utf8JsonReader, returnType As Type, Optional options As JsonSerializerOptions = Nothing) As Object" FrameworkAlternate="net-6.0;net-7.0" />
      <MemberSignature Language="C#" Value="public static object Deserialize (ref System.Text.Json.Utf8JsonReader reader, Type returnType, System.Text.Json.JsonSerializerOptions options = default);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Text.Json.Utf8JsonReader" RefType="ref" />
        <Parameter Name="returnType" Type="System.Type">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
      </Parameters>
      <Docs>
        <param name="reader">The reader to read the JSON from.</param>
        <param name="returnType">The type of the object to convert to and return.</param>
        <param name="options">Options to control the serializer behavior during reading.</param>
        <summary>Reads one JSON value (including objects or arrays) from the provided reader and converts it into an instance of  a specified type.</summary>
        <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

If the <xref:System.Text.Json.Utf8JsonReader.TokenType> property of `reader` is <xref:System.Text.Json.JsonTokenType.PropertyName?displayProperty=nameWithType> or <xref:System.Text.Json.JsonTokenType.None?displayProperty=nameWithType>, the reader will be advanced by one call to <xref:System.Text.Json.Utf8JsonReader.Read?displayProperty=nameWithType> to determine the start of the value.

Upon completion of this method, `reader` will be positioned at the final token in the JSON value.  If an exception is thrown, the reader is reset to the state it was in when the method was called.

This method makes a copy of the data the reader acted on, so there is no caller requirement to maintain data integrity beyond the return of this method.

The <xref:System.Text.Json.JsonReaderOptions> used to create the instance of the <xref:System.Text.Json.Utf8JsonReader> take precedence over the <xref:System.Text.Json.JsonSerializerOptions> when they conflict. Hence, <xref:System.Text.Json.JsonReaderOptions.AllowTrailingCommas?displayProperty=nameWithType>, <xref:System.Text.Json.JsonReaderOptions.MaxDepth?displayProperty=nameWithType>, and <xref:System.Text.Json.JsonReaderOptions.CommentHandling?displayProperty=nameWithType> are used while reading.

For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to).
          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="returnType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.Json.JsonException">The JSON is invalid.

-or-

<typeparamref name="returnType" /> is not compatible with the JSON.

-or-

A value could not be read from the reader.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="reader" /> is using unsupported options.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="System.Text.Json.Serialization.JsonConverter" /> for <paramref name="returnType" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize">
      <MemberSignature Language="C#" Value="public static object? Deserialize (ref System.Text.Json.Utf8JsonReader reader, Type returnType, System.Text.Json.Serialization.JsonSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Deserialize(valuetype System.Text.Json.Utf8JsonReader&amp; reader, class System.Type returnType, class System.Text.Json.Serialization.JsonSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize(System.Text.Json.Utf8JsonReader@,System.Type,System.Text.Json.Serialization.JsonSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function Deserialize (ByRef reader As Utf8JsonReader, returnType As Type, context As JsonSerializerContext) As Object" />
      <MemberSignature Language="F#" Value="static member Deserialize : Utf8JsonReader * Type * System.Text.Json.Serialization.JsonSerializerContext -&gt; obj" Usage="System.Text.Json.JsonSerializer.Deserialize (reader, returnType, context)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Deserialize(System::Text::Json::Utf8JsonReader % reader, Type ^ returnType, System::Text::Json::Serialization::JsonSerializerContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Text.Json.Utf8JsonReader" RefType="ref" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="context" Type="System.Text.Json.Serialization.JsonSerializerContext" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <param name="reader">The reader to read.</param>
        <param name="returnType">The type of the object to convert to and return.</param>
        <param name="context">A metadata provider for serializable types.</param>
        <summary>Reads one JSON value (including objects or arrays) from the provided reader into a <paramref name="returnType" />.</summary>
        <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

If the <xref:System.Text.Json.Utf8JsonReader.TokenType> property of `reader` is <xref:System.Text.Json.JsonTokenType.PropertyName> or <xref:System.Text.Json.JsonTokenType.None>, the reader will be advanced by one call to <xref:System.Text.Json.Utf8JsonReader.Read> to determine the start of the value.

Upon completion of this method, `reader` is positioned at the final token in the JSON value. If an exception is thrown, the reader is reset to the state it was in when the method was called.

This method makes a copy of the data the reader acted on, so there is no caller requirement to maintain data integrity beyond the return of this method.

The <xref:System.Text.Json.JsonReaderOptions> used to create the instance of the <xref:System.Text.Json.Utf8JsonReader> take precedence over the <xref:System.Text.Json.JsonSerializerOptions> when they conflict. Hence, <xref:System.Text.Json.JsonReaderOptions.AllowTrailingCommas>, <xref:System.Text.Json.JsonReaderOptions.MaxDepth>, and <xref:System.Text.Json.JsonReaderOptions.CommentHandling> are used while reading.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="returnType" /> or <paramref name="context" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.Json.JsonException">The JSON is invalid, <paramref name="returnType" /> is not compatible with the JSON, or a value could not be read from the reader.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="reader" /> is using unsupported options.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <paramref name="returnType" /> or its serializable members.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Text.Json.Serialization.JsonSerializerContext.GetTypeInfo(System.Type)" /> method on the provided <paramref name="context" /> did not return a compatible <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> for <paramref name="returnType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static TValue? Deserialize&lt;TValue&gt; (System.IO.Stream utf8Json, System.Text.Json.JsonSerializerOptions? options = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TValue Deserialize&lt;TValue&gt;(class System.IO.Stream utf8Json, class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize``1(System.IO.Stream,System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Deserialize(Of TValue) (utf8Json As Stream, Optional options As JsonSerializerOptions = Nothing) As TValue" />
      <MemberSignature Language="F#" Value="static member Deserialize : System.IO.Stream * System.Text.Json.JsonSerializerOptions -&gt; 'Value" Usage="System.Text.Json.JsonSerializer.Deserialize (utf8Json, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="utf8Json" Type="System.IO.Stream" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        <param name="utf8Json">JSON data to parse.</param>
        <param name="options">Options to control the behavior during reading.</param>
        <summary>Reads the UTF-8 encoded text representing a single JSON value into a <typeparamref name="TValue" />.
            The Stream will be read to completion.</summary>
        <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="utf8Json" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.Json.JsonException">The JSON is invalid, <typeparamref name="TValue" /> is not compatible with the JSON, or there is remaining data in the Stream.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static TValue? Deserialize&lt;TValue&gt; (System.IO.Stream utf8Json, System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt; jsonTypeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TValue Deserialize&lt;TValue&gt;(class System.IO.Stream utf8Json, class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TValue&gt; jsonTypeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize``1(System.IO.Stream,System.Text.Json.Serialization.Metadata.JsonTypeInfo{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Deserialize(Of TValue) (utf8Json As Stream, jsonTypeInfo As JsonTypeInfo(Of TValue)) As TValue" />
      <MemberSignature Language="F#" Value="static member Deserialize : System.IO.Stream * System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Value&gt; -&gt; 'Value" Usage="System.Text.Json.JsonSerializer.Deserialize (utf8Json, jsonTypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TValue&gt;&#xA; static TValue Deserialize(System::IO::Stream ^ utf8Json, System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TValue&gt; ^ jsonTypeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="utf8Json" Type="System.IO.Stream" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="jsonTypeInfo" Type="System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt;" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        <param name="utf8Json">JSON data to parse.</param>
        <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        <summary>Reads the UTF-8 encoded text representing a single JSON value into a <typeparamref name="TValue" />.
            The Stream will be read to completion.</summary>
        <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="utf8Json" /> or <paramref name="jsonTypeInfo" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.Json.JsonException">The JSON is invalid, <typeparamref name="TValue" /> is not compatible with the JSON, or there is remaining data in the Stream.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static TValue? Deserialize&lt;TValue&gt; (ReadOnlySpan&lt;byte&gt; utf8Json, System.Text.Json.JsonSerializerOptions? options = default);" FrameworkAlternate="net-5.0;net-6.0;net-7.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TValue Deserialize&lt;TValue&gt;(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Json, class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize``1(System.ReadOnlySpan{System.Byte},System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Deserialize(Of TValue) (utf8Json As ReadOnlySpan(Of Byte), Optional options As JsonSerializerOptions = Nothing) As TValue" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="F#" Value="static member Deserialize : ReadOnlySpan&lt;byte&gt; * System.Text.Json.JsonSerializerOptions -&gt; 'Value" Usage="System.Text.Json.JsonSerializer.Deserialize (utf8Json, options)" />
      <MemberSignature Language="VB.NET" Value="Public Function Deserialize(Of TValue) (utf8Json As ReadOnlySpan(Of Byte), Optional options As JsonSerializerOptions = Nothing) As TValue" FrameworkAlternate="net-6.0;net-7.0" />
      <MemberSignature Language="C#" Value="public static TValue Deserialize&lt;TValue&gt; (ReadOnlySpan&lt;byte&gt; utf8Json, System.Text.Json.JsonSerializerOptions options = default);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="utf8Json" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The target type of the UTF-8 encoded text.</typeparam>
        <param name="utf8Json">The JSON text to parse.</param>
        <param name="options">Options to control the behavior during parsing.</param>
        <summary>Parses the UTF-8 encoded text representing a single JSON value into an instance of the type specified by a generic type parameter.</summary>
        <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to).

 ]]></format>
        </remarks>
        <exception cref="T:System.Text.Json.JsonException">The JSON is invalid.

-or-

<typeparamref name="TValue" /> is not compatible with the JSON.

-or-

There is remaining data in the span beyond a single JSON value.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static TValue? Deserialize&lt;TValue&gt; (ReadOnlySpan&lt;byte&gt; utf8Json, System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt; jsonTypeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TValue Deserialize&lt;TValue&gt;(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Json, class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TValue&gt; jsonTypeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize``1(System.ReadOnlySpan{System.Byte},System.Text.Json.Serialization.Metadata.JsonTypeInfo{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Deserialize(Of TValue) (utf8Json As ReadOnlySpan(Of Byte), jsonTypeInfo As JsonTypeInfo(Of TValue)) As TValue" />
      <MemberSignature Language="F#" Value="static member Deserialize : ReadOnlySpan&lt;byte&gt; * System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Value&gt; -&gt; 'Value" Usage="System.Text.Json.JsonSerializer.Deserialize (utf8Json, jsonTypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TValue&gt;&#xA; static TValue Deserialize(ReadOnlySpan&lt;System::Byte&gt; utf8Json, System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TValue&gt; ^ jsonTypeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="utf8Json" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="jsonTypeInfo" Type="System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt;" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        <param name="utf8Json">JSON text to parse.</param>
        <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        <summary>Parses the UTF-8 encoded text representing a single JSON value into a <typeparamref name="TValue" />.</summary>
        <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Text.Json.JsonException">The JSON is invalid, <typeparamref name="TValue" /> is not compatible with the JSON, or there is remaining data in the Stream.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static TValue? Deserialize&lt;TValue&gt; (ReadOnlySpan&lt;char&gt; json, System.Text.Json.JsonSerializerOptions? options = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TValue Deserialize&lt;TValue&gt;(valuetype System.ReadOnlySpan`1&lt;char&gt; json, class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize``1(System.ReadOnlySpan{System.Char},System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Deserialize(Of TValue) (json As ReadOnlySpan(Of Char), Optional options As JsonSerializerOptions = Nothing) As TValue" />
      <MemberSignature Language="F#" Value="static member Deserialize : ReadOnlySpan&lt;char&gt; * System.Text.Json.JsonSerializerOptions -&gt; 'Value" Usage="System.Text.Json.JsonSerializer.Deserialize (json, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="json" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-6.0;net-7.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-7.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("Json")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("Json")&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        <param name="json">The JSON text to parse.</param>
        <param name="options">Options to control the behavior during parsing.</param>
        <summary>Parses the text representing a single JSON value into an instance of the type specified by a generic type parameter.</summary>
        <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Using a UTF-16 span is not as efficient as using the
             UTF-8 methods since the implementation natively uses UTF-8.

          ]]></format>
        </remarks>
        <exception cref="T:System.Text.Json.JsonException">The JSON is invalid.

-or-

<typeparamref name="TValue" /> is not compatible with the JSON.

-or-

There is remaining data in the span beyond a single JSON value.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static TValue? Deserialize&lt;TValue&gt; (ReadOnlySpan&lt;char&gt; json, System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt; jsonTypeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TValue Deserialize&lt;TValue&gt;(valuetype System.ReadOnlySpan`1&lt;char&gt; json, class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TValue&gt; jsonTypeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize``1(System.ReadOnlySpan{System.Char},System.Text.Json.Serialization.Metadata.JsonTypeInfo{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Deserialize(Of TValue) (json As ReadOnlySpan(Of Char), jsonTypeInfo As JsonTypeInfo(Of TValue)) As TValue" />
      <MemberSignature Language="F#" Value="static member Deserialize : ReadOnlySpan&lt;char&gt; * System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Value&gt; -&gt; 'Value" Usage="System.Text.Json.JsonSerializer.Deserialize (json, jsonTypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TValue&gt;&#xA; static TValue Deserialize(ReadOnlySpan&lt;char&gt; json, System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TValue&gt; ^ jsonTypeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="json" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-6.0;net-7.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-7.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("Json")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("Json")&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="jsonTypeInfo" Type="System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt;" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        <param name="json">JSON text to parse.</param>
        <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        <summary>Parses the text representing a single JSON value into a <typeparamref name="TValue" />.</summary>
        <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Using a <xref:System.String> is not as efficient as using the
             UTF-8 methods since the implementation natively uses UTF-8.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="json" /> is <see langword="null" />.

-or-

<paramref name="jsonTypeInfo" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.Json.JsonException">The JSON is invalid.

-or-

<typeparamref name="TValue" /> is not compatible with the JSON.

-or-

There is remaining data in the string beyond a single JSON value.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static TValue? Deserialize&lt;TValue&gt; (string json, System.Text.Json.JsonSerializerOptions? options = default);" FrameworkAlternate="net-5.0;net-6.0;net-7.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TValue Deserialize&lt;TValue&gt;(string json, class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize``1(System.String,System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Deserialize(Of TValue) (json As String, Optional options As JsonSerializerOptions = Nothing) As TValue" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="F#" Value="static member Deserialize : string * System.Text.Json.JsonSerializerOptions -&gt; 'Value" Usage="System.Text.Json.JsonSerializer.Deserialize (json, options)" />
      <MemberSignature Language="VB.NET" Value="Public Function Deserialize(Of TValue) (json As String, Optional options As JsonSerializerOptions = Nothing) As TValue" FrameworkAlternate="net-6.0;net-7.0" />
      <MemberSignature Language="C#" Value="public static TValue Deserialize&lt;TValue&gt; (string json, System.Text.Json.JsonSerializerOptions options = default);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="json" Type="System.String">
          <Attributes>
            <Attribute FrameworkAlternate="net-7.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("Json")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("Json")&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The target type of the JSON value.</typeparam>
        <param name="json">The JSON text to parse.</param>
        <param name="options">Options to control the behavior during parsing.</param>
        <summary>Parses the text representing a single JSON value into an instance of the type specified by a generic type parameter.</summary>
        <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Using a <xref:System.String> is not as efficient as using the UTF-8 methods since the implementation natively uses UTF-8.

For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to).

]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="json" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.Json.JsonException">The JSON is invalid.

-or-

<typeparamref name="TValue" /> is not compatible with the JSON.

-or-

There is remaining data in the string beyond a single JSON value.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static TValue? Deserialize&lt;TValue&gt; (string json, System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt; jsonTypeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TValue Deserialize&lt;TValue&gt;(string json, class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TValue&gt; jsonTypeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize``1(System.String,System.Text.Json.Serialization.Metadata.JsonTypeInfo{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Deserialize(Of TValue) (json As String, jsonTypeInfo As JsonTypeInfo(Of TValue)) As TValue" />
      <MemberSignature Language="F#" Value="static member Deserialize : string * System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Value&gt; -&gt; 'Value" Usage="System.Text.Json.JsonSerializer.Deserialize (json, jsonTypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TValue&gt;&#xA; static TValue Deserialize(System::String ^ json, System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TValue&gt; ^ jsonTypeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="json" Type="System.String" Index="0" FrameworkAlternate="net-6.0;net-7.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-7.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("Json")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("Json")&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="jsonTypeInfo" Type="System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt;" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        <param name="json">JSON text to parse.</param>
        <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        <summary>Parses the text representing a single JSON value into a <typeparamref name="TValue" />.</summary>
        <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Using a <xref:System.String> is not as efficient as using the
             UTF-8 methods since the implementation natively uses UTF-8.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="json" /> is <see langword="null" />.

-or-

<paramref name="jsonTypeInfo" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.Json.JsonException">The JSON is invalid.

-or-

<typeparamref name="TValue" /> is not compatible with the JSON.

-or-

There is remaining data in the string beyond a single JSON value.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static TValue? Deserialize&lt;TValue&gt; (this System.Text.Json.JsonDocument document, System.Text.Json.JsonSerializerOptions? options = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TValue Deserialize&lt;TValue&gt;(class System.Text.Json.JsonDocument document, class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize``1(System.Text.Json.JsonDocument,System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Deserialize(Of TValue) (document As JsonDocument, Optional options As JsonSerializerOptions = Nothing) As TValue" />
      <MemberSignature Language="F#" Value="static member Deserialize : System.Text.Json.JsonDocument * System.Text.Json.JsonSerializerOptions -&gt; 'Value" Usage="System.Text.Json.JsonSerializer.Deserialize (document, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="document" Type="System.Text.Json.JsonDocument" RefType="this" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        <param name="document">The <see cref="T:System.Text.Json.JsonDocument" /> to convert.</param>
        <param name="options">Options to control the behavior during parsing.</param>
        <summary>Converts the <see cref="T:System.Text.Json.JsonDocument" /> representing a single JSON value into a <typeparamref name="TValue" />.</summary>
        <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="document" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.Json.JsonException">
          <typeparamref name="TValue" /> is not compatible with the JSON.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static TValue? Deserialize&lt;TValue&gt; (this System.Text.Json.JsonDocument document, System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt; jsonTypeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TValue Deserialize&lt;TValue&gt;(class System.Text.Json.JsonDocument document, class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TValue&gt; jsonTypeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize``1(System.Text.Json.JsonDocument,System.Text.Json.Serialization.Metadata.JsonTypeInfo{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Deserialize(Of TValue) (document As JsonDocument, jsonTypeInfo As JsonTypeInfo(Of TValue)) As TValue" />
      <MemberSignature Language="F#" Value="static member Deserialize : System.Text.Json.JsonDocument * System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Value&gt; -&gt; 'Value" Usage="System.Text.Json.JsonSerializer.Deserialize (document, jsonTypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TValue&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TValue Deserialize(System::Text::Json::JsonDocument ^ document, System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TValue&gt; ^ jsonTypeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="document" Type="System.Text.Json.JsonDocument" RefType="this" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="jsonTypeInfo" Type="System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt;" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        <param name="document">The <see cref="T:System.Text.Json.JsonDocument" /> to convert.</param>
        <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        <summary>Converts the <see cref="T:System.Text.Json.JsonDocument" /> representing a single JSON value into a <typeparamref name="TValue" />.</summary>
        <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="document" /> is <see langword="null" />.

-or-

<paramref name="jsonTypeInfo" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.Json.JsonException">
          <typeparamref name="TValue" /> is not compatible with the JSON.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static TValue? Deserialize&lt;TValue&gt; (this System.Text.Json.JsonElement element, System.Text.Json.JsonSerializerOptions? options = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TValue Deserialize&lt;TValue&gt;(valuetype System.Text.Json.JsonElement element, class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize``1(System.Text.Json.JsonElement,System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Deserialize(Of TValue) (element As JsonElement, Optional options As JsonSerializerOptions = Nothing) As TValue" />
      <MemberSignature Language="F#" Value="static member Deserialize : System.Text.Json.JsonElement * System.Text.Json.JsonSerializerOptions -&gt; 'Value" Usage="System.Text.Json.JsonSerializer.Deserialize (element, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="element" Type="System.Text.Json.JsonElement" RefType="this" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        <param name="element">The <see cref="T:System.Text.Json.JsonElement" /> to convert.</param>
        <param name="options">Options to control the behavior during parsing.</param>
        <summary>Converts the <see cref="T:System.Text.Json.JsonElement" /> representing a single JSON value into a <typeparamref name="TValue" />.</summary>
        <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Text.Json.JsonException">
          <typeparamref name="TValue" /> is not compatible with the JSON.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static TValue? Deserialize&lt;TValue&gt; (this System.Text.Json.JsonElement element, System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt; jsonTypeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TValue Deserialize&lt;TValue&gt;(valuetype System.Text.Json.JsonElement element, class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TValue&gt; jsonTypeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize``1(System.Text.Json.JsonElement,System.Text.Json.Serialization.Metadata.JsonTypeInfo{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Deserialize(Of TValue) (element As JsonElement, jsonTypeInfo As JsonTypeInfo(Of TValue)) As TValue" />
      <MemberSignature Language="F#" Value="static member Deserialize : System.Text.Json.JsonElement * System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Value&gt; -&gt; 'Value" Usage="System.Text.Json.JsonSerializer.Deserialize (element, jsonTypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TValue&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TValue Deserialize(System::Text::Json::JsonElement element, System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TValue&gt; ^ jsonTypeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="element" Type="System.Text.Json.JsonElement" RefType="this" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="jsonTypeInfo" Type="System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt;" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        <param name="element">The <see cref="T:System.Text.Json.JsonElement" /> to convert.</param>
        <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        <summary>Converts the <see cref="T:System.Text.Json.JsonElement" /> representing a single JSON value into a <typeparamref name="TValue" />.</summary>
        <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jsonTypeInfo" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.Json.JsonException">
          <typeparamref name="TValue" /> is not compatible with the JSON.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static TValue? Deserialize&lt;TValue&gt; (this System.Text.Json.Nodes.JsonNode? node, System.Text.Json.JsonSerializerOptions? options = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TValue Deserialize&lt;TValue&gt;(class System.Text.Json.Nodes.JsonNode node, class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize``1(System.Text.Json.Nodes.JsonNode,System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Deserialize(Of TValue) (node As JsonNode, Optional options As JsonSerializerOptions = Nothing) As TValue" />
      <MemberSignature Language="F#" Value="static member Deserialize : System.Text.Json.Nodes.JsonNode * System.Text.Json.JsonSerializerOptions -&gt; 'Value" Usage="System.Text.Json.JsonSerializer.Deserialize (node, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="node" Type="System.Text.Json.Nodes.JsonNode" RefType="this" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        <param name="node">The <see cref="T:System.Text.Json.Nodes.JsonNode" /> to convert.</param>
        <param name="options">Options to control the behavior during parsing.</param>
        <summary>Converts the <see cref="T:System.Text.Json.Nodes.JsonNode" /> representing a single JSON value into a <typeparamref name="TValue" />.</summary>
        <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Text.Json.JsonException">
          <typeparamref name="TValue" /> is not compatible with the JSON.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static TValue? Deserialize&lt;TValue&gt; (this System.Text.Json.Nodes.JsonNode? node, System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt; jsonTypeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TValue Deserialize&lt;TValue&gt;(class System.Text.Json.Nodes.JsonNode node, class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TValue&gt; jsonTypeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize``1(System.Text.Json.Nodes.JsonNode,System.Text.Json.Serialization.Metadata.JsonTypeInfo{``0})" />
      <MemberSignature Language="VB.NET" Value="&lt;Extension()&gt;&#xA;Public Function Deserialize(Of TValue) (node As JsonNode, jsonTypeInfo As JsonTypeInfo(Of TValue)) As TValue" />
      <MemberSignature Language="F#" Value="static member Deserialize : System.Text.Json.Nodes.JsonNode * System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Value&gt; -&gt; 'Value" Usage="System.Text.Json.JsonSerializer.Deserialize (node, jsonTypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TValue&gt;&#xA;[System::Runtime::CompilerServices::Extension]&#xA; static TValue Deserialize(System::Text::Json::Nodes::JsonNode ^ node, System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TValue&gt; ^ jsonTypeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="node" Type="System.Text.Json.Nodes.JsonNode" RefType="this" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="jsonTypeInfo" Type="System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt;" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        <param name="node">The <see cref="T:System.Text.Json.Nodes.JsonNode" /> to convert.</param>
        <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        <summary>Converts the <see cref="T:System.Text.Json.Nodes.JsonNode" /> representing a single JSON value into a <typeparamref name="TValue" />.</summary>
        <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jsonTypeInfo" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.Json.JsonException">
          <typeparamref name="TValue" /> is not compatible with the JSON.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static TValue? Deserialize&lt;TValue&gt; (ref System.Text.Json.Utf8JsonReader reader, System.Text.Json.JsonSerializerOptions? options = default);" FrameworkAlternate="net-5.0;net-6.0;net-7.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TValue Deserialize&lt;TValue&gt;(valuetype System.Text.Json.Utf8JsonReader&amp; reader, class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize``1(System.Text.Json.Utf8JsonReader@,System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Deserialize(Of TValue) (ByRef reader As Utf8JsonReader, Optional options As JsonSerializerOptions = Nothing) As TValue" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="F#" Value="static member Deserialize : Utf8JsonReader * System.Text.Json.JsonSerializerOptions -&gt; 'Value" Usage="System.Text.Json.JsonSerializer.Deserialize (reader, options)" />
      <MemberSignature Language="VB.NET" Value="Public Function Deserialize(Of TValue) (ByRef reader As Utf8JsonReader, Optional options As JsonSerializerOptions = Nothing) As TValue" FrameworkAlternate="net-6.0;net-7.0" />
      <MemberSignature Language="C#" Value="public static TValue Deserialize&lt;TValue&gt; (ref System.Text.Json.Utf8JsonReader reader, System.Text.Json.JsonSerializerOptions options = default);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Text.Json.Utf8JsonReader" RefType="ref" />
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The target type of the JSON value.</typeparam>
        <param name="reader">The reader to read the JSON from.</param>
        <param name="options">Options to control serializer behavior during reading.</param>
        <summary>Reads one JSON value (including objects or arrays) from the provided reader into an instance of the type specified by a generic type parameter.</summary>
        <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

If the <xref:System.Text.Json.Utf8JsonReader.TokenType> property of `reader` is <xref:System.Text.Json.JsonTokenType.PropertyName?displayProperty=nameWithType> or <xref:System.Text.Json.JsonTokenType.None?displayProperty=nameWithType>, the reader will be advanced by one call to <xref:System.Text.Json.Utf8JsonReader.Read?displayProperty=nameWithType> to determine the start of the value.

Upon completion of this method, `reader` will be positioned at the final token in the JSON value. If an exception is thrown, the reader is reset to the state it was in when the method was called.

This method makes a copy of the data the reader acted on, so there is no caller requirement to maintain data integrity beyond the return of this method.

The <xref:System.Text.Json.JsonReaderOptions> used to create the instance of the <xref:System.Text.Json.Utf8JsonReader> take precedence over the <xref:System.Text.Json.JsonSerializerOptions> when they conflict. Hence, <xref:System.Text.Json.JsonReaderOptions.AllowTrailingCommas?displayProperty=nameWithType>, <xref:System.Text.Json.JsonReaderOptions.MaxDepth?displayProperty=nameWithType>, and <xref:System.Text.Json.JsonReaderOptions.CommentHandling?displayProperty=nameWithType> are used while reading.

For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to).

          ]]></format>
        </remarks>
        <exception cref="T:System.Text.Json.JsonException">The JSON is invalid.

-or-

<typeparamref name="TValue" /> is not compatible with the JSON.

-or-

A value could not be read from the reader.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="reader" /> uses unsupported options.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Deserialize&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static TValue? Deserialize&lt;TValue&gt; (ref System.Text.Json.Utf8JsonReader reader, System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt; jsonTypeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TValue Deserialize&lt;TValue&gt;(valuetype System.Text.Json.Utf8JsonReader&amp; reader, class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TValue&gt; jsonTypeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Deserialize``1(System.Text.Json.Utf8JsonReader@,System.Text.Json.Serialization.Metadata.JsonTypeInfo{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Deserialize(Of TValue) (ByRef reader As Utf8JsonReader, jsonTypeInfo As JsonTypeInfo(Of TValue)) As TValue" />
      <MemberSignature Language="F#" Value="static member Deserialize : Utf8JsonReader * System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Value&gt; -&gt; 'Value" Usage="System.Text.Json.JsonSerializer.Deserialize (reader, jsonTypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TValue&gt;&#xA; static TValue Deserialize(System::Text::Json::Utf8JsonReader % reader, System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TValue&gt; ^ jsonTypeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="reader" Type="System.Text.Json.Utf8JsonReader" RefType="ref" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="jsonTypeInfo" Type="System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt;" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        <param name="reader">The reader to read.</param>
        <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        <summary>Reads one JSON value (including objects or arrays) from the provided reader into a <typeparamref name="TValue" />.</summary>
        <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

If the <xref:System.Text.Json.Utf8JsonReader.TokenType> property of `reader` is <xref:System.Text.Json.JsonTokenType.PropertyName> or <xref:System.Text.Json.JsonTokenType.None>, the reader will be advanced by one call to <xref:System.Text.Json.Utf8JsonReader.Read> to determine the start of the value.

Upon completion of this method, `reader` is positioned at the final token in the JSON value.  If an exception is thrown, the reader is reset to the state it was in when the method was called.

This method makes a copy of the data the reader acted on, so there is no caller requirement to maintain data integrity beyond the return of this method.

The <xref:System.Text.Json.JsonReaderOptions> used to create the instance of the <xref:System.Text.Json.Utf8JsonReader> take precedence over the <xref:System.Text.Json.JsonSerializerOptions> when they conflict. Hence, <xref:System.Text.Json.JsonReaderOptions.AllowTrailingCommas>, <xref:System.Text.Json.JsonReaderOptions.MaxDepth>, and <xref:System.Text.Json.JsonReaderOptions.CommentHandling> are used while reading.

          ]]></format>
        </remarks>
        <exception cref="T:System.Text.Json.JsonException">The JSON is invalid, <typeparamref name="TValue" /> is not compatible with the JSON, or a value could not be read from the reader.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="reader" /> is using unsupported options.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeserializeAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ValueTask&lt;object?&gt; DeserializeAsync (System.IO.Stream utf8Json, Type returnType, System.Text.Json.JsonSerializerOptions? options = default, System.Threading.CancellationToken cancellationToken = default);" FrameworkAlternate="net-5.0;net-6.0;net-7.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ValueTask`1&lt;object&gt; DeserializeAsync(class System.IO.Stream utf8Json, class System.Type returnType, class System.Text.Json.JsonSerializerOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.DeserializeAsync(System.IO.Stream,System.Type,System.Text.Json.JsonSerializerOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DeserializeAsync (utf8Json As Stream, returnType As Type, Optional options As JsonSerializerOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As ValueTask(Of Object)" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="F#" Value="static member DeserializeAsync : System.IO.Stream * Type * System.Text.Json.JsonSerializerOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;obj&gt;" Usage="System.Text.Json.JsonSerializer.DeserializeAsync (utf8Json, returnType, options, cancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeserializeAsync (utf8Json As Stream, returnType As Type, Optional options As JsonSerializerOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As ValueTask(Of Object)" FrameworkAlternate="net-6.0;net-7.0" />
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ValueTask&lt;object&gt; DeserializeAsync (System.IO.Stream utf8Json, Type returnType, System.Text.Json.JsonSerializerOptions options = default, System.Threading.CancellationToken cancellationToken = default);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Json" Type="System.IO.Stream" />
        <Parameter Name="returnType" Type="System.Type">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicConstructors | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="utf8Json">The JSON data to parse.</param>
        <param name="returnType">The type of the object to convert to and return.</param>
        <param name="options">Options to control the behavior during reading.</param>
        <param name="cancellationToken">A cancellation token that may be used to cancel the read operation.</param>
        <summary>Asynchronously reads the UTF-8 encoded text representing a single JSON value into an instance of a specified type. The stream will be read to completion.</summary>
        <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to).

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="utf8Json" /> or <paramref name="returnType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.Json.JsonException">The JSON is invalid.

-or-

<typeparamref name="TValue" /> is not compatible with the JSON.

-or-

There is remaining data in the stream.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="System.Text.Json.Serialization.JsonConverter" /> for <paramref name="returnType" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeserializeAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ValueTask&lt;object?&gt; DeserializeAsync (System.IO.Stream utf8Json, Type returnType, System.Text.Json.Serialization.JsonSerializerContext context, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ValueTask`1&lt;object&gt; DeserializeAsync(class System.IO.Stream utf8Json, class System.Type returnType, class System.Text.Json.Serialization.JsonSerializerContext context, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.DeserializeAsync(System.IO.Stream,System.Type,System.Text.Json.Serialization.JsonSerializerContext,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeserializeAsync (utf8Json As Stream, returnType As Type, context As JsonSerializerContext, Optional cancellationToken As CancellationToken = Nothing) As ValueTask(Of Object)" />
      <MemberSignature Language="F#" Value="static member DeserializeAsync : System.IO.Stream * Type * System.Text.Json.Serialization.JsonSerializerContext * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;obj&gt;" Usage="System.Text.Json.JsonSerializer.DeserializeAsync (utf8Json, returnType, context, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Json" Type="System.IO.Stream" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="context" Type="System.Text.Json.Serialization.JsonSerializerContext" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <param name="utf8Json">JSON data to parse.</param>
        <param name="returnType">The type of the object to convert to and return.</param>
        <param name="context">A metadata provider for serializable types.</param>
        <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> that can be used to cancel the read operation.</param>
        <summary>Reads the UTF-8 encoded text representing a single JSON value into a <paramref name="returnType" />.
            The Stream will be read to completion.</summary>
        <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="utf8Json" />, <paramref name="returnType" />, or <paramref name="context" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.Json.JsonException">The JSON is invalid, the <paramref name="returnType" /> is not compatible with the JSON, or there is remaining data in the Stream.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <paramref name="returnType" /> or its serializable members.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Text.Json.Serialization.JsonSerializerContext.GetTypeInfo(System.Type)" /> method on the provided <paramref name="context" /> did not return a compatible <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> for <paramref name="returnType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeserializeAsync&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ValueTask&lt;TValue?&gt; DeserializeAsync&lt;TValue&gt; (System.IO.Stream utf8Json, System.Text.Json.JsonSerializerOptions? options = default, System.Threading.CancellationToken cancellationToken = default);" FrameworkAlternate="net-5.0;net-6.0;net-7.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ValueTask`1&lt;!!TValue&gt; DeserializeAsync&lt;TValue&gt;(class System.IO.Stream utf8Json, class System.Text.Json.JsonSerializerOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.DeserializeAsync``1(System.IO.Stream,System.Text.Json.JsonSerializerOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DeserializeAsync(Of TValue) (utf8Json As Stream, Optional options As JsonSerializerOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As ValueTask(Of TValue)" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="F#" Value="static member DeserializeAsync : System.IO.Stream * System.Text.Json.JsonSerializerOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;'Value&gt;" Usage="System.Text.Json.JsonSerializer.DeserializeAsync (utf8Json, options, cancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeserializeAsync(Of TValue) (utf8Json As Stream, Optional options As JsonSerializerOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As ValueTask(Of TValue)" FrameworkAlternate="net-6.0;net-7.0" />
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ValueTask&lt;TValue&gt; DeserializeAsync&lt;TValue&gt; (System.IO.Stream utf8Json, System.Text.Json.JsonSerializerOptions options = default, System.Threading.CancellationToken cancellationToken = default);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="utf8Json" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The target type of the JSON value.</typeparam>
        <param name="utf8Json">The JSON data to parse.</param>
        <param name="options">Options to control the behavior during reading.</param>
        <param name="cancellationToken">A token that may be used to cancel the read operation.</param>
        <summary>Asynchronously reads the UTF-8 encoded text representing a single JSON value into an instance of a type specified by a generic type parameter. The stream will be read to completion.</summary>
        <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to).

 ]]></format>
        </remarks>
        <exception cref="T:System.Text.Json.JsonException">The JSON is invalid.

-or-

<typeparamref name="TValue" /> is not compatible with the JSON.

-or-

There is remaining data in the stream.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="utf8Json" />is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeserializeAsync&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ValueTask&lt;TValue?&gt; DeserializeAsync&lt;TValue&gt; (System.IO.Stream utf8Json, System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt; jsonTypeInfo, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ValueTask`1&lt;!!TValue&gt; DeserializeAsync&lt;TValue&gt;(class System.IO.Stream utf8Json, class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TValue&gt; jsonTypeInfo, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.DeserializeAsync``1(System.IO.Stream,System.Text.Json.Serialization.Metadata.JsonTypeInfo{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeserializeAsync(Of TValue) (utf8Json As Stream, jsonTypeInfo As JsonTypeInfo(Of TValue), Optional cancellationToken As CancellationToken = Nothing) As ValueTask(Of TValue)" />
      <MemberSignature Language="F#" Value="static member DeserializeAsync : System.IO.Stream * System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Value&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.ValueTask&lt;'Value&gt;" Usage="System.Text.Json.JsonSerializer.DeserializeAsync (utf8Json, jsonTypeInfo, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ValueTask&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="utf8Json" Type="System.IO.Stream" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="jsonTypeInfo" Type="System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt;" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        <param name="utf8Json">JSON data to parse.</param>
        <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> which may be used to cancel the read operation.</param>
        <summary>Reads the UTF-8 encoded text representing a single JSON value into a <typeparamref name="TValue" />.
            The Stream will be read to completion.</summary>
        <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="utf8Json" /> or <paramref name="jsonTypeInfo" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Text.Json.JsonException">The JSON is invalid, <typeparamref name="TValue" /> is not compatible with the JSON, or there is remaining data in the Stream.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeserializeAsyncEnumerable&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IAsyncEnumerable&lt;TValue?&gt; DeserializeAsyncEnumerable&lt;TValue&gt; (System.IO.Stream utf8Json, System.Text.Json.JsonSerializerOptions? options = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IAsyncEnumerable`1&lt;!!TValue&gt; DeserializeAsyncEnumerable&lt;TValue&gt;(class System.IO.Stream utf8Json, class System.Text.Json.JsonSerializerOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.DeserializeAsyncEnumerable``1(System.IO.Stream,System.Text.Json.JsonSerializerOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeserializeAsyncEnumerable(Of TValue) (utf8Json As Stream, Optional options As JsonSerializerOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As IAsyncEnumerable(Of TValue)" />
      <MemberSignature Language="F#" Value="static member DeserializeAsyncEnumerable : System.IO.Stream * System.Text.Json.JsonSerializerOptions * System.Threading.CancellationToken -&gt; System.Collections.Generic.IAsyncEnumerable&lt;'Value&gt;" Usage="System.Text.Json.JsonSerializer.DeserializeAsyncEnumerable (utf8Json, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IAsyncEnumerable&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="utf8Json" Type="System.IO.Stream" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The element type to deserialize asynchronously.</typeparam>
        <param name="utf8Json">JSON data to parse.</param>
        <param name="options">Options to control the behavior during reading.</param>
        <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> which may be used to cancel the read operation.</param>
        <summary>Wraps the UTF-8 encoded text into an <see cref="T:System.Collections.Generic.IAsyncEnumerable`1" /> that can be used to deserialize root-level JSON arrays in a streaming manner.</summary>
        <returns>An <see cref="T:System.Collections.Generic.IAsyncEnumerable`1" /> representation of the provided JSON array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="utf8Json" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeserializeAsyncEnumerable&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IAsyncEnumerable&lt;TValue?&gt; DeserializeAsyncEnumerable&lt;TValue&gt; (System.IO.Stream utf8Json, System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt; jsonTypeInfo, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IAsyncEnumerable`1&lt;!!TValue&gt; DeserializeAsyncEnumerable&lt;TValue&gt;(class System.IO.Stream utf8Json, class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TValue&gt; jsonTypeInfo, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.DeserializeAsyncEnumerable``1(System.IO.Stream,System.Text.Json.Serialization.Metadata.JsonTypeInfo{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeserializeAsyncEnumerable(Of TValue) (utf8Json As Stream, jsonTypeInfo As JsonTypeInfo(Of TValue), Optional cancellationToken As CancellationToken = Nothing) As IAsyncEnumerable(Of TValue)" />
      <MemberSignature Language="F#" Value="static member DeserializeAsyncEnumerable : System.IO.Stream * System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Value&gt; * System.Threading.CancellationToken -&gt; System.Collections.Generic.IAsyncEnumerable&lt;'Value&gt;" Usage="System.Text.Json.JsonSerializer.DeserializeAsyncEnumerable (utf8Json, jsonTypeInfo, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IAsyncEnumerable&lt;TValue&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="utf8Json" Type="System.IO.Stream" Index="0" FrameworkAlternate="net-7.0" />
        <Parameter Name="jsonTypeInfo" Type="System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt;" Index="1" FrameworkAlternate="net-7.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="2" FrameworkAlternate="net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The element type to deserialize asynchronously.</typeparam>
        <param name="utf8Json">JSON data to parse.</param>
        <param name="jsonTypeInfo">Metadata about the element type to convert.</param>
        <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> that can be used to cancel the read operation.</param>
        <summary>Wraps the UTF-8 encoded text into an <see cref="T:System.Collections.Generic.IAsyncEnumerable`1" /> that can be used to deserialize root-level JSON arrays in a streaming manner.</summary>
        <returns>An <see cref="T:System.Collections.Generic.IAsyncEnumerable`1" /> representation of the provided JSON array.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="utf8Json" /> or <paramref name="jsonTypeInfo" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Serialize">
      <MemberSignature Language="C#" Value="public static string Serialize (object? value, Type inputType, System.Text.Json.JsonSerializerOptions? options = default);" FrameworkAlternate="net-5.0;net-6.0;net-7.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Serialize(object value, class System.Type inputType, class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Serialize(System.Object,System.Type,System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Serialize (value As Object, inputType As Type, Optional options As JsonSerializerOptions = Nothing) As String" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="F#" Value="static member Serialize : obj * Type * System.Text.Json.JsonSerializerOptions -&gt; string" Usage="System.Text.Json.JsonSerializer.Serialize (value, inputType, options)" />
      <MemberSignature Language="VB.NET" Value="Public Function Serialize (value As Object, inputType As Type, Optional options As JsonSerializerOptions = Nothing) As String" FrameworkAlternate="net-6.0;net-7.0" />
      <MemberSignature Language="C#" Value="public static string Serialize (object value, Type inputType, System.Text.Json.JsonSerializerOptions options = default);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="inputType" Type="System.Type">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        <param name="options">Options to control the conversion behavior.</param>
        <summary>Converts the value of a specified type into a JSON string.</summary>
        <returns>The JSON string representation of the value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Using a <xref:System.String> is not as efficient as using UTF-8 encoding since the implementation internally uses UTF-8. See also <xref:System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(System.Object,System.Type,System.Text.Json.JsonSerializerOptions)> and <xref:System.Text.Json.JsonSerializer.SerializeAsync(System.IO.Stream,System.Object,System.Type,System.Text.Json.JsonSerializerOptions,System.Threading.CancellationToken)>.

For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to).

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="inputType" /> is not compatible with <paramref name="value" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inputType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="System.Text.Json.Serialization.JsonConverter" /> for <paramref name="inputType" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Serialize">
      <MemberSignature Language="C#" Value="public static string Serialize (object? value, Type inputType, System.Text.Json.Serialization.JsonSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Serialize(object value, class System.Type inputType, class System.Text.Json.Serialization.JsonSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Serialize(System.Object,System.Type,System.Text.Json.Serialization.JsonSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function Serialize (value As Object, inputType As Type, context As JsonSerializerContext) As String" />
      <MemberSignature Language="F#" Value="static member Serialize : obj * Type * System.Text.Json.Serialization.JsonSerializerContext -&gt; string" Usage="System.Text.Json.JsonSerializer.Serialize (value, inputType, context)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Serialize(System::Object ^ value, Type ^ inputType, System::Text::Json::Serialization::JsonSerializerContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="inputType" Type="System.Type" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="context" Type="System.Text.Json.Serialization.JsonSerializerContext" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        <param name="context">A metadata provider for serializable types.</param>
        <summary>Converts the provided value into a <see cref="T:System.String" />.</summary>
        <returns>A <see cref="T:System.String" /> representation of the value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Using a <xref:System.String> is not as efficient as using UTF-8 encoding, since the implementation internally uses UTF-8. Also see <xref:System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(System.Object,System.Type,System.Text.Json.Serialization.JsonSerializerContext)> and <xref:System.Text.Json.JsonSerializer.SerializeAsync(System.IO.Stream,System.Object,System.Type,System.Text.Json.Serialization.JsonSerializerContext,System.Threading.CancellationToken)>.

          ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <paramref name="inputType" /> or its serializable members.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Text.Json.Serialization.JsonSerializerContext.GetTypeInfo(System.Type)" /> method of the provided <paramref name="context" /> returns <see langword="null" /> for the type to convert.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inputType" /> or <paramref name="context" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Serialize">
      <MemberSignature Language="C#" Value="public static void Serialize (System.IO.Stream utf8Json, object? value, Type inputType, System.Text.Json.JsonSerializerOptions? options = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Serialize(class System.IO.Stream utf8Json, object value, class System.Type inputType, class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Serialize(System.IO.Stream,System.Object,System.Type,System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Serialize (utf8Json As Stream, value As Object, inputType As Type, Optional options As JsonSerializerOptions = Nothing)" />
      <MemberSignature Language="F#" Value="static member Serialize : System.IO.Stream * obj * Type * System.Text.Json.JsonSerializerOptions -&gt; unit" Usage="System.Text.Json.JsonSerializer.Serialize (utf8Json, value, inputType, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Json" Type="System.IO.Stream" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="inputType" Type="System.Type" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" Index="3" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <param name="utf8Json">The UTF-8 <see cref="T:System.IO.Stream" /> to write to.</param>
        <param name="value">The value to convert.</param>
        <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        <param name="options">Options to control the conversion behavior.</param>
        <summary>Converts the provided value to UTF-8 encoded JSON text and write it to the <see cref="T:System.IO.Stream" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="inputType" /> is not compatible with <paramref name="value" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="utf8Json" /> or <paramref name="inputType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <paramref name="inputType" />  or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Serialize">
      <MemberSignature Language="C#" Value="public static void Serialize (System.IO.Stream utf8Json, object? value, Type inputType, System.Text.Json.Serialization.JsonSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Serialize(class System.IO.Stream utf8Json, object value, class System.Type inputType, class System.Text.Json.Serialization.JsonSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Serialize(System.IO.Stream,System.Object,System.Type,System.Text.Json.Serialization.JsonSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Serialize (utf8Json As Stream, value As Object, inputType As Type, context As JsonSerializerContext)" />
      <MemberSignature Language="F#" Value="static member Serialize : System.IO.Stream * obj * Type * System.Text.Json.Serialization.JsonSerializerContext -&gt; unit" Usage="System.Text.Json.JsonSerializer.Serialize (utf8Json, value, inputType, context)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Serialize(System::IO::Stream ^ utf8Json, System::Object ^ value, Type ^ inputType, System::Text::Json::Serialization::JsonSerializerContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Json" Type="System.IO.Stream" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="inputType" Type="System.Type" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="context" Type="System.Text.Json.Serialization.JsonSerializerContext" Index="3" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <param name="utf8Json">The UTF-8 <see cref="T:System.IO.Stream" /> to write to.</param>
        <param name="value">The value to convert.</param>
        <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        <param name="context">A metadata provider for serializable types.</param>
        <summary>Converts the provided value to UTF-8 encoded JSON text and write it to the <see cref="T:System.IO.Stream" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="inputType" /> is not compatible with <paramref name="value" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="utf8Json" />, <paramref name="inputType" />, or <paramref name="context" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <paramref name="inputType" />  or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Serialize">
      <MemberSignature Language="C#" Value="public static void Serialize (System.Text.Json.Utf8JsonWriter writer, object? value, Type inputType, System.Text.Json.JsonSerializerOptions? options = default);" FrameworkAlternate="net-5.0;net-6.0;net-7.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Serialize(class System.Text.Json.Utf8JsonWriter writer, object value, class System.Type inputType, class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Serialize(System.Text.Json.Utf8JsonWriter,System.Object,System.Type,System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Serialize (writer As Utf8JsonWriter, value As Object, inputType As Type, Optional options As JsonSerializerOptions = Nothing)" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="F#" Value="static member Serialize : System.Text.Json.Utf8JsonWriter * obj * Type * System.Text.Json.JsonSerializerOptions -&gt; unit" Usage="System.Text.Json.JsonSerializer.Serialize (writer, value, inputType, options)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Serialize (writer As Utf8JsonWriter, value As Object, inputType As Type, Optional options As JsonSerializerOptions = Nothing)" FrameworkAlternate="net-6.0;net-7.0" />
      <MemberSignature Language="C#" Value="public static void Serialize (System.Text.Json.Utf8JsonWriter writer, object value, Type inputType, System.Text.Json.JsonSerializerOptions options = default);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Text.Json.Utf8JsonWriter" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="inputType" Type="System.Type">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
      </Parameters>
      <Docs>
        <param name="writer">The JSON writer to write to.</param>
        <param name="value">The value to convert and write.</param>
        <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        <param name="options">Options to control serialization behavior.</param>
        <summary>Writes the JSON representation of the specified type to the provided writer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The <xref:System.Text.Json.JsonWriterOptions> used to create the instance of the <xref:System.Text.Json.Utf8JsonWriter> take precedence over the <xref:System.Text.Json.JsonSerializerOptions> when they conflict. Hence, <xref:System.Text.Json.JsonWriterOptions.Indented?displayProperty=nameWithType>, <xref:System.Text.Json.JsonWriterOptions.SkipValidation?displayProperty=nameWithType>, and <xref:System.Text.Json.JsonWriterOptions.Encoder?displayProperty=nameWithType> are used while writing.

For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to).

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="inputType" /> is not compatible with <paramref name="value" /></exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="writer" /> or <paramref name="inputType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="System.Text.Json.Serialization.JsonConverter" /> for <paramref name="inputType" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Serialize">
      <MemberSignature Language="C#" Value="public static void Serialize (System.Text.Json.Utf8JsonWriter writer, object? value, Type inputType, System.Text.Json.Serialization.JsonSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Serialize(class System.Text.Json.Utf8JsonWriter writer, object value, class System.Type inputType, class System.Text.Json.Serialization.JsonSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Serialize(System.Text.Json.Utf8JsonWriter,System.Object,System.Type,System.Text.Json.Serialization.JsonSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Serialize (writer As Utf8JsonWriter, value As Object, inputType As Type, context As JsonSerializerContext)" />
      <MemberSignature Language="F#" Value="static member Serialize : System.Text.Json.Utf8JsonWriter * obj * Type * System.Text.Json.Serialization.JsonSerializerContext -&gt; unit" Usage="System.Text.Json.JsonSerializer.Serialize (writer, value, inputType, context)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Serialize(System::Text::Json::Utf8JsonWriter ^ writer, System::Object ^ value, Type ^ inputType, System::Text::Json::Serialization::JsonSerializerContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Text.Json.Utf8JsonWriter" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="inputType" Type="System.Type" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="context" Type="System.Text.Json.Serialization.JsonSerializerContext" Index="3" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <param name="writer">A JSON writer to write to.</param>
        <param name="value">The value to convert and write.</param>
        <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        <param name="context">A metadata provider for serializable types.</param>
        <summary>Writes one JSON value (including objects or arrays) to the provided writer.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="inputType" /> is not compatible with <paramref name="value" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="writer" /> or <paramref name="inputType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <paramref name="inputType" /> or its serializable members.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Text.Json.Serialization.JsonSerializerContext.GetTypeInfo(System.Type)" /> method of the provided <paramref name="context" /> returns <see langword="null" /> for the type to convert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Serialize&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static string Serialize&lt;TValue&gt; (TValue value, System.Text.Json.JsonSerializerOptions? options = default);" FrameworkAlternate="net-5.0;net-6.0;net-7.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Serialize&lt;TValue&gt;(!!TValue value, class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Serialize``1(``0,System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Serialize(Of TValue) (value As TValue, Optional options As JsonSerializerOptions = Nothing) As String" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="F#" Value="static member Serialize : 'Value * System.Text.Json.JsonSerializerOptions -&gt; string" Usage="System.Text.Json.JsonSerializer.Serialize (value, options)" />
      <MemberSignature Language="VB.NET" Value="Public Function Serialize(Of TValue) (value As TValue, Optional options As JsonSerializerOptions = Nothing) As String" FrameworkAlternate="net-6.0;net-7.0" />
      <MemberSignature Language="C#" Value="public static string Serialize&lt;TValue&gt; (TValue value, System.Text.Json.JsonSerializerOptions options = default);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TValue" />
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The type of the value to serialize.</typeparam>
        <param name="value">The value to convert.</param>
        <param name="options">Options to control serialization behavior.</param>
        <summary>Converts the value of a type specified by a generic type parameter into a JSON string.</summary>
        <returns>A JSON string representation of the value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Using a <xref:System.String> is not as efficient as using UTF-8 encoding since the implementation internally uses UTF-8. See also <xref:System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(System.Object,System.Type,System.Text.Json.JsonSerializerOptions)> and <xref:System.Text.Json.JsonSerializer.SerializeAsync(System.IO.Stream,System.Object,System.Type,System.Text.Json.JsonSerializerOptions,System.Threading.CancellationToken)>.

For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to).

          ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Serialize&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static string Serialize&lt;TValue&gt; (TValue value, System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt; jsonTypeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Serialize&lt;TValue&gt;(!!TValue value, class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TValue&gt; jsonTypeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Serialize``1(``0,System.Text.Json.Serialization.Metadata.JsonTypeInfo{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Serialize(Of TValue) (value As TValue, jsonTypeInfo As JsonTypeInfo(Of TValue)) As String" />
      <MemberSignature Language="F#" Value="static member Serialize : 'Value * System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Value&gt; -&gt; string" Usage="System.Text.Json.JsonSerializer.Serialize (value, jsonTypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TValue&gt;&#xA; static System::String ^ Serialize(TValue value, System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TValue&gt; ^ jsonTypeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TValue" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="jsonTypeInfo" Type="System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt;" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The type of the value to serialize.</typeparam>
        <param name="value">The value to convert.</param>
        <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        <summary>Converts the provided value into a <see cref="T:System.String" />.</summary>
        <returns>A <see cref="T:System.String" /> representation of the value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Using a <xref:System.String> is not as efficient as using UTF-8
            encoding since the implementation internally uses UTF-8. See also <xref:System.Text.Json.JsonSerializer.SerializeToUtf8Bytes``1(``0,System.Text.Json.Serialization.Metadata.JsonTypeInfo{``0})>
            and <xref:System.Text.Json.JsonSerializer.SerializeAsync``1(System.IO.Stream,``0,System.Text.Json.Serialization.Metadata.JsonTypeInfo{``0},System.Threading.CancellationToken)>.

          ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jsonTypeInfo" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Serialize&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Serialize&lt;TValue&gt; (System.IO.Stream utf8Json, TValue value, System.Text.Json.JsonSerializerOptions? options = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Serialize&lt;TValue&gt;(class System.IO.Stream utf8Json, !!TValue value, class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Serialize``1(System.IO.Stream,``0,System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Serialize(Of TValue) (utf8Json As Stream, value As TValue, Optional options As JsonSerializerOptions = Nothing)" />
      <MemberSignature Language="F#" Value="static member Serialize : System.IO.Stream * 'Value * System.Text.Json.JsonSerializerOptions -&gt; unit" Usage="System.Text.Json.JsonSerializer.Serialize (utf8Json, value, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="utf8Json" Type="System.IO.Stream" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="value" Type="TValue" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The type of the value to serialize.</typeparam>
        <param name="utf8Json">The UTF-8 <see cref="T:System.IO.Stream" /> to write to.</param>
        <param name="value">The value to convert.</param>
        <param name="options">Options to control the conversion behavior.</param>
        <summary>Converts the provided value to UTF-8 encoded JSON text and write it to the <see cref="T:System.IO.Stream" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="utf8Json" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Serialize&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Serialize&lt;TValue&gt; (System.IO.Stream utf8Json, TValue value, System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt; jsonTypeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Serialize&lt;TValue&gt;(class System.IO.Stream utf8Json, !!TValue value, class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TValue&gt; jsonTypeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Serialize``1(System.IO.Stream,``0,System.Text.Json.Serialization.Metadata.JsonTypeInfo{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Serialize(Of TValue) (utf8Json As Stream, value As TValue, jsonTypeInfo As JsonTypeInfo(Of TValue))" />
      <MemberSignature Language="F#" Value="static member Serialize : System.IO.Stream * 'Value * System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Value&gt; -&gt; unit" Usage="System.Text.Json.JsonSerializer.Serialize (utf8Json, value, jsonTypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TValue&gt;&#xA; static void Serialize(System::IO::Stream ^ utf8Json, TValue value, System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TValue&gt; ^ jsonTypeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="utf8Json" Type="System.IO.Stream" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="value" Type="TValue" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="jsonTypeInfo" Type="System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt;" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The type of the value to serialize.</typeparam>
        <param name="utf8Json">The UTF-8 <see cref="T:System.IO.Stream" /> to write to.</param>
        <param name="value">The value to convert.</param>
        <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        <summary>Converts the provided value to UTF-8 encoded JSON text and write it to the <see cref="T:System.IO.Stream" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="utf8Json" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Serialize&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Serialize&lt;TValue&gt; (System.Text.Json.Utf8JsonWriter writer, TValue value, System.Text.Json.JsonSerializerOptions? options = default);" FrameworkAlternate="net-5.0;net-6.0;net-7.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Serialize&lt;TValue&gt;(class System.Text.Json.Utf8JsonWriter writer, !!TValue value, class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Serialize``1(System.Text.Json.Utf8JsonWriter,``0,System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Serialize(Of TValue) (writer As Utf8JsonWriter, value As TValue, Optional options As JsonSerializerOptions = Nothing)" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="F#" Value="static member Serialize : System.Text.Json.Utf8JsonWriter * 'Value * System.Text.Json.JsonSerializerOptions -&gt; unit" Usage="System.Text.Json.JsonSerializer.Serialize (writer, value, options)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Serialize(Of TValue) (writer As Utf8JsonWriter, value As TValue, Optional options As JsonSerializerOptions = Nothing)" FrameworkAlternate="net-6.0;net-7.0" />
      <MemberSignature Language="C#" Value="public static void Serialize&lt;TValue&gt; (System.Text.Json.Utf8JsonWriter writer, TValue value, System.Text.Json.JsonSerializerOptions options = default);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="writer" Type="System.Text.Json.Utf8JsonWriter" />
        <Parameter Name="value" Type="TValue" />
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The type of the value to serialize.</typeparam>
        <param name="writer">A JSON writer to write to.</param>
        <param name="value">The value to convert and write.</param>
        <param name="options">Options to control serialization behavior.</param>
        <summary>Writes the JSON representation of a type specified by a generic type parameter to the provided writer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The <xref:System.Text.Json.JsonWriterOptions> used to create the instance of the <xref:System.Text.Json.Utf8JsonWriter> take precedence over the <xref:System.Text.Json.JsonSerializerOptions> when they conflict. Hence, <xref:System.Text.Json.JsonWriterOptions.Indented?displayProperty=nameWithType>, <xref:System.Text.Json.JsonWriterOptions.SkipValidation?displayProperty=nameWithType>, and <xref:System.Text.Json.JsonWriterOptions.Encoder?displayProperty=nameWithType> are used while writing.

For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to).

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="writer" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="Serialize&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Serialize&lt;TValue&gt; (System.Text.Json.Utf8JsonWriter writer, TValue value, System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt; jsonTypeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Serialize&lt;TValue&gt;(class System.Text.Json.Utf8JsonWriter writer, !!TValue value, class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TValue&gt; jsonTypeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.Serialize``1(System.Text.Json.Utf8JsonWriter,``0,System.Text.Json.Serialization.Metadata.JsonTypeInfo{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub Serialize(Of TValue) (writer As Utf8JsonWriter, value As TValue, jsonTypeInfo As JsonTypeInfo(Of TValue))" />
      <MemberSignature Language="F#" Value="static member Serialize : System.Text.Json.Utf8JsonWriter * 'Value * System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Value&gt; -&gt; unit" Usage="System.Text.Json.JsonSerializer.Serialize (writer, value, jsonTypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TValue&gt;&#xA; static void Serialize(System::Text::Json::Utf8JsonWriter ^ writer, TValue value, System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TValue&gt; ^ jsonTypeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="writer" Type="System.Text.Json.Utf8JsonWriter" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="value" Type="TValue" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="jsonTypeInfo" Type="System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt;" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The type of the value to serialize.</typeparam>
        <param name="writer">The writer to write.</param>
        <param name="value">The value to convert and write.</param>
        <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        <summary>Writes one JSON value (including objects or arrays) to the provided writer.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="writer" /> or <paramref name="jsonTypeInfo" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="SerializeAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task SerializeAsync (System.IO.Stream utf8Json, object? value, Type inputType, System.Text.Json.JsonSerializerOptions? options = default, System.Threading.CancellationToken cancellationToken = default);" FrameworkAlternate="net-5.0;net-6.0;net-7.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task SerializeAsync(class System.IO.Stream utf8Json, object value, class System.Type inputType, class System.Text.Json.JsonSerializerOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.SerializeAsync(System.IO.Stream,System.Object,System.Type,System.Text.Json.JsonSerializerOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SerializeAsync (utf8Json As Stream, value As Object, inputType As Type, Optional options As JsonSerializerOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="F#" Value="static member SerializeAsync : System.IO.Stream * obj * Type * System.Text.Json.JsonSerializerOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Text.Json.JsonSerializer.SerializeAsync (utf8Json, value, inputType, options, cancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function SerializeAsync (utf8Json As Stream, value As Object, inputType As Type, Optional options As JsonSerializerOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task" FrameworkAlternate="net-6.0;net-7.0" />
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task SerializeAsync (System.IO.Stream utf8Json, object value, Type inputType, System.Text.Json.JsonSerializerOptions options = default, System.Threading.CancellationToken cancellationToken = default);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Json" Type="System.IO.Stream" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="inputType" Type="System.Type">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="utf8Json">The UTF-8 stream to write to.</param>
        <param name="value">The value to convert.</param>
        <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        <param name="options">Options to control serialization behavior.</param>
        <param name="cancellationToken">A token that may be used to cancel the write operation.</param>
        <summary>Asynchronously converts the value of a specified type to UTF-8 encoded JSON text and writes it to the specified stream.</summary>
        <returns>A task that represents the asynchronous write operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to).

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="inputType" /> is not compatible with <paramref name="value" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="utf8Json" /> or <paramref name="inputType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="System.Text.Json.Serialization.JsonConverter" /> for <paramref name="inputType" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="SerializeAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task SerializeAsync (System.IO.Stream utf8Json, object? value, Type inputType, System.Text.Json.Serialization.JsonSerializerContext context, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task SerializeAsync(class System.IO.Stream utf8Json, object value, class System.Type inputType, class System.Text.Json.Serialization.JsonSerializerContext context, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.SerializeAsync(System.IO.Stream,System.Object,System.Type,System.Text.Json.Serialization.JsonSerializerContext,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function SerializeAsync (utf8Json As Stream, value As Object, inputType As Type, context As JsonSerializerContext, Optional cancellationToken As CancellationToken = Nothing) As Task" />
      <MemberSignature Language="F#" Value="static member SerializeAsync : System.IO.Stream * obj * Type * System.Text.Json.Serialization.JsonSerializerContext * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Text.Json.JsonSerializer.SerializeAsync (utf8Json, value, inputType, context, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Json" Type="System.IO.Stream" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="value" Type="System.Object" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="inputType" Type="System.Type" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="context" Type="System.Text.Json.Serialization.JsonSerializerContext" Index="3" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="4" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <param name="utf8Json">The UTF-8 <see cref="T:System.IO.Stream" /> to write to.</param>
        <param name="value">The value to convert.</param>
        <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        <param name="context">A metadata provider for serializable types.</param>
        <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> that can be used to cancel the write operation.</param>
        <summary>Converts the provided value to UTF-8 encoded JSON text and write it to the <see cref="T:System.IO.Stream" />.</summary>
        <returns>A task that represents the asynchronous write operation.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="inputType" /> is not compatible with <paramref name="value" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="utf8Json" />, <paramref name="inputType" />, or <paramref name="context" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <paramref name="inputType" />  or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="SerializeAsync&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task SerializeAsync&lt;TValue&gt; (System.IO.Stream utf8Json, TValue value, System.Text.Json.JsonSerializerOptions? options = default, System.Threading.CancellationToken cancellationToken = default);" FrameworkAlternate="net-5.0;net-6.0;net-7.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task SerializeAsync&lt;TValue&gt;(class System.IO.Stream utf8Json, !!TValue value, class System.Text.Json.JsonSerializerOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.SerializeAsync``1(System.IO.Stream,``0,System.Text.Json.JsonSerializerOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SerializeAsync(Of TValue) (utf8Json As Stream, value As TValue, Optional options As JsonSerializerOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="F#" Value="static member SerializeAsync : System.IO.Stream * 'Value * System.Text.Json.JsonSerializerOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Text.Json.JsonSerializer.SerializeAsync (utf8Json, value, options, cancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function SerializeAsync(Of TValue) (utf8Json As Stream, value As TValue, Optional options As JsonSerializerOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task" FrameworkAlternate="net-6.0;net-7.0" />
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task SerializeAsync&lt;TValue&gt; (System.IO.Stream utf8Json, TValue value, System.Text.Json.JsonSerializerOptions options = default, System.Threading.CancellationToken cancellationToken = default);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="utf8Json" Type="System.IO.Stream" />
        <Parameter Name="value" Type="TValue" />
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The type of the value to serialize.</typeparam>
        <param name="utf8Json">The UTF-8 stream to write to.</param>
        <param name="value">The value to convert.</param>
        <param name="options">Options to control serialization behavior.</param>
        <param name="cancellationToken">A token that may be used to cancel the write operation.</param>
        <summary>Asynchronously converts a value of a type specified by a generic type parameter to UTF-8 encoded JSON text and writes it to a stream.</summary>
        <returns>A task that represents the asynchronous write operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to).

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="utf8Json" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="SerializeAsync&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task SerializeAsync&lt;TValue&gt; (System.IO.Stream utf8Json, TValue value, System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt; jsonTypeInfo, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task SerializeAsync&lt;TValue&gt;(class System.IO.Stream utf8Json, !!TValue value, class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TValue&gt; jsonTypeInfo, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.SerializeAsync``1(System.IO.Stream,``0,System.Text.Json.Serialization.Metadata.JsonTypeInfo{``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Function SerializeAsync(Of TValue) (utf8Json As Stream, value As TValue, jsonTypeInfo As JsonTypeInfo(Of TValue), Optional cancellationToken As CancellationToken = Nothing) As Task" />
      <MemberSignature Language="F#" Value="static member SerializeAsync : System.IO.Stream * 'Value * System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Value&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="System.Text.Json.JsonSerializer.SerializeAsync (utf8Json, value, jsonTypeInfo, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="utf8Json" Type="System.IO.Stream" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="value" Type="TValue" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="jsonTypeInfo" Type="System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt;" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="3" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The type of the value to serialize.</typeparam>
        <param name="utf8Json">The UTF-8 <see cref="T:System.IO.Stream" /> to write to.</param>
        <param name="value">The value to convert.</param>
        <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> that can be used to cancel the write operation.</param>
        <summary>Converts the provided value to UTF-8 encoded JSON text and write it to the <see cref="T:System.IO.Stream" />.</summary>
        <returns>A task that represents the asynchronous write operation.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="utf8Json" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="SerializeToDocument">
      <MemberSignature Language="C#" Value="public static System.Text.Json.JsonDocument SerializeToDocument (object? value, Type inputType, System.Text.Json.JsonSerializerOptions? options = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.JsonDocument SerializeToDocument(object value, class System.Type inputType, class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.SerializeToDocument(System.Object,System.Type,System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function SerializeToDocument (value As Object, inputType As Type, Optional options As JsonSerializerOptions = Nothing) As JsonDocument" />
      <MemberSignature Language="F#" Value="static member SerializeToDocument : obj * Type * System.Text.Json.JsonSerializerOptions -&gt; System.Text.Json.JsonDocument" Usage="System.Text.Json.JsonSerializer.SerializeToDocument (value, inputType, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="inputType" Type="System.Type" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        <param name="options">Options to control the conversion behavior.</param>
        <summary>Converts the provided value into a <see cref="T:System.Text.Json.JsonDocument" />.</summary>
        <returns>A <see cref="T:System.Text.Json.JsonDocument" /> representation of the value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="inputType" /> is not compatible with <paramref name="value" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inputType" /> is <see langword="null" />.
        </exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <paramref name="inputType" />  or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="SerializeToDocument">
      <MemberSignature Language="C#" Value="public static System.Text.Json.JsonDocument SerializeToDocument (object? value, Type inputType, System.Text.Json.Serialization.JsonSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.JsonDocument SerializeToDocument(object value, class System.Type inputType, class System.Text.Json.Serialization.JsonSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.SerializeToDocument(System.Object,System.Type,System.Text.Json.Serialization.JsonSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function SerializeToDocument (value As Object, inputType As Type, context As JsonSerializerContext) As JsonDocument" />
      <MemberSignature Language="F#" Value="static member SerializeToDocument : obj * Type * System.Text.Json.Serialization.JsonSerializerContext -&gt; System.Text.Json.JsonDocument" Usage="System.Text.Json.JsonSerializer.SerializeToDocument (value, inputType, context)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Json::JsonDocument ^ SerializeToDocument(System::Object ^ value, Type ^ inputType, System::Text::Json::Serialization::JsonSerializerContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="inputType" Type="System.Type" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="context" Type="System.Text.Json.Serialization.JsonSerializerContext" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        <param name="context">A metadata provider for serializable types.</param>
        <summary>Converts the provided value into a <see cref="T:System.Text.Json.JsonDocument" />.</summary>
        <returns>A <see cref="T:System.Text.Json.JsonDocument" /> representation of the value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <paramref name="inputType" /> or its serializable members.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Text.Json.Serialization.JsonSerializerContext.GetTypeInfo(System.Type)" /> method of the provided <paramref name="context" /> returns <see langword="null" /> for the type to convert.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inputType" /> or <paramref name="context" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SerializeToDocument&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.JsonDocument SerializeToDocument&lt;TValue&gt; (TValue value, System.Text.Json.JsonSerializerOptions? options = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.JsonDocument SerializeToDocument&lt;TValue&gt;(!!TValue value, class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.SerializeToDocument``1(``0,System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function SerializeToDocument(Of TValue) (value As TValue, Optional options As JsonSerializerOptions = Nothing) As JsonDocument" />
      <MemberSignature Language="F#" Value="static member SerializeToDocument : 'Value * System.Text.Json.JsonSerializerOptions -&gt; System.Text.Json.JsonDocument" Usage="System.Text.Json.JsonSerializer.SerializeToDocument (value, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonDocument</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TValue" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The type of the value to serialize.</typeparam>
        <param name="value">The value to convert.</param>
        <param name="options">Options to control the conversion behavior.</param>
        <summary>Converts the provided value into a <see cref="T:System.Text.Json.JsonDocument" />.</summary>
        <returns>A <see cref="T:System.Text.Json.JsonDocument" /> representation of the JSON value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="SerializeToDocument&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.JsonDocument SerializeToDocument&lt;TValue&gt; (TValue value, System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt; jsonTypeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.JsonDocument SerializeToDocument&lt;TValue&gt;(!!TValue value, class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TValue&gt; jsonTypeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.SerializeToDocument``1(``0,System.Text.Json.Serialization.Metadata.JsonTypeInfo{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SerializeToDocument(Of TValue) (value As TValue, jsonTypeInfo As JsonTypeInfo(Of TValue)) As JsonDocument" />
      <MemberSignature Language="F#" Value="static member SerializeToDocument : 'Value * System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Value&gt; -&gt; System.Text.Json.JsonDocument" Usage="System.Text.Json.JsonSerializer.SerializeToDocument (value, jsonTypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TValue&gt;&#xA; static System::Text::Json::JsonDocument ^ SerializeToDocument(TValue value, System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TValue&gt; ^ jsonTypeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonDocument</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TValue" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="jsonTypeInfo" Type="System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt;" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The type of the value to serialize.</typeparam>
        <param name="value">The value to convert.</param>
        <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        <summary>Converts the provided value into a <see cref="T:System.Text.Json.JsonDocument" />.</summary>
        <returns>A <see cref="T:System.Text.Json.JsonDocument" /> representation of the value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jsonTypeInfo" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SerializeToElement">
      <MemberSignature Language="C#" Value="public static System.Text.Json.JsonElement SerializeToElement (object? value, Type inputType, System.Text.Json.JsonSerializerOptions? options = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.Json.JsonElement SerializeToElement(object value, class System.Type inputType, class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.SerializeToElement(System.Object,System.Type,System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function SerializeToElement (value As Object, inputType As Type, Optional options As JsonSerializerOptions = Nothing) As JsonElement" />
      <MemberSignature Language="F#" Value="static member SerializeToElement : obj * Type * System.Text.Json.JsonSerializerOptions -&gt; System.Text.Json.JsonElement" Usage="System.Text.Json.JsonSerializer.SerializeToElement (value, inputType, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="inputType" Type="System.Type" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        <param name="options">Options to control the conversion behavior.</param>
        <summary>Converts the provided value into a <see cref="T:System.Text.Json.JsonDocument" />.</summary>
        <returns>A <see cref="T:System.Text.Json.JsonDocument" /> representation of the value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="inputType" /> is not compatible with <paramref name="value" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inputType" /> is <see langword="null" />.
        </exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <paramref name="inputType" />  or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="SerializeToElement">
      <MemberSignature Language="C#" Value="public static System.Text.Json.JsonElement SerializeToElement (object? value, Type inputType, System.Text.Json.Serialization.JsonSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.Json.JsonElement SerializeToElement(object value, class System.Type inputType, class System.Text.Json.Serialization.JsonSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.SerializeToElement(System.Object,System.Type,System.Text.Json.Serialization.JsonSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function SerializeToElement (value As Object, inputType As Type, context As JsonSerializerContext) As JsonElement" />
      <MemberSignature Language="F#" Value="static member SerializeToElement : obj * Type * System.Text.Json.Serialization.JsonSerializerContext -&gt; System.Text.Json.JsonElement" Usage="System.Text.Json.JsonSerializer.SerializeToElement (value, inputType, context)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Json::JsonElement SerializeToElement(System::Object ^ value, Type ^ inputType, System::Text::Json::Serialization::JsonSerializerContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="inputType" Type="System.Type" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="context" Type="System.Text.Json.Serialization.JsonSerializerContext" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        <param name="context">A metadata provider for serializable types.</param>
        <summary>Converts the provided value into a <see cref="T:System.Text.Json.JsonDocument" />.</summary>
        <returns>A <see cref="T:System.Text.Json.JsonDocument" /> representation of the value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <paramref name="inputType" /> or its serializable members.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Text.Json.Serialization.JsonSerializerContext.GetTypeInfo(System.Type)" /> method of the provided <paramref name="context" /> returns <see langword="null" /> for the type to convert.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inputType" /> or <paramref name="context" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SerializeToElement&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.JsonElement SerializeToElement&lt;TValue&gt; (TValue value, System.Text.Json.JsonSerializerOptions? options = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.Json.JsonElement SerializeToElement&lt;TValue&gt;(!!TValue value, class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.SerializeToElement``1(``0,System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function SerializeToElement(Of TValue) (value As TValue, Optional options As JsonSerializerOptions = Nothing) As JsonElement" />
      <MemberSignature Language="F#" Value="static member SerializeToElement : 'Value * System.Text.Json.JsonSerializerOptions -&gt; System.Text.Json.JsonElement" Usage="System.Text.Json.JsonSerializer.SerializeToElement (value, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonElement</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TValue" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The type of the value to serialize.</typeparam>
        <param name="value">The value to convert.</param>
        <param name="options">Options to control the conversion behavior.</param>
        <summary>Converts the provided value into a <see cref="T:System.Text.Json.JsonDocument" />.</summary>
        <returns>A <see cref="T:System.Text.Json.JsonDocument" /> representation of the JSON value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="SerializeToElement&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.JsonElement SerializeToElement&lt;TValue&gt; (TValue value, System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt; jsonTypeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Text.Json.JsonElement SerializeToElement&lt;TValue&gt;(!!TValue value, class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TValue&gt; jsonTypeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.SerializeToElement``1(``0,System.Text.Json.Serialization.Metadata.JsonTypeInfo{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SerializeToElement(Of TValue) (value As TValue, jsonTypeInfo As JsonTypeInfo(Of TValue)) As JsonElement" />
      <MemberSignature Language="F#" Value="static member SerializeToElement : 'Value * System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Value&gt; -&gt; System.Text.Json.JsonElement" Usage="System.Text.Json.JsonSerializer.SerializeToElement (value, jsonTypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TValue&gt;&#xA; static System::Text::Json::JsonElement SerializeToElement(TValue value, System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TValue&gt; ^ jsonTypeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonElement</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TValue" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="jsonTypeInfo" Type="System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt;" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The type of the value to serialize.</typeparam>
        <param name="value">The value to convert.</param>
        <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        <summary>Converts the provided value into a <see cref="T:System.Text.Json.JsonDocument" />.</summary>
        <returns>A <see cref="T:System.Text.Json.JsonDocument" /> representation of the value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jsonTypeInfo" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SerializeToNode">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Nodes.JsonNode? SerializeToNode (object? value, Type inputType, System.Text.Json.JsonSerializerOptions? options = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.Nodes.JsonNode SerializeToNode(object value, class System.Type inputType, class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.SerializeToNode(System.Object,System.Type,System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function SerializeToNode (value As Object, inputType As Type, Optional options As JsonSerializerOptions = Nothing) As JsonNode" />
      <MemberSignature Language="F#" Value="static member SerializeToNode : obj * Type * System.Text.Json.JsonSerializerOptions -&gt; System.Text.Json.Nodes.JsonNode" Usage="System.Text.Json.JsonSerializer.SerializeToNode (value, inputType, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Json.Nodes.JsonNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="inputType" Type="System.Type" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        <param name="options">Options to control the conversion behavior.</param>
        <summary>Converts the provided value into a <see cref="T:System.Text.Json.Nodes.JsonNode" />.</summary>
        <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> representation of the value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="inputType" /> is not compatible with <paramref name="value" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inputType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <paramref name="inputType" />  or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="SerializeToNode">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Nodes.JsonNode? SerializeToNode (object? value, Type inputType, System.Text.Json.Serialization.JsonSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.Nodes.JsonNode SerializeToNode(object value, class System.Type inputType, class System.Text.Json.Serialization.JsonSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.SerializeToNode(System.Object,System.Type,System.Text.Json.Serialization.JsonSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function SerializeToNode (value As Object, inputType As Type, context As JsonSerializerContext) As JsonNode" />
      <MemberSignature Language="F#" Value="static member SerializeToNode : obj * Type * System.Text.Json.Serialization.JsonSerializerContext -&gt; System.Text.Json.Nodes.JsonNode" Usage="System.Text.Json.JsonSerializer.SerializeToNode (value, inputType, context)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Text::Json::Nodes::JsonNode ^ SerializeToNode(System::Object ^ value, Type ^ inputType, System::Text::Json::Serialization::JsonSerializerContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Nodes.JsonNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="inputType" Type="System.Type" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="context" Type="System.Text.Json.Serialization.JsonSerializerContext" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        <param name="context">A metadata provider for serializable types.</param>
        <summary>Converts the provided value into a <see cref="T:System.Text.Json.Nodes.JsonNode" />.</summary>
        <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> representation of the value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <paramref name="inputType" /> or its serializable members.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Text.Json.Serialization.JsonSerializerContext.GetTypeInfo(System.Type)" /> method of the provided <paramref name="context" /> returns <see langword="null" /> for the type to convert.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inputType" /> or <paramref name="context" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SerializeToNode&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Nodes.JsonNode? SerializeToNode&lt;TValue&gt; (TValue value, System.Text.Json.JsonSerializerOptions? options = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.Nodes.JsonNode SerializeToNode&lt;TValue&gt;(!!TValue value, class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.SerializeToNode``1(``0,System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function SerializeToNode(Of TValue) (value As TValue, Optional options As JsonSerializerOptions = Nothing) As JsonNode" />
      <MemberSignature Language="F#" Value="static member SerializeToNode : 'Value * System.Text.Json.JsonSerializerOptions -&gt; System.Text.Json.Nodes.JsonNode" Usage="System.Text.Json.JsonSerializer.SerializeToNode (value, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Json.Nodes.JsonNode</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TValue" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The type of the value to serialize.</typeparam>
        <param name="value">The value to convert.</param>
        <param name="options">Options to control the conversion behavior.</param>
        <summary>Converts the provided value into a <see cref="T:System.Text.Json.Nodes.JsonNode" />.</summary>
        <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> representation of the JSON value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="SerializeToNode&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static System.Text.Json.Nodes.JsonNode? SerializeToNode&lt;TValue&gt; (TValue value, System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt; jsonTypeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Json.Nodes.JsonNode SerializeToNode&lt;TValue&gt;(!!TValue value, class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TValue&gt; jsonTypeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.SerializeToNode``1(``0,System.Text.Json.Serialization.Metadata.JsonTypeInfo{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SerializeToNode(Of TValue) (value As TValue, jsonTypeInfo As JsonTypeInfo(Of TValue)) As JsonNode" />
      <MemberSignature Language="F#" Value="static member SerializeToNode : 'Value * System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Value&gt; -&gt; System.Text.Json.Nodes.JsonNode" Usage="System.Text.Json.JsonSerializer.SerializeToNode (value, jsonTypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TValue&gt;&#xA; static System::Text::Json::Nodes::JsonNode ^ SerializeToNode(TValue value, System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TValue&gt; ^ jsonTypeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Nodes.JsonNode</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TValue" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="jsonTypeInfo" Type="System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt;" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The type of the value to serialize.</typeparam>
        <param name="value">The value to convert.</param>
        <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        <summary>Converts the provided value into a <see cref="T:System.Text.Json.Nodes.JsonNode" />.</summary>
        <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> representation of the value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jsonTypeInfo" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SerializeToUtf8Bytes">
      <MemberSignature Language="C#" Value="public static byte[] SerializeToUtf8Bytes (object? value, Type inputType, System.Text.Json.JsonSerializerOptions? options = default);" FrameworkAlternate="net-5.0;net-6.0;net-7.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] SerializeToUtf8Bytes(object value, class System.Type inputType, class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(System.Object,System.Type,System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SerializeToUtf8Bytes (value As Object, inputType As Type, Optional options As JsonSerializerOptions = Nothing) As Byte()" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="F#" Value="static member SerializeToUtf8Bytes : obj * Type * System.Text.Json.JsonSerializerOptions -&gt; byte[]" Usage="System.Text.Json.JsonSerializer.SerializeToUtf8Bytes (value, inputType, options)" />
      <MemberSignature Language="VB.NET" Value="Public Function SerializeToUtf8Bytes (value As Object, inputType As Type, Optional options As JsonSerializerOptions = Nothing) As Byte()" FrameworkAlternate="net-6.0;net-7.0" />
      <MemberSignature Language="C#" Value="public static byte[] SerializeToUtf8Bytes (object value, Type inputType, System.Text.Json.JsonSerializerOptions options = default);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="inputType" Type="System.Type">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembers(System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicFields | System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes.PublicProperties)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        <param name="options">Options to control the conversion behavior.</param>
        <summary>Converts a value of the specified type into a JSON string, encoded as UTF-8 bytes.</summary>
        <returns>A JSON string representation of the value, encoded as UTF-8 bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to).

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="inputType" /> is not compatible with <paramref name="value" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inputType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="System.Text.Json.Serialization.JsonConverter" /> for <paramref name="inputType" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="SerializeToUtf8Bytes">
      <MemberSignature Language="C#" Value="public static byte[] SerializeToUtf8Bytes (object? value, Type inputType, System.Text.Json.Serialization.JsonSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] SerializeToUtf8Bytes(object value, class System.Type inputType, class System.Text.Json.Serialization.JsonSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(System.Object,System.Type,System.Text.Json.Serialization.JsonSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Function SerializeToUtf8Bytes (value As Object, inputType As Type, context As JsonSerializerContext) As Byte()" />
      <MemberSignature Language="F#" Value="static member SerializeToUtf8Bytes : obj * Type * System.Text.Json.Serialization.JsonSerializerContext -&gt; byte[]" Usage="System.Text.Json.JsonSerializer.SerializeToUtf8Bytes (value, inputType, context)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Byte&gt; ^ SerializeToUtf8Bytes(System::Object ^ value, Type ^ inputType, System::Text::Json::Serialization::JsonSerializerContext ^ context);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="inputType" Type="System.Type" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="context" Type="System.Text.Json.Serialization.JsonSerializerContext" Index="2" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to convert.</param>
        <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        <param name="context">A metadata provider for serializable types.</param>
        <summary>Converts the provided value into a <see cref="T:System.Byte" /> array.</summary>
        <returns>A UTF-8 representation of the value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="inputType" /> is not compatible with <paramref name="value" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="inputType" /> is <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <paramref name="inputType" />  or its serializable members.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Text.Json.Serialization.JsonSerializerContext.GetTypeInfo(System.Type)" /> method of the provided <paramref name="context" /> returns <see langword="null" /> for the type to convert.</exception>
      </Docs>
    </Member>
    <Member MemberName="SerializeToUtf8Bytes&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static byte[] SerializeToUtf8Bytes&lt;TValue&gt; (TValue value, System.Text.Json.JsonSerializerOptions? options = default);" FrameworkAlternate="net-5.0;net-6.0;net-7.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] SerializeToUtf8Bytes&lt;TValue&gt;(!!TValue value, class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.SerializeToUtf8Bytes``1(``0,System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SerializeToUtf8Bytes(Of TValue) (value As TValue, Optional options As JsonSerializerOptions = Nothing) As Byte()" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="F#" Value="static member SerializeToUtf8Bytes : 'Value * System.Text.Json.JsonSerializerOptions -&gt; byte[]" Usage="System.Text.Json.JsonSerializer.SerializeToUtf8Bytes (value, options)" />
      <MemberSignature Language="VB.NET" Value="Public Function SerializeToUtf8Bytes(Of TValue) (value As TValue, Optional options As JsonSerializerOptions = Nothing) As Byte()" FrameworkAlternate="net-6.0;net-7.0" />
      <MemberSignature Language="C#" Value="public static byte[] SerializeToUtf8Bytes&lt;TValue&gt; (TValue value, System.Text.Json.JsonSerializerOptions options = default);" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TValue" />
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The type of the value.</typeparam>
        <param name="value">The value to convert.</param>
        <param name="options">Options to control the conversion behavior.</param>
        <summary>Converts the value of a type specified by a generic type parameter into a JSON string, encoded as UTF-8 bytes.</summary>
        <returns>A JSON string representation of the value, encoded as UTF-8 bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to).

 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="SerializeToUtf8Bytes&lt;TValue&gt;">
      <MemberSignature Language="C#" Value="public static byte[] SerializeToUtf8Bytes&lt;TValue&gt; (TValue value, System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt; jsonTypeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] SerializeToUtf8Bytes&lt;TValue&gt;(!!TValue value, class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1&lt;!!TValue&gt; jsonTypeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializer.SerializeToUtf8Bytes``1(``0,System.Text.Json.Serialization.Metadata.JsonTypeInfo{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SerializeToUtf8Bytes(Of TValue) (value As TValue, jsonTypeInfo As JsonTypeInfo(Of TValue)) As Byte()" />
      <MemberSignature Language="F#" Value="static member SerializeToUtf8Bytes : 'Value * System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;'Value&gt; -&gt; byte[]" Usage="System.Text.Json.JsonSerializer.SerializeToUtf8Bytes (value, jsonTypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TValue&gt;&#xA; static cli::array &lt;System::Byte&gt; ^ SerializeToUtf8Bytes(TValue value, System::Text::Json::Serialization::Metadata::JsonTypeInfo&lt;TValue&gt; ^ jsonTypeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TValue" Index="0" FrameworkAlternate="net-6.0;net-7.0" />
        <Parameter Name="jsonTypeInfo" Type="System.Text.Json.Serialization.Metadata.JsonTypeInfo&lt;TValue&gt;" Index="1" FrameworkAlternate="net-6.0;net-7.0" />
      </Parameters>
      <Docs>
        <typeparam name="TValue">The type of the value to serialize.</typeparam>
        <param name="value">The value to convert.</param>
        <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        <summary>Converts the provided value into a <see cref="T:System.Byte" /> array.</summary>
        <returns>A UTF-8 representation of the value.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <typeparamref name="TValue" /> or its serializable members.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="jsonTypeInfo" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
