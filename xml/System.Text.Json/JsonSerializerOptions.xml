<Type Name="JsonSerializerOptions" FullName="System.Text.Json.JsonSerializerOptions">
  <TypeSignature Language="C#" Value="public sealed class JsonSerializerOptions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit JsonSerializerOptions extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Text.Json.JsonSerializerOptions" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class JsonSerializerOptions" />
  <TypeSignature Language="C++ CLI" Value="public ref class JsonSerializerOptions sealed" />
  <TypeSignature Language="F#" Value="type JsonSerializerOptions = class" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Json</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Provides options to be used with <see cref="T:System.Text.Json.JsonSerializer" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks

For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to).

 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public JsonSerializerOptions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializerOptions.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; JsonSerializerOptions();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Text.Json.JsonSerializerOptions" /> class.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public JsonSerializerOptions (System.Text.Json.JsonSerializerDefaults defaults);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Text.Json.JsonSerializerDefaults defaults) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializerOptions.#ctor(System.Text.Json.JsonSerializerDefaults)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaults As JsonSerializerDefaults)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; JsonSerializerOptions(System::Text::Json::JsonSerializerDefaults defaults);" />
      <MemberSignature Language="F#" Value="new System.Text.Json.JsonSerializerOptions : System.Text.Json.JsonSerializerDefaults -&gt; System.Text.Json.JsonSerializerOptions" Usage="new System.Text.Json.JsonSerializerOptions defaults" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaults" Type="System.Text.Json.JsonSerializerDefaults" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="defaults">The <see cref="T:System.Text.Json.JsonSerializerDefaults" /> to reason about.</param>
        <summary>Constructs a new <see cref="T:System.Text.Json.JsonSerializerOptions" /> instance with a predefined set of options determined by the specified <see cref="T:System.Text.Json.JsonSerializerDefaults" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public JsonSerializerOptions (System.Text.Json.JsonSerializerOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializerOptions.#ctor(System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (options As JsonSerializerOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; JsonSerializerOptions(System::Text::Json::JsonSerializerOptions ^ options);" />
      <MemberSignature Language="F#" Value="new System.Text.Json.JsonSerializerOptions : System.Text.Json.JsonSerializerOptions -&gt; System.Text.Json.JsonSerializerOptions" Usage="new System.Text.Json.JsonSerializerOptions options" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="options">The options instance to copy options from.</param>
        <summary>Copies the options from a <see cref="T:System.Text.Json.JsonSerializerOptions" /> instance to a new instance.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="options" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowTrailingCommas">
      <MemberSignature Language="C#" Value="public bool AllowTrailingCommas { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowTrailingCommas" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.AllowTrailingCommas" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowTrailingCommas As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowTrailingCommas { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowTrailingCommas : bool with get, set" Usage="System.Text.Json.JsonSerializerOptions.AllowTrailingCommas" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Get or sets a value that indicates whether an extra comma at the end of a list of JSON values in an object or array is allowed (and ignored) within the JSON payload being deserialized.</summary>
        <value>
          <see langword="true" /> if an extra comma at the end of a list of JSON values in an object or array is allowed (and ignored); <see langword="false" /> otherwise.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

By default, `AllowTrailingCommas` is set to `false`, and a <xref:System.Text.Json.JsonException> is thrown during deserialization if a trailing comma is encountered.

For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to#allow-comments-and-trailing-commas).

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This property was set after serialization or deserialization has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Converters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Text.Json.Serialization.JsonConverter&gt;? Converters { get; }" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Text.Json.Serialization.JsonConverter&gt; Converters" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.Converters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Converters As IList(Of JsonConverter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Text::Json::Serialization::JsonConverter ^&gt; ^ Converters { System::Collections::Generic::IList&lt;System::Text::Json::Serialization::JsonConverter ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Converters : System.Collections.Generic.IList&lt;System.Text.Json.Serialization.JsonConverter&gt;" Usage="System.Text.Json.JsonSerializerOptions.Converters" />
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Text.Json.Serialization.JsonConverter&gt; Converters { get; }" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Text.Json.Serialization.JsonConverter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the list of user-defined converters that were registered.</summary>
        <value>The list of custom converters.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Once serialization or deserialization occurs, the list cannot be modified.

For more information, see [How to write custom converters](/dotnet/standard/serialization/system-text-json-converters-how-to#registration-sample---converters-collection).

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultBufferSize">
      <MemberSignature Language="C#" Value="public int DefaultBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DefaultBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.DefaultBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DefaultBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBufferSize : int with get, set" Usage="System.Text.Json.JsonSerializerOptions.DefaultBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the default buffer size, in bytes, to use when creating temporary buffers.</summary>
        <value>The default buffer size in bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The default buffer size, in bytes, is 16,384.
For most workloads, the default size is a reasonable amount of JSON to buffer while reading from a stream or writing to a stream.
That is, it performs well without creating objects on the Large Object Heap for the Garbage Collector (GC) to track.
In non-streaming scenarios, increasing the default buffer size could improve performance for large JSON strings or UTF-8 byte arrays.
We recommend that you leave this value unchanged unless changing it makes an observable difference in performance.


          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The buffer size is less than 1.</exception>
        <exception cref="T:System.InvalidOperationException">This property was set after serialization or deserialization has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultIgnoreCondition">
      <MemberSignature Language="C#" Value="public System.Text.Json.Serialization.JsonIgnoreCondition DefaultIgnoreCondition { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.Json.Serialization.JsonIgnoreCondition DefaultIgnoreCondition" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.DefaultIgnoreCondition" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultIgnoreCondition As JsonIgnoreCondition" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::Serialization::JsonIgnoreCondition DefaultIgnoreCondition { System::Text::Json::Serialization::JsonIgnoreCondition get(); void set(System::Text::Json::Serialization::JsonIgnoreCondition value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultIgnoreCondition : System.Text.Json.Serialization.JsonIgnoreCondition with get, set" Usage="System.Text.Json.JsonSerializerOptions.DefaultIgnoreCondition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonIgnoreCondition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies a condition to determine when properties with default values are ignored during serialization or deserialization.
 The default value is <see cref="F:System.Text.Json.Serialization.JsonIgnoreCondition.Never" />.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">This property is set to <see cref="F:System.Text.Json.Serialization.JsonIgnoreCondition.Always" />.</exception>
        <exception cref="T:System.InvalidOperationException">This property is set after serialization or deserialization has occurred.

-or-

<see cref="P:System.Text.Json.JsonSerializerOptions.IgnoreNullValues" /> has been set to <see langword="true" />. These properties cannot be used together.</exception>
      </Docs>
    </Member>
    <Member MemberName="DictionaryKeyPolicy">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonNamingPolicy DictionaryKeyPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Json.JsonNamingPolicy DictionaryKeyPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.DictionaryKeyPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property DictionaryKeyPolicy As JsonNamingPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::JsonNamingPolicy ^ DictionaryKeyPolicy { System::Text::Json::JsonNamingPolicy ^ get(); void set(System::Text::Json::JsonNamingPolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DictionaryKeyPolicy : System.Text.Json.JsonNamingPolicy with get, set" Usage="System.Text.Json.JsonSerializerOptions.DictionaryKeyPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonNamingPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the policy used to convert a <see cref="T:System.Collections.IDictionary" /> key's name to another format, such as camel-casing.</summary>
        <value>The policy used to convert a <see cref="T:System.Collections.IDictionary" /> key's name to another format.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This property can be set to <xref:System.Text.Json.JsonNamingPolicy.CamelCase?displayProperty=nameWithType> to specify a camel-casing policy.

This property can be set to <xref:System.Text.Json.JsonNamingPolicy.CamelCase> to specify a camel-casing policy.

It is not used when deserializing.

For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to#camel-case-dictionary-keys).

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Encoder">
      <MemberSignature Language="C#" Value="public System.Text.Encodings.Web.JavaScriptEncoder Encoder { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encodings.Web.JavaScriptEncoder Encoder" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.Encoder" />
      <MemberSignature Language="VB.NET" Value="Public Property Encoder As JavaScriptEncoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encodings::Web::JavaScriptEncoder ^ Encoder { System::Text::Encodings::Web::JavaScriptEncoder ^ get(); void set(System::Text::Encodings::Web::JavaScriptEncoder ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Encoder : System.Text.Encodings.Web.JavaScriptEncoder with get, set" Usage="System.Text.Json.JsonSerializerOptions.Encoder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encodings.Web.JavaScriptEncoder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the encoder to use when escaping strings, or <see langword="null" /> to use the default encoder.</summary>
        <value>The JavaScript character encoding.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to#customize-character-encoding).

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public System.Text.Json.Serialization.JsonConverter GetConverter (Type typeToConvert);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.Json.Serialization.JsonConverter GetConverter(class System.Type typeToConvert) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializerOptions.GetConverter(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConverter (typeToConvert As Type) As JsonConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::Json::Serialization::JsonConverter ^ GetConverter(Type ^ typeToConvert);" />
      <MemberSignature Language="F#" Value="member this.GetConverter : Type -&gt; System.Text.Json.Serialization.JsonConverter" Usage="jsonSerializerOptions.GetConverter typeToConvert" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeToConvert" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="typeToConvert">The type to return a converter for.</param>
        <summary>Returns the converter for the specified type.</summary>
        <returns>The first converter that supports the given type, or <see langword="null" /> if there is no converter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to#sample-factory-pattern-converter).

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The configured <see cref="System.Text.Json.Serialization.JsonConverter" /> for <paramref name="typeToConvert" /> returned an invalid converter.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="System.Text.Json.Serialization.JsonConverter" /> for <paramref name="typeToConvert" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="IgnoreNullValues">
      <MemberSignature Language="C#" Value="public bool IgnoreNullValues { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreNullValues" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.IgnoreNullValues" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreNullValues As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreNullValues { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreNullValues : bool with get, set" Usage="System.Text.Json.JsonSerializerOptions.IgnoreNullValues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that determines whether <see langword="null" /> values are ignored during serialization and deserialization. The default value is <see langword="false" />.</summary>
        <value>
          <see langword="true" /> to ignore null values during serialization and deserialization; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For more information, see [Exclude all null value properties](/dotnet/standard/serialization/system-text-json-how-to#exclude-all-null-value-properties) and [Ignore null when deserializing](/dotnet/standard/serialization/system-text-json-how-to#ignore-null-when-deserializing).

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This property was set after serialization or deserialization has occurred.

-or-

<see cref="P:System.Text.Json.JsonSerializerOptions.DefaultIgnoreCondition" /> has been set to a non-default value. These properties cannot be used together.</exception>
      </Docs>
    </Member>
    <Member MemberName="IgnoreReadOnlyFields">
      <MemberSignature Language="C#" Value="public bool IgnoreReadOnlyFields { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreReadOnlyFields" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.IgnoreReadOnlyFields" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreReadOnlyFields As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreReadOnlyFields { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreReadOnlyFields : bool with get, set" Usage="System.Text.Json.JsonSerializerOptions.IgnoreReadOnlyFields" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether read-only fields are ignored during serialization. A field is read-only if it is marked with the <see langword="readonly" /> keyword. The default value is <see langword="false" />.</summary>
        <value>
          <see langword="true" /> if read-only fields should be ignored during serialization; <see langword="false" /> otherwise.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Read-only fields are not deserialized regardless of this setting.

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This property is set after serialization or deserialization has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="IgnoreReadOnlyProperties">
      <MemberSignature Language="C#" Value="public bool IgnoreReadOnlyProperties { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreReadOnlyProperties" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.IgnoreReadOnlyProperties" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreReadOnlyProperties As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreReadOnlyProperties { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreReadOnlyProperties : bool with get, set" Usage="System.Text.Json.JsonSerializerOptions.IgnoreReadOnlyProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that determines whether read-only properties are ignored during serialization. The default value is <see langword="false" />.</summary>
        <value>
          <see langword="true" /> to ignore read-only properties during serialization; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

A property is read-only if it contains a public getter but not a public setter. 

Read-only properties are not deserialized regardless of this setting.

For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to#exclude-all-read-only-properties).

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This property was set after serialization or deserialization has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="IncludeFields">
      <MemberSignature Language="C#" Value="public bool IncludeFields { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeFields" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.IncludeFields" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeFields As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeFields { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IncludeFields : bool with get, set" Usage="System.Text.Json.JsonSerializerOptions.IncludeFields" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether fields are handled during serialization and deserialization.
            The default value is <see langword="false" />.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">This property is set after serialization or deserialization has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxDepth">
      <MemberSignature Language="C#" Value="public int MaxDepth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxDepth" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.MaxDepth" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxDepth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxDepth { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxDepth : int with get, set" Usage="System.Text.Json.JsonSerializerOptions.MaxDepth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum depth allowed when serializing or deserializing JSON, with the default value of 0 indicating a maximum depth of 64.</summary>
        <value>The maximum depth allowed when serializing or deserializing JSON.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Going past this depth throws a <xref:System.Text.Json.JsonException>.

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This property was set after serialization or deserialization has occurred.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The max depth is set to a negative value.</exception>
      </Docs>
    </Member>
    <Member MemberName="NumberHandling">
      <MemberSignature Language="C#" Value="public System.Text.Json.Serialization.JsonNumberHandling NumberHandling { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.Json.Serialization.JsonNumberHandling NumberHandling" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.NumberHandling" />
      <MemberSignature Language="VB.NET" Value="Public Property NumberHandling As JsonNumberHandling" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::Serialization::JsonNumberHandling NumberHandling { System::Text::Json::Serialization::JsonNumberHandling get(); void set(System::Text::Json::Serialization::JsonNumberHandling value); };" />
      <MemberSignature Language="F#" Value="member this.NumberHandling : System.Text.Json.Serialization.JsonNumberHandling with get, set" Usage="System.Text.Json.JsonSerializerOptions.NumberHandling" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonNumberHandling</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies how number types should be handled when serializing or deserializing.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">This property is set after serialization or deserialization has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="PropertyNameCaseInsensitive">
      <MemberSignature Language="C#" Value="public bool PropertyNameCaseInsensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PropertyNameCaseInsensitive" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.PropertyNameCaseInsensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyNameCaseInsensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PropertyNameCaseInsensitive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PropertyNameCaseInsensitive : bool with get, set" Usage="System.Text.Json.JsonSerializerOptions.PropertyNameCaseInsensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that determines whether a property's name uses a case-insensitive comparison during deserialization. The default value is <see langword="false" />.</summary>
        <value>
          <see langword="true" /> to compare property names using case-insensitive comparison; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

There is a performance cost associated with case-insensitive comparison (that is, when `PropertyNameCaseInsensitive` is `true`).

For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to#case-insensitive-property-matching).

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyNamingPolicy">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonNamingPolicy PropertyNamingPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Json.JsonNamingPolicy PropertyNamingPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.PropertyNamingPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyNamingPolicy As JsonNamingPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::JsonNamingPolicy ^ PropertyNamingPolicy { System::Text::Json::JsonNamingPolicy ^ get(); void set(System::Text::Json::JsonNamingPolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PropertyNamingPolicy : System.Text.Json.JsonNamingPolicy with get, set" Usage="System.Text.Json.JsonSerializerOptions.PropertyNamingPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonNamingPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that specifies the policy used to convert a property's name on an object to another format, such as camel-casing, or <see langword="null" /> to leave property names unchanged.</summary>
        <value>A property naming policy, or <see langword="null" /> to leave property names unchanged.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The resulting property name is expected to match the JSON payload during deserialization, and will be used when writing the property name during serialization.

The policy is not used for properties that have a <xref:System.Text.Json.Serialization.JsonPropertyNameAttribute> applied.

This property can be set to <xref:System.Text.Json.JsonNamingPolicy.CamelCase?displayProperty=nameWithType> to specify a camel-casing policy.

For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to#customize-json-names-and-values).

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadCommentHandling">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonCommentHandling ReadCommentHandling { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.Json.JsonCommentHandling ReadCommentHandling" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.ReadCommentHandling" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadCommentHandling As JsonCommentHandling" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::JsonCommentHandling ReadCommentHandling { System::Text::Json::JsonCommentHandling get(); void set(System::Text::Json::JsonCommentHandling value); };" />
      <MemberSignature Language="F#" Value="member this.ReadCommentHandling : System.Text.Json.JsonCommentHandling with get, set" Usage="System.Text.Json.JsonSerializerOptions.ReadCommentHandling" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonCommentHandling</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that defines how comments are handled during deserialization.</summary>
        <value>A value that indicates whether comments are allowed, disallowed, or skipped.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

By default, a <xref:System.Text.Json.JsonException> is thrown during deserialization if a comment is encountered.

For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to#allow-comments-and-trailing-commas).

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This property was set after serialization or deserialization has occurred.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The comment handling enum is set to a value that is not supported (or not within the <see cref="T:System.Text.Json.JsonCommentHandling" /> enum range).</exception>
      </Docs>
    </Member>
    <Member MemberName="ReferenceHandler">
      <MemberSignature Language="C#" Value="public System.Text.Json.Serialization.ReferenceHandler ReferenceHandler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Json.Serialization.ReferenceHandler ReferenceHandler" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.ReferenceHandler" />
      <MemberSignature Language="VB.NET" Value="Public Property ReferenceHandler As ReferenceHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::Serialization::ReferenceHandler ^ ReferenceHandler { System::Text::Json::Serialization::ReferenceHandler ^ get(); void set(System::Text::Json::Serialization::ReferenceHandler ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ReferenceHandler : System.Text.Json.Serialization.ReferenceHandler with get, set" Usage="System.Text.Json.JsonSerializerOptions.ReferenceHandler" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.ReferenceHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Configures how object references are handled when reading and writing JSON.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

By default, serialization does not support objects with cycles and does not preserve duplicate references. Metadata properties will not be written when serializing reference types and will be treated as regular properties on deserialize.
 
* On Serialize:

  * Treats duplicate object references as if they were unique and writes all their properties.
  * The serializer throws a <xref:System.Text.Json.JsonException> if an object contains a cycle.

* On Deserialize:

  * Metadata properties (`$id`, `$values`, and `$ref`) will not be consumed and therefore will be treated as regular JSON properties.
  * The metadata properties can map to a real property on the returned object if the property names match, or will be added to the <xref:System.Text.Json.Serialization.JsonExtensionDataAttribute> overflow dictionary, if one exists; otherwise, they are ignored.

Use <xref:System.Text.Json.Serialization.ReferenceHandler.Preserve> to enable unique object reference preservation on serialization and metadata consumption to read preserved references on deserialization.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteIndented">
      <MemberSignature Language="C#" Value="public bool WriteIndented { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool WriteIndented" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.WriteIndented" />
      <MemberSignature Language="VB.NET" Value="Public Property WriteIndented As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool WriteIndented { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.WriteIndented : bool with get, set" Usage="System.Text.Json.JsonSerializerOptions.WriteIndented" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that defines whether JSON should use pretty printing. By default, JSON is serialized without any extra white space.</summary>
        <value>
          <see langword="true" /> if JSON should pretty print on serialization; otherwise, <see langword="false" />. The default is <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Pretty printing includes: 

- Indenting nested JSON tokens.
- Adding new lines
- Adding white space between property names and values. 

For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to#serialize-to-formatted-json).

         ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This property was set after serialization or deserialization has occurred.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
