<Type Name="JsonSerializerOptions" FullName="System.Text.Json.JsonSerializerOptions">
  <TypeSignature Language="C#" Value="public sealed class JsonSerializerOptions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit JsonSerializerOptions extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Text.Json.JsonSerializerOptions" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class JsonSerializerOptions" />
  <TypeSignature Language="C++ CLI" Value="public ref class JsonSerializerOptions sealed" />
  <TypeSignature Language="F#" Value="type JsonSerializerOptions = class" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Json</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Provides options to be used with <see cref="T:System.Text.Json.JsonSerializer" />.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public JsonSerializerOptions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializerOptions.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; JsonSerializerOptions();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Text.Json.JsonSerializerOptions" /> class.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowTrailingCommas">
      <MemberSignature Language="C#" Value="public bool AllowTrailingCommas { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowTrailingCommas" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.AllowTrailingCommas" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowTrailingCommas As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowTrailingCommas { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowTrailingCommas : bool with get, set" Usage="System.Text.Json.JsonSerializerOptions.AllowTrailingCommas" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Get or sets a value that indicates whether an extra comma at the end of a list of JSON values in an object or array is allowed (and ignored) within the JSON payload being deserialized.</summary>
        <value>
          <see langword="true" /> if an extra comma at the end of a list of JSON values in an object or array is allowed (and ignored); <see langword="false" /> otherwise.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

By default, `AllowTrailingCommas` is set to `false`, and a <exception cref="T:System.Text.Json.JsonException> is thrown if a trailing comma is encountered.

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This property was set after serialization or deserialization has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Converters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Text.Json.Serialization.JsonConverter&gt; Converters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Text.Json.Serialization.JsonConverter&gt; Converters" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.Converters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Converters As IList(Of JsonConverter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Text::Json::Serialization::JsonConverter ^&gt; ^ Converters { System::Collections::Generic::IList&lt;System::Text::Json::Serialization::JsonConverter ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Converters : System.Collections.Generic.IList&lt;System.Text.Json.Serialization.JsonConverter&gt;" Usage="System.Text.Json.JsonSerializerOptions.Converters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Text.Json.Serialization.JsonConverter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the list of user-defined converters that were registered.</summary>
        <value>The list of custom converters.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Once serialization or deserialization occurs, the list cannot be modified.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultBufferSize">
      <MemberSignature Language="C#" Value="public int DefaultBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DefaultBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.DefaultBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DefaultBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBufferSize : int with get, set" Usage="System.Text.Json.JsonSerializerOptions.DefaultBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the default buffer size, in bytes, to use when creating temporary buffers.</summary>
        <value>The default buffer size in bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The default buffer size, in bytes, is 16384.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The buffer size is less than 1.</exception>
        <exception cref="T:System.InvalidOperationException">This property was set after serialization or deserialization has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="DictionaryKeyPolicy">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonNamingPolicy DictionaryKeyPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Json.JsonNamingPolicy DictionaryKeyPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.DictionaryKeyPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property DictionaryKeyPolicy As JsonNamingPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::JsonNamingPolicy ^ DictionaryKeyPolicy { System::Text::Json::JsonNamingPolicy ^ get(); void set(System::Text::Json::JsonNamingPolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.DictionaryKeyPolicy : System.Text.Json.JsonNamingPolicy with get, set" Usage="System.Text.Json.JsonSerializerOptions.DictionaryKeyPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonNamingPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the policy used to convert a <see cref="T:System.Collections.IDictionary" /> key's name to another format, such as camel-casing.</summary>
        <value>The policy used to convert a <see cref="T:System.Collections.IDictionary" /> key's name to another format.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This property can be set to <xref:System.Text.Json.JsonNamingPolicy.CamelCase?displayProperty=nameWithType> to specify a camel-casing policy.

This property can be set to <xref:System.Text.Json.JsonNamingPolicy.CamelCase> to specify a camel-casing policy.

It is not used when deserializing.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Encoder">
      <MemberSignature Language="C#" Value="public System.Text.Encodings.Web.JavaScriptEncoder Encoder { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encodings.Web.JavaScriptEncoder Encoder" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.Encoder" />
      <MemberSignature Language="VB.NET" Value="Public Property Encoder As JavaScriptEncoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encodings::Web::JavaScriptEncoder ^ Encoder { System::Text::Encodings::Web::JavaScriptEncoder ^ get(); void set(System::Text::Encodings::Web::JavaScriptEncoder ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Encoder : System.Text.Encodings.Web.JavaScriptEncoder with get, set" Usage="System.Text.Json.JsonSerializerOptions.Encoder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encodings.Web.JavaScriptEncoder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the encoder to use when escaping strings, or <see langword="null" /> to use the default encoder.</summary>
        <value>The JavaScript character encoding.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public System.Text.Json.Serialization.JsonConverter GetConverter (Type typeToConvert);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.Json.Serialization.JsonConverter GetConverter(class System.Type typeToConvert) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializerOptions.GetConverter(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConverter (typeToConvert As Type) As JsonConverter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::Json::Serialization::JsonConverter ^ GetConverter(Type ^ typeToConvert);" />
      <MemberSignature Language="F#" Value="member this.GetConverter : Type -&gt; System.Text.Json.Serialization.JsonConverter" Usage="jsonSerializerOptions.GetConverter typeToConvert" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeToConvert" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="typeToConvert">The type to return a converter for.</param>
        <summary>Returns the converter for the specified type.</summary>
        <returns>The first converter that supports the given type, or <see langword="null" /> if there is no converter.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IgnoreNullValues">
      <MemberSignature Language="C#" Value="public bool IgnoreNullValues { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreNullValues" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.IgnoreNullValues" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreNullValues As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreNullValues { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreNullValues : bool with get, set" Usage="System.Text.Json.JsonSerializerOptions.IgnoreNullValues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that determines whether <see langword="null" /> values are ignored during serialization and deserialization. The default value is <see langword="false" />.</summary>
        <value>
          <see langword="true" /> to ignore null values during serialization and deserialization; otherwise, see langword="false" /&gt;.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">This property was set after serialization or deserialization has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="IgnoreReadOnlyProperties">
      <MemberSignature Language="C#" Value="public bool IgnoreReadOnlyProperties { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreReadOnlyProperties" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.IgnoreReadOnlyProperties" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreReadOnlyProperties As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreReadOnlyProperties { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IgnoreReadOnlyProperties : bool with get, set" Usage="System.Text.Json.JsonSerializerOptions.IgnoreReadOnlyProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that determines whether read-only properties are ignored during serialization. The default value is <see langword="false" />.</summary>
        <value>
          <see langword="true" /> to ignore read-only properties during serialization; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

A property is read-only if it contains a public getter but not a public setter. 

Read-only properties are not deserialized regardless of this setting.

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This property was set after serialization or deserialization has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxDepth">
      <MemberSignature Language="C#" Value="public int MaxDepth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxDepth" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.MaxDepth" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxDepth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxDepth { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxDepth : int with get, set" Usage="System.Text.Json.JsonSerializerOptions.MaxDepth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum depth allowed when serializing or deserializing JSON, with the default value of 0 indicating a maximum depth of 64.</summary>
        <value>The maximum depth allowed when serializing or deserializing JSON.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Going past this depth will throw a <exception cref="T:System.Text.Json.JsonException>.

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This property was set after serialization or deserialization has occurred.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The max depth is set to a negative value.</exception>
      </Docs>
    </Member>
    <Member MemberName="PropertyNameCaseInsensitive">
      <MemberSignature Language="C#" Value="public bool PropertyNameCaseInsensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PropertyNameCaseInsensitive" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.PropertyNameCaseInsensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyNameCaseInsensitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PropertyNameCaseInsensitive { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PropertyNameCaseInsensitive : bool with get, set" Usage="System.Text.Json.JsonSerializerOptions.PropertyNameCaseInsensitive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that determines whether a property's name uses a case-insensitive comparison during deserialization. The default value is <see langword="false" />.</summary>
        <value>
          <see langword="true" /> to compare property names using case-insensitive comparison; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

There is a performance cost associated with case-insensitie comparison (that is, when `PropertyNameCaseInsensitive` is `true`).

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyNamingPolicy">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonNamingPolicy PropertyNamingPolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Json.JsonNamingPolicy PropertyNamingPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.PropertyNamingPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyNamingPolicy As JsonNamingPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::JsonNamingPolicy ^ PropertyNamingPolicy { System::Text::Json::JsonNamingPolicy ^ get(); void set(System::Text::Json::JsonNamingPolicy ^ value); };" />
      <MemberSignature Language="F#" Value="member this.PropertyNamingPolicy : System.Text.Json.JsonNamingPolicy with get, set" Usage="System.Text.Json.JsonSerializerOptions.PropertyNamingPolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonNamingPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that specifies the policy used to convert a property's name on an object to another format, such as camel-casing. </summary>
        <value>One of the enum values from <see cref="T:System.Text.Json.JsonNamingPolicy" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The resulting property name is expected to match the JSON payload during deserialization, and will be used when writing the property name during serialization.

The policy is not used for properties that have a <xref:System.Text.Json.Serialization.JsonPropertyNameAttribute> applied.

This property can be set to <xref:System.Text.Json.JsonNamingPolicy.CamelCase?displayProperty=nameWithType> to specify a camel-casing policy.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadCommentHandling">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonCommentHandling ReadCommentHandling { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.Json.JsonCommentHandling ReadCommentHandling" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.ReadCommentHandling" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadCommentHandling As JsonCommentHandling" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::JsonCommentHandling ReadCommentHandling { System::Text::Json::JsonCommentHandling get(); void set(System::Text::Json::JsonCommentHandling value); };" />
      <MemberSignature Language="F#" Value="member this.ReadCommentHandling : System.Text.Json.JsonCommentHandling with get, set" Usage="System.Text.Json.JsonSerializerOptions.ReadCommentHandling" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonCommentHandling</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that defines how comments are handled during deserialization.</summary>
        <value>A value that indicates whether comments are allowed, disallowed, or skipped.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

By default, a <exception cref="T:System.Text.Json.JsonException> is thrown if a comment is encountered.

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This property was set after serialization or deserialization has occurred.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The comment handling enum is set to a value that is not supported (or not within the <see cref="T:System.Text.Json.JsonCommentHandling" /> enum range).</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteIndented">
      <MemberSignature Language="C#" Value="public bool WriteIndented { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool WriteIndented" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.WriteIndented" />
      <MemberSignature Language="VB.NET" Value="Public Property WriteIndented As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool WriteIndented { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.WriteIndented : bool with get, set" Usage="System.Text.Json.JsonSerializerOptions.WriteIndented" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that defines whether JSON should use pretty printing. By default, JSON is serialized without any extra white space.</summary>
        <value>
          <see langword="true" /> if JSON should pretty print on serialization; otherwise, <see langword="false" />. The default is <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Pretty printing includes: 

- Indenting nested JSON tokens.
- Adding new lines
- Adding white space between property names and values. 

         ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This property was set after serialization or deserialization has occurred.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
