<Type Name="JsonSerializerOptions" FullName="System.Text.Json.JsonSerializerOptions">
  <TypeSignature Language="C#" Value="public sealed class JsonSerializerOptions" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit JsonSerializerOptions extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Text.Json.JsonSerializerOptions" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class JsonSerializerOptions" />
  <TypeSignature Language="F#" Value="type JsonSerializerOptions = class" />
  <TypeSignature Language="C++ CLI" Value="public ref class JsonSerializerOptions sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Json</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Provides options to be used with <see cref="T:System.Text.Json.JsonSerializer" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks

For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to).

 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public JsonSerializerOptions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializerOptions.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; JsonSerializerOptions();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Text.Json.JsonSerializerOptions" /> class.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public JsonSerializerOptions (System.Text.Json.JsonSerializerDefaults defaults);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Text.Json.JsonSerializerDefaults defaults) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializerOptions.#ctor(System.Text.Json.JsonSerializerDefaults)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaults As JsonSerializerDefaults)" />
      <MemberSignature Language="F#" Value="new System.Text.Json.JsonSerializerOptions : System.Text.Json.JsonSerializerDefaults -&gt; System.Text.Json.JsonSerializerOptions" Usage="new System.Text.Json.JsonSerializerOptions defaults" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; JsonSerializerOptions(System::Text::Json::JsonSerializerDefaults defaults);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaults" Type="System.Text.Json.JsonSerializerDefaults" Index="0" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0" />
      </Parameters>
      <Docs>
        <param name="defaults">The <see cref="T:System.Text.Json.JsonSerializerDefaults" /> to reason about.</param>
        <summary>Constructs a new <see cref="T:System.Text.Json.JsonSerializerOptions" /> instance with a predefined set of options determined by the specified <see cref="T:System.Text.Json.JsonSerializerDefaults" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public JsonSerializerOptions (System.Text.Json.JsonSerializerOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Text.Json.JsonSerializerOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializerOptions.#ctor(System.Text.Json.JsonSerializerOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (options As JsonSerializerOptions)" />
      <MemberSignature Language="F#" Value="new System.Text.Json.JsonSerializerOptions : System.Text.Json.JsonSerializerOptions -&gt; System.Text.Json.JsonSerializerOptions" Usage="new System.Text.Json.JsonSerializerOptions options" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; JsonSerializerOptions(System::Text::Json::JsonSerializerOptions ^ options);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="options" Type="System.Text.Json.JsonSerializerOptions" Index="0" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0" />
      </Parameters>
      <Docs>
        <param name="options">The options instance to copy options from.</param>
        <summary>Copies the options from a <see cref="T:System.Text.Json.JsonSerializerOptions" /> instance to a new instance.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="options" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddContext&lt;TContext&gt;">
      <MemberSignature Language="C#" Value="public void AddContext&lt;TContext&gt; () where TContext : System.Text.Json.Serialization.JsonSerializerContext, new();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddContext&lt;.ctor (class System.Text.Json.Serialization.JsonSerializerContext) TContext&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializerOptions.AddContext``1" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddContext(Of TContext As {JsonSerializerContextNew}) ()" />
      <MemberSignature Language="F#" Value="member this.AddContext : unit -&gt; unit (requires 'Context :&gt; System.Text.Json.Serialization.JsonSerializerContext and 'Context : (new : unit -&gt; 'Context))" Usage="jsonSerializerOptions.AddContext " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TContext&gt;&#xA; where TContext : System::Text::Json::Serialization::JsonSerializerContextgcnew() void AddContext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TContext">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <BaseTypeName>System.Text.Json.Serialization.JsonSerializerContext</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TContext">The generic definition of the specified context type.</typeparam>
        <summary>Appends a new <see cref="T:System.Text.Json.Serialization.JsonSerializerContext" /> to the metadata resolution of the current <see cref="T:System.Text.Json.JsonSerializerOptions" /> instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

When serializing and deserializing types using the options instance, metadata for the types will be fetched from the context instance.

The methods supports adding multiple contexts per options instance. Metadata will be resolved in the order of configuration, 
similar to how <xref:System.Text.Json.Serialization.Metadata.JsonTypeInfoResolver.Combine(System.Text.Json.Serialization.Metadata.IJsonTypeInfoResolver[])> resolves metadata.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowTrailingCommas">
      <MemberSignature Language="C#" Value="public bool AllowTrailingCommas { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowTrailingCommas" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.AllowTrailingCommas" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowTrailingCommas As Boolean" />
      <MemberSignature Language="F#" Value="member this.AllowTrailingCommas : bool with get, set" Usage="System.Text.Json.JsonSerializerOptions.AllowTrailingCommas" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowTrailingCommas { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Get or sets a value that indicates whether an extra comma at the end of a list of JSON values in an object or array is allowed (and ignored) within the JSON payload being deserialized.</summary>
        <value>
          <see langword="true" /> if an extra comma at the end of a list of JSON values in an object or array is allowed (and ignored); <see langword="false" /> otherwise.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

By default, `AllowTrailingCommas` is set to `false`, and a <xref:System.Text.Json.JsonException> is thrown during deserialization if a trailing comma is encountered.

For more information, see [How to allow some kinds of invalid JSON with System.Text.Json](/dotnet/standard/serialization/system-text-json-invalid-json#allow-comments-and-trailing-commas).

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This property was set after serialization or deserialization has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="Converters">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Text.Json.Serialization.JsonConverter&gt; Converters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Text.Json.Serialization.JsonConverter&gt; Converters" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.Converters" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Converters As IList(Of JsonConverter)" />
      <MemberSignature Language="F#" Value="member this.Converters : System.Collections.Generic.IList&lt;System.Text.Json.Serialization.JsonConverter&gt;" Usage="System.Text.Json.JsonSerializerOptions.Converters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Text::Json::Serialization::JsonConverter ^&gt; ^ Converters { System::Collections::Generic::IList&lt;System::Text::Json::Serialization::JsonConverter ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Text.Json.Serialization.JsonConverter&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the list of user-defined converters that were registered.</summary>
        <value>The list of custom converters.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Once serialization or deserialization occurs, the list cannot be modified.

For more information, see [How to write custom converters](/dotnet/standard/serialization/system-text-json-converters-how-to#registration-sample---converters-collection).

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Json.JsonSerializerOptions Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Json.JsonSerializerOptions Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As JsonSerializerOptions" />
      <MemberSignature Language="F#" Value="static member Default : System.Text.Json.JsonSerializerOptions" Usage="System.Text.Json.JsonSerializerOptions.Default" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Json::JsonSerializerOptions ^ Default { System::Text::Json::JsonSerializerOptions ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-7.0;net-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.CodeAnalysis.RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0;net-8.0">
          <AttributeName Language="C#">[get: System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonSerializerOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a read-only, singleton instance of <see cref="T:System.Text.Json.JsonSerializerOptions" /> that uses the default configuration.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Each <xref:System.Text.Json.JsonSerializerOptions> instance encapsulates its own serialization metadata caches,
            so using fresh default instances every time one is needed can result in redundant recomputation of converters.
            This property provides a shared instance that can be consumed by any number of components without necessitating any converter recomputation.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultBufferSize">
      <MemberSignature Language="C#" Value="public int DefaultBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DefaultBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.DefaultBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultBufferSize As Integer" />
      <MemberSignature Language="F#" Value="member this.DefaultBufferSize : int with get, set" Usage="System.Text.Json.JsonSerializerOptions.DefaultBufferSize" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DefaultBufferSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the default buffer size, in bytes, to use when creating temporary buffers.</summary>
        <value>The default buffer size in bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The default buffer size, in bytes, is 16,384.
For most workloads, the default size is a reasonable amount of JSON to buffer while reading from a stream or writing to a stream.
That is, it performs well without creating objects on the Large Object Heap for the Garbage Collector (GC) to track.
In non-streaming scenarios, increasing the default buffer size could improve performance for large JSON strings or UTF-8 byte arrays.
We recommend that you leave this value unchanged unless changing it makes an observable difference in performance.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">The buffer size is less than 1.</exception>
        <exception cref="T:System.InvalidOperationException">This property was set after serialization or deserialization has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultIgnoreCondition">
      <MemberSignature Language="C#" Value="public System.Text.Json.Serialization.JsonIgnoreCondition DefaultIgnoreCondition { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.Json.Serialization.JsonIgnoreCondition DefaultIgnoreCondition" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.DefaultIgnoreCondition" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultIgnoreCondition As JsonIgnoreCondition" />
      <MemberSignature Language="F#" Value="member this.DefaultIgnoreCondition : System.Text.Json.Serialization.JsonIgnoreCondition with get, set" Usage="System.Text.Json.JsonSerializerOptions.DefaultIgnoreCondition" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::Serialization::JsonIgnoreCondition DefaultIgnoreCondition { System::Text::Json::Serialization::JsonIgnoreCondition get(); void set(System::Text::Json::Serialization::JsonIgnoreCondition value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonIgnoreCondition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that determines when properties with default values are ignored during serialization or deserialization.
 The default value is <see cref="F:System.Text.Json.Serialization.JsonIgnoreCondition.Never" />.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">This property is set to <see cref="F:System.Text.Json.Serialization.JsonIgnoreCondition.Always" />.</exception>
        <exception cref="T:System.InvalidOperationException">This property is set after serialization or deserialization has occurred.

-or-

<see cref="P:System.Text.Json.JsonSerializerOptions.IgnoreNullValues" /> has been set to <see langword="true" />. These properties cannot be used together.</exception>
      </Docs>
    </Member>
    <Member MemberName="DictionaryKeyPolicy">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonNamingPolicy? DictionaryKeyPolicy { get; set; }" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Json.JsonNamingPolicy DictionaryKeyPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.DictionaryKeyPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property DictionaryKeyPolicy As JsonNamingPolicy" />
      <MemberSignature Language="F#" Value="member this.DictionaryKeyPolicy : System.Text.Json.JsonNamingPolicy with get, set" Usage="System.Text.Json.JsonSerializerOptions.DictionaryKeyPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::JsonNamingPolicy ^ DictionaryKeyPolicy { System::Text::Json::JsonNamingPolicy ^ get(); void set(System::Text::Json::JsonNamingPolicy ^ value); };" />
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonNamingPolicy DictionaryKeyPolicy { get; set; }" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonNamingPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the policy used to convert a <see cref="T:System.Collections.IDictionary" /> key's name to another format, such as camel-casing.</summary>
        <value>The policy used to convert a <see cref="T:System.Collections.IDictionary" /> key's name to another format.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This property can be set to <xref:System.Text.Json.JsonNamingPolicy.CamelCase?displayProperty=nameWithType> to specify a camel-casing policy.

This property can be set to <xref:System.Text.Json.JsonNamingPolicy.CamelCase> to specify a camel-casing policy.

It is not used when deserializing.

For more information, see [How to customize property names and values with System.Text.Json](/dotnet/standard/serialization/system-text-json-customize-properties#camel-case-dictionary-keys).

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Encoder">
      <MemberSignature Language="C#" Value="public System.Text.Encodings.Web.JavaScriptEncoder? Encoder { get; set; }" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encodings.Web.JavaScriptEncoder Encoder" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.Encoder" />
      <MemberSignature Language="VB.NET" Value="Public Property Encoder As JavaScriptEncoder" />
      <MemberSignature Language="F#" Value="member this.Encoder : System.Text.Encodings.Web.JavaScriptEncoder with get, set" Usage="System.Text.Json.JsonSerializerOptions.Encoder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encodings::Web::JavaScriptEncoder ^ Encoder { System::Text::Encodings::Web::JavaScriptEncoder ^ get(); void set(System::Text::Encodings::Web::JavaScriptEncoder ^ value); };" />
      <MemberSignature Language="C#" Value="public System.Text.Encodings.Web.JavaScriptEncoder Encoder { get; set; }" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encodings.Web.JavaScriptEncoder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the encoder to use when escaping strings, or <see langword="null" /> to use the default encoder.</summary>
        <value>The JavaScript character encoding.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For more information, see [How to customize character encoding with System.Text.Json](/dotnet/standard/serialization/system-text-json-character-encoding).

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConverter">
      <MemberSignature Language="C#" Value="public System.Text.Json.Serialization.JsonConverter GetConverter (Type typeToConvert);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.Json.Serialization.JsonConverter GetConverter(class System.Type typeToConvert) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializerOptions.GetConverter(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConverter (typeToConvert As Type) As JsonConverter" />
      <MemberSignature Language="F#" Value="member this.GetConverter : Type -&gt; System.Text.Json.Serialization.JsonConverter" Usage="jsonSerializerOptions.GetConverter typeToConvert" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::Json::Serialization::JsonConverter ^ GetConverter(Type ^ typeToConvert);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-6.0;net-7.0;net-8.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Getting a converter for a type may require reflection which depends on unreferenced code.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresUnreferencedCode("Getting a converter for a type may require reflection which depends on unreferenced code.")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-7.0;net-8.0">
          <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.RequiresDynamicCode("Getting a converter for a type may require reflection which depends on runtime code generation.")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.RequiresDynamicCode("Getting a converter for a type may require reflection which depends on runtime code generation.")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonConverter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeToConvert" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="typeToConvert">The type to return a converter for.</param>
        <summary>Returns the converter for the specified type.</summary>
        <returns>The first converter that supports the given type.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For more information, see [How to write custom converters for JSON serialization (marshalling) in .NET](/dotnet/standard/serialization/system-text-json-converters-how-to#sample-factory-pattern-converter).

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The configured <see cref="System.Text.Json.Serialization.JsonConverter" /> for <paramref name="typeToConvert" /> returned an invalid converter.</exception>
        <exception cref="T:System.NotSupportedException">There is no compatible <see cref="System.Text.Json.Serialization.JsonConverter" /> for <paramref name="typeToConvert" /> or its serializable members.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeInfo">
      <MemberSignature Language="C#" Value="public System.Text.Json.Serialization.Metadata.JsonTypeInfo GetTypeInfo (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.Json.Serialization.Metadata.JsonTypeInfo GetTypeInfo(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializerOptions.GetTypeInfo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeInfo (type As Type) As JsonTypeInfo" />
      <MemberSignature Language="F#" Value="member this.GetTypeInfo : Type -&gt; System.Text.Json.Serialization.Metadata.JsonTypeInfo" Usage="jsonSerializerOptions.GetTypeInfo type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::Json::Serialization::Metadata::JsonTypeInfo ^ GetTypeInfo(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.Metadata.JsonTypeInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="net-7.0;net-8.0" />
      </Parameters>
      <Docs>
        <param name="type">The type to resolve contract metadata for.</param>
        <summary>Gets the <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> contract metadata resolved by the current <see cref="T:System.Text.Json.JsonSerializerOptions" /> instance.</summary>
        <returns>The contract metadata resolved for <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Returned metadata can be downcast to <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo`1> and used with the relevant <xref:System.Text.Json.JsonSerializer> overloads.
            
If the <xref:System.Text.Json.JsonSerializerOptions> instance is locked for modification, the method will return a cached instance for the metadata.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> is not valid for serialization.</exception>
      </Docs>
    </Member>
    <Member MemberName="IgnoreNullValues">
      <MemberSignature Language="C#" Value="public bool IgnoreNullValues { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreNullValues" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.IgnoreNullValues" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreNullValues As Boolean" />
      <MemberSignature Language="F#" Value="member this.IgnoreNullValues : bool with get, set" Usage="System.Text.Json.JsonSerializerOptions.IgnoreNullValues" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreNullValues { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0">
          <AttributeName Language="C#">[System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="net-6.0;net-7.0;net-8.0">
          <AttributeName Language="C#">[System.Obsolete("JsonSerializerOptions.IgnoreNullValues is obsolete. To ignore null values when serializing, set DefaultIgnoreCondition to JsonIgnoreCondition.WhenWritingNull.", DiagnosticId="SYSLIB0020", UrlFormat="https://aka.ms/dotnet-warnings/{0}")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("JsonSerializerOptions.IgnoreNullValues is obsolete. To ignore null values when serializing, set DefaultIgnoreCondition to JsonIgnoreCondition.WhenWritingNull.", DiagnosticId="SYSLIB0020", UrlFormat="https://aka.ms/dotnet-warnings/{0}")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether <see langword="null" /> values are ignored during serialization and deserialization. The default value is <see langword="false" />.</summary>
        <value>
          <see langword="true" /> if null values are ignored during serialization and deserialization; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For more information, see [How to ignore properties](/dotnet/standard/serialization/system-text-json-ignore-properties).

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This property was set after serialization or deserialization has occurred.

-or-

<see cref="P:System.Text.Json.JsonSerializerOptions.DefaultIgnoreCondition" /> has been set to a non-default value. These properties cannot be used together.</exception>
      </Docs>
    </Member>
    <Member MemberName="IgnoreReadOnlyFields">
      <MemberSignature Language="C#" Value="public bool IgnoreReadOnlyFields { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreReadOnlyFields" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.IgnoreReadOnlyFields" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreReadOnlyFields As Boolean" />
      <MemberSignature Language="F#" Value="member this.IgnoreReadOnlyFields : bool with get, set" Usage="System.Text.Json.JsonSerializerOptions.IgnoreReadOnlyFields" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreReadOnlyFields { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether read-only fields are ignored during serialization. A field is read-only if it is marked with the <see langword="readonly" /> keyword. The default value is <see langword="false" />.</summary>
        <value>
          <see langword="true" /> if read-only fields are ignored during serialization; <see langword="false" /> otherwise.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Read-only fields are not deserialized regardless of this setting.

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This property is set after serialization or deserialization has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="IgnoreReadOnlyProperties">
      <MemberSignature Language="C#" Value="public bool IgnoreReadOnlyProperties { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IgnoreReadOnlyProperties" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.IgnoreReadOnlyProperties" />
      <MemberSignature Language="VB.NET" Value="Public Property IgnoreReadOnlyProperties As Boolean" />
      <MemberSignature Language="F#" Value="member this.IgnoreReadOnlyProperties : bool with get, set" Usage="System.Text.Json.JsonSerializerOptions.IgnoreReadOnlyProperties" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IgnoreReadOnlyProperties { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether read-only properties are ignored during serialization. The default value is <see langword="false" />.</summary>
        <value>
          <see langword="true" /> if read-only properties are ignored during serialization; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

A property is read-only if it contains a public getter but not a public setter. 

Read-only properties are not deserialized regardless of this setting.

For more information, see [How to ignore properties with System.Text.Json](/dotnet/standard/serialization/system-text-json-ignore-properties#ignore-all-read-only-properties).

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This property was set after serialization or deserialization has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="IncludeFields">
      <MemberSignature Language="C#" Value="public bool IncludeFields { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeFields" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.IncludeFields" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeFields As Boolean" />
      <MemberSignature Language="F#" Value="member this.IncludeFields : bool with get, set" Usage="System.Text.Json.JsonSerializerOptions.IncludeFields" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeFields { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether fields are handled during serialization and deserialization.
            The default value is <see langword="false" />.</summary>
        <value>
          <see langword="true" /> if fields are included during serialization; otherwise, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">This property is set after serialization or deserialization has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Text.Json.JsonSerializerOptions.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeReadOnly">
      <MemberSignature Language="C#" Value="public void MakeReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MakeReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Json.JsonSerializerOptions.MakeReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub MakeReadOnly ()" />
      <MemberSignature Language="F#" Value="member this.MakeReadOnly : unit -&gt; unit" Usage="jsonSerializerOptions.MakeReadOnly " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MakeReadOnly();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxDepth">
      <MemberSignature Language="C#" Value="public int MaxDepth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxDepth" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.MaxDepth" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxDepth As Integer" />
      <MemberSignature Language="F#" Value="member this.MaxDepth : int with get, set" Usage="System.Text.Json.JsonSerializerOptions.MaxDepth" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MaxDepth { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the maximum depth allowed when serializing or deserializing JSON, with the default value of 0 indicating a maximum depth of 64.</summary>
        <value>The maximum depth allowed when serializing or deserializing JSON.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Going past this depth throws a <xref:System.Text.Json.JsonException>.

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This property was set after serialization or deserialization has occurred.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The max depth is set to a negative value.</exception>
      </Docs>
    </Member>
    <Member MemberName="NumberHandling">
      <MemberSignature Language="C#" Value="public System.Text.Json.Serialization.JsonNumberHandling NumberHandling { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.Json.Serialization.JsonNumberHandling NumberHandling" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.NumberHandling" />
      <MemberSignature Language="VB.NET" Value="Public Property NumberHandling As JsonNumberHandling" />
      <MemberSignature Language="F#" Value="member this.NumberHandling : System.Text.Json.Serialization.JsonNumberHandling with get, set" Usage="System.Text.Json.JsonSerializerOptions.NumberHandling" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::Serialization::JsonNumberHandling NumberHandling { System::Text::Json::Serialization::JsonNumberHandling get(); void set(System::Text::Json::Serialization::JsonNumberHandling value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonNumberHandling</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets an object that specifies how number types should be handled when serializing or deserializing.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">This property is set after serialization or deserialization has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="PropertyNameCaseInsensitive">
      <MemberSignature Language="C#" Value="public bool PropertyNameCaseInsensitive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PropertyNameCaseInsensitive" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.PropertyNameCaseInsensitive" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyNameCaseInsensitive As Boolean" />
      <MemberSignature Language="F#" Value="member this.PropertyNameCaseInsensitive : bool with get, set" Usage="System.Text.Json.JsonSerializerOptions.PropertyNameCaseInsensitive" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PropertyNameCaseInsensitive { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether a property's name uses a case-insensitive comparison during deserialization. The default value is <see langword="false" />.</summary>
        <value>
          <see langword="true" /> if property names are compared case-insensitively; otherwise, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

There is a performance cost associated with case-insensitive comparison (that is, when `PropertyNameCaseInsensitive` is `true`).

For more information, see [How to enable case-insensitive property name matching with System.Text.Json](/dotnet/standard/serialization/system-text-json-character-casing#case-insensitive-property-matching).

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyNamingPolicy">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonNamingPolicy? PropertyNamingPolicy { get; set; }" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Json.JsonNamingPolicy PropertyNamingPolicy" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.PropertyNamingPolicy" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyNamingPolicy As JsonNamingPolicy" />
      <MemberSignature Language="F#" Value="member this.PropertyNamingPolicy : System.Text.Json.JsonNamingPolicy with get, set" Usage="System.Text.Json.JsonSerializerOptions.PropertyNamingPolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::JsonNamingPolicy ^ PropertyNamingPolicy { System::Text::Json::JsonNamingPolicy ^ get(); void set(System::Text::Json::JsonNamingPolicy ^ value); };" />
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonNamingPolicy PropertyNamingPolicy { get; set; }" FrameworkAlternate="netcore-3.0;netcore-3.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonNamingPolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that specifies the policy used to convert a property's name on an object to another format, such as camel-casing, or <see langword="null" /> to leave property names unchanged.</summary>
        <value>A property naming policy, or <see langword="null" /> to leave property names unchanged.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

The resulting property name is expected to match the JSON payload during deserialization, and will be used when writing the property name during serialization.

The policy is not used for properties that have a <xref:System.Text.Json.Serialization.JsonPropertyNameAttribute> applied.

This property can be set to <xref:System.Text.Json.JsonNamingPolicy.CamelCase?displayProperty=nameWithType> to specify a camel-casing policy.

For more information, see [How to customize property names and values with System.Text.Json](/dotnet/standard/serialization/system-text-json-customize-properties).

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadCommentHandling">
      <MemberSignature Language="C#" Value="public System.Text.Json.JsonCommentHandling ReadCommentHandling { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.Json.JsonCommentHandling ReadCommentHandling" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.ReadCommentHandling" />
      <MemberSignature Language="VB.NET" Value="Public Property ReadCommentHandling As JsonCommentHandling" />
      <MemberSignature Language="F#" Value="member this.ReadCommentHandling : System.Text.Json.JsonCommentHandling with get, set" Usage="System.Text.Json.JsonSerializerOptions.ReadCommentHandling" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::JsonCommentHandling ReadCommentHandling { System::Text::Json::JsonCommentHandling get(); void set(System::Text::Json::JsonCommentHandling value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.JsonCommentHandling</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that defines how comments are handled during deserialization.</summary>
        <value>A value that indicates whether comments are allowed, disallowed, or skipped.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

By default, a <xref:System.Text.Json.JsonException> is thrown during deserialization if a comment is encountered.

For more information, see [How to allow some kinds of invalid JSON with System.Text.Json](/dotnet/standard/serialization/system-text-json-invalid-json#allow-comments-and-trailing-commas).

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This property was set after serialization or deserialization has occurred.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The comment handling enum is set to a value that is not supported (or not within the <see cref="T:System.Text.Json.JsonCommentHandling" /> enum range).</exception>
      </Docs>
    </Member>
    <Member MemberName="ReferenceHandler">
      <MemberSignature Language="C#" Value="public System.Text.Json.Serialization.ReferenceHandler? ReferenceHandler { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Json.Serialization.ReferenceHandler ReferenceHandler" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.ReferenceHandler" />
      <MemberSignature Language="VB.NET" Value="Public Property ReferenceHandler As ReferenceHandler" />
      <MemberSignature Language="F#" Value="member this.ReferenceHandler : System.Text.Json.Serialization.ReferenceHandler with get, set" Usage="System.Text.Json.JsonSerializerOptions.ReferenceHandler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::Serialization::ReferenceHandler ^ ReferenceHandler { System::Text::Json::Serialization::ReferenceHandler ^ get(); void set(System::Text::Json::Serialization::ReferenceHandler ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.ReferenceHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets an object that specifies how object references are handled when reading and writing JSON.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

By default, serialization does not support objects with cycles and does not preserve duplicate references. Metadata properties will not be written when serializing reference types and will be treated as regular properties on deserialize.
 
* On Serialize:

  * Treats duplicate object references as if they were unique and writes all their properties.
  * The serializer throws a <xref:System.Text.Json.JsonException> if an object contains a cycle.

* On Deserialize:

  * Metadata properties (`$id`, `$values`, and `$ref`) will not be consumed and therefore will be treated as regular JSON properties.
  * The metadata properties can map to a real property on the returned object if the property names match, or will be added to the <xref:System.Text.Json.Serialization.JsonExtensionDataAttribute> overflow dictionary, if one exists; otherwise, they are ignored.

Use <xref:System.Text.Json.Serialization.ReferenceHandler.Preserve> to enable unique object reference preservation on serialization and metadata consumption to read preserved references on deserialization.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeInfoResolver">
      <MemberSignature Language="C#" Value="public System.Text.Json.Serialization.Metadata.IJsonTypeInfoResolver? TypeInfoResolver { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Json.Serialization.Metadata.IJsonTypeInfoResolver TypeInfoResolver" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.TypeInfoResolver" />
      <MemberSignature Language="VB.NET" Value="Public Property TypeInfoResolver As IJsonTypeInfoResolver" />
      <MemberSignature Language="F#" Value="member this.TypeInfoResolver : System.Text.Json.Serialization.Metadata.IJsonTypeInfoResolver with get, set" Usage="System.Text.Json.JsonSerializerOptions.TypeInfoResolver" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::Serialization::Metadata::IJsonTypeInfoResolver ^ TypeInfoResolver { System::Text::Json::Serialization::Metadata::IJsonTypeInfoResolver ^ get(); void set(System::Text::Json::Serialization::Metadata::IJsonTypeInfoResolver ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.Metadata.IJsonTypeInfoResolver</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> contract resolver used by this instance.</summary>
        <value>To be added.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

A `null` setting is equivalent to using the reflection-based <xref:System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver>.
            The property will be populated automatically once used with one of the <xref:System.Text.Json.JsonSerializer> methods.

          ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The property is set after serialization or deserialization has occurred.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnknownTypeHandling">
      <MemberSignature Language="C#" Value="public System.Text.Json.Serialization.JsonUnknownTypeHandling UnknownTypeHandling { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.Json.Serialization.JsonUnknownTypeHandling UnknownTypeHandling" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.UnknownTypeHandling" />
      <MemberSignature Language="VB.NET" Value="Public Property UnknownTypeHandling As JsonUnknownTypeHandling" />
      <MemberSignature Language="F#" Value="member this.UnknownTypeHandling : System.Text.Json.Serialization.JsonUnknownTypeHandling with get, set" Usage="System.Text.Json.JsonSerializerOptions.UnknownTypeHandling" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::Serialization::JsonUnknownTypeHandling UnknownTypeHandling { System::Text::Json::Serialization::JsonUnknownTypeHandling get(); void set(System::Text::Json::Serialization::JsonUnknownTypeHandling value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonUnknownTypeHandling</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets an object that specifies how deserializing a type declared as an <see cref="T:System.Object" /> is handled during deserialization.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnmappedMemberHandling">
      <MemberSignature Language="C#" Value="public System.Text.Json.Serialization.JsonUnmappedMemberHandling UnmappedMemberHandling { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Text.Json.Serialization.JsonUnmappedMemberHandling UnmappedMemberHandling" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.UnmappedMemberHandling" />
      <MemberSignature Language="VB.NET" Value="Public Property UnmappedMemberHandling As JsonUnmappedMemberHandling" />
      <MemberSignature Language="F#" Value="member this.UnmappedMemberHandling : System.Text.Json.Serialization.JsonUnmappedMemberHandling with get, set" Usage="System.Text.Json.JsonSerializerOptions.UnmappedMemberHandling" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Json::Serialization::JsonUnmappedMemberHandling UnmappedMemberHandling { System::Text::Json::Serialization::JsonUnmappedMemberHandling get(); void set(System::Text::Json::Serialization::JsonUnmappedMemberHandling value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Json.Serialization.JsonUnmappedMemberHandling</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteIndented">
      <MemberSignature Language="C#" Value="public bool WriteIndented { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool WriteIndented" />
      <MemberSignature Language="DocId" Value="P:System.Text.Json.JsonSerializerOptions.WriteIndented" />
      <MemberSignature Language="VB.NET" Value="Public Property WriteIndented As Boolean" />
      <MemberSignature Language="F#" Value="member this.WriteIndented : bool with get, set" Usage="System.Text.Json.JsonSerializerOptions.WriteIndented" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool WriteIndented { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Json</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that indicates whether JSON should use pretty printing. By default, JSON is serialized without any extra white space.</summary>
        <value>
          <see langword="true" /> if JSON is pretty printed on serialization; otherwise, <see langword="false" />. The default is <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

Pretty printing includes: 

- Indenting nested JSON tokens.
- Adding new lines
- Adding white space between property names and values. 

For more information, see [How to serialize and deserialize JSON](/dotnet/standard/serialization/system-text-json-how-to#how-to-write-net-objects-as-json-serialize).

         ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This property was set after serialization or deserialization has occurred.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
