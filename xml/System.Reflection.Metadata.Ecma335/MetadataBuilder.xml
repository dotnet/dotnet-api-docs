<Type Name="MetadataBuilder" FullName="System.Reflection.Metadata.Ecma335.MetadataBuilder">
  <TypeSignature Language="C#" Value="public sealed class MetadataBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit MetadataBuilder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class MetadataBuilder" />
  <TypeSignature Language="C++ CLI" Value="public ref class MetadataBuilder sealed" />
  <TypeSignature Language="F#" Value="type MetadataBuilder = class" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Metadata</AssemblyName>
    <AssemblyVersion>1.4.1.0</AssemblyVersion>
    <AssemblyVersion>1.4.2.0</AssemblyVersion>
    <AssemblyVersion>1.4.3.0</AssemblyVersion>
    <AssemblyVersion>1.4.4.0</AssemblyVersion>
    <AssemblyVersion>1.4.5.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>The MetadataBuilder class reads and writes metadata for an assembly in a highly performant manner. It is designed for use by compilers and other assembly generation tools.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MetadataBuilder (int userStringHeapStartOffset = 0, int stringHeapStartOffset = 0, int blobHeapStartOffset = 0, int guidHeapStartOffset = 0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 userStringHeapStartOffset, int32 stringHeapStartOffset, int32 blobHeapStartOffset, int32 guidHeapStartOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Optional userStringHeapStartOffset As Integer = 0, Optional stringHeapStartOffset As Integer = 0, Optional blobHeapStartOffset As Integer = 0, Optional guidHeapStartOffset As Integer = 0)" />
      <MemberSignature Language="F#" Value="new System.Reflection.Metadata.Ecma335.MetadataBuilder : int * int * int * int -&gt; System.Reflection.Metadata.Ecma335.MetadataBuilder" Usage="new System.Reflection.Metadata.Ecma335.MetadataBuilder (userStringHeapStartOffset, stringHeapStartOffset, blobHeapStartOffset, guidHeapStartOffset)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="userStringHeapStartOffset" Type="System.Int32" />
        <Parameter Name="stringHeapStartOffset" Type="System.Int32" />
        <Parameter Name="blobHeapStartOffset" Type="System.Int32" />
        <Parameter Name="guidHeapStartOffset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="userStringHeapStartOffset">The start offset of the User String heap. The cumulative size of User String heaps of all previous EnC generations should be 0 unless the metadata is EnC delta metadata.</param>
        <param name="stringHeapStartOffset">The start offset of the String heap. The cumulative size of String heaps of all previous EnC generations should be 0 unless the metadata is EnC delta metadata.</param>
        <param name="blobHeapStartOffset">The start offset of the Blob heap. The cumulative size of Blob heaps of all previous EnC generations should be 0 unless the metadata is EnC delta metadata.</param>
        <param name="guidHeapStartOffset">The start offset of the Guid heap. The cumulative size of Guid heaps of all previous EnC generations should be 0 unless the metadata is EnC delta metadata.</param>
        <summary>Creates a builder for metadata tables and heaps.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">Offset is too big.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Offset is negative.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="guidHeapStartOffset" /> is not a multiple of size of GUID.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.AssemblyDefinitionHandle AddAssembly (System.Reflection.Metadata.StringHandle name, Version version, System.Reflection.Metadata.StringHandle culture, System.Reflection.Metadata.BlobHandle publicKey, System.Reflection.AssemblyFlags flags, System.Reflection.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.AssemblyDefinitionHandle AddAssembly(valuetype System.Reflection.Metadata.StringHandle name, class System.Version version, valuetype System.Reflection.Metadata.StringHandle culture, valuetype System.Reflection.Metadata.BlobHandle publicKey, valuetype System.Reflection.AssemblyFlags flags, valuetype System.Reflection.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssembly(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddAssembly (name As StringHandle, version As Version, culture As StringHandle, publicKey As BlobHandle, flags As AssemblyFlags, hashAlgorithm As AssemblyHashAlgorithm) As AssemblyDefinitionHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::AssemblyDefinitionHandle AddAssembly(System::Reflection::Metadata::StringHandle name, Version ^ version, System::Reflection::Metadata::StringHandle culture, System::Reflection::Metadata::BlobHandle publicKey, System::Reflection::AssemblyFlags flags, System::Reflection::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.AddAssembly : System.Reflection.Metadata.StringHandle * Version * System.Reflection.Metadata.StringHandle * System.Reflection.Metadata.BlobHandle * System.Reflection.AssemblyFlags * System.Reflection.AssemblyHashAlgorithm -&gt; System.Reflection.Metadata.AssemblyDefinitionHandle" Usage="metadataBuilder.AddAssembly (name, version, culture, publicKey, flags, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.AssemblyDefinitionHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.Metadata.StringHandle" />
        <Parameter Name="version" Type="System.Version" />
        <Parameter Name="culture" Type="System.Reflection.Metadata.StringHandle" />
        <Parameter Name="publicKey" Type="System.Reflection.Metadata.BlobHandle" />
        <Parameter Name="flags" Type="System.Reflection.AssemblyFlags" />
        <Parameter Name="hashAlgorithm" Type="System.Reflection.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="version">To be added.</param>
        <param name="culture">To be added.</param>
        <param name="publicKey">To be added.</param>
        <param name="flags">To be added.</param>
        <param name="hashAlgorithm">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssemblyFile">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.AssemblyFileHandle AddAssemblyFile (System.Reflection.Metadata.StringHandle name, System.Reflection.Metadata.BlobHandle hashValue, bool containsMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.AssemblyFileHandle AddAssemblyFile(valuetype System.Reflection.Metadata.StringHandle name, valuetype System.Reflection.Metadata.BlobHandle hashValue, bool containsMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyFile(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddAssemblyFile (name As StringHandle, hashValue As BlobHandle, containsMetadata As Boolean) As AssemblyFileHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::AssemblyFileHandle AddAssemblyFile(System::Reflection::Metadata::StringHandle name, System::Reflection::Metadata::BlobHandle hashValue, bool containsMetadata);" />
      <MemberSignature Language="F#" Value="member this.AddAssemblyFile : System.Reflection.Metadata.StringHandle * System.Reflection.Metadata.BlobHandle * bool -&gt; System.Reflection.Metadata.AssemblyFileHandle" Usage="metadataBuilder.AddAssemblyFile (name, hashValue, containsMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.AssemblyFileHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.Metadata.StringHandle" />
        <Parameter Name="hashValue" Type="System.Reflection.Metadata.BlobHandle" />
        <Parameter Name="containsMetadata" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="hashValue">To be added.</param>
        <param name="containsMetadata">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddAssemblyReference">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.AssemblyReferenceHandle AddAssemblyReference (System.Reflection.Metadata.StringHandle name, Version version, System.Reflection.Metadata.StringHandle culture, System.Reflection.Metadata.BlobHandle publicKeyOrToken, System.Reflection.AssemblyFlags flags, System.Reflection.Metadata.BlobHandle hashValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.AssemblyReferenceHandle AddAssemblyReference(valuetype System.Reflection.Metadata.StringHandle name, class System.Version version, valuetype System.Reflection.Metadata.StringHandle culture, valuetype System.Reflection.Metadata.BlobHandle publicKeyOrToken, valuetype System.Reflection.AssemblyFlags flags, valuetype System.Reflection.Metadata.BlobHandle hashValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddAssemblyReference(System.Reflection.Metadata.StringHandle,System.Version,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.AssemblyFlags,System.Reflection.Metadata.BlobHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddAssemblyReference (name As StringHandle, version As Version, culture As StringHandle, publicKeyOrToken As BlobHandle, flags As AssemblyFlags, hashValue As BlobHandle) As AssemblyReferenceHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::AssemblyReferenceHandle AddAssemblyReference(System::Reflection::Metadata::StringHandle name, Version ^ version, System::Reflection::Metadata::StringHandle culture, System::Reflection::Metadata::BlobHandle publicKeyOrToken, System::Reflection::AssemblyFlags flags, System::Reflection::Metadata::BlobHandle hashValue);" />
      <MemberSignature Language="F#" Value="member this.AddAssemblyReference : System.Reflection.Metadata.StringHandle * Version * System.Reflection.Metadata.StringHandle * System.Reflection.Metadata.BlobHandle * System.Reflection.AssemblyFlags * System.Reflection.Metadata.BlobHandle -&gt; System.Reflection.Metadata.AssemblyReferenceHandle" Usage="metadataBuilder.AddAssemblyReference (name, version, culture, publicKeyOrToken, flags, hashValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.AssemblyReferenceHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.Metadata.StringHandle" />
        <Parameter Name="version" Type="System.Version" />
        <Parameter Name="culture" Type="System.Reflection.Metadata.StringHandle" />
        <Parameter Name="publicKeyOrToken" Type="System.Reflection.Metadata.BlobHandle" />
        <Parameter Name="flags" Type="System.Reflection.AssemblyFlags" />
        <Parameter Name="hashValue" Type="System.Reflection.Metadata.BlobHandle" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="version">To be added.</param>
        <param name="culture">To be added.</param>
        <param name="publicKeyOrToken">To be added.</param>
        <param name="flags">To be added.</param>
        <param name="hashValue">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddConstant">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.ConstantHandle AddConstant (System.Reflection.Metadata.EntityHandle parent, object? value);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.ConstantHandle AddConstant(valuetype System.Reflection.Metadata.EntityHandle parent, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddConstant(System.Reflection.Metadata.EntityHandle,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddConstant (parent As EntityHandle, value As Object) As ConstantHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::ConstantHandle AddConstant(System::Reflection::Metadata::EntityHandle parent, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.AddConstant : System.Reflection.Metadata.EntityHandle * obj -&gt; System.Reflection.Metadata.ConstantHandle" Usage="metadataBuilder.AddConstant (parent, value)" />
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.ConstantHandle AddConstant (System.Reflection.Metadata.EntityHandle parent, object value);" FrameworkAlternate="netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.ConstantHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parent" Type="System.Reflection.Metadata.EntityHandle" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parent">The parent entity handle, which can be one of the following: <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, or <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />.</param>
        <param name="value">The constant value.</param>
        <summary>Adds a default value for a parameter, field or property.</summary>
        <returns>A handle to the added constant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Entries may be added in any order. The table is automatically sorted when serialized.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parent" /> doesn't have the expected handle kind.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddCustomAttribute">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.CustomAttributeHandle AddCustomAttribute (System.Reflection.Metadata.EntityHandle parent, System.Reflection.Metadata.EntityHandle constructor, System.Reflection.Metadata.BlobHandle value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.CustomAttributeHandle AddCustomAttribute(valuetype System.Reflection.Metadata.EntityHandle parent, valuetype System.Reflection.Metadata.EntityHandle constructor, valuetype System.Reflection.Metadata.BlobHandle value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddCustomAttribute (parent As EntityHandle, constructor As EntityHandle, value As BlobHandle) As CustomAttributeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::CustomAttributeHandle AddCustomAttribute(System::Reflection::Metadata::EntityHandle parent, System::Reflection::Metadata::EntityHandle constructor, System::Reflection::Metadata::BlobHandle value);" />
      <MemberSignature Language="F#" Value="member this.AddCustomAttribute : System.Reflection.Metadata.EntityHandle * System.Reflection.Metadata.EntityHandle * System.Reflection.Metadata.BlobHandle -&gt; System.Reflection.Metadata.CustomAttributeHandle" Usage="metadataBuilder.AddCustomAttribute (parent, constructor, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.CustomAttributeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parent" Type="System.Reflection.Metadata.EntityHandle" />
        <Parameter Name="constructor" Type="System.Reflection.Metadata.EntityHandle" />
        <Parameter Name="value" Type="System.Reflection.Metadata.BlobHandle" />
      </Parameters>
      <Docs>
        <param name="parent">An entity to attach the custom attribute to: a <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />, or a <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />.</param>
        <param name="constructor">A custom attribute constructor: a <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> or <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
        <param name="value">A custom attribute value blob.</param>
        <summary>Adds a custom attribute.</summary>
        <returns>A handle to the added custom attribute.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Entries may be added in any order. The table is automatically sorted when serialized.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parent" /> doesn't have the expected handle kind.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddCustomDebugInformation">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.CustomDebugInformationHandle AddCustomDebugInformation (System.Reflection.Metadata.EntityHandle parent, System.Reflection.Metadata.GuidHandle kind, System.Reflection.Metadata.BlobHandle value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.CustomDebugInformationHandle AddCustomDebugInformation(valuetype System.Reflection.Metadata.EntityHandle parent, valuetype System.Reflection.Metadata.GuidHandle kind, valuetype System.Reflection.Metadata.BlobHandle value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddCustomDebugInformation(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddCustomDebugInformation (parent As EntityHandle, kind As GuidHandle, value As BlobHandle) As CustomDebugInformationHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::CustomDebugInformationHandle AddCustomDebugInformation(System::Reflection::Metadata::EntityHandle parent, System::Reflection::Metadata::GuidHandle kind, System::Reflection::Metadata::BlobHandle value);" />
      <MemberSignature Language="F#" Value="member this.AddCustomDebugInformation : System.Reflection.Metadata.EntityHandle * System.Reflection.Metadata.GuidHandle * System.Reflection.Metadata.BlobHandle -&gt; System.Reflection.Metadata.CustomDebugInformationHandle" Usage="metadataBuilder.AddCustomDebugInformation (parent, kind, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.CustomDebugInformationHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parent" Type="System.Reflection.Metadata.EntityHandle" />
        <Parameter Name="kind" Type="System.Reflection.Metadata.GuidHandle" />
        <Parameter Name="value" Type="System.Reflection.Metadata.BlobHandle" />
      </Parameters>
      <Docs>
        <param name="parent">An entity to attach the debug information to: a <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />, <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />, <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />, <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />, <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.DocumentHandle" />, <see cref="T:System.Reflection.Metadata.LocalScopeHandle" />, <see cref="T:System.Reflection.Metadata.LocalVariableHandle" />, <see cref="T:System.Reflection.Metadata.LocalConstantHandle" />, or a <see cref="T:System.Reflection.Metadata.ImportScopeHandle" />.</param>
        <param name="kind">The information kind. Determines the structure of the <paramref name="value" /> blob.</param>
        <param name="value">The custom debug information blob.</param>
        <summary>Adds custom debug information.</summary>
        <returns>A handle to the added custom debug information.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Entries may be added in any order. The table is automatically sorted when serialized.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parent" /> doesn't have the expected handle kind.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddDeclarativeSecurityAttribute">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.DeclarativeSecurityAttributeHandle AddDeclarativeSecurityAttribute (System.Reflection.Metadata.EntityHandle parent, System.Reflection.DeclarativeSecurityAction action, System.Reflection.Metadata.BlobHandle permissionSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.DeclarativeSecurityAttributeHandle AddDeclarativeSecurityAttribute(valuetype System.Reflection.Metadata.EntityHandle parent, valuetype System.Reflection.DeclarativeSecurityAction action, valuetype System.Reflection.Metadata.BlobHandle permissionSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDeclarativeSecurityAttribute(System.Reflection.Metadata.EntityHandle,System.Reflection.DeclarativeSecurityAction,System.Reflection.Metadata.BlobHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddDeclarativeSecurityAttribute (parent As EntityHandle, action As DeclarativeSecurityAction, permissionSet As BlobHandle) As DeclarativeSecurityAttributeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::DeclarativeSecurityAttributeHandle AddDeclarativeSecurityAttribute(System::Reflection::Metadata::EntityHandle parent, System::Reflection::DeclarativeSecurityAction action, System::Reflection::Metadata::BlobHandle permissionSet);" />
      <MemberSignature Language="F#" Value="member this.AddDeclarativeSecurityAttribute : System.Reflection.Metadata.EntityHandle * System.Reflection.DeclarativeSecurityAction * System.Reflection.Metadata.BlobHandle -&gt; System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" Usage="metadataBuilder.AddDeclarativeSecurityAttribute (parent, action, permissionSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.DeclarativeSecurityAttributeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parent" Type="System.Reflection.Metadata.EntityHandle" />
        <Parameter Name="action" Type="System.Reflection.DeclarativeSecurityAction" />
        <Parameter Name="permissionSet" Type="System.Reflection.Metadata.BlobHandle" />
      </Parameters>
      <Docs>
        <param name="parent">The parent entity handle, which can be one of the following: a <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, or a <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />.</param>
        <param name="action">A declarative security action.</param>
        <param name="permissionSet">The permission set blob.</param>
        <summary>Adds a declarative security attribute to a type, method, or assembly.</summary>
        <returns>A handle to the added declarative security attribute.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Entries may be added in any order. The table is automatically sorted when serialized.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parent" /> doesn't have the expected handle kind.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddDocument">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.DocumentHandle AddDocument (System.Reflection.Metadata.BlobHandle name, System.Reflection.Metadata.GuidHandle hashAlgorithm, System.Reflection.Metadata.BlobHandle hash, System.Reflection.Metadata.GuidHandle language);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.DocumentHandle AddDocument(valuetype System.Reflection.Metadata.BlobHandle name, valuetype System.Reflection.Metadata.GuidHandle hashAlgorithm, valuetype System.Reflection.Metadata.BlobHandle hash, valuetype System.Reflection.Metadata.GuidHandle language) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddDocument(System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.BlobHandle,System.Reflection.Metadata.GuidHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddDocument (name As BlobHandle, hashAlgorithm As GuidHandle, hash As BlobHandle, language As GuidHandle) As DocumentHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::DocumentHandle AddDocument(System::Reflection::Metadata::BlobHandle name, System::Reflection::Metadata::GuidHandle hashAlgorithm, System::Reflection::Metadata::BlobHandle hash, System::Reflection::Metadata::GuidHandle language);" />
      <MemberSignature Language="F#" Value="member this.AddDocument : System.Reflection.Metadata.BlobHandle * System.Reflection.Metadata.GuidHandle * System.Reflection.Metadata.BlobHandle * System.Reflection.Metadata.GuidHandle -&gt; System.Reflection.Metadata.DocumentHandle" Usage="metadataBuilder.AddDocument (name, hashAlgorithm, hash, language)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.DocumentHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.Metadata.BlobHandle" />
        <Parameter Name="hashAlgorithm" Type="System.Reflection.Metadata.GuidHandle" />
        <Parameter Name="hash" Type="System.Reflection.Metadata.BlobHandle" />
        <Parameter Name="language" Type="System.Reflection.Metadata.GuidHandle" />
      </Parameters>
      <Docs>
        <param name="name">The document name blob.</param>
        <param name="hashAlgorithm">THe GUID of the hash algorithm used to calculate the value of <paramref name="hash" />.</param>
        <param name="hash">The hash of the document content.</param>
        <param name="language">The GUID of the language.</param>
        <summary>Adds document debug information.</summary>
        <returns>A handle to the added document.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For more information about `name`, see <https://github.com/dotnet/runtime/blob/master/docs/design/specs/PortablePdb-Metadata.md#document-name-blob>.

For more information about common values for `hashAlgorithm`, see <https://github.com/dotnet/runtime/blob/master/docs/design/specs/PortablePdb-Metadata.md#document-table-0x30>.

For more information about common values for `language`, see <https://github.com/dotnet/runtime/blob/master/docs/design/specs/PortablePdb-Metadata.md#document-table-0x30>.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddEncLogEntry">
      <MemberSignature Language="C#" Value="public void AddEncLogEntry (System.Reflection.Metadata.EntityHandle entity, System.Reflection.Metadata.Ecma335.EditAndContinueOperation code);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEncLogEntry(valuetype System.Reflection.Metadata.EntityHandle entity, valuetype System.Reflection.Metadata.Ecma335.EditAndContinueOperation code) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncLogEntry(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.Ecma335.EditAndContinueOperation)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddEncLogEntry (entity As EntityHandle, code As EditAndContinueOperation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddEncLogEntry(System::Reflection::Metadata::EntityHandle entity, System::Reflection::Metadata::Ecma335::EditAndContinueOperation code);" />
      <MemberSignature Language="F#" Value="member this.AddEncLogEntry : System.Reflection.Metadata.EntityHandle * System.Reflection.Metadata.Ecma335.EditAndContinueOperation -&gt; unit" Usage="metadataBuilder.AddEncLogEntry (entity, code)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Reflection.Metadata.EntityHandle" />
        <Parameter Name="code" Type="System.Reflection.Metadata.Ecma335.EditAndContinueOperation" />
      </Parameters>
      <Docs>
        <param name="entity">To be added.</param>
        <param name="code">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddEncMapEntry">
      <MemberSignature Language="C#" Value="public void AddEncMapEntry (System.Reflection.Metadata.EntityHandle entity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEncMapEntry(valuetype System.Reflection.Metadata.EntityHandle entity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEncMapEntry(System.Reflection.Metadata.EntityHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddEncMapEntry (entity As EntityHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddEncMapEntry(System::Reflection::Metadata::EntityHandle entity);" />
      <MemberSignature Language="F#" Value="member this.AddEncMapEntry : System.Reflection.Metadata.EntityHandle -&gt; unit" Usage="metadataBuilder.AddEncMapEntry entity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="entity" Type="System.Reflection.Metadata.EntityHandle" />
      </Parameters>
      <Docs>
        <param name="entity">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.EventDefinitionHandle AddEvent (System.Reflection.EventAttributes attributes, System.Reflection.Metadata.StringHandle name, System.Reflection.Metadata.EntityHandle type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.EventDefinitionHandle AddEvent(valuetype System.Reflection.EventAttributes attributes, valuetype System.Reflection.Metadata.StringHandle name, valuetype System.Reflection.Metadata.EntityHandle type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEvent(System.Reflection.EventAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddEvent (attributes As EventAttributes, name As StringHandle, type As EntityHandle) As EventDefinitionHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::EventDefinitionHandle AddEvent(System::Reflection::EventAttributes attributes, System::Reflection::Metadata::StringHandle name, System::Reflection::Metadata::EntityHandle type);" />
      <MemberSignature Language="F#" Value="member this.AddEvent : System.Reflection.EventAttributes * System.Reflection.Metadata.StringHandle * System.Reflection.Metadata.EntityHandle -&gt; System.Reflection.Metadata.EventDefinitionHandle" Usage="metadataBuilder.AddEvent (attributes, name, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.EventDefinitionHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.EventAttributes" />
        <Parameter Name="name" Type="System.Reflection.Metadata.StringHandle" />
        <Parameter Name="type" Type="System.Reflection.Metadata.EntityHandle" />
      </Parameters>
      <Docs>
        <param name="attributes">The event attributes.</param>
        <param name="name">The event name.</param>
        <param name="type">The type of the event: a <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, or <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
        <summary>Adds an event definition.</summary>
        <returns>A handle to the added event definition.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> doesn't have the expected handle kind.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddEventMap">
      <MemberSignature Language="C#" Value="public void AddEventMap (System.Reflection.Metadata.TypeDefinitionHandle declaringType, System.Reflection.Metadata.EventDefinitionHandle eventList);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddEventMap(valuetype System.Reflection.Metadata.TypeDefinitionHandle declaringType, valuetype System.Reflection.Metadata.EventDefinitionHandle eventList) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddEventMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EventDefinitionHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddEventMap (declaringType As TypeDefinitionHandle, eventList As EventDefinitionHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddEventMap(System::Reflection::Metadata::TypeDefinitionHandle declaringType, System::Reflection::Metadata::EventDefinitionHandle eventList);" />
      <MemberSignature Language="F#" Value="member this.AddEventMap : System.Reflection.Metadata.TypeDefinitionHandle * System.Reflection.Metadata.EventDefinitionHandle -&gt; unit" Usage="metadataBuilder.AddEventMap (declaringType, eventList)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="declaringType" Type="System.Reflection.Metadata.TypeDefinitionHandle" />
        <Parameter Name="eventList" Type="System.Reflection.Metadata.EventDefinitionHandle" />
      </Parameters>
      <Docs>
        <param name="declaringType">To be added.</param>
        <param name="eventList">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddExportedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.ExportedTypeHandle AddExportedType (System.Reflection.TypeAttributes attributes, System.Reflection.Metadata.StringHandle namespace, System.Reflection.Metadata.StringHandle name, System.Reflection.Metadata.EntityHandle implementation, int typeDefinitionId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.ExportedTypeHandle AddExportedType(valuetype System.Reflection.TypeAttributes attributes, valuetype System.Reflection.Metadata.StringHandle namespace, valuetype System.Reflection.Metadata.StringHandle name, valuetype System.Reflection.Metadata.EntityHandle implementation, int32 typeDefinitionId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddExportedType(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddExportedType (attributes As TypeAttributes, namespace As StringHandle, name As StringHandle, implementation As EntityHandle, typeDefinitionId As Integer) As ExportedTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::ExportedTypeHandle AddExportedType(System::Reflection::TypeAttributes attributes, System::Reflection::Metadata::StringHandle namespace, System::Reflection::Metadata::StringHandle name, System::Reflection::Metadata::EntityHandle implementation, int typeDefinitionId);" />
      <MemberSignature Language="F#" Value="member this.AddExportedType : System.Reflection.TypeAttributes * System.Reflection.Metadata.StringHandle * System.Reflection.Metadata.StringHandle * System.Reflection.Metadata.EntityHandle * int -&gt; System.Reflection.Metadata.ExportedTypeHandle" Usage="metadataBuilder.AddExportedType (attributes, namespace, name, implementation, typeDefinitionId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.ExportedTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="namespace" Type="System.Reflection.Metadata.StringHandle" />
        <Parameter Name="name" Type="System.Reflection.Metadata.StringHandle" />
        <Parameter Name="implementation" Type="System.Reflection.Metadata.EntityHandle" />
        <Parameter Name="typeDefinitionId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="attributes">The type attributes.</param>
        <param name="namespace">The type namespace.</param>
        <param name="name">The type name.</param>
        <param name="implementation">The implementation entity handle, which can be one of the following: an <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />, or <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />.</param>
        <param name="typeDefinitionId">The type definition ID.</param>
        <summary>Adds an exported type.</summary>
        <returns>A handle to the added exported type.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="implementation" /> doesn't have the expected handle kind.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddFieldDefinition">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.FieldDefinitionHandle AddFieldDefinition (System.Reflection.FieldAttributes attributes, System.Reflection.Metadata.StringHandle name, System.Reflection.Metadata.BlobHandle signature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.FieldDefinitionHandle AddFieldDefinition(valuetype System.Reflection.FieldAttributes attributes, valuetype System.Reflection.Metadata.StringHandle name, valuetype System.Reflection.Metadata.BlobHandle signature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldDefinition(System.Reflection.FieldAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddFieldDefinition (attributes As FieldAttributes, name As StringHandle, signature As BlobHandle) As FieldDefinitionHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::FieldDefinitionHandle AddFieldDefinition(System::Reflection::FieldAttributes attributes, System::Reflection::Metadata::StringHandle name, System::Reflection::Metadata::BlobHandle signature);" />
      <MemberSignature Language="F#" Value="member this.AddFieldDefinition : System.Reflection.FieldAttributes * System.Reflection.Metadata.StringHandle * System.Reflection.Metadata.BlobHandle -&gt; System.Reflection.Metadata.FieldDefinitionHandle" Usage="metadataBuilder.AddFieldDefinition (attributes, name, signature)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.FieldDefinitionHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
        <Parameter Name="name" Type="System.Reflection.Metadata.StringHandle" />
        <Parameter Name="signature" Type="System.Reflection.Metadata.BlobHandle" />
      </Parameters>
      <Docs>
        <param name="attributes">The field attributes.</param>
        <param name="name">The field name.</param>
        <param name="signature">The field signature. Use <see cref="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature" /> to construct the blob.</param>
        <summary>Adds a field definition.</summary>
        <returns>A handle to the added field definition.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddFieldLayout">
      <MemberSignature Language="C#" Value="public void AddFieldLayout (System.Reflection.Metadata.FieldDefinitionHandle field, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFieldLayout(valuetype System.Reflection.Metadata.FieldDefinitionHandle field, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldLayout(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFieldLayout (field As FieldDefinitionHandle, offset As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFieldLayout(System::Reflection::Metadata::FieldDefinitionHandle field, int offset);" />
      <MemberSignature Language="F#" Value="member this.AddFieldLayout : System.Reflection.Metadata.FieldDefinitionHandle * int -&gt; unit" Usage="metadataBuilder.AddFieldLayout (field, offset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="field" Type="System.Reflection.Metadata.FieldDefinitionHandle" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="field">The field definition handle.</param>
        <param name="offset">The byte offset of the field within the declaring type instance.</param>
        <summary>Defines a field layout of a field definition.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Entries must be added in the same order as the corresponding field definitions.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddFieldRelativeVirtualAddress">
      <MemberSignature Language="C#" Value="public void AddFieldRelativeVirtualAddress (System.Reflection.Metadata.FieldDefinitionHandle field, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFieldRelativeVirtualAddress(valuetype System.Reflection.Metadata.FieldDefinitionHandle field, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddFieldRelativeVirtualAddress(System.Reflection.Metadata.FieldDefinitionHandle,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFieldRelativeVirtualAddress (field As FieldDefinitionHandle, offset As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFieldRelativeVirtualAddress(System::Reflection::Metadata::FieldDefinitionHandle field, int offset);" />
      <MemberSignature Language="F#" Value="member this.AddFieldRelativeVirtualAddress : System.Reflection.Metadata.FieldDefinitionHandle * int -&gt; unit" Usage="metadataBuilder.AddFieldRelativeVirtualAddress (field, offset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="field" Type="System.Reflection.Metadata.FieldDefinitionHandle" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="field">The field definition handle.</param>
        <param name="offset">The offset within the block in the PE image that stores initial values of mapped fields (usually in the .text section).</param>
        <summary>Adds a mapping from a field to its initial value stored in the PE image.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Entires must be added in the same order as the corresponding field definitions.

The final relative virtual address stored in the metadata is calculated when the metadata is serialized by adding the offset to the virtual address of the block start.
          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> is negative.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddGenericParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.GenericParameterHandle AddGenericParameter (System.Reflection.Metadata.EntityHandle parent, System.Reflection.GenericParameterAttributes attributes, System.Reflection.Metadata.StringHandle name, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.GenericParameterHandle AddGenericParameter(valuetype System.Reflection.Metadata.EntityHandle parent, valuetype System.Reflection.GenericParameterAttributes attributes, valuetype System.Reflection.Metadata.StringHandle name, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameter(System.Reflection.Metadata.EntityHandle,System.Reflection.GenericParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddGenericParameter (parent As EntityHandle, attributes As GenericParameterAttributes, name As StringHandle, index As Integer) As GenericParameterHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::GenericParameterHandle AddGenericParameter(System::Reflection::Metadata::EntityHandle parent, System::Reflection::GenericParameterAttributes attributes, System::Reflection::Metadata::StringHandle name, int index);" />
      <MemberSignature Language="F#" Value="member this.AddGenericParameter : System.Reflection.Metadata.EntityHandle * System.Reflection.GenericParameterAttributes * System.Reflection.Metadata.StringHandle * int -&gt; System.Reflection.Metadata.GenericParameterHandle" Usage="metadataBuilder.AddGenericParameter (parent, attributes, name, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.GenericParameterHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parent" Type="System.Reflection.Metadata.EntityHandle" />
        <Parameter Name="attributes" Type="System.Reflection.GenericParameterAttributes" />
        <Parameter Name="name" Type="System.Reflection.Metadata.StringHandle" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parent">The parent entity handle, which can be either a <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> or <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />.</param>
        <param name="attributes">The generic parameter attributes.</param>
        <param name="name">The parameter name.</param>
        <param name="index">The zero-based parameter index.</param>
        <summary>Adds a generic parameter definition.</summary>
        <returns>A handle to the added generic parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Generic parameters must be added in an order determined by the coded index of their parent entity (<xref:System.Reflection.Metadata.Ecma335.CodedIndex.TypeOrMethodDef(System.Reflection.Metadata.EntityHandle)?displayProperty=nameWithType>).

Generic parameters with the same parent must be ordered by their `index`.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parent" /> doesn't have the expected handle kind.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is greater than <see cref="F:System.UInt16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddGenericParameterConstraint">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.GenericParameterConstraintHandle AddGenericParameterConstraint (System.Reflection.Metadata.GenericParameterHandle genericParameter, System.Reflection.Metadata.EntityHandle constraint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.GenericParameterConstraintHandle AddGenericParameterConstraint(valuetype System.Reflection.Metadata.GenericParameterHandle genericParameter, valuetype System.Reflection.Metadata.EntityHandle constraint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddGenericParameterConstraint(System.Reflection.Metadata.GenericParameterHandle,System.Reflection.Metadata.EntityHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddGenericParameterConstraint (genericParameter As GenericParameterHandle, constraint As EntityHandle) As GenericParameterConstraintHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::GenericParameterConstraintHandle AddGenericParameterConstraint(System::Reflection::Metadata::GenericParameterHandle genericParameter, System::Reflection::Metadata::EntityHandle constraint);" />
      <MemberSignature Language="F#" Value="member this.AddGenericParameterConstraint : System.Reflection.Metadata.GenericParameterHandle * System.Reflection.Metadata.EntityHandle -&gt; System.Reflection.Metadata.GenericParameterConstraintHandle" Usage="metadataBuilder.AddGenericParameterConstraint (genericParameter, constraint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.GenericParameterConstraintHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericParameter" Type="System.Reflection.Metadata.GenericParameterHandle" />
        <Parameter Name="constraint" Type="System.Reflection.Metadata.EntityHandle" />
      </Parameters>
      <Docs>
        <param name="genericParameter">The generic parameter to constrain.</param>
        <param name="constraint">The type constraint, which can be one of the following: a <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> or a <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
        <summary>Adds a type constraint to a generic parameter.</summary>
        <returns>A handle to the added generic parameter constraint.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Constraints must be added in the same order as the corresponding generic parameters.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="genericParameter" /> doesn't have the expected handle kind.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddImportScope">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.ImportScopeHandle AddImportScope (System.Reflection.Metadata.ImportScopeHandle parentScope, System.Reflection.Metadata.BlobHandle imports);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.ImportScopeHandle AddImportScope(valuetype System.Reflection.Metadata.ImportScopeHandle parentScope, valuetype System.Reflection.Metadata.BlobHandle imports) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddImportScope(System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.BlobHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddImportScope (parentScope As ImportScopeHandle, imports As BlobHandle) As ImportScopeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::ImportScopeHandle AddImportScope(System::Reflection::Metadata::ImportScopeHandle parentScope, System::Reflection::Metadata::BlobHandle imports);" />
      <MemberSignature Language="F#" Value="member this.AddImportScope : System.Reflection.Metadata.ImportScopeHandle * System.Reflection.Metadata.BlobHandle -&gt; System.Reflection.Metadata.ImportScopeHandle" Usage="metadataBuilder.AddImportScope (parentScope, imports)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.ImportScopeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parentScope" Type="System.Reflection.Metadata.ImportScopeHandle" />
        <Parameter Name="imports" Type="System.Reflection.Metadata.BlobHandle" />
      </Parameters>
      <Docs>
        <param name="parentScope">The parent scope handle.</param>
        <param name="imports">The import scope handle.</param>
        <summary>Adds local scope debug information.</summary>
        <returns>A handle to the added import scope.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For more information about `imports`, see <https://github.com/dotnet/runtime/blob/master/docs/design/specs/PortablePdb-Metadata.md#imports-blob>.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddInterfaceImplementation">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.InterfaceImplementationHandle AddInterfaceImplementation (System.Reflection.Metadata.TypeDefinitionHandle type, System.Reflection.Metadata.EntityHandle implementedInterface);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.InterfaceImplementationHandle AddInterfaceImplementation(valuetype System.Reflection.Metadata.TypeDefinitionHandle type, valuetype System.Reflection.Metadata.EntityHandle implementedInterface) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddInterfaceImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddInterfaceImplementation (type As TypeDefinitionHandle, implementedInterface As EntityHandle) As InterfaceImplementationHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::InterfaceImplementationHandle AddInterfaceImplementation(System::Reflection::Metadata::TypeDefinitionHandle type, System::Reflection::Metadata::EntityHandle implementedInterface);" />
      <MemberSignature Language="F#" Value="member this.AddInterfaceImplementation : System.Reflection.Metadata.TypeDefinitionHandle * System.Reflection.Metadata.EntityHandle -&gt; System.Reflection.Metadata.InterfaceImplementationHandle" Usage="metadataBuilder.AddInterfaceImplementation (type, implementedInterface)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.InterfaceImplementationHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Reflection.Metadata.TypeDefinitionHandle" />
        <Parameter Name="implementedInterface" Type="System.Reflection.Metadata.EntityHandle" />
      </Parameters>
      <Docs>
        <param name="type">The type implementing the interface.</param>
        <param name="implementedInterface">The interface being implemented, which can be one of the following: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, or <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
        <summary>Adds an interface implementation to a type.</summary>
        <returns>A handle to the added interface implementation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Interface implementations must be added in the same order as the corresponding type definitions implementing the interface.

If a type implements multiple interfaces, the corresponding entries must be added in the order determined by their coded indices (<xref:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRefOrSpec(System.Reflection.Metadata.EntityHandle)?displayProperty=nameWithType>).

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="implementedInterface" /> doesn't have the expected handle kind.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddLocalConstant">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.LocalConstantHandle AddLocalConstant (System.Reflection.Metadata.StringHandle name, System.Reflection.Metadata.BlobHandle signature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.LocalConstantHandle AddLocalConstant(valuetype System.Reflection.Metadata.StringHandle name, valuetype System.Reflection.Metadata.BlobHandle signature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalConstant(System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddLocalConstant (name As StringHandle, signature As BlobHandle) As LocalConstantHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::LocalConstantHandle AddLocalConstant(System::Reflection::Metadata::StringHandle name, System::Reflection::Metadata::BlobHandle signature);" />
      <MemberSignature Language="F#" Value="member this.AddLocalConstant : System.Reflection.Metadata.StringHandle * System.Reflection.Metadata.BlobHandle -&gt; System.Reflection.Metadata.LocalConstantHandle" Usage="metadataBuilder.AddLocalConstant (name, signature)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.LocalConstantHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.Metadata.StringHandle" />
        <Parameter Name="signature" Type="System.Reflection.Metadata.BlobHandle" />
      </Parameters>
      <Docs>
        <param name="name">The name of the variable.</param>
        <param name="signature">The LocalConstantSig blob.</param>
        <summary>Adds local constant debug information.</summary>
        <returns>A handle to the added local constant.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For more information about `signature`, see: [LocalConstantSig Blob](https://github.com/dotnet/runtime/blob/master/docs/design/specs/PortablePdb-Metadata.md#localconstantsig-blob) on GitHub.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLocalScope">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.LocalScopeHandle AddLocalScope (System.Reflection.Metadata.MethodDefinitionHandle method, System.Reflection.Metadata.ImportScopeHandle importScope, System.Reflection.Metadata.LocalVariableHandle variableList, System.Reflection.Metadata.LocalConstantHandle constantList, int startOffset, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.LocalScopeHandle AddLocalScope(valuetype System.Reflection.Metadata.MethodDefinitionHandle method, valuetype System.Reflection.Metadata.ImportScopeHandle importScope, valuetype System.Reflection.Metadata.LocalVariableHandle variableList, valuetype System.Reflection.Metadata.LocalConstantHandle constantList, int32 startOffset, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalScope(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.ImportScopeHandle,System.Reflection.Metadata.LocalVariableHandle,System.Reflection.Metadata.LocalConstantHandle,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddLocalScope (method As MethodDefinitionHandle, importScope As ImportScopeHandle, variableList As LocalVariableHandle, constantList As LocalConstantHandle, startOffset As Integer, length As Integer) As LocalScopeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::LocalScopeHandle AddLocalScope(System::Reflection::Metadata::MethodDefinitionHandle method, System::Reflection::Metadata::ImportScopeHandle importScope, System::Reflection::Metadata::LocalVariableHandle variableList, System::Reflection::Metadata::LocalConstantHandle constantList, int startOffset, int length);" />
      <MemberSignature Language="F#" Value="member this.AddLocalScope : System.Reflection.Metadata.MethodDefinitionHandle * System.Reflection.Metadata.ImportScopeHandle * System.Reflection.Metadata.LocalVariableHandle * System.Reflection.Metadata.LocalConstantHandle * int * int -&gt; System.Reflection.Metadata.LocalScopeHandle" Usage="metadataBuilder.AddLocalScope (method, importScope, variableList, constantList, startOffset, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.LocalScopeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.Metadata.MethodDefinitionHandle" />
        <Parameter Name="importScope" Type="System.Reflection.Metadata.ImportScopeHandle" />
        <Parameter Name="variableList" Type="System.Reflection.Metadata.LocalVariableHandle" />
        <Parameter Name="constantList" Type="System.Reflection.Metadata.LocalConstantHandle" />
        <Parameter Name="startOffset" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="method">The containing method.</param>
        <param name="importScope">The handle of the associated import scope.</param>
        <param name="variableList">If the scope declares variables, set this to the handle of the first one. Otherwise, set this to the handle of the first variable declared by the next scope definition. If no scope defines any variables, <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(1)" />.</param>
        <param name="constantList">If the scope declares constants, set this the handle of the first one. Otherwise, set this to the handle of the first constant declared by the next scope definition. If no scope defines any constants, <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(1)" />.</param>
        <param name="startOffset">The offset of the first instruction covered by the scope.</param>
        <param name="length">The length (in bytes) of the scope.</param>
        <summary>Adds local scope debug information.</summary>
        <returns>A handle to the added local scope.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Local scopes should be added in the same order as the corresponding method definition.

Within a method, they should be ordered by ascending `startOffset` and then by descending `length`.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLocalVariable">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.LocalVariableHandle AddLocalVariable (System.Reflection.Metadata.LocalVariableAttributes attributes, int index, System.Reflection.Metadata.StringHandle name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.LocalVariableHandle AddLocalVariable(valuetype System.Reflection.Metadata.LocalVariableAttributes attributes, int32 index, valuetype System.Reflection.Metadata.StringHandle name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddLocalVariable(System.Reflection.Metadata.LocalVariableAttributes,System.Int32,System.Reflection.Metadata.StringHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddLocalVariable (attributes As LocalVariableAttributes, index As Integer, name As StringHandle) As LocalVariableHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::LocalVariableHandle AddLocalVariable(System::Reflection::Metadata::LocalVariableAttributes attributes, int index, System::Reflection::Metadata::StringHandle name);" />
      <MemberSignature Language="F#" Value="member this.AddLocalVariable : System.Reflection.Metadata.LocalVariableAttributes * int * System.Reflection.Metadata.StringHandle -&gt; System.Reflection.Metadata.LocalVariableHandle" Usage="metadataBuilder.AddLocalVariable (attributes, index, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.LocalVariableHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.Metadata.LocalVariableAttributes" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="name" Type="System.Reflection.Metadata.StringHandle" />
      </Parameters>
      <Docs>
        <param name="attributes">The local variable attributes.</param>
        <param name="index">The zero-base index of the local variable in the local signature.</param>
        <param name="name">The name of the variable.</param>
        <summary>Adds local variable debug information.</summary>
        <returns>A handle to the added local variable.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> is greater than <see cref="F:System.UInt16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddManifestResource">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.ManifestResourceHandle AddManifestResource (System.Reflection.ManifestResourceAttributes attributes, System.Reflection.Metadata.StringHandle name, System.Reflection.Metadata.EntityHandle implementation, uint offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.ManifestResourceHandle AddManifestResource(valuetype System.Reflection.ManifestResourceAttributes attributes, valuetype System.Reflection.Metadata.StringHandle name, valuetype System.Reflection.Metadata.EntityHandle implementation, unsigned int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddManifestResource(System.Reflection.ManifestResourceAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddManifestResource (attributes As ManifestResourceAttributes, name As StringHandle, implementation As EntityHandle, offset As UInteger) As ManifestResourceHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::ManifestResourceHandle AddManifestResource(System::Reflection::ManifestResourceAttributes attributes, System::Reflection::Metadata::StringHandle name, System::Reflection::Metadata::EntityHandle implementation, System::UInt32 offset);" />
      <MemberSignature Language="F#" Value="member this.AddManifestResource : System.Reflection.ManifestResourceAttributes * System.Reflection.Metadata.StringHandle * System.Reflection.Metadata.EntityHandle * uint32 -&gt; System.Reflection.Metadata.ManifestResourceHandle" Usage="metadataBuilder.AddManifestResource (attributes, name, implementation, offset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.ManifestResourceHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.ManifestResourceAttributes" />
        <Parameter Name="name" Type="System.Reflection.Metadata.StringHandle" />
        <Parameter Name="implementation" Type="System.Reflection.Metadata.EntityHandle" />
        <Parameter Name="offset" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="attributes">The manifest resource attributes.</param>
        <param name="name">The name of the manifest resource.</param>
        <param name="implementation">The implementation entity handle, which can be one of the following: <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, or <see langword="null" />.</param>
        <param name="offset">Specifies the byte offset within the referenced file at which this resource record begins.</param>
        <summary>Adds a manifest resource.</summary>
        <returns>A handle to the added manifest resource.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="implementation" /> doesn't have the expected handle kind.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddMarshallingDescriptor">
      <MemberSignature Language="C#" Value="public void AddMarshallingDescriptor (System.Reflection.Metadata.EntityHandle parent, System.Reflection.Metadata.BlobHandle descriptor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddMarshallingDescriptor(valuetype System.Reflection.Metadata.EntityHandle parent, valuetype System.Reflection.Metadata.BlobHandle descriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMarshallingDescriptor(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddMarshallingDescriptor (parent As EntityHandle, descriptor As BlobHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddMarshallingDescriptor(System::Reflection::Metadata::EntityHandle parent, System::Reflection::Metadata::BlobHandle descriptor);" />
      <MemberSignature Language="F#" Value="member this.AddMarshallingDescriptor : System.Reflection.Metadata.EntityHandle * System.Reflection.Metadata.BlobHandle -&gt; unit" Usage="metadataBuilder.AddMarshallingDescriptor (parent, descriptor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parent" Type="System.Reflection.Metadata.EntityHandle" />
        <Parameter Name="descriptor" Type="System.Reflection.Metadata.BlobHandle" />
      </Parameters>
      <Docs>
        <param name="parent">The parent entity handle, which can be one of the following: <see cref="T:System.Reflection.Metadata.ParameterHandle" /> or <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />.</param>
        <param name="descriptor">The descriptor blob.</param>
        <summary>Adds marshalling information to a field or a parameter.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Entries may be added in any order. The table is automatically sorted when serialized.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parent" /> doesn't have the expected handle kind.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddMemberReference">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.MemberReferenceHandle AddMemberReference (System.Reflection.Metadata.EntityHandle parent, System.Reflection.Metadata.StringHandle name, System.Reflection.Metadata.BlobHandle signature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.MemberReferenceHandle AddMemberReference(valuetype System.Reflection.Metadata.EntityHandle parent, valuetype System.Reflection.Metadata.StringHandle name, valuetype System.Reflection.Metadata.BlobHandle signature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMemberReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddMemberReference (parent As EntityHandle, name As StringHandle, signature As BlobHandle) As MemberReferenceHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::MemberReferenceHandle AddMemberReference(System::Reflection::Metadata::EntityHandle parent, System::Reflection::Metadata::StringHandle name, System::Reflection::Metadata::BlobHandle signature);" />
      <MemberSignature Language="F#" Value="member this.AddMemberReference : System.Reflection.Metadata.EntityHandle * System.Reflection.Metadata.StringHandle * System.Reflection.Metadata.BlobHandle -&gt; System.Reflection.Metadata.MemberReferenceHandle" Usage="metadataBuilder.AddMemberReference (parent, name, signature)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.MemberReferenceHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parent" Type="System.Reflection.Metadata.EntityHandle" />
        <Parameter Name="name" Type="System.Reflection.Metadata.StringHandle" />
        <Parameter Name="signature" Type="System.Reflection.Metadata.BlobHandle" />
      </Parameters>
      <Docs>
        <param name="parent">The containing entity, which can be one of the following: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, or <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
        <param name="name">The member name.</param>
        <param name="signature">The member signature.</param>
        <summary>Adds a MemberRef table row.</summary>
        <returns>A handle to the added member reference.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="parent" /> doesn't have the expected handle kind.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddMethodDebugInformation">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.MethodDebugInformationHandle AddMethodDebugInformation (System.Reflection.Metadata.DocumentHandle document, System.Reflection.Metadata.BlobHandle sequencePoints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.MethodDebugInformationHandle AddMethodDebugInformation(valuetype System.Reflection.Metadata.DocumentHandle document, valuetype System.Reflection.Metadata.BlobHandle sequencePoints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDebugInformation(System.Reflection.Metadata.DocumentHandle,System.Reflection.Metadata.BlobHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddMethodDebugInformation (document As DocumentHandle, sequencePoints As BlobHandle) As MethodDebugInformationHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::MethodDebugInformationHandle AddMethodDebugInformation(System::Reflection::Metadata::DocumentHandle document, System::Reflection::Metadata::BlobHandle sequencePoints);" />
      <MemberSignature Language="F#" Value="member this.AddMethodDebugInformation : System.Reflection.Metadata.DocumentHandle * System.Reflection.Metadata.BlobHandle -&gt; System.Reflection.Metadata.MethodDebugInformationHandle" Usage="metadataBuilder.AddMethodDebugInformation (document, sequencePoints)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.MethodDebugInformationHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="document" Type="System.Reflection.Metadata.DocumentHandle" />
        <Parameter Name="sequencePoints" Type="System.Reflection.Metadata.BlobHandle" />
      </Parameters>
      <Docs>
        <param name="document">The handle of a single document containing all sequence points of the method, or <see langword="null" /> if the method doesn't have sequence points or spans multiple documents.</param>
        <param name="sequencePoints">The sequence Points blob, or <see langword="null" /> if the method doesn't have sequence points.</param>
        <summary>Adds method debug information.</summary>
        <returns>A handle to the added method debug information.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For more information about `sequencePoints`, see: [Sequence Points Blob](https://github.com/dotnet/runtime/blob/master/docs/design/specs/PortablePdb-Metadata.md#sequence-points-blob) on GitHub.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMethodDefinition">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.MethodDefinitionHandle AddMethodDefinition (System.Reflection.MethodAttributes attributes, System.Reflection.MethodImplAttributes implAttributes, System.Reflection.Metadata.StringHandle name, System.Reflection.Metadata.BlobHandle signature, int bodyOffset, System.Reflection.Metadata.ParameterHandle parameterList);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.MethodDefinitionHandle AddMethodDefinition(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.MethodImplAttributes implAttributes, valuetype System.Reflection.Metadata.StringHandle name, valuetype System.Reflection.Metadata.BlobHandle signature, int32 bodyOffset, valuetype System.Reflection.Metadata.ParameterHandle parameterList) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodDefinition(System.Reflection.MethodAttributes,System.Reflection.MethodImplAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle,System.Int32,System.Reflection.Metadata.ParameterHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddMethodDefinition (attributes As MethodAttributes, implAttributes As MethodImplAttributes, name As StringHandle, signature As BlobHandle, bodyOffset As Integer, parameterList As ParameterHandle) As MethodDefinitionHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::MethodDefinitionHandle AddMethodDefinition(System::Reflection::MethodAttributes attributes, System::Reflection::MethodImplAttributes implAttributes, System::Reflection::Metadata::StringHandle name, System::Reflection::Metadata::BlobHandle signature, int bodyOffset, System::Reflection::Metadata::ParameterHandle parameterList);" />
      <MemberSignature Language="F#" Value="member this.AddMethodDefinition : System.Reflection.MethodAttributes * System.Reflection.MethodImplAttributes * System.Reflection.Metadata.StringHandle * System.Reflection.Metadata.BlobHandle * int * System.Reflection.Metadata.ParameterHandle -&gt; System.Reflection.Metadata.MethodDefinitionHandle" Usage="metadataBuilder.AddMethodDefinition (attributes, implAttributes, name, signature, bodyOffset, parameterList)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.MethodDefinitionHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="implAttributes" Type="System.Reflection.MethodImplAttributes" />
        <Parameter Name="name" Type="System.Reflection.Metadata.StringHandle" />
        <Parameter Name="signature" Type="System.Reflection.Metadata.BlobHandle" />
        <Parameter Name="bodyOffset" Type="System.Int32" />
        <Parameter Name="parameterList" Type="System.Reflection.Metadata.ParameterHandle" />
      </Parameters>
      <Docs>
        <param name="attributes">The method attributes.</param>
        <param name="implAttributes">The method implementation attributes.</param>
        <param name="name">The method name.</param>
        <param name="signature">The method signature.</param>
        <param name="bodyOffset">Offset within the block in the PE image that stores method bodies (the IL stream), or -1 if the method doesn't have a body. </param>
        <param name="parameterList">If the method declares parameters in the Params table, set this to the handle of the first one. Otherwise, set this to the handle of the first parameter declared by the next method definition. If no parameters are declared in the module, <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(1)" />.</param>
        <summary>Adds a method definition.</summary>
        <returns>A handle to the added method definition.</returns>
        <remarks>The final relative virtual address stored in the metadata is calculated when the metadata is serialized by adding the offset to the virtual address of the beginning of the block.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bodyOffset" /> is less than -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddMethodImplementation">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.MethodImplementationHandle AddMethodImplementation (System.Reflection.Metadata.TypeDefinitionHandle type, System.Reflection.Metadata.EntityHandle methodBody, System.Reflection.Metadata.EntityHandle methodDeclaration);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.MethodImplementationHandle AddMethodImplementation(valuetype System.Reflection.Metadata.TypeDefinitionHandle type, valuetype System.Reflection.Metadata.EntityHandle methodBody, valuetype System.Reflection.Metadata.EntityHandle methodDeclaration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImplementation(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddMethodImplementation (type As TypeDefinitionHandle, methodBody As EntityHandle, methodDeclaration As EntityHandle) As MethodImplementationHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::MethodImplementationHandle AddMethodImplementation(System::Reflection::Metadata::TypeDefinitionHandle type, System::Reflection::Metadata::EntityHandle methodBody, System::Reflection::Metadata::EntityHandle methodDeclaration);" />
      <MemberSignature Language="F#" Value="member this.AddMethodImplementation : System.Reflection.Metadata.TypeDefinitionHandle * System.Reflection.Metadata.EntityHandle * System.Reflection.Metadata.EntityHandle -&gt; System.Reflection.Metadata.MethodImplementationHandle" Usage="metadataBuilder.AddMethodImplementation (type, methodBody, methodDeclaration)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.MethodImplementationHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Reflection.Metadata.TypeDefinitionHandle" />
        <Parameter Name="methodBody" Type="System.Reflection.Metadata.EntityHandle" />
        <Parameter Name="methodDeclaration" Type="System.Reflection.Metadata.EntityHandle" />
      </Parameters>
      <Docs>
        <param name="type">The type definition.</param>
        <param name="methodBody">The method body entity handle, which can be one of the following: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> or <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
        <param name="methodDeclaration">The method declaration entity handle, which can be one of the following: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> or <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
        <summary>Defines an implementation for a method declaration within a type.</summary>
        <returns>A handle to the added method implementation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Method implementations must be added in the same order as the corresponding type definitions.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="methodBody" /> or <paramref name="methodDeclaration" /> doesn't have the expected handle kind.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddMethodImport">
      <MemberSignature Language="C#" Value="public void AddMethodImport (System.Reflection.Metadata.MethodDefinitionHandle method, System.Reflection.MethodImportAttributes attributes, System.Reflection.Metadata.StringHandle name, System.Reflection.Metadata.ModuleReferenceHandle module);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddMethodImport(valuetype System.Reflection.Metadata.MethodDefinitionHandle method, valuetype System.Reflection.MethodImportAttributes attributes, valuetype System.Reflection.Metadata.StringHandle name, valuetype System.Reflection.Metadata.ModuleReferenceHandle module) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodImport(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.MethodImportAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.ModuleReferenceHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddMethodImport (method As MethodDefinitionHandle, attributes As MethodImportAttributes, name As StringHandle, module As ModuleReferenceHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddMethodImport(System::Reflection::Metadata::MethodDefinitionHandle method, System::Reflection::MethodImportAttributes attributes, System::Reflection::Metadata::StringHandle name, System::Reflection::Metadata::ModuleReferenceHandle module);" />
      <MemberSignature Language="F#" Value="member this.AddMethodImport : System.Reflection.Metadata.MethodDefinitionHandle * System.Reflection.MethodImportAttributes * System.Reflection.Metadata.StringHandle * System.Reflection.Metadata.ModuleReferenceHandle -&gt; unit" Usage="metadataBuilder.AddMethodImport (method, attributes, name, module)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.Metadata.MethodDefinitionHandle" />
        <Parameter Name="attributes" Type="System.Reflection.MethodImportAttributes" />
        <Parameter Name="name" Type="System.Reflection.Metadata.StringHandle" />
        <Parameter Name="module" Type="System.Reflection.Metadata.ModuleReferenceHandle" />
      </Parameters>
      <Docs>
        <param name="method">The method definition handle.</param>
        <param name="attributes">The method import attributes.</param>
        <param name="name">The unmanaged method name.</param>
        <param name="module">The module containing the unmanaged method.</param>
        <summary>Adds import information to a method definition.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Method imports must be added in the same order as the corresponding method definitions.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddMethodSemantics">
      <MemberSignature Language="C#" Value="public void AddMethodSemantics (System.Reflection.Metadata.EntityHandle association, System.Reflection.MethodSemanticsAttributes semantics, System.Reflection.Metadata.MethodDefinitionHandle methodDefinition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddMethodSemantics(valuetype System.Reflection.Metadata.EntityHandle association, valuetype System.Reflection.MethodSemanticsAttributes semantics, valuetype System.Reflection.Metadata.MethodDefinitionHandle methodDefinition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSemantics(System.Reflection.Metadata.EntityHandle,System.Reflection.MethodSemanticsAttributes,System.Reflection.Metadata.MethodDefinitionHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddMethodSemantics (association As EntityHandle, semantics As MethodSemanticsAttributes, methodDefinition As MethodDefinitionHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddMethodSemantics(System::Reflection::Metadata::EntityHandle association, System::Reflection::MethodSemanticsAttributes semantics, System::Reflection::Metadata::MethodDefinitionHandle methodDefinition);" />
      <MemberSignature Language="F#" Value="member this.AddMethodSemantics : System.Reflection.Metadata.EntityHandle * System.Reflection.MethodSemanticsAttributes * System.Reflection.Metadata.MethodDefinitionHandle -&gt; unit" Usage="metadataBuilder.AddMethodSemantics (association, semantics, methodDefinition)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="association" Type="System.Reflection.Metadata.EntityHandle" />
        <Parameter Name="semantics" Type="System.Reflection.MethodSemanticsAttributes" />
        <Parameter Name="methodDefinition" Type="System.Reflection.Metadata.MethodDefinitionHandle" />
      </Parameters>
      <Docs>
        <param name="association">The association entity handle, which can be one of the following: <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" /> or <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />.</param>
        <param name="semantics">The method semantics attributes.</param>
        <param name="methodDefinition">The method definition.</param>
        <summary>Associates a method (a getter, a setter, an adder, etc.) with a property or an event.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Entries may be added in any order. The table is automatically sorted when serialized.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="association" /> doesn't have the expected handle kind.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddMethodSpecification">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.MethodSpecificationHandle AddMethodSpecification (System.Reflection.Metadata.EntityHandle method, System.Reflection.Metadata.BlobHandle instantiation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.MethodSpecificationHandle AddMethodSpecification(valuetype System.Reflection.Metadata.EntityHandle method, valuetype System.Reflection.Metadata.BlobHandle instantiation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddMethodSpecification(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.BlobHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddMethodSpecification (method As EntityHandle, instantiation As BlobHandle) As MethodSpecificationHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::MethodSpecificationHandle AddMethodSpecification(System::Reflection::Metadata::EntityHandle method, System::Reflection::Metadata::BlobHandle instantiation);" />
      <MemberSignature Language="F#" Value="member this.AddMethodSpecification : System.Reflection.Metadata.EntityHandle * System.Reflection.Metadata.BlobHandle -&gt; System.Reflection.Metadata.MethodSpecificationHandle" Usage="metadataBuilder.AddMethodSpecification (method, instantiation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.MethodSpecificationHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Reflection.Metadata.EntityHandle" />
        <Parameter Name="instantiation" Type="System.Reflection.Metadata.BlobHandle" />
      </Parameters>
      <Docs>
        <param name="method">The generic method entity handle, which can be one of the following: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> or <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />.</param>
        <param name="instantiation">The instantiation blob encoding the generic arguments of the method.</param>
        <summary>Adds a method specification (an instantiation).</summary>
        <returns>A handle to the added method specification.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" /> doesn't have the expected handle kind.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.ModuleDefinitionHandle AddModule (int generation, System.Reflection.Metadata.StringHandle moduleName, System.Reflection.Metadata.GuidHandle mvid, System.Reflection.Metadata.GuidHandle encId, System.Reflection.Metadata.GuidHandle encBaseId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.ModuleDefinitionHandle AddModule(int32 generation, valuetype System.Reflection.Metadata.StringHandle moduleName, valuetype System.Reflection.Metadata.GuidHandle mvid, valuetype System.Reflection.Metadata.GuidHandle encId, valuetype System.Reflection.Metadata.GuidHandle encBaseId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModule(System.Int32,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle,System.Reflection.Metadata.GuidHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddModule (generation As Integer, moduleName As StringHandle, mvid As GuidHandle, encId As GuidHandle, encBaseId As GuidHandle) As ModuleDefinitionHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::ModuleDefinitionHandle AddModule(int generation, System::Reflection::Metadata::StringHandle moduleName, System::Reflection::Metadata::GuidHandle mvid, System::Reflection::Metadata::GuidHandle encId, System::Reflection::Metadata::GuidHandle encBaseId);" />
      <MemberSignature Language="F#" Value="member this.AddModule : int * System.Reflection.Metadata.StringHandle * System.Reflection.Metadata.GuidHandle * System.Reflection.Metadata.GuidHandle * System.Reflection.Metadata.GuidHandle -&gt; System.Reflection.Metadata.ModuleDefinitionHandle" Usage="metadataBuilder.AddModule (generation, moduleName, mvid, encId, encBaseId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.ModuleDefinitionHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="moduleName" Type="System.Reflection.Metadata.StringHandle" />
        <Parameter Name="mvid" Type="System.Reflection.Metadata.GuidHandle" />
        <Parameter Name="encId" Type="System.Reflection.Metadata.GuidHandle" />
        <Parameter Name="encBaseId" Type="System.Reflection.Metadata.GuidHandle" />
      </Parameters>
      <Docs>
        <param name="generation">To be added.</param>
        <param name="moduleName">To be added.</param>
        <param name="mvid">To be added.</param>
        <param name="encId">To be added.</param>
        <param name="encBaseId">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddModuleReference">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.ModuleReferenceHandle AddModuleReference (System.Reflection.Metadata.StringHandle moduleName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.ModuleReferenceHandle AddModuleReference(valuetype System.Reflection.Metadata.StringHandle moduleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddModuleReference(System.Reflection.Metadata.StringHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddModuleReference (moduleName As StringHandle) As ModuleReferenceHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::ModuleReferenceHandle AddModuleReference(System::Reflection::Metadata::StringHandle moduleName);" />
      <MemberSignature Language="F#" Value="member this.AddModuleReference : System.Reflection.Metadata.StringHandle -&gt; System.Reflection.Metadata.ModuleReferenceHandle" Usage="metadataBuilder.AddModuleReference moduleName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.ModuleReferenceHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.Reflection.Metadata.StringHandle" />
      </Parameters>
      <Docs>
        <param name="moduleName">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddNestedType">
      <MemberSignature Language="C#" Value="public void AddNestedType (System.Reflection.Metadata.TypeDefinitionHandle type, System.Reflection.Metadata.TypeDefinitionHandle enclosingType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddNestedType(valuetype System.Reflection.Metadata.TypeDefinitionHandle type, valuetype System.Reflection.Metadata.TypeDefinitionHandle enclosingType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddNestedType(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.TypeDefinitionHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddNestedType (type As TypeDefinitionHandle, enclosingType As TypeDefinitionHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddNestedType(System::Reflection::Metadata::TypeDefinitionHandle type, System::Reflection::Metadata::TypeDefinitionHandle enclosingType);" />
      <MemberSignature Language="F#" Value="member this.AddNestedType : System.Reflection.Metadata.TypeDefinitionHandle * System.Reflection.Metadata.TypeDefinitionHandle -&gt; unit" Usage="metadataBuilder.AddNestedType (type, enclosingType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Reflection.Metadata.TypeDefinitionHandle" />
        <Parameter Name="enclosingType" Type="System.Reflection.Metadata.TypeDefinitionHandle" />
      </Parameters>
      <Docs>
        <param name="type">The nested type definition handle.</param>
        <param name="enclosingType">The enclosing type definition handle.</param>
        <summary>Defines a nesting relationship to specified type definitions.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Entries must be added in the same order as the corresponding nested type definitions.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddParameter">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.ParameterHandle AddParameter (System.Reflection.ParameterAttributes attributes, System.Reflection.Metadata.StringHandle name, int sequenceNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.ParameterHandle AddParameter(valuetype System.Reflection.ParameterAttributes attributes, valuetype System.Reflection.Metadata.StringHandle name, int32 sequenceNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddParameter(System.Reflection.ParameterAttributes,System.Reflection.Metadata.StringHandle,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddParameter (attributes As ParameterAttributes, name As StringHandle, sequenceNumber As Integer) As ParameterHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::ParameterHandle AddParameter(System::Reflection::ParameterAttributes attributes, System::Reflection::Metadata::StringHandle name, int sequenceNumber);" />
      <MemberSignature Language="F#" Value="member this.AddParameter : System.Reflection.ParameterAttributes * System.Reflection.Metadata.StringHandle * int -&gt; System.Reflection.Metadata.ParameterHandle" Usage="metadataBuilder.AddParameter (attributes, name, sequenceNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.ParameterHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.ParameterAttributes" />
        <Parameter Name="name" Type="System.Reflection.Metadata.StringHandle" />
        <Parameter Name="sequenceNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="attributes">The parameter attributes.</param>
        <param name="name">Optional. The parameter name.</param>
        <param name="sequenceNumber">The sequence number of the parameter. A value of 0 refers to the owner method's return type; its parameters are then numbered from 1 onward.</param>
        <summary>Adds a parameter definition.</summary>
        <returns>A handle to the added parameter.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sequenceNumber" /> is greater than <see cref="F:System.UInt16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.PropertyDefinitionHandle AddProperty (System.Reflection.PropertyAttributes attributes, System.Reflection.Metadata.StringHandle name, System.Reflection.Metadata.BlobHandle signature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.PropertyDefinitionHandle AddProperty(valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.Metadata.StringHandle name, valuetype System.Reflection.Metadata.BlobHandle signature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddProperty(System.Reflection.PropertyAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.BlobHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddProperty (attributes As PropertyAttributes, name As StringHandle, signature As BlobHandle) As PropertyDefinitionHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::PropertyDefinitionHandle AddProperty(System::Reflection::PropertyAttributes attributes, System::Reflection::Metadata::StringHandle name, System::Reflection::Metadata::BlobHandle signature);" />
      <MemberSignature Language="F#" Value="member this.AddProperty : System.Reflection.PropertyAttributes * System.Reflection.Metadata.StringHandle * System.Reflection.Metadata.BlobHandle -&gt; System.Reflection.Metadata.PropertyDefinitionHandle" Usage="metadataBuilder.AddProperty (attributes, name, signature)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.PropertyDefinitionHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="name" Type="System.Reflection.Metadata.StringHandle" />
        <Parameter Name="signature" Type="System.Reflection.Metadata.BlobHandle" />
      </Parameters>
      <Docs>
        <param name="attributes">The property attributes.</param>
        <param name="name">The property name.</param>
        <param name="signature">The signature of the property.</param>
        <summary>Adds a property definition.</summary>
        <returns>A handle to the added property definition.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddPropertyMap">
      <MemberSignature Language="C#" Value="public void AddPropertyMap (System.Reflection.Metadata.TypeDefinitionHandle declaringType, System.Reflection.Metadata.PropertyDefinitionHandle propertyList);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddPropertyMap(valuetype System.Reflection.Metadata.TypeDefinitionHandle declaringType, valuetype System.Reflection.Metadata.PropertyDefinitionHandle propertyList) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddPropertyMap(System.Reflection.Metadata.TypeDefinitionHandle,System.Reflection.Metadata.PropertyDefinitionHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddPropertyMap (declaringType As TypeDefinitionHandle, propertyList As PropertyDefinitionHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddPropertyMap(System::Reflection::Metadata::TypeDefinitionHandle declaringType, System::Reflection::Metadata::PropertyDefinitionHandle propertyList);" />
      <MemberSignature Language="F#" Value="member this.AddPropertyMap : System.Reflection.Metadata.TypeDefinitionHandle * System.Reflection.Metadata.PropertyDefinitionHandle -&gt; unit" Usage="metadataBuilder.AddPropertyMap (declaringType, propertyList)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="declaringType" Type="System.Reflection.Metadata.TypeDefinitionHandle" />
        <Parameter Name="propertyList" Type="System.Reflection.Metadata.PropertyDefinitionHandle" />
      </Parameters>
      <Docs>
        <param name="declaringType">To be added.</param>
        <param name="propertyList">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddStandaloneSignature">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.StandaloneSignatureHandle AddStandaloneSignature (System.Reflection.Metadata.BlobHandle signature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.StandaloneSignatureHandle AddStandaloneSignature(valuetype System.Reflection.Metadata.BlobHandle signature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStandaloneSignature(System.Reflection.Metadata.BlobHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddStandaloneSignature (signature As BlobHandle) As StandaloneSignatureHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::StandaloneSignatureHandle AddStandaloneSignature(System::Reflection::Metadata::BlobHandle signature);" />
      <MemberSignature Language="F#" Value="member this.AddStandaloneSignature : System.Reflection.Metadata.BlobHandle -&gt; System.Reflection.Metadata.StandaloneSignatureHandle" Usage="metadataBuilder.AddStandaloneSignature signature" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.StandaloneSignatureHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="signature" Type="System.Reflection.Metadata.BlobHandle" />
      </Parameters>
      <Docs>
        <param name="signature">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddStateMachineMethod">
      <MemberSignature Language="C#" Value="public void AddStateMachineMethod (System.Reflection.Metadata.MethodDefinitionHandle moveNextMethod, System.Reflection.Metadata.MethodDefinitionHandle kickoffMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddStateMachineMethod(valuetype System.Reflection.Metadata.MethodDefinitionHandle moveNextMethod, valuetype System.Reflection.Metadata.MethodDefinitionHandle kickoffMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddStateMachineMethod(System.Reflection.Metadata.MethodDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddStateMachineMethod (moveNextMethod As MethodDefinitionHandle, kickoffMethod As MethodDefinitionHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddStateMachineMethod(System::Reflection::Metadata::MethodDefinitionHandle moveNextMethod, System::Reflection::Metadata::MethodDefinitionHandle kickoffMethod);" />
      <MemberSignature Language="F#" Value="member this.AddStateMachineMethod : System.Reflection.Metadata.MethodDefinitionHandle * System.Reflection.Metadata.MethodDefinitionHandle -&gt; unit" Usage="metadataBuilder.AddStateMachineMethod (moveNextMethod, kickoffMethod)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moveNextMethod" Type="System.Reflection.Metadata.MethodDefinitionHandle" />
        <Parameter Name="kickoffMethod" Type="System.Reflection.Metadata.MethodDefinitionHandle" />
      </Parameters>
      <Docs>
        <param name="moveNextMethod">The handle of the <see langword="MoveNext" /> method of the state machine (the compiler-generated method).</param>
        <param name="kickoffMethod">The handle of the kickoff method (the user defined iterator/async method).</param>
        <summary>Adds state machine method debug information.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Entries should be added in the same order as the corresponding `MoveNext` method definitions.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddTypeDefinition">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.TypeDefinitionHandle AddTypeDefinition (System.Reflection.TypeAttributes attributes, System.Reflection.Metadata.StringHandle namespace, System.Reflection.Metadata.StringHandle name, System.Reflection.Metadata.EntityHandle baseType, System.Reflection.Metadata.FieldDefinitionHandle fieldList, System.Reflection.Metadata.MethodDefinitionHandle methodList);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.TypeDefinitionHandle AddTypeDefinition(valuetype System.Reflection.TypeAttributes attributes, valuetype System.Reflection.Metadata.StringHandle namespace, valuetype System.Reflection.Metadata.StringHandle name, valuetype System.Reflection.Metadata.EntityHandle baseType, valuetype System.Reflection.Metadata.FieldDefinitionHandle fieldList, valuetype System.Reflection.Metadata.MethodDefinitionHandle methodList) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeDefinition(System.Reflection.TypeAttributes,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.FieldDefinitionHandle,System.Reflection.Metadata.MethodDefinitionHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddTypeDefinition (attributes As TypeAttributes, namespace As StringHandle, name As StringHandle, baseType As EntityHandle, fieldList As FieldDefinitionHandle, methodList As MethodDefinitionHandle) As TypeDefinitionHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::TypeDefinitionHandle AddTypeDefinition(System::Reflection::TypeAttributes attributes, System::Reflection::Metadata::StringHandle namespace, System::Reflection::Metadata::StringHandle name, System::Reflection::Metadata::EntityHandle baseType, System::Reflection::Metadata::FieldDefinitionHandle fieldList, System::Reflection::Metadata::MethodDefinitionHandle methodList);" />
      <MemberSignature Language="F#" Value="member this.AddTypeDefinition : System.Reflection.TypeAttributes * System.Reflection.Metadata.StringHandle * System.Reflection.Metadata.StringHandle * System.Reflection.Metadata.EntityHandle * System.Reflection.Metadata.FieldDefinitionHandle * System.Reflection.Metadata.MethodDefinitionHandle -&gt; System.Reflection.Metadata.TypeDefinitionHandle" Usage="metadataBuilder.AddTypeDefinition (attributes, namespace, name, baseType, fieldList, methodList)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.TypeDefinitionHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="namespace" Type="System.Reflection.Metadata.StringHandle" />
        <Parameter Name="name" Type="System.Reflection.Metadata.StringHandle" />
        <Parameter Name="baseType" Type="System.Reflection.Metadata.EntityHandle" />
        <Parameter Name="fieldList" Type="System.Reflection.Metadata.FieldDefinitionHandle" />
        <Parameter Name="methodList" Type="System.Reflection.Metadata.MethodDefinitionHandle" />
      </Parameters>
      <Docs>
        <param name="attributes">The type attributes.</param>
        <param name="namespace">The type namespace.</param>
        <param name="name">The type name.</param>
        <param name="baseType">The base type entity handle, which can be one of the following: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, or <see langword="null" />.</param>
        <param name="fieldList">If the type declares fields, set this to the handle of the first one. Otherwise, set this to the handle of the first field declared by the next type definition. If no type defines any fields in the module, <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(1)" />.</param>
        <param name="methodList">If the type declares methods, the handle of the first one. Otherwise, the handle of the first method declared by the next type definition. If no type defines any methods in the module, <see langword="System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(1)" />.</param>
        <summary>Adds a type definition.</summary>
        <returns>A handle to the added type definition.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="baseType" /> doesn't have the expected handle kind.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddTypeLayout">
      <MemberSignature Language="C#" Value="public void AddTypeLayout (System.Reflection.Metadata.TypeDefinitionHandle type, ushort packingSize, uint size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddTypeLayout(valuetype System.Reflection.Metadata.TypeDefinitionHandle type, unsigned int16 packingSize, unsigned int32 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeLayout(System.Reflection.Metadata.TypeDefinitionHandle,System.UInt16,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddTypeLayout (type As TypeDefinitionHandle, packingSize As UShort, size As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddTypeLayout(System::Reflection::Metadata::TypeDefinitionHandle type, System::UInt16 packingSize, System::UInt32 size);" />
      <MemberSignature Language="F#" Value="member this.AddTypeLayout : System.Reflection.Metadata.TypeDefinitionHandle * uint16 * uint32 -&gt; unit" Usage="metadataBuilder.AddTypeLayout (type, packingSize, size)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Reflection.Metadata.TypeDefinitionHandle" />
        <Parameter Name="packingSize" Type="System.UInt16" />
        <Parameter Name="size" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="type">The type definition.</param>
        <param name="packingSize">Specifies that fields should be placed within the type instance at byte addresses which are a multiple of <paramref name="packingSize" />, or at natural alignment for that field type, whichever is smaller. Its value should be one of the following: 0, 1, 2, 4, 8, 16, 32, 64, or 128. A value of zero indicates that the packing size used should match the default for the current platform.</param>
        <param name="size">Indicates a minimum size of the type instance and is intended to allow for padding. The amount of memory allocated is the maximum of the size calculated from the layout and <paramref name="size" />. Note that if this directive applies to a value type, then the size will be less than 1 MB.</param>
        <summary>Defines a type layout of a type definition.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Entires must be added in the same order as the corresponding type definitions.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddTypeReference">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.TypeReferenceHandle AddTypeReference (System.Reflection.Metadata.EntityHandle resolutionScope, System.Reflection.Metadata.StringHandle namespace, System.Reflection.Metadata.StringHandle name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.TypeReferenceHandle AddTypeReference(valuetype System.Reflection.Metadata.EntityHandle resolutionScope, valuetype System.Reflection.Metadata.StringHandle namespace, valuetype System.Reflection.Metadata.StringHandle name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeReference(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.StringHandle,System.Reflection.Metadata.StringHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddTypeReference (resolutionScope As EntityHandle, namespace As StringHandle, name As StringHandle) As TypeReferenceHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::TypeReferenceHandle AddTypeReference(System::Reflection::Metadata::EntityHandle resolutionScope, System::Reflection::Metadata::StringHandle namespace, System::Reflection::Metadata::StringHandle name);" />
      <MemberSignature Language="F#" Value="member this.AddTypeReference : System.Reflection.Metadata.EntityHandle * System.Reflection.Metadata.StringHandle * System.Reflection.Metadata.StringHandle -&gt; System.Reflection.Metadata.TypeReferenceHandle" Usage="metadataBuilder.AddTypeReference (resolutionScope, namespace, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.TypeReferenceHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resolutionScope" Type="System.Reflection.Metadata.EntityHandle" />
        <Parameter Name="namespace" Type="System.Reflection.Metadata.StringHandle" />
        <Parameter Name="name" Type="System.Reflection.Metadata.StringHandle" />
      </Parameters>
      <Docs>
        <param name="resolutionScope">The entity declaring the target type, which can be one of the following: <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, or <see langword="null" />.</param>
        <param name="namespace">The type reference namespace.</param>
        <param name="name">The type reference name.</param>
        <summary>Adds a type reference.</summary>
        <returns>A handle to the added type reference.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="resolutionScope" /> doesn't have the expected handle kind.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddTypeSpecification">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.TypeSpecificationHandle AddTypeSpecification (System.Reflection.Metadata.BlobHandle signature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.TypeSpecificationHandle AddTypeSpecification(valuetype System.Reflection.Metadata.BlobHandle signature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.AddTypeSpecification(System.Reflection.Metadata.BlobHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddTypeSpecification (signature As BlobHandle) As TypeSpecificationHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::TypeSpecificationHandle AddTypeSpecification(System::Reflection::Metadata::BlobHandle signature);" />
      <MemberSignature Language="F#" Value="member this.AddTypeSpecification : System.Reflection.Metadata.BlobHandle -&gt; System.Reflection.Metadata.TypeSpecificationHandle" Usage="metadataBuilder.AddTypeSpecification signature" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.TypeSpecificationHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="signature" Type="System.Reflection.Metadata.BlobHandle" />
      </Parameters>
      <Docs>
        <param name="signature">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrAddBlob">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.BlobHandle GetOrAddBlob (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.BlobHandle GetOrAddBlob(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrAddBlob (value As Byte()) As BlobHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::BlobHandle GetOrAddBlob(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="member this.GetOrAddBlob : byte[] -&gt; System.Reflection.Metadata.BlobHandle" Usage="metadataBuilder.GetOrAddBlob value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.BlobHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">The array containing the blob.</param>
        <summary>Adds the specified blob to the Blob heap, if it's not there already.</summary>
        <returns>A handle to the added or existing blob.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetOrAddBlob">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.BlobHandle GetOrAddBlob (System.Collections.Immutable.ImmutableArray&lt;byte&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.BlobHandle GetOrAddBlob(valuetype System.Collections.Immutable.ImmutableArray`1&lt;unsigned int8&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Collections.Immutable.ImmutableArray{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrAddBlob (value As ImmutableArray(Of Byte)) As BlobHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::BlobHandle GetOrAddBlob(System::Collections::Immutable::ImmutableArray&lt;System::Byte&gt; value);" />
      <MemberSignature Language="F#" Value="member this.GetOrAddBlob : System.Collections.Immutable.ImmutableArray&lt;byte&gt; -&gt; System.Reflection.Metadata.BlobHandle" Usage="metadataBuilder.GetOrAddBlob value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.BlobHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Collections.Immutable.ImmutableArray&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="value">The array containing the blob.</param>
        <summary>Adds the specified blob from a byte array to the Blob heap, if it's not there already.</summary>
        <returns>A handle to the added or existing blob.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetOrAddBlob">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.BlobHandle GetOrAddBlob (System.Reflection.Metadata.BlobBuilder value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.BlobHandle GetOrAddBlob(class System.Reflection.Metadata.BlobBuilder value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlob(System.Reflection.Metadata.BlobBuilder)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrAddBlob (value As BlobBuilder) As BlobHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::BlobHandle GetOrAddBlob(System::Reflection::Metadata::BlobBuilder ^ value);" />
      <MemberSignature Language="F#" Value="member this.GetOrAddBlob : System.Reflection.Metadata.BlobBuilder -&gt; System.Reflection.Metadata.BlobHandle" Usage="metadataBuilder.GetOrAddBlob value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.BlobHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Reflection.Metadata.BlobBuilder" />
      </Parameters>
      <Docs>
        <param name="value">The blob builder instance containing the blob.</param>
        <summary>Adds the specified blob from an immutable byte array to the Blob heap, if it's not there already.</summary>
        <returns>A handle to the added or existing blob.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetOrAddBlobUTF16">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.BlobHandle GetOrAddBlobUTF16 (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.BlobHandle GetOrAddBlobUTF16(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF16(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrAddBlobUTF16 (value As String) As BlobHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::BlobHandle GetOrAddBlobUTF16(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.GetOrAddBlobUTF16 : string -&gt; System.Reflection.Metadata.BlobHandle" Usage="metadataBuilder.GetOrAddBlobUTF16 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.BlobHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">The string to add.</param>
        <summary>Encodes a string using UTF16 encoding to a blob and adds it to the Blob heap, if it's not there already.</summary>
        <returns>A handle to the added or existing blob.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetOrAddBlobUTF8">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.BlobHandle GetOrAddBlobUTF8 (string value, bool allowUnpairedSurrogates = true);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.BlobHandle GetOrAddBlobUTF8(string value, bool allowUnpairedSurrogates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddBlobUTF8(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrAddBlobUTF8 (value As String, Optional allowUnpairedSurrogates As Boolean = true) As BlobHandle" />
      <MemberSignature Language="F#" Value="member this.GetOrAddBlobUTF8 : string * bool -&gt; System.Reflection.Metadata.BlobHandle" Usage="metadataBuilder.GetOrAddBlobUTF8 (value, allowUnpairedSurrogates)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.BlobHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="allowUnpairedSurrogates" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">The value to add.</param>
        <param name="allowUnpairedSurrogates">
          <see langword="true" /> to encode the unpaired surrogates as specified; <see langword="false" /> to replace them with the U+FFFD character.</param>
        <summary>Encodes a string using UTF8 encoding to a blob and adds it to the Blob heap, if it's not there already.</summary>
        <returns>A handle to the added or existing blob.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetOrAddConstantBlob">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.BlobHandle GetOrAddConstantBlob (object? value);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.BlobHandle GetOrAddConstantBlob(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddConstantBlob(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrAddConstantBlob (value As Object) As BlobHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::BlobHandle GetOrAddConstantBlob(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.GetOrAddConstantBlob : obj -&gt; System.Reflection.Metadata.BlobHandle" Usage="metadataBuilder.GetOrAddConstantBlob value" />
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.BlobHandle GetOrAddConstantBlob (object value);" FrameworkAlternate="netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.BlobHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The constant value to add.</param>
        <summary>Encodes a constant value to a blob and adds it to the Blob heap, if it's not there already. Uses UTF16 to encode string constants.</summary>
        <returns>A handle to the added or existing blob.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrAddDocumentName">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.BlobHandle GetOrAddDocumentName (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.BlobHandle GetOrAddDocumentName(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddDocumentName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrAddDocumentName (value As String) As BlobHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::BlobHandle GetOrAddDocumentName(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.GetOrAddDocumentName : string -&gt; System.Reflection.Metadata.BlobHandle" Usage="metadataBuilder.GetOrAddDocumentName value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.BlobHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">The document name to add.</param>
        <summary>Encodes a debug document name and adds it to the Blob heap, if it's not there already.</summary>
        <returns>A handle to the added or existing document name blob.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For more information about document name blobs, see: https://github.com/dotnet/runtime/blob/master/docs/design/specs/PortablePdb-Metadata.md#DocumentNameBlob

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetOrAddGuid">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.GuidHandle GetOrAddGuid (Guid guid);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.GuidHandle GetOrAddGuid(valuetype System.Guid guid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddGuid(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrAddGuid (guid As Guid) As GuidHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::GuidHandle GetOrAddGuid(Guid guid);" />
      <MemberSignature Language="F#" Value="member this.GetOrAddGuid : Guid -&gt; System.Reflection.Metadata.GuidHandle" Usage="metadataBuilder.GetOrAddGuid guid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.GuidHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="guid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="guid">The Guid to add.</param>
        <summary>Adds the specified Guid to the Guid heap, if it's not there already.</summary>
        <returns>A handle to the added or existing Guid.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrAddString">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.StringHandle GetOrAddString (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.StringHandle GetOrAddString(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrAddString (value As String) As StringHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::StringHandle GetOrAddString(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.GetOrAddString : string -&gt; System.Reflection.Metadata.StringHandle" Usage="metadataBuilder.GetOrAddString value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.StringHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">The string to add.</param>
        <summary>Adds the specified string to the string heap, if it's not there already.</summary>
        <returns>A handle to the added or existing string.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetOrAddUserString">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.UserStringHandle GetOrAddUserString (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.UserStringHandle GetOrAddUserString(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetOrAddUserString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOrAddUserString (value As String) As UserStringHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::UserStringHandle GetOrAddUserString(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.GetOrAddUserString : string -&gt; System.Reflection.Metadata.UserStringHandle" Usage="metadataBuilder.GetOrAddUserString value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.UserStringHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">The string to add.</param>
        <summary>Adds the specified string to the user string heap, if it's not there already.</summary>
        <returns>A handle to the added or existing string. This value may be used in <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">The remaining space on the heap is too small to fit the string.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> is <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRowCount">
      <MemberSignature Language="C#" Value="public int GetRowCount (System.Reflection.Metadata.Ecma335.TableIndex table);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetRowCount(valuetype System.Reflection.Metadata.Ecma335.TableIndex table) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCount(System.Reflection.Metadata.Ecma335.TableIndex)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRowCount (table As TableIndex) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetRowCount(System::Reflection::Metadata::Ecma335::TableIndex table);" />
      <MemberSignature Language="F#" Value="member this.GetRowCount : System.Reflection.Metadata.Ecma335.TableIndex -&gt; int" Usage="metadataBuilder.GetRowCount table" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Reflection.Metadata.Ecma335.TableIndex" />
      </Parameters>
      <Docs>
        <param name="table">The table index.</param>
        <summary>Returns the current number of items in the specified table.</summary>
        <returns>The number of items in the table.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="table" /> is not a valid table index.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRowCounts">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.ImmutableArray&lt;int&gt; GetRowCounts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Immutable.ImmutableArray`1&lt;int32&gt; GetRowCounts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.GetRowCounts" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRowCounts () As ImmutableArray(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::ImmutableArray&lt;int&gt; GetRowCounts();" />
      <MemberSignature Language="F#" Value="member this.GetRowCounts : unit -&gt; System.Collections.Immutable.ImmutableArray&lt;int&gt;" Usage="metadataBuilder.GetRowCounts " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.ImmutableArray&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the current number of items in each table.</summary>
        <returns>An array of size <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" />, with each item filled with the current row count of the corresponding table.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReserveGuid">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.ReservedBlob&lt;System.Reflection.Metadata.GuidHandle&gt; ReserveGuid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.ReservedBlob`1&lt;valuetype System.Reflection.Metadata.GuidHandle&gt; ReserveGuid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveGuid" />
      <MemberSignature Language="VB.NET" Value="Public Function ReserveGuid () As ReservedBlob(Of GuidHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::ReservedBlob&lt;System::Reflection::Metadata::GuidHandle&gt; ReserveGuid();" />
      <MemberSignature Language="F#" Value="member this.ReserveGuid : unit -&gt; System.Reflection.Metadata.ReservedBlob&lt;System.Reflection.Metadata.GuidHandle&gt;" Usage="metadataBuilder.ReserveGuid " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.ReservedBlob&lt;System.Reflection.Metadata.GuidHandle&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reserves space on the Guid heap for a GUID.</summary>
        <returns>A handle to the reserved Guid and a <see cref="T:System.Reflection.Metadata.Blob" /> representing the GUID blob as stored on the heap.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">The remaining space on the heap is too small to fit the string.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReserveUserString">
      <MemberSignature Language="C#" Value="public System.Reflection.Metadata.ReservedBlob&lt;System.Reflection.Metadata.UserStringHandle&gt; ReserveUserString (int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Reflection.Metadata.ReservedBlob`1&lt;valuetype System.Reflection.Metadata.UserStringHandle&gt; ReserveUserString(int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.ReserveUserString(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReserveUserString (length As Integer) As ReservedBlob(Of UserStringHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Metadata::ReservedBlob&lt;System::Reflection::Metadata::UserStringHandle&gt; ReserveUserString(int length);" />
      <MemberSignature Language="F#" Value="member this.ReserveUserString : int -&gt; System.Reflection.Metadata.ReservedBlob&lt;System.Reflection.Metadata.UserStringHandle&gt;" Usage="metadataBuilder.ReserveUserString length" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Metadata.ReservedBlob&lt;System.Reflection.Metadata.UserStringHandle&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="length">The number of characters to reserve.</param>
        <summary>Reserves space on the user string heap for a string of the specified length.</summary>
        <returns>A handle to the reserved user string and a <see cref="T:System.Reflection.Metadata.Blob" /> representing the entire User String blob (including its length and terminal character). The handle may be used in <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" />.
 Use <see cref="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)" /> to fill in the blob content.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">The remaining space on the heap is too small to fit the string.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> is negative.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCapacity">
      <MemberSignature Language="C#" Value="public void SetCapacity (System.Reflection.Metadata.Ecma335.HeapIndex heap, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCapacity(valuetype System.Reflection.Metadata.Ecma335.HeapIndex heap, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.HeapIndex,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCapacity (heap As HeapIndex, byteCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCapacity(System::Reflection::Metadata::Ecma335::HeapIndex heap, int byteCount);" />
      <MemberSignature Language="F#" Value="member this.SetCapacity : System.Reflection.Metadata.Ecma335.HeapIndex * int -&gt; unit" Usage="metadataBuilder.SetCapacity (heap, byteCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="heap" Type="System.Reflection.Metadata.Ecma335.HeapIndex" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="heap">The heap index.</param>
        <param name="byteCount">The number of bytes.</param>
        <summary>Sets the capacity of the specified heap.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Use this method to reduce allocations if the approximate number of bytes is known ahead of time.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="heap" /> is not a valid heap index.

-or-

<paramref name="byteCount" /> is negative.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCapacity">
      <MemberSignature Language="C#" Value="public void SetCapacity (System.Reflection.Metadata.Ecma335.TableIndex table, int rowCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCapacity(valuetype System.Reflection.Metadata.Ecma335.TableIndex table, int32 rowCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Metadata.Ecma335.MetadataBuilder.SetCapacity(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCapacity (table As TableIndex, rowCount As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCapacity(System::Reflection::Metadata::Ecma335::TableIndex table, int rowCount);" />
      <MemberSignature Language="F#" Value="member this.SetCapacity : System.Reflection.Metadata.Ecma335.TableIndex * int -&gt; unit" Usage="metadataBuilder.SetCapacity (table, rowCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Metadata</AssemblyName>
        <AssemblyVersion>1.4.1.0</AssemblyVersion>
        <AssemblyVersion>1.4.2.0</AssemblyVersion>
        <AssemblyVersion>1.4.3.0</AssemblyVersion>
        <AssemblyVersion>1.4.4.0</AssemblyVersion>
        <AssemblyVersion>1.4.5.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="table" Type="System.Reflection.Metadata.Ecma335.TableIndex" />
        <Parameter Name="rowCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="table">The table index.</param>
        <param name="rowCount">The number of rows in the table.</param>
        <summary>Sets the capacity of the specified table.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Use this method to reduce allocations if the approximate number of rows is known ahead of time.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="table" /> is not a valid table index.

-or-

<paramref name="rowCount" /> is negative.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
