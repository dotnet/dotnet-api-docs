<Type Name="Int64" FullName="System.Int64">
  <TypeSignature Language="C#" Value="public struct Int64 : IComparable, IComparable&lt;long&gt;, IConvertible, IEquatable&lt;long&gt;, IFormattable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit int64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;int64&gt;, class System.IConvertible, class System.IEquatable`1&lt;int64&gt;, class System.IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Int64" />
  <TypeSignature Language="VB.NET" Value="Public Structure Int64&#xA;Implements IComparable, IComparable(Of Long), IConvertible, IEquatable(Of Long), IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="F#" Value="type int64 = struct&#xA;    interface IConvertible&#xA;    interface IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="C++ CLI" Value="public value class long : IComparable, IComparable&lt;long&gt;, IConvertible, IEquatable&lt;long&gt;, IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="C#" Value="public readonly struct Int64 : IComparable, IComparable&lt;long&gt;, IConvertible, IEquatable&lt;long&gt;, IFormattable" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
  <TypeSignature Language="C#" Value="public readonly struct Int64 : IComparable, IComparable&lt;long&gt;, IConvertible, IEquatable&lt;long&gt;, ISpanFormattable" FrameworkAlternate="net-6.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit int64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;int64&gt;, class System.IConvertible, class System.IEquatable`1&lt;int64&gt;, class System.IFormattable, class System.ISpanFormattable" FrameworkAlternate="net-6.0" />
  <TypeSignature Language="VB.NET" Value="Public Structure Int64&#xA;Implements IComparable, IComparable(Of Long), IConvertible, IEquatable(Of Long), ISpanFormattable" FrameworkAlternate="net-6.0" />
  <TypeSignature Language="F#" Value="type int64 = struct&#xA;    interface IConvertible&#xA;    interface ISpanFormattable&#xA;    interface IFormattable" FrameworkAlternate="net-6.0" />
  <TypeSignature Language="C++ CLI" Value="public value class long : IComparable, IComparable&lt;long&gt;, IConvertible, IEquatable&lt;long&gt;, ISpanFormattable" FrameworkAlternate="net-6.0" />
  <TypeSignature Language="C#" Value="public readonly struct Int64 : IComparable&lt;long&gt;, IConvertible, IEquatable&lt;long&gt;, IParsable&lt;long&gt;, ISpanParsable&lt;long&gt;, System.Numerics.IAdditionOperators&lt;long,long,long&gt;, System.Numerics.IAdditiveIdentity&lt;long,long&gt;, System.Numerics.IBinaryInteger&lt;long&gt;, System.Numerics.IBinaryNumber&lt;long&gt;, System.Numerics.IBitwiseOperators&lt;long,long,long&gt;, System.Numerics.IComparisonOperators&lt;long,long,bool&gt;, System.Numerics.IDecrementOperators&lt;long&gt;, System.Numerics.IDivisionOperators&lt;long,long,long&gt;, System.Numerics.IEqualityOperators&lt;long,long,bool&gt;, System.Numerics.IIncrementOperators&lt;long&gt;, System.Numerics.IMinMaxValue&lt;long&gt;, System.Numerics.IModulusOperators&lt;long,long,long&gt;, System.Numerics.IMultiplicativeIdentity&lt;long,long&gt;, System.Numerics.IMultiplyOperators&lt;long,long,long&gt;, System.Numerics.INumber&lt;long&gt;, System.Numerics.INumberBase&lt;long&gt;, System.Numerics.IShiftOperators&lt;long,int,long&gt;, System.Numerics.ISignedNumber&lt;long&gt;, System.Numerics.ISubtractionOperators&lt;long,long,long&gt;, System.Numerics.IUnaryNegationOperators&lt;long,long&gt;, System.Numerics.IUnaryPlusOperators&lt;long,long&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit int64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;int64&gt;, class System.IConvertible, class System.IEquatable`1&lt;int64&gt;, class System.IFormattable, class System.IParsable`1&lt;int64&gt;, class System.ISpanFormattable, class System.ISpanParsable`1&lt;int64&gt;, class System.Numerics.IAdditionOperators`3&lt;int64, int64, int64&gt;, class System.Numerics.IAdditiveIdentity`2&lt;int64, int64&gt;, class System.Numerics.IBinaryInteger`1&lt;int64&gt;, class System.Numerics.IBinaryNumber`1&lt;int64&gt;, class System.Numerics.IBitwiseOperators`3&lt;int64, int64, int64&gt;, class System.Numerics.IComparisonOperators`3&lt;int64, int64, bool&gt;, class System.Numerics.IDecrementOperators`1&lt;int64&gt;, class System.Numerics.IDivisionOperators`3&lt;int64, int64, int64&gt;, class System.Numerics.IEqualityOperators`3&lt;int64, int64, bool&gt;, class System.Numerics.IIncrementOperators`1&lt;int64&gt;, class System.Numerics.IMinMaxValue`1&lt;int64&gt;, class System.Numerics.IModulusOperators`3&lt;int64, int64, int64&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;int64, int64&gt;, class System.Numerics.IMultiplyOperators`3&lt;int64, int64, int64&gt;, class System.Numerics.INumber`1&lt;int64&gt;, class System.Numerics.INumberBase`1&lt;int64&gt;, class System.Numerics.IShiftOperators`3&lt;int64, int32, int64&gt;, class System.Numerics.ISignedNumber`1&lt;int64&gt;, class System.Numerics.ISubtractionOperators`3&lt;int64, int64, int64&gt;, class System.Numerics.IUnaryNegationOperators`2&lt;int64, int64&gt;, class System.Numerics.IUnaryPlusOperators`2&lt;int64, int64&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="VB.NET" Value="Public Structure Int64&#xA;Implements IAdditionOperators(Of Long, Long, Long), IAdditiveIdentity(Of Long, Long), IBinaryInteger(Of Long), IBinaryNumber(Of Long), IBitwiseOperators(Of Long, Long, Long), IComparable(Of Long), IComparisonOperators(Of Long, Long, Boolean), IConvertible, IDecrementOperators(Of Long), IDivisionOperators(Of Long, Long, Long), IEqualityOperators(Of Long, Long, Boolean), IEquatable(Of Long), IIncrementOperators(Of Long), IMinMaxValue(Of Long), IModulusOperators(Of Long, Long, Long), IMultiplicativeIdentity(Of Long, Long), IMultiplyOperators(Of Long, Long, Long), INumber(Of Long), INumberBase(Of Long), IParsable(Of Long), IShiftOperators(Of Long, Integer, Long), ISignedNumber(Of Long), ISpanParsable(Of Long), ISubtractionOperators(Of Long, Long, Long), IUnaryNegationOperators(Of Long, Long), IUnaryPlusOperators(Of Long, Long)" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="F#" Value="type int64 = struct&#xA;    interface IConvertible&#xA;    interface IFormattable&#xA;    interface IParsable&lt;int64&gt;&#xA;    interface ISpanFormattable&#xA;    interface ISpanParsable&lt;int64&gt;&#xA;    interface IAdditionOperators&lt;int64, int64, int64&gt;&#xA;    interface IAdditiveIdentity&lt;int64, int64&gt;&#xA;    interface IBinaryInteger&lt;int64&gt;&#xA;    interface IBinaryNumber&lt;int64&gt;&#xA;    interface IBitwiseOperators&lt;int64, int64, int64&gt;&#xA;    interface IComparisonOperators&lt;int64, int64, bool&gt;&#xA;    interface IEqualityOperators&lt;int64, int64, bool&gt;&#xA;    interface IDecrementOperators&lt;int64&gt;&#xA;    interface IDivisionOperators&lt;int64, int64, int64&gt;&#xA;    interface IIncrementOperators&lt;int64&gt;&#xA;    interface IModulusOperators&lt;int64, int64, int64&gt;&#xA;    interface IMultiplicativeIdentity&lt;int64, int64&gt;&#xA;    interface IMultiplyOperators&lt;int64, int64, int64&gt;&#xA;    interface INumber&lt;int64&gt;&#xA;    interface INumberBase&lt;int64&gt;&#xA;    interface ISubtractionOperators&lt;int64, int64, int64&gt;&#xA;    interface IUnaryNegationOperators&lt;int64, int64&gt;&#xA;    interface IUnaryPlusOperators&lt;int64, int64&gt;&#xA;    interface IShiftOperators&lt;int64, int, int64&gt;&#xA;    interface IMinMaxValue&lt;int64&gt;&#xA;    interface ISignedNumber&lt;int64&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="C++ CLI" Value="public value class long : IComparable&lt;long&gt;, IConvertible, IEquatable&lt;long&gt;, IParsable&lt;long&gt;, ISpanParsable&lt;long&gt;, System::Numerics::IAdditionOperators&lt;long, long, long&gt;, System::Numerics::IAdditiveIdentity&lt;long, long&gt;, System::Numerics::IBinaryInteger&lt;long&gt;, System::Numerics::IBinaryNumber&lt;long&gt;, System::Numerics::IBitwiseOperators&lt;long, long, long&gt;, System::Numerics::IComparisonOperators&lt;long, long, bool&gt;, System::Numerics::IDecrementOperators&lt;long&gt;, System::Numerics::IDivisionOperators&lt;long, long, long&gt;, System::Numerics::IEqualityOperators&lt;long, long, bool&gt;, System::Numerics::IIncrementOperators&lt;long&gt;, System::Numerics::IMinMaxValue&lt;long&gt;, System::Numerics::IModulusOperators&lt;long, long, long&gt;, System::Numerics::IMultiplicativeIdentity&lt;long, long&gt;, System::Numerics::IMultiplyOperators&lt;long, long, long&gt;, System::Numerics::INumber&lt;long&gt;, System::Numerics::INumberBase&lt;long&gt;, System::Numerics::IShiftOperators&lt;long, int, long&gt;, System::Numerics::ISignedNumber&lt;long&gt;, System::Numerics::ISubtractionOperators&lt;long, long, long&gt;, System::Numerics::IUnaryNegationOperators&lt;long, long&gt;, System::Numerics::IUnaryPlusOperators&lt;long, long&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="C#" Value="public readonly struct Int64 : IComparable&lt;long&gt;, IConvertible, IEquatable&lt;long&gt;, IParsable&lt;long&gt;, ISpanParsable&lt;long&gt;, IUtf8SpanParsable&lt;long&gt;, System.Numerics.IAdditionOperators&lt;long,long,long&gt;, System.Numerics.IAdditiveIdentity&lt;long,long&gt;, System.Numerics.IBinaryInteger&lt;long&gt;, System.Numerics.IBinaryNumber&lt;long&gt;, System.Numerics.IBitwiseOperators&lt;long,long,long&gt;, System.Numerics.IComparisonOperators&lt;long,long,bool&gt;, System.Numerics.IDecrementOperators&lt;long&gt;, System.Numerics.IDivisionOperators&lt;long,long,long&gt;, System.Numerics.IEqualityOperators&lt;long,long,bool&gt;, System.Numerics.IIncrementOperators&lt;long&gt;, System.Numerics.IMinMaxValue&lt;long&gt;, System.Numerics.IModulusOperators&lt;long,long,long&gt;, System.Numerics.IMultiplicativeIdentity&lt;long,long&gt;, System.Numerics.IMultiplyOperators&lt;long,long,long&gt;, System.Numerics.INumber&lt;long&gt;, System.Numerics.INumberBase&lt;long&gt;, System.Numerics.IShiftOperators&lt;long,int,long&gt;, System.Numerics.ISignedNumber&lt;long&gt;, System.Numerics.ISubtractionOperators&lt;long,long,long&gt;, System.Numerics.IUnaryNegationOperators&lt;long,long&gt;, System.Numerics.IUnaryPlusOperators&lt;long,long&gt;" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit int64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;int64&gt;, class System.IConvertible, class System.IEquatable`1&lt;int64&gt;, class System.IFormattable, class System.IParsable`1&lt;int64&gt;, class System.ISpanFormattable, class System.ISpanParsable`1&lt;int64&gt;, class System.IUtf8SpanFormattable, class System.IUtf8SpanParsable`1&lt;int64&gt;, class System.Numerics.IAdditionOperators`3&lt;int64, int64, int64&gt;, class System.Numerics.IAdditiveIdentity`2&lt;int64, int64&gt;, class System.Numerics.IBinaryInteger`1&lt;int64&gt;, class System.Numerics.IBinaryNumber`1&lt;int64&gt;, class System.Numerics.IBitwiseOperators`3&lt;int64, int64, int64&gt;, class System.Numerics.IComparisonOperators`3&lt;int64, int64, bool&gt;, class System.Numerics.IDecrementOperators`1&lt;int64&gt;, class System.Numerics.IDivisionOperators`3&lt;int64, int64, int64&gt;, class System.Numerics.IEqualityOperators`3&lt;int64, int64, bool&gt;, class System.Numerics.IIncrementOperators`1&lt;int64&gt;, class System.Numerics.IMinMaxValue`1&lt;int64&gt;, class System.Numerics.IModulusOperators`3&lt;int64, int64, int64&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;int64, int64&gt;, class System.Numerics.IMultiplyOperators`3&lt;int64, int64, int64&gt;, class System.Numerics.INumber`1&lt;int64&gt;, class System.Numerics.INumberBase`1&lt;int64&gt;, class System.Numerics.IShiftOperators`3&lt;int64, int32, int64&gt;, class System.Numerics.ISignedNumber`1&lt;int64&gt;, class System.Numerics.ISubtractionOperators`3&lt;int64, int64, int64&gt;, class System.Numerics.IUnaryNegationOperators`2&lt;int64, int64&gt;, class System.Numerics.IUnaryPlusOperators`2&lt;int64, int64&gt;" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="VB.NET" Value="Public Structure Int64&#xA;Implements IAdditionOperators(Of Long, Long, Long), IAdditiveIdentity(Of Long, Long), IBinaryInteger(Of Long), IBinaryNumber(Of Long), IBitwiseOperators(Of Long, Long, Long), IComparable(Of Long), IComparisonOperators(Of Long, Long, Boolean), IConvertible, IDecrementOperators(Of Long), IDivisionOperators(Of Long, Long, Long), IEqualityOperators(Of Long, Long, Boolean), IEquatable(Of Long), IIncrementOperators(Of Long), IMinMaxValue(Of Long), IModulusOperators(Of Long, Long, Long), IMultiplicativeIdentity(Of Long, Long), IMultiplyOperators(Of Long, Long, Long), INumber(Of Long), INumberBase(Of Long), IParsable(Of Long), IShiftOperators(Of Long, Integer, Long), ISignedNumber(Of Long), ISpanParsable(Of Long), ISubtractionOperators(Of Long, Long, Long), IUnaryNegationOperators(Of Long, Long), IUnaryPlusOperators(Of Long, Long), IUtf8SpanParsable(Of Long)" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="F#" Value="type int64 = struct&#xA;    interface IConvertible&#xA;    interface IFormattable&#xA;    interface IParsable&lt;int64&gt;&#xA;    interface ISpanFormattable&#xA;    interface ISpanParsable&lt;int64&gt;&#xA;    interface IAdditionOperators&lt;int64, int64, int64&gt;&#xA;    interface IAdditiveIdentity&lt;int64, int64&gt;&#xA;    interface IBinaryInteger&lt;int64&gt;&#xA;    interface IBinaryNumber&lt;int64&gt;&#xA;    interface IBitwiseOperators&lt;int64, int64, int64&gt;&#xA;    interface IComparisonOperators&lt;int64, int64, bool&gt;&#xA;    interface IEqualityOperators&lt;int64, int64, bool&gt;&#xA;    interface IDecrementOperators&lt;int64&gt;&#xA;    interface IDivisionOperators&lt;int64, int64, int64&gt;&#xA;    interface IIncrementOperators&lt;int64&gt;&#xA;    interface IModulusOperators&lt;int64, int64, int64&gt;&#xA;    interface IMultiplicativeIdentity&lt;int64, int64&gt;&#xA;    interface IMultiplyOperators&lt;int64, int64, int64&gt;&#xA;    interface INumber&lt;int64&gt;&#xA;    interface INumberBase&lt;int64&gt;&#xA;    interface ISubtractionOperators&lt;int64, int64, int64&gt;&#xA;    interface IUnaryNegationOperators&lt;int64, int64&gt;&#xA;    interface IUnaryPlusOperators&lt;int64, int64&gt;&#xA;    interface IUtf8SpanFormattable&#xA;    interface IUtf8SpanParsable&lt;int64&gt;&#xA;    interface IShiftOperators&lt;int64, int, int64&gt;&#xA;    interface IMinMaxValue&lt;int64&gt;&#xA;    interface ISignedNumber&lt;int64&gt;" FrameworkAlternate="net-8.0" />
  <TypeSignature Language="C++ CLI" Value="public value class long : IComparable&lt;long&gt;, IConvertible, IEquatable&lt;long&gt;, IParsable&lt;long&gt;, ISpanParsable&lt;long&gt;, IUtf8SpanParsable&lt;long&gt;, System::Numerics::IAdditionOperators&lt;long, long, long&gt;, System::Numerics::IAdditiveIdentity&lt;long, long&gt;, System::Numerics::IBinaryInteger&lt;long&gt;, System::Numerics::IBinaryNumber&lt;long&gt;, System::Numerics::IBitwiseOperators&lt;long, long, long&gt;, System::Numerics::IComparisonOperators&lt;long, long, bool&gt;, System::Numerics::IDecrementOperators&lt;long&gt;, System::Numerics::IDivisionOperators&lt;long, long, long&gt;, System::Numerics::IEqualityOperators&lt;long, long, bool&gt;, System::Numerics::IIncrementOperators&lt;long&gt;, System::Numerics::IMinMaxValue&lt;long&gt;, System::Numerics::IModulusOperators&lt;long, long, long&gt;, System::Numerics::IMultiplicativeIdentity&lt;long, long&gt;, System::Numerics::IMultiplyOperators&lt;long, long, long&gt;, System::Numerics::INumber&lt;long&gt;, System::Numerics::INumberBase&lt;long&gt;, System::Numerics::IShiftOperators&lt;long, int, long&gt;, System::Numerics::ISignedNumber&lt;long&gt;, System::Numerics::ISubtractionOperators&lt;long, long, long&gt;, System::Numerics::IUnaryNegationOperators&lt;long, long&gt;, System::Numerics::IUnaryPlusOperators&lt;long, long&gt;" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="F#" Value="type int64 = struct&#xA;    interface IConvertible&#xA;    interface IFormattable&#xA;    interface IParsable&lt;int64&gt;&#xA;    interface ISpanFormattable&#xA;    interface ISpanParsable&lt;int64&gt;&#xA;    interface IUtf8SpanFormattable&#xA;    interface IUtf8SpanParsable&lt;int64&gt;&#xA;    interface IAdditionOperators&lt;int64, int64, int64&gt;&#xA;    interface IAdditiveIdentity&lt;int64, int64&gt;&#xA;    interface IBinaryInteger&lt;int64&gt;&#xA;    interface IBinaryNumber&lt;int64&gt;&#xA;    interface IBitwiseOperators&lt;int64, int64, int64&gt;&#xA;    interface IComparisonOperators&lt;int64, int64, bool&gt;&#xA;    interface IEqualityOperators&lt;int64, int64, bool&gt;&#xA;    interface IDecrementOperators&lt;int64&gt;&#xA;    interface IDivisionOperators&lt;int64, int64, int64&gt;&#xA;    interface IIncrementOperators&lt;int64&gt;&#xA;    interface IModulusOperators&lt;int64, int64, int64&gt;&#xA;    interface IMultiplicativeIdentity&lt;int64, int64&gt;&#xA;    interface IMultiplyOperators&lt;int64, int64, int64&gt;&#xA;    interface INumber&lt;int64&gt;&#xA;    interface INumberBase&lt;int64&gt;&#xA;    interface ISubtractionOperators&lt;int64, int64, int64&gt;&#xA;    interface IUnaryNegationOperators&lt;int64, int64&gt;&#xA;    interface IUnaryPlusOperators&lt;int64, int64&gt;&#xA;    interface IShiftOperators&lt;int64, int, int64&gt;&#xA;    interface IMinMaxValue&lt;int64&gt;&#xA;    interface ISignedNumber&lt;int64&gt;" FrameworkAlternate="net-9.0" />
  <TypeSignature Language="C#" Value="public struct Int64 : IComparable, IConvertible, IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit int64 extends System.ValueType implements class System.IComparable, class System.IConvertible, class System.IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="VB.NET" Value="Public Structure Int64&#xA;Implements IComparable, IConvertible, IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="F#" Value="type int64 = struct&#xA;    interface IFormattable&#xA;    interface IConvertible" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1" />
  <TypeSignature Language="C++ CLI" Value="public value class long : IComparable, IConvertible, IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit int64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;int64&gt;, class System.IConvertible, class System.IEquatable`1&lt;int64&gt;, class System.IFormattable" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1" />
  <TypeSignature Language="C#" Value="public struct Int64 : IComparable, IComparable&lt;long&gt;, IEquatable&lt;long&gt;, IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit int64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;int64&gt;, class System.IEquatable`1&lt;int64&gt;, class System.IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="VB.NET" Value="Public Structure Int64&#xA;Implements IComparable, IComparable(Of Long), IEquatable(Of Long), IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="F#" Value="type int64 = struct&#xA;    interface IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="C++ CLI" Value="public value class long : IComparable, IComparable&lt;long&gt;, IEquatable&lt;long&gt;, IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>9.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="6.0.0.0" FrameworkAlternate="net-6.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="7.0.0.0" FrameworkAlternate="net-7.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="8.0.0.0" FrameworkAlternate="net-8.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="9.0.0.0" FrameworkAlternate="net-9.0" />
    <TypeForwarding From="System.Runtime" FromVersion="4.1.1.1" To="mscorlib" ToVersion="4.0.0.0" FrameworkAlternate="netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1">
      <InterfaceName>System.IComparable&lt;System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1">
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1">
      <InterfaceName>System.IEquatable&lt;System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.ISpanFormattable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.IComparable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.IEquatable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.IParsable&lt;System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.IParsable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.ISpanParsable&lt;System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.ISpanParsable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IAdditionOperators&lt;System.Int64,System.Int64,System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IAdditionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IAdditiveIdentity&lt;System.Int64,System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IAdditiveIdentity&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IBinaryInteger&lt;System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IBinaryNumber&lt;System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IBinaryNumber&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IBitwiseOperators&lt;System.Int64,System.Int64,System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IBitwiseOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IComparisonOperators&lt;System.Int64,System.Int64,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IComparisonOperators&lt;TSelf,TSelf,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IDecrementOperators&lt;System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IDecrementOperators&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IDivisionOperators&lt;System.Int64,System.Int64,System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IDivisionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IEqualityOperators&lt;System.Int64,System.Int64,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IEqualityOperators&lt;TSelf,TOther,TResult&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IEqualityOperators&lt;TSelf,TSelf,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IIncrementOperators&lt;System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IIncrementOperators&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IMinMaxValue&lt;System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IModulusOperators&lt;System.Int64,System.Int64,System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IModulusOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;System.Int64,System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IMultiplyOperators&lt;System.Int64,System.Int64,System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IMultiplyOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.INumber&lt;System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.INumber&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.INumberBase&lt;System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.INumberBase&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IShiftOperators&lt;System.Int64,System.Int32,System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IShiftOperators&lt;TSelf,System.Int32,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.ISignedNumber&lt;System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.ISubtractionOperators&lt;System.Int64,System.Int64,System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.ISubtractionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IUnaryNegationOperators&lt;System.Int64,System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IUnaryNegationOperators&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IUnaryPlusOperators&lt;System.Int64,System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IUnaryPlusOperators&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-8.0;net-9.0">
      <InterfaceName>System.IUtf8SpanFormattable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-8.0;net-9.0">
      <InterfaceName>System.IUtf8SpanParsable&lt;System.Int64&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-8.0;net-9.0">
      <InterfaceName>System.IUtf8SpanParsable&lt;TSelf&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1;netstandard-2.1">
      <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a 64-bit signed integer.</summary>
    <remarks>For more information about this API, see <see href="/dotnet/fundamentals/runtime-libraries/system-int64">Supplemental API remarks for Int64</see>.</remarks>
    <threadsafe>All members of this type are thread safe. Members that appear to modify instance state actually return a new instance initialized with the new value. As with any other type, reading and writing to a shared variable that contains an instance of this type must be protected by a lock to guarantee thread safety.</threadsafe>
    <altmember cref="T:System.UInt64" />
    <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/windowsforms-formatting-utility-cs/">Sample: .NET Core WinForms Formatting Utility (C#)</related>
    <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/windowsforms-formatting-utility-vb/">Sample: .NET Core WinForms Formatting Utility (Visual Basic)</related>
  </Docs>
  <Members>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static long Abs (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Abs(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.Abs(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Long) As Long" />
      <MemberSignature Language="F#" Value="static member Abs : int64 -&gt; int64" Usage="System.int64.Abs value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Abs(long value) = System::Numerics::INumberBase&lt;long&gt;::Abs;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.Abs(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value for which to get its absolute.</param>
        <summary>Computes the absolute of a value.</summary>
        <returns>The absolute of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.Abs(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static long Clamp (long value, long min, long max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Clamp(int64 value, int64 min, int64 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.Clamp(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Long, min As Long, max As Long) As Long" />
      <MemberSignature Language="F#" Value="static member Clamp : int64 * int64 * int64 -&gt; int64" Usage="System.int64.Clamp (value, min, max)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Clamp(long value, long min, long max) = System::Numerics::INumber&lt;long&gt;::Clamp;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.Clamp(`0,`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="min" Type="System.Int64" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="max" Type="System.Int64" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to clamp.</param>
        <param name="min">The inclusive minimum to which <paramref name="value" /> should clamp.</param>
        <param name="max">The inclusive maximum to which <paramref name="value" /> should clamp.</param>
        <summary>Clamps a value to an inclusive minimum and maximum value.</summary>
        <returns>The result of clamping <paramref name="value" /> to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumber`1.Clamp(`0,`0,`0)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compares this instance to a specified object or <see cref="T:System.Int64" /> and returns an indication of their relative values.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.CompareTo(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Long) As Integer" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : int64 -&gt; int&#xA;override this.CompareTo : int64 -&gt; int" Usage="int64.CompareTo value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(long value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">An integer to compare.</param>
        <summary>Compares this instance to a specified 64-bit signed integer and returns an indication of their relative values.</summary>
        <returns>A signed number indicating the relative values of this instance and <paramref name="value" />.

 <list type="table"><listheader><term> Return Value

 </term><description> Description

 </description></listheader><item><term> Less than zero

 </term><description> This instance is less than <paramref name="value" />.

 </description></item><item><term> Zero

 </term><description> This instance is equal to <paramref name="value" />.

 </description></item><item><term> Greater than zero

 </term><description> This instance is greater than <paramref name="value" />.

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This method implements the <xref:System.IComparable%601?displayProperty=nameWithType> interface and performs slightly better than the <xref:System.Int64.CompareTo%2A?displayProperty=nameWithType> method because it does not have to convert the `value` parameter to an object.

 Depending on your programming language, it might be possible to code a <xref:System.Int64.CompareTo%2A> method where the parameter type has fewer bits (is narrower) than the instance type. This is possible because some programming languages perform an implicit widening conversion that represents the parameter as a type with as many bits as the instance.

 For example, suppose the instance type is <xref:System.Int32> and the parameter type is <xref:System.Byte>. The Microsoft C# compiler generates instructions to represent the value of the parameter as an <xref:System.Int32> object, then generates a <xref:System.Int32.CompareTo%2A?displayProperty=nameWithType> method that compares the values of the <xref:System.Int32> instance and the <xref:System.Int32> parameter representation.

 Consult your programming language's documentation to determine whether its compiler performs implicit widening conversions on numeric types.



## Examples
 The following code example demonstrates generic and nongeneric versions of the <xref:System.Int64.CompareTo%2A> method for several value and reference types.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp" id="Snippet1":::
 :::code language="csharp" source="~/snippets/csharp/System/Boolean/CompareTo/cat.cs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.UInt64" />
        <altmember cref="M:System.Int64.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object? value);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="int64.CompareTo value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-2.0;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;netframework-4.8.1;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">An object to compare, or <see langword="null" />.</param>
        <summary>Compares this instance to a specified object and returns an indication of their relative values.</summary>
        <returns>A signed number indicating the relative values of this instance and <paramref name="value" />.

 <list type="table"><listheader><term> Return Value

 </term><description> Description

 </description></listheader><item><term> Less than zero

 </term><description> This instance is less than <paramref name="value" />.

 </description></item><item><term> Zero

 </term><description> This instance is equal to <paramref name="value" />.

 </description></item><item><term> Greater than zero

 </term><description> This instance is greater than <paramref name="value" />, or <paramref name="value" /> is <see langword="null" />.

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 An <xref:System.Int64>, regardless of its value, is considered greater than a null reference.

 The `value` parameter must be `null` or an instance of <xref:System.Int64>; otherwise, an exception is thrown.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> is not an <see cref="T:System.Int64" />.</exception>
        <altmember cref="T:System.UInt64" />
        <altmember cref="M:System.Int64.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CopySign">
      <MemberSignature Language="C#" Value="public static long CopySign (long value, long sign);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 CopySign(int64 value, int64 sign) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.CopySign(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CopySign (value As Long, sign As Long) As Long" />
      <MemberSignature Language="F#" Value="static member CopySign : int64 * int64 -&gt; int64" Usage="System.int64.CopySign (value, sign)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long CopySign(long value, long sign) = System::Numerics::INumber&lt;long&gt;::CopySign;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.CopySign(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="sign" Type="System.Int64" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value whose magnitude is used in the result.</param>
        <param name="sign">The value whose sign is used in the result.</param>
        <summary>Copies the sign of a value to the sign of another value.</summary>
        <returns>A value with the magnitude of <paramref name="value" /> and the sign of <paramref name="sign" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumber`1.CopySign(`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="CreateChecked&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="public static long CreateChecked&lt;TOther&gt; (TOther value) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 CreateChecked&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.CreateChecked``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateChecked(Of TOther As INumberBase(Of TOther)) (value As TOther) As Long" />
      <MemberSignature Language="F#" Value="static member CreateChecked : 'Other -&gt; int64 (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.int64.CreateChecked value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static long CreateChecked(TOther value) = System::Numerics::INumberBase&lt;long&gt;::CreateChecked;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.CreateChecked``1(``0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type of <paramref name="value" />.</typeparam>
        <param name="value">The value that's used to create the instance of <typeparamref name="TSelf" />.</param>
        <summary>Creates an instance of the current type from a value, throwing an overflow exception for any values that fall outside the representable range of the current type.</summary>
        <returns>An instance of <typeparamref name="TSelf" /> created from <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.CreateChecked``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSaturating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="public static long CreateSaturating&lt;TOther&gt; (TOther value) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 CreateSaturating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.CreateSaturating``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSaturating(Of TOther As INumberBase(Of TOther)) (value As TOther) As Long" />
      <MemberSignature Language="F#" Value="static member CreateSaturating : 'Other -&gt; int64 (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.int64.CreateSaturating value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static long CreateSaturating(TOther value) = System::Numerics::INumberBase&lt;long&gt;::CreateSaturating;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.CreateSaturating``1(``0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type of <paramref name="value" />.</typeparam>
        <param name="value">The value that's used to create the instance of <typeparamref name="TSelf" />.</param>
        <summary>Creates an instance of the current type from a value, saturating any values that fall outside the representable range of the current type.</summary>
        <returns>An instance of <typeparamref name="TSelf" /> created from <paramref name="value" />, saturating if <paramref name="value" /> falls outside the representable range of <typeparamref name="TSelf" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.CreateSaturating``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="CreateTruncating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="public static long CreateTruncating&lt;TOther&gt; (TOther value) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 CreateTruncating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.CreateTruncating``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateTruncating(Of TOther As INumberBase(Of TOther)) (value As TOther) As Long" />
      <MemberSignature Language="F#" Value="static member CreateTruncating : 'Other -&gt; int64 (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.int64.CreateTruncating value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static long CreateTruncating(TOther value) = System::Numerics::INumberBase&lt;long&gt;::CreateTruncating;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.CreateTruncating``1(``0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type of <paramref name="value" />.</typeparam>
        <param name="value">The value that's used to create the instance of <typeparamref name="TSelf" />.</param>
        <summary>Creates an instance of the current type from a value, truncating any values that fall outside the representable range of the current type.</summary>
        <returns>An instance of <typeparamref name="TSelf" /> created from <paramref name="value" />, truncating if <paramref name="value" /> falls outside the representable range of <typeparamref name="TSelf" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.CreateTruncating``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static (long Quotient, long Remainder) DivRem (long left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;int64, int64&gt; DivRem(int64 left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.DivRem(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (left As Long, right As Long) As ValueTuple(Of Long, Long)" />
      <MemberSignature Language="F#" Value="static member DivRem : int64 * int64 -&gt; ValueTuple&lt;int64, int64&gt;" Usage="System.int64.DivRem (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ValueTuple&lt;long, long&gt; DivRem(long left, long right) = System::Numerics::IBinaryInteger&lt;long&gt;::DivRem;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.DivRem(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;System.Int64,System.Int64&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-7.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Quotient", "Remainder" })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Quotient", "Remainder" })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Int64" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value which <paramref name="right" /> divides.</param>
        <param name="right">The value which divides <paramref name="left" />.</param>
        <summary>Computes the quotient and remainder of two values.</summary>
        <returns>The quotient and remainder of <paramref name="left" /> divided-by <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.DivRem(`0,`0)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a value indicating whether this instance is equal to a specified object or <see cref="T:System.Int64" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (long obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(int64 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.Equals(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Long) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Equals : int64 -&gt; bool" Usage="int64.Equals obj" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(long obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Int64" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj">An <see cref="T:System.Int64" /> value to compare to this instance.</param>
        <summary>Returns a value indicating whether this instance is equal to a specified <see cref="T:System.Int64" /> value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="obj" /> has the same value as this instance; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This method implements the <xref:System.IEquatable%601?displayProperty=nameWithType> interface, and performs slightly better than <xref:System.Int64.Equals%2A> because it does not have to convert the `obj` parameter to an object.

 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Compiler overload resolution may account for an apparent difference in the behavior of the two <see cref="M:System.Int64.Equals(System.Int64)" /> method overloads. If an implicit conversion between the <paramref name="obj" /> argument and an <see cref="T:System.Int64" /> is defined and the argument is not typed as an <see cref="T:System.Object" />, compilers perform an implicit conversion and call the <see cref="M:System.Int64.Equals(System.Int64)" /> method. Otherwise, they call the <see cref="M:System.Int64.Equals(System.Object)" /> method, which always returns <see langword="false" /> if its <paramref name="obj" /> argument is not an <see cref="T:System.Int64" /> value. The following example illustrates the difference in behavior between the two method overloads. In the case of the <see cref="T:System.Byte" />, <see cref="T:System.SByte" />, <see cref="T:System.Int16" />, <see cref="T:System.UInt16" />, <see cref="T:System.Int32" />, and <see cref="T:System.UInt32" /> values, the first comparison returns <see langword="true" /> because the compiler automatically performs a widening conversion and calls the <see cref="M:System.Int64.Equals(System.Int64)" /> method, whereas the second comparison returns <see langword="false" /> because the compiler calls the <see cref="M:System.Int64.Equals(System.Object)" /> method.

 :::code language="csharp" source="~/snippets/csharp/System/Int64/Equals/equalsoverl.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.int64.equals/fs/equalsoverl.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.int64.equals/vb/equalsoverl.vb" id="Snippet1":::</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="int64.Equals obj" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="C#" Value="public override bool Equals (object? obj);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object">
          <Attributes>
            <Attribute FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="obj">An object to compare with this instance.</param>
        <summary>Returns a value indicating whether this instance is equal to a specified object.</summary>
        <returns>
          <see langword="true" /> if <paramref name="obj" /> is an instance of an <see cref="T:System.Int64" /> and equals the value of this instance; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 The following code example illustrates the use of `Equals` in the context of `Int64`, comparing two long values and returning `true` if they represent the same number, or `false` if they do not.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR/Int64_Equals/CPP/int64_equals.cpp" id="Snippet1":::
 :::code language="csharp" source="~/snippets/csharp/System/Int64/Equals/int64_equals.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR/Int64_Equals/FS/int64_equals.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR/Int64_Equals/VB/int64_equals.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Compiler overload resolution may account for an apparent difference in the behavior of the two <see cref="M:System.Int64.Equals(System.Int64)" /> method overloads. If an implicit conversion between the <paramref name="obj" /> argument and an <see cref="T:System.Int64" /> is defined and the argument is not typed as an <see cref="T:System.Object" />, compilers perform an implicit conversion and call the <see cref="M:System.Int64.Equals(System.Int64)" /> method. Otherwise, they call the <see cref="M:System.Int64.Equals(System.Object)" /> method, which always returns <see langword="false" /> if its <paramref name="obj" /> argument is not an <see cref="T:System.Int64" /> value. The following example illustrates the difference in behavior between the two method overloads. In the case of the <see cref="T:System.Byte" />, <see cref="T:System.SByte" />, <see cref="T:System.Int16" />, <see cref="T:System.UInt16" />, <see cref="T:System.Int32" />, and <see cref="T:System.UInt32" /> values, the first comparison returns <see langword="true" /> because the compiler automatically performs a widening conversion and calls the <see cref="M:System.Int64.Equals(System.Int64)" /> method, whereas the second comparison returns <see langword="false" /> because the compiler calls the <see cref="M:System.Int64.Equals(System.Object)" /> method.

 :::code language="csharp" source="~/snippets/csharp/System/Int64/Equals/equalsoverl.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.int64.equals/fs/equalsoverl.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.int64.equals/vb/equalsoverl.vb" id="Snippet1":::</para>
        </block>
        <altmember cref="M:System.Int64.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="int64.GetHashCode " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the hash code for this instance.</summary>
        <returns>A 32-bit signed integer hash code.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="int64.GetTypeCode " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the <see cref="T:System.TypeCode" /> for value type <see cref="T:System.Int64" />.</summary>
        <returns>The enumerated constant, <see cref="F:System.TypeCode.Int64" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.TypeCode" />
      </Docs>
    </Member>
    <Member MemberName="IsEvenInteger">
      <MemberSignature Language="C#" Value="public static bool IsEvenInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEvenInteger(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.IsEvenInteger(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEvenInteger (value As Long) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsEvenInteger : int64 -&gt; bool" Usage="System.int64.IsEvenInteger value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEvenInteger(long value) = System::Numerics::INumberBase&lt;long&gt;::IsEvenInteger;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsEvenInteger(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents an even integral number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an even integer; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This method correctly handles floating-point values and so `2.0` will return `true` while `2.2` will return `false`.

A return value of `false` does not imply that <xref:System.Numerics.INumberBase%601.IsOddInteger(%600)> will return `true`. A number with a fractional portion, for example, `3.3`, is not even or odd.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.IsEvenInteger(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegative(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.IsNegative(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (value As Long) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsNegative : int64 -&gt; bool" Usage="System.int64.IsNegative value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(long value) = System::Numerics::INumberBase&lt;long&gt;::IsNegative;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsNegative(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is negative.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is negative; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

A return value of `false` does not imply that <xref:System.Numerics.INumberBase%601.IsPositive(%600)> will return `true`. A complex number, `a + bi` for non-zero `b`, is not positive or negative

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.IsNegative(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IsOddInteger">
      <MemberSignature Language="C#" Value="public static bool IsOddInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsOddInteger(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.IsOddInteger(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsOddInteger (value As Long) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsOddInteger : int64 -&gt; bool" Usage="System.int64.IsOddInteger value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsOddInteger(long value) = System::Numerics::INumberBase&lt;long&gt;::IsOddInteger;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsOddInteger(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents an odd integral number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an odd integer; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This method correctly handles floating-point values and so `3.0` will return `true` while `3.3` will return `false`.

A return value of `false` does not imply that <xref:System.Numerics.INumberBase%601.IsEvenInteger(%600)> will return `true`. A number with a fractional portion, for example, `3.3`, is not even or odd.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.IsOddInteger(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IsPositive">
      <MemberSignature Language="C#" Value="public static bool IsPositive (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositive(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.IsPositive(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositive (value As Long) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsPositive : int64 -&gt; bool" Usage="System.int64.IsPositive value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositive(long value) = System::Numerics::INumberBase&lt;long&gt;::IsPositive;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsPositive(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is positive.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is positive; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

A return value of `false` does not imply that <xref:System.Numerics.INumberBase%601.IsNegative(%600)> will return `true`. A complex number, `a + bi` for non-zero `b`, is not positive or negative

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.IsPositive(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IsPow2">
      <MemberSignature Language="C#" Value="public static bool IsPow2 (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPow2(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.IsPow2(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPow2 (value As Long) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsPow2 : int64 -&gt; bool" Usage="System.int64.IsPow2 value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPow2(long value) = System::Numerics::IBinaryNumber&lt;long&gt;::IsPow2;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryNumber`1.IsPow2(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is a power of two.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is a power of two; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryNumber`1.IsPow2(`0)" />
      </Docs>
    </Member>
    <Member MemberName="LeadingZeroCount">
      <MemberSignature Language="C#" Value="public static long LeadingZeroCount (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LeadingZeroCount(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.LeadingZeroCount(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeadingZeroCount (value As Long) As Long" />
      <MemberSignature Language="F#" Value="static member LeadingZeroCount : int64 -&gt; int64" Usage="System.int64.LeadingZeroCount value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LeadingZeroCount(long value) = System::Numerics::IBinaryInteger&lt;long&gt;::LeadingZeroCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.LeadingZeroCount(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value whose leading zeroes are to be counted.</param>
        <summary>Computes the number of leading zeros in a value.</summary>
        <returns>The number of leading zeros in <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.LeadingZeroCount(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Log2">
      <MemberSignature Language="C#" Value="public static long Log2 (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Log2(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.Log2(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log2 (value As Long) As Long" />
      <MemberSignature Language="F#" Value="static member Log2 : int64 -&gt; int64" Usage="System.int64.Log2 value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Log2(long value) = System::Numerics::IBinaryNumber&lt;long&gt;::Log2;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryNumber`1.Log2(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value whose log2 is to be computed.</param>
        <summary>Computes the log2 of a value.</summary>
        <returns>The log2 of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryNumber`1.Log2(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static long Max (long x, long y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max(int64 x, int64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.Max(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (x As Long, y As Long) As Long" />
      <MemberSignature Language="F#" Value="static member Max : int64 * int64 -&gt; int64" Usage="System.int64.Max (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Max(long x, long y) = System::Numerics::INumber&lt;long&gt;::Max;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.Max(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.Int64" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is greater.</summary>
        <returns>
          <paramref name="x" /> if it is greater than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For <xref:System.Numerics.IFloatingPoint%601> this method matches the IEEE 754:2019 `maximum` function. This requires NaN inputs to be propagated back to the caller and for `-0.0` to be treated as less than `+0.0`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumber`1.Max(`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude">
      <MemberSignature Language="C#" Value="public static long MaxMagnitude (long x, long y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 MaxMagnitude(int64 x, int64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.MaxMagnitude(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MaxMagnitude (x As Long, y As Long) As Long" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : int64 * int64 -&gt; int64" Usage="System.int64.MaxMagnitude (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long MaxMagnitude(long x, long y) = System::Numerics::INumberBase&lt;long&gt;::MaxMagnitude;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.MaxMagnitude(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.Int64" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is greater.</summary>
        <returns>
          <paramref name="x" /> if it is greater than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For <xref:System.Numerics.IFloatingPointIeee754%601> this method matches the IEEE 754:2019 `maximumMagnitude` function. This requires NaN inputs to not be propagated back to the caller and for `-0.0` to be treated as less than `+0.0`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.MaxMagnitude(`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const long MaxValue = 9223372036854775807;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int64 MaxValue = int64(9223372036854775807)" />
      <MemberSignature Language="DocId" Value="F:System.Int64.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Long  = 9223372036854775807" />
      <MemberSignature Language="F#" Value="val mutable MaxValue : int64" Usage="System.int64.MaxValue" />
      <MemberSignature Language="C++ CLI" Value="public: long MaxValue = 9223372036854775807;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <MemberValue>9223372036854775807</MemberValue>
      <Docs>
        <summary>Represents the largest possible value of an <see cref="T:System.Int64" />. This field is constant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The value of this constant is 9,223,372,036,854,775,807; that is, hexadecimal 0x7FFFFFFFFFFFFFFF.

 ]]></format>
        </remarks>
        <altmember cref="F:System.Int64.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static long Min (long x, long y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min(int64 x, int64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.Min(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (x As Long, y As Long) As Long" />
      <MemberSignature Language="F#" Value="static member Min : int64 * int64 -&gt; int64" Usage="System.int64.Min (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Min(long x, long y) = System::Numerics::INumber&lt;long&gt;::Min;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.Min(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.Int64" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is lesser.</summary>
        <returns>
          <paramref name="x" /> if it is less than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For <xref:System.Numerics.IFloatingPoint%601> this method matches the IEEE 754:2019 `minimum` function. This requires NaN inputs to be propagated back to the caller and for `-0.0` to be treated as less than `+0.0`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumber`1.Min(`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude">
      <MemberSignature Language="C#" Value="public static long MinMagnitude (long x, long y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 MinMagnitude(int64 x, int64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.MinMagnitude(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MinMagnitude (x As Long, y As Long) As Long" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : int64 * int64 -&gt; int64" Usage="System.int64.MinMagnitude (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long MinMagnitude(long x, long y) = System::Numerics::INumberBase&lt;long&gt;::MinMagnitude;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.MinMagnitude(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.Int64" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is lesser.</summary>
        <returns>
          <paramref name="x" /> if it is less than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For <xref:System.Numerics.IFloatingPointIeee754%601> this method matches the IEEE 754:2019 `minimumMagnitude` function. This requires NaN inputs to not be propagated back to the caller and for `-0.0` to be treated as less than `+0.0`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.MinMagnitude(`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const long MinValue = -9223372036854775808;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int64 MinValue = int64(-9223372036854775808)" />
      <MemberSignature Language="DocId" Value="F:System.Int64.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Long  = -9223372036854775808" />
      <MemberSignature Language="F#" Value="val mutable MinValue : int64" Usage="System.int64.MinValue" />
      <MemberSignature Language="C++ CLI" Value="public: long MinValue = -9223372036854775808;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <MemberValue>-9223372036854775808</MemberValue>
      <Docs>
        <summary>Represents the smallest possible value of an <see cref="T:System.Int64" />. This field is constant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The value of this constant is negative 9,223,372,036,854,775,808; that is, hexadecimal 0x8000000000000000.

 ]]></format>
        </remarks>
        <altmember cref="F:System.Int64.MaxValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converts the string representation of a number to its 64-bit signed integer equivalent.</summary>
        <altmember cref="Overload:System.Int64.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static long Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Long" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; int64" Usage="System.int64.Parse s" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Parse(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">A string containing a number to convert.</param>
        <summary>Converts the string representation of a number to its 64-bit signed integer equivalent.</summary>
        <returns>A 64-bit signed integer equivalent to the number contained in <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The `s` parameter contains a number of the form:

 [ws][sign]digits[ws]

 Elements in square brackets ([ and ]) are optional. The following table describes each element.

|Element|Description|
|-------------|-----------------|
|ws|Optional white space.|
|sign|An optional sign.|
|digits|A sequence of digits ranging from 0 to 9.|

 The `s` parameter is interpreted using the <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> style. In addition to decimal digits, only leading and trailing spaces together with a leading sign are allowed. To explicitly define the style elements that can be present in `s`, use either the <xref:System.Int64.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> or the <xref:System.Int64.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.

 The `s` parameter is parsed using the formatting information in a <xref:System.Globalization.NumberFormatInfo> object that is initialized for the current system culture. To parse a string using the formatting information of some other culture, use the <xref:System.Int64.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.



## Examples
 The following example demonstrates how to convert a string value into a 64-bit signed integer value using the <xref:System.Int64.Parse%28System.String%29?displayProperty=nameWithType> method. It then displays the resulting long integer value.

 :::code language="csharp" source="~/snippets/csharp/System/Int64/Parse/Parse1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.int64.parse/fs/Parse1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.int64.parse/vb/Parse1.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> is not in the correct format.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> represents a number less than <see cref="F:System.Int64.MinValue">Int64.MinValue</see> or greater than <see cref="F:System.Int64.MaxValue">Int64.MaxValue</see>.</exception>
        <altmember cref="M:System.Int64.ToString" />
        <related type="Article" href="/dotnet/standard/base-types/parsing-numeric">Parsing Numeric Strings in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static long Parse (ReadOnlySpan&lt;byte&gt; utf8Text, IFormatProvider? provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Parse(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Text, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.Parse(System.ReadOnlySpan{System.Byte},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (utf8Text As ReadOnlySpan(Of Byte), provider As IFormatProvider) As Long" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;byte&gt; * IFormatProvider -&gt; int64" Usage="System.int64.Parse (utf8Text, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Parse(ReadOnlySpan&lt;System::Byte&gt; utf8Text, IFormatProvider ^ provider) = IUtf8SpanParsable&lt;long&gt;::Parse;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IUtf8SpanParsable`1.Parse(System.ReadOnlySpan{System.Byte},System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Text" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="utf8Text">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.IUtf8SpanParsable`1.Parse(System.ReadOnlySpan{System.Byte},System.IFormatProvider)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static long Parse (ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), provider As IFormatProvider) As Long" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; int64" Usage="System.int64.Parse (s, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Parse(ReadOnlySpan&lt;char&gt; s, IFormatProvider ^ provider) = ISpanParsable&lt;long&gt;::Parse;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ISpanParsable`1.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="s">The span of characters to parse.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <summary>Parses a span of characters into a value.</summary>
        <returns>The result of parsing <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.ISpanParsable`1.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static long Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Long" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; int64" Usage="System.int64.Parse (s, style)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">A string containing a number to convert.</param>
        <param name="style">A bitwise combination of <see cref="T:System.Globalization.NumberStyles" /> values that indicates the permitted format of <paramref name="s" />. A typical value to specify is <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <summary>Converts the string representation of a number in a specified style to its 64-bit signed integer equivalent.</summary>
        <returns>A 64-bit signed integer equivalent to the number specified in <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The `style` parameter defines the style elements (such as white space, the positive or negative sign symbol, or the thousands separator symbol) that are allowed in the `s` parameter for the parse operation to succeed. It must be a combination of bit flags from the <xref:System.Globalization.NumberStyles> enumeration. Depending on the value of `style`, the `s` parameter may contain the following elements:

 [ws][$][sign][digits,]digits[.fractional_digits][e[sign]exponential_digits][ws]

 Or, if `style` includes <xref:System.Globalization.NumberStyles.AllowHexSpecifier>:

 [ws]hexdigits[ws]

 Elements in square brackets ([ and ]) are optional. The following table describes each element.

|Element|Description|
|-------------|-----------------|
|*ws*|Optional white space. White space can appear at the beginning of `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flag, and it can appear at the end of `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flag.|
|*$*|A culture-specific currency symbol. Its position in the string is defined by the <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> and <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> properties of the current culture. The current culture's currency symbol can appear in `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flag.|
|*sign*|An optional sign. The sign can appear at the beginning of `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flag, and it can appear at the end of `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flag. Parentheses can be used in `s` to indicate a negative value if `style` includes the <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flag.|
|*digits*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|A sequence of digits from 0 through 9. For *fractional_digits*, only the digit 0 is valid.|
|*,*|A culture-specific thousands separator symbol. The current culture's thousands separator can appear in `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag.|
|*.*|A culture-specific decimal point symbol. The current culture's decimal point symbol can appear in `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag. Only the digit 0 can appear as a fractional digit for the parse operation to succeed; if *fractional_digits* includes any other digit, an <xref:System.OverflowException> is thrown.|
|*e*|The 'e' or 'E' character, which indicates that the value is represented in exponential notation. The `s` parameter can represent a number in exponential notation if `style` includes the <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.|
|*hexdigits*|A sequence of hexadecimal digits from 0 through f, or 0 through F.|

> [!NOTE]
> Any terminating NUL (U+0000) characters in `s` are ignored by the parsing operation, regardless of the value of the `style` argument.

 A string with digits only (which corresponds to the <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> style) always parses successfully if it is in the range of the <xref:System.Int64> type. Most of the remaining <xref:System.Globalization.NumberStyles> members control elements that may be but are not required to be present in the input string. The following table indicates how individual <xref:System.Globalization.NumberStyles> members affect the elements that may be present in `s`.

|NumberStyles value|Elements permitted in s in addition to digits|
|------------------------|---------------------------------------------------|
|<xref:System.Globalization.NumberStyles.None>|The *digits* element only.|
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|The decimal point ( *.* ) and *fractional-digits* elements.|
|<xref:System.Globalization.NumberStyles.AllowExponent>|The `s` parameter can also use exponential notation. If `s` represents a number in exponential notation, the resulting numeric value cannot include any non-zero fractional digits.|
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|The *ws* element at the beginning of `s`.|
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|The *ws* element at the end of `s`.|
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|The *sign* element at the beginning of `s`.|
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|The *sign* element at the end of `s`.|
|<xref:System.Globalization.NumberStyles.AllowParentheses>|The *sign* element in the form of parentheses enclosing the numeric value.|
|<xref:System.Globalization.NumberStyles.AllowThousands>|The thousands separator ( *,* ) element.|
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|The *$* element.|
|<xref:System.Globalization.NumberStyles.Currency>|All. The `s` parameter cannot represent a hexadecimal number or a number in exponential notation.|
|<xref:System.Globalization.NumberStyles.Float>|The *ws* element at the beginning or end of `s`, *sign* at the beginning of `s`, and the decimal point ( *.* ) symbol. The `s` parameter can also use exponential notation.|
|<xref:System.Globalization.NumberStyles.Number>|The *ws*, *sign*, thousands separator ( *,* ), and decimal point ( *.* ) elements.|
|<xref:System.Globalization.NumberStyles.Any>|All styles, except `s` cannot represent a hexadecimal number.|

 If the <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> flag is used, `s` must be a hexadecimal value without a prefix. For example, "C9AF3" parses successfully, but "0xC9AF3" does not. The only other flags that can be combined with the `s` parameter are <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> and <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (The <xref:System.Globalization.NumberStyles> enumeration includes a composite number style, <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>, that includes both white space flags.)

 The `s` parameter is parsed using the formatting information in a <xref:System.Globalization.NumberFormatInfo> object that is initialized for the current system culture. To specify the culture whose formatting information is used for the parse operation, call the <xref:System.Int64.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> overload.



## Examples
 The following example uses the <xref:System.Int64.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> method to parse the string representations of several <xref:System.Int64> values. The current culture for the example is en-US.

 :::code language="csharp" source="~/snippets/csharp/System/Int64/Parse/Parse2.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.int64.parse/fs/Parse2.fs" id="Snippet2":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.int64.parse/vb/Parse2.vb" id="Snippet2":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> is not a <see cref="T:System.Globalization.NumberStyles" /> value.

 -or-

 <paramref name="style" /> is not a combination of <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="F:System.Globalization.NumberStyles.HexNumber" /> values.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> is not in a format compliant with <paramref name="style" />.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> represents a number less than <see cref="F:System.Int64.MinValue">Int64.MinValue</see> or greater than <see cref="F:System.Int64.MaxValue">Int64.MaxValue</see>.

 -or-

 <paramref name="style" /> supports fractional digits but <paramref name="s" /> includes non-zero fractional digits.</exception>
        <altmember cref="M:System.Int64.ToString" />
        <altmember cref="Overload:System.Int64.TryParse" />
        <related type="Article" href="/dotnet/standard/base-types/parsing-numeric">Parsing Numeric Strings in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static long Parse (string s, IFormatProvider provider);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Long" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; int64" Usage="System.int64.Parse (s, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Parse(System::String ^ s, IFormatProvider ^ provider);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public static long Parse (string s, IFormatProvider? provider);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Parse(System::String ^ s, IFormatProvider ^ provider) = IParsable&lt;long&gt;::Parse;" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0;net-8.0;net-9.0">M:System.IParsable`1.Parse(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="s">A string containing a number to convert.</param>
        <param name="provider">An object that supplies culture-specific formatting information about <paramref name="s" />.</param>
        <summary>Converts the string representation of a number in a specified culture-specific format to its 64-bit signed integer equivalent.</summary>
        <returns>A 64-bit signed integer equivalent to the number specified in <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This overload of the <xref:System.Int64.Parse%28System.String%2CSystem.IFormatProvider%29> method is typically used to convert text that can be formatted in a variety of ways to an <xref:System.Int64> value. For example, it can be used to convert the text entered by a user into an HTML text box to a numeric value.

 The `s` parameter contains a number of the form:

 [ws][sign]digits[ws]

 Items in square brackets ([ and ]) are optional, and other items are as follows.

 ws
 An optional white space.

 sign
 An optional sign.

 digits
 A sequence of digits ranging from 0 to 9.

 The `s` parameter is interpreted using the <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> style. In addition to decimal digits, only leading and trailing spaces together with a leading sign are allowed. To explicitly define the style elements that can be present in `s`, use the <xref:System.Int64.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.

 The `provider` parameter is an <xref:System.IFormatProvider> implementation, such as a <xref:System.Globalization.NumberFormatInfo> or <xref:System.Globalization.CultureInfo> object. The `provider` parameter supplies culture-specific information about the format of `s`. If `provider` is `null`, the <xref:System.Globalization.NumberFormatInfo> for the current culture is used.



## Examples
 The following example is the button click event handler of a Web form. It uses the array returned by the <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType> property to determine the user's locale. It then instantiates a <xref:System.Globalization.CultureInfo> object that corresponds to that locale. The <xref:System.Globalization.NumberFormatInfo> object that belongs to that <xref:System.Globalization.CultureInfo> object is then passed to the <xref:System.Int64.Parse%28System.String%2CSystem.IFormatProvider%29> method to convert the user's input to an <xref:System.Int64> value.

 :::code language="csharp" source="~/snippets/csharp/System/Decimal/Parse/Default.aspx.cs" id="Snippet5":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb" id="Snippet5":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> is not in the correct format.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> represents a number less than <see cref="F:System.Int64.MinValue">Int64.MinValue</see> or greater than <see cref="F:System.Int64.MaxValue">Int64.MaxValue</see>.</exception>
        <altmember cref="M:System.Int64.ToString" />
        <altmember cref="Overload:System.Int64.TryParse" />
        <related type="Article" href="/dotnet/standard/base-types/parsing-numeric">Parsing Numeric Strings in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static long Parse (ReadOnlySpan&lt;byte&gt; utf8Text, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider? provider = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Parse(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Text, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.Parse(System.ReadOnlySpan{System.Byte},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (utf8Text As ReadOnlySpan(Of Byte), Optional style As NumberStyles = System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = Nothing) As Long" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;byte&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; int64" Usage="System.int64.Parse (utf8Text, style, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.Parse(System.ReadOnlySpan{System.Byte},System.Globalization.NumberStyles,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Text" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="utf8Text">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.Parse(System.ReadOnlySpan{System.Byte},System.Globalization.NumberStyles,System.IFormatProvider)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static long Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider? provider = default);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = Nothing) As Long" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; int64" Usage="System.int64.Parse (s, style, provider)" />
      <MemberSignature Language="C#" Value="public static long Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider provider = default);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0;net-8.0;net-9.0">M:System.Numerics.INumberBase`1.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="s">A span containing the characters representing the number to convert.</param>
        <param name="style">A bitwise combination of enumeration values that indicates the style elements that can be present in <paramref name="s" />. A typical value to specify is <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information about <paramref name="s" />.</param>
        <summary>Converts the span representation of a number in a specified style and culture-specific format to its 64-bit signed integer equivalent.</summary>
        <returns>A 64-bit signed integer equivalent to the number specified in <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static long Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Long" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; int64" Usage="System.int64.Parse (s, style, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public static long Parse (string s, System.Globalization.NumberStyles style, IFormatProvider? provider);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider) = System::Numerics::INumberBase&lt;long&gt;::Parse;" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0;net-8.0;net-9.0">M:System.Numerics.INumberBase`1.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="s">A string containing a number to convert.</param>
        <param name="style">A bitwise combination of enumeration values that indicates the style elements that can be present in <paramref name="s" />. A typical value to specify is <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information about <paramref name="s" />.</param>
        <summary>Converts the string representation of a number in a specified style and culture-specific format to its 64-bit signed integer equivalent.</summary>
        <returns>A 64-bit signed integer equivalent to the number specified in <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The `style` parameter defines the style elements (such as white space or the positive sign) that are allowed in the `s` parameter for the parse operation to succeed. It must be a combination of bit flags from the <xref:System.Globalization.NumberStyles> enumeration. Depending on the value of `style`, the `s` parameter may include the following elements:

 [ws][$][sign][digits,]digits[.fractional_digits][e[sign]exponential_digits][ws]

 Or, if `style` includes <xref:System.Globalization.NumberStyles.AllowHexSpecifier>:

 [ws]hexdigits[ws]

 Elements in square brackets ([ and ]) are optional. The following table describes each element.

|Element|Description|
|-------------|-----------------|
|*ws*|Optional white space. White space can appear at the beginning of `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flag, and it can appear at the end of `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flag.|
|*$*|A culture-specific currency symbol. Its position in the string is defined by the <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> property of the <xref:System.Globalization.NumberFormatInfo> object returned by the <xref:System.IFormatProvider.GetFormat%2A> method of the `provider` parameter. The currency symbol can appear in `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flag.|
|*sign*|An optional sign. The sign can appear at the beginning of `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flag or at the end of `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flag. Parentheses can be used in `s` to indicate a negative value if `style` includes the <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> flag.|
|*digits*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|A sequence of digits from 0 through 9.|
|*,*|A culture-specific thousands separator symbol. The thousands separator of the culture specified by `provider` can appear in `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag.|
|*.*|A culture-specific decimal point symbol. The decimal point symbol of the culture specified by `provider` can appear in `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.<br /><br /> Only the digit 0 can appear as a fractional digit for the parse operation to succeed; if *fractional_digits* includes any other digit, an <xref:System.OverflowException> is thrown.|
|*e*|The 'e' or 'E' character, which indicates that the value is represented in exponential notation. The `s` parameter can represent a number in exponential notation if `style` includes the <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.|
|*hexdigits*|A sequence of hexadecimal digits from 0 through f, or 0 through F.|

> [!NOTE]
> Any terminating NUL (U+0000) characters in `s` are ignored by the parsing operation, regardless of the value of the `style` argument.

 A string with decimal digits only (which corresponds to the <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> style) always parses successfully if it is in the range of the <xref:System.Int64> type. Most of the remaining <xref:System.Globalization.NumberStyles> members control elements that may be but are not required to be present in this input string. The following table indicates how individual <xref:System.Globalization.NumberStyles> members affect the elements that may be present in `s`.

|Non-composite NumberStyles values|Elements permitted in s in addition to digits|
|----------------------------------------|---------------------------------------------------|
|<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>|Decimal digits only.|
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>|The decimal point ( *.* ) and *fractional-digits* elements. However, *fractional-digits* must consist of only one or more 0 digits or an <xref:System.OverflowException> is thrown.|
|<xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>|The `s` parameter can also use exponential notation.|
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>|The *ws* element at the beginning of `s`.|
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>|The *ws* element at the end of `s`.|
|<xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>|A sign can appear before *digits*.|
|<xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>|A sign can appear after *digits*.|
|<xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>|The *sign* element in the form of parentheses enclosing the numeric value.|
|<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>|The thousands separator ( *,* ) element.|
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>|The *$* element.|

 If the <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> flag is used, `s` must be a hexadecimal value without a prefix. For example, "C9AF3" parses successfully, but "0xC9AF3" does not. The only other flags that can be present in `style` are <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> and <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (The <xref:System.Globalization.NumberStyles> enumeration has a composite number style, <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>, that includes both white space flags.)

 The `provider` parameter is an <xref:System.IFormatProvider> implementation, such as a <xref:System.Globalization.NumberFormatInfo> or <xref:System.Globalization.CultureInfo> object. The `provider` parameter supplies culture-specific information used in parsing. If `provider` is `null`, the <xref:System.Globalization.NumberFormatInfo> for the current culture is used.



## Examples
 The following example uses a variety of `style` and `provider` parameters to parse the string representations of <xref:System.Int64> values. It also illustrates some of the different ways the same string can be interpreted depending on the culture whose formatting information is used for the parsing operation.

 :::code language="csharp" source="~/snippets/csharp/System/Int64/Parse/Parse3.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.int64.parse/fs/Parse3.fs" id="Snippet3":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.int64.parse/vb/Parse3.vb" id="Snippet3":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> is not a <see cref="T:System.Globalization.NumberStyles" /> value.

 -or-

 <paramref name="style" /> is not a combination of <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="F:System.Globalization.NumberStyles.HexNumber" /> values.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> is not in a format compliant with <paramref name="style" />.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> represents a number less than <see cref="F:System.Int64.MinValue">Int64.MinValue</see> or greater than <see cref="F:System.Int64.MaxValue">Int64.MaxValue</see>.

 -or-

 <paramref name="style" /> supports fractional digits, but <paramref name="s" /> includes non-zero fractional digits.</exception>
        <altmember cref="M:System.Int64.ToString" />
        <related type="Article" href="/dotnet/standard/base-types/parsing-numeric">Parsing Numeric Strings in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="PopCount">
      <MemberSignature Language="C#" Value="public static long PopCount (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 PopCount(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.PopCount(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PopCount (value As Long) As Long" />
      <MemberSignature Language="F#" Value="static member PopCount : int64 -&gt; int64" Usage="System.int64.PopCount value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long PopCount(long value) = System::Numerics::IBinaryInteger&lt;long&gt;::PopCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.PopCount(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value whose set bits are to be counted.</param>
        <summary>Computes the number of bits that are set in a value.</summary>
        <returns>The number of set bits in <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.PopCount(`0)" />
      </Docs>
    </Member>
    <Member MemberName="RotateLeft">
      <MemberSignature Language="C#" Value="public static long RotateLeft (long value, int rotateAmount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 RotateLeft(int64 value, int32 rotateAmount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.RotateLeft(System.Int64,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RotateLeft (value As Long, rotateAmount As Integer) As Long" />
      <MemberSignature Language="F#" Value="static member RotateLeft : int64 * int -&gt; int64" Usage="System.int64.RotateLeft (value, rotateAmount)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long RotateLeft(long value, int rotateAmount) = System::Numerics::IBinaryInteger&lt;long&gt;::RotateLeft;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.RotateLeft(`0,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="rotateAmount" Type="System.Int32" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value which is rotated left by <paramref name="rotateAmount" />.</param>
        <param name="rotateAmount">The amount by which <paramref name="value" /> is rotated left.</param>
        <summary>Rotates a value left by a given amount.</summary>
        <returns>The result of rotating <paramref name="value" /> left by <paramref name="rotateAmount" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.RotateLeft(`0,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RotateRight">
      <MemberSignature Language="C#" Value="public static long RotateRight (long value, int rotateAmount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 RotateRight(int64 value, int32 rotateAmount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.RotateRight(System.Int64,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RotateRight (value As Long, rotateAmount As Integer) As Long" />
      <MemberSignature Language="F#" Value="static member RotateRight : int64 * int -&gt; int64" Usage="System.int64.RotateRight (value, rotateAmount)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long RotateRight(long value, int rotateAmount) = System::Numerics::IBinaryInteger&lt;long&gt;::RotateRight;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.RotateRight(`0,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="rotateAmount" Type="System.Int32" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value which is rotated right by <paramref name="rotateAmount" />.</param>
        <param name="rotateAmount">The amount by which <paramref name="value" /> is rotated right.</param>
        <summary>Rotates a value right by a given amount.</summary>
        <returns>The result of rotating <paramref name="value" /> right by <paramref name="rotateAmount" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.RotateRight(`0,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.Sign(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Long) As Integer" />
      <MemberSignature Language="F#" Value="static member Sign : int64 -&gt; int" Usage="System.int64.Sign value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(long value) = System::Numerics::INumber&lt;long&gt;::Sign;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.Sign(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value whose sign is to be computed.</param>
        <summary>Computes the sign of a value.</summary>
        <returns>A positive value if <paramref name="value" /> is positive, <see cref="P:System.Numerics.INumberBase`1.Zero" /> if <paramref name="value" /> is zero, and a negative value if <paramref name="value" /> is negative.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

It is recommended that a function return `1`, `0`, and `-1`, respectively.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumber`1.Sign(`0)" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="F#" Value="abstract member System.IComparable.CompareTo : obj -&gt; int&#xA;override this.System.IComparable.CompareTo : obj -&gt; int" Usage="int64.System.IComparable.CompareTo value" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value">An object to compare, or <see langword="null" />.</param>
        <summary>Compares this instance to a specified object and returns an indication of their relative values.</summary>
        <returns>A signed number indicating the relative values of this instance and <paramref name="value" />.
          <list type="table"><listheader><term>Return Value</term><description>Description</description></listheader><item><term>Less than zero</term><description>This instance is less than <paramref name="value" />.</description></item><item><term>Zero</term><description>This instance is equal to <paramref name="value" />.</description></item><item><term>Greater than zero</term><description>This instance is greater than <paramref name="value" />, or <paramref name="value" /> is <see langword="null" />.</description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This member is an explicit interface member implementation. It can be used only when the <xref:System.Int64> instance is cast to an <xref:System.IConvertible> interface.

An <xref:System.Int64>, regardless of its value, is considered greater than a null reference.

          ]]></format>
        </remarks>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> is not an <see cref="T:System.Int64" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.GetTypeCode : unit -&gt; TypeCode&#xA;override this.System.IConvertible.GetTypeCode : unit -&gt; TypeCode" Usage="int64.System.IConvertible.GetTypeCode " />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the <see cref="T:System.TypeCode" /> for value type <see cref="T:System.Int64" />.</summary>
        <returns>The enumerated constant, <see cref="F:System.TypeCode.Int64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This member is an explicit interface member implementation. It can be used only when the <xref:System.Int64> instance is cast to an <xref:System.IConvertible> interface.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToBoolean : IFormatProvider -&gt; bool&#xA;override this.System.IConvertible.ToBoolean : IFormatProvider -&gt; bool" Usage="int64.System.IConvertible.ToBoolean provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns>
          <see langword="true" /> if the value of the current instance is not zero; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Int64> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToBoolean%28System.Int64%29?displayProperty=nameWithType> method.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToByte : IFormatProvider -&gt; byte&#xA;override this.System.IConvertible.ToByte : IFormatProvider -&gt; byte" Usage="int64.System.IConvertible.ToByte provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>The value of the current instance, converted to a <see cref="T:System.Byte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Int64> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToByte%28System.Int64%29?displayProperty=nameWithType> method.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToChar : IFormatProvider -&gt; char&#xA;override this.System.IConvertible.ToChar : IFormatProvider -&gt; char" Usage="int64.System.IConvertible.ToChar provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</summary>
        <returns>The value of the current instance, converted to a <see cref="T:System.Char" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Int64> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToChar%28System.Int64%29?displayProperty=nameWithType> method.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDateTime : IFormatProvider -&gt; DateTime&#xA;override this.System.IConvertible.ToDateTime : IFormatProvider -&gt; DateTime" Usage="int64.System.IConvertible.ToDateTime provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>This conversion is not supported. Attempting to use this method throws an <see cref="T:System.InvalidCastException" />.</summary>
        <returns>This conversion is not supported. No value is returned.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">In all cases.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDecimal : IFormatProvider -&gt; decimal&#xA;override this.System.IConvertible.ToDecimal : IFormatProvider -&gt; decimal" Usage="int64.System.IConvertible.ToDecimal provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>The value of the current instance, converted to a <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Int64> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToDecimal%28System.Int64%29?displayProperty=nameWithType> method.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDouble : IFormatProvider -&gt; double&#xA;override this.System.IConvertible.ToDouble : IFormatProvider -&gt; double" Usage="int64.System.IConvertible.ToDouble provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>The value of the current instance, converted to a <see cref="T:System.Double" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Int64> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToDouble%28System.Int64%29?displayProperty=nameWithType> method.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt16 : IFormatProvider -&gt; int16&#xA;override this.System.IConvertible.ToInt16 : IFormatProvider -&gt; int16" Usage="int64.System.IConvertible.ToInt16 provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>The value of the current instance, converted to an <see cref="T:System.Int16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Int64> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToInt16%28System.Int64%29?displayProperty=nameWithType> method.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt32 : IFormatProvider -&gt; int&#xA;override this.System.IConvertible.ToInt32 : IFormatProvider -&gt; int" Usage="int64.System.IConvertible.ToInt32 provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>The value of the current instance, converted to an <see cref="T:System.Int32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Int64> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToInt32%28System.Int64%29?displayProperty=nameWithType> method.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt64 : IFormatProvider -&gt; int64&#xA;override this.System.IConvertible.ToInt64 : IFormatProvider -&gt; int64" Usage="int64.System.IConvertible.ToInt64 provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>The value of the current instance, unchanged.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Int64> instance is cast to an <xref:System.IConvertible> interface.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToSByte : IFormatProvider -&gt; sbyte&#xA;override this.System.IConvertible.ToSByte : IFormatProvider -&gt; sbyte" Usage="int64.System.IConvertible.ToSByte provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>The value of the current instance, converted to an <see cref="T:System.SByte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Int64> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToSByte%28System.Int64%29?displayProperty=nameWithType> method.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToSingle : IFormatProvider -&gt; single&#xA;override this.System.IConvertible.ToSingle : IFormatProvider -&gt; single" Usage="int64.System.IConvertible.ToSingle provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>The value of the current instance, converted to a <see cref="T:System.Single" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Int64> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToSingle%28System.Int64%29?displayProperty=nameWithType> method.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToType (type As Type, provider As IFormatProvider) As Object Implements IConvertible.ToType" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToType : Type * IFormatProvider -&gt; obj&#xA;override this.System.IConvertible.ToType : Type * IFormatProvider -&gt; obj" Usage="int64.System.IConvertible.ToType (type, provider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">The type to which to convert this <see cref="T:System.Int64" /> value.</param>
        <param name="provider">An <see cref="T:System.IFormatProvider" /> implementation that provides information about the format of the returned value.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>The value of the current instance, converted to <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Int64> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the `static` (`Shared` in Visual Basic) <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> method.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt16 : IFormatProvider -&gt; uint16&#xA;override this.System.IConvertible.ToUInt16 : IFormatProvider -&gt; uint16" Usage="int64.System.IConvertible.ToUInt16 provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>The value of the current instance, converted to a <see cref="T:System.UInt16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Int64> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToUInt16%28System.Int64%29?displayProperty=nameWithType> method.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt32 : IFormatProvider -&gt; uint32&#xA;override this.System.IConvertible.ToUInt32 : IFormatProvider -&gt; uint32" Usage="int64.System.IConvertible.ToUInt32 provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>The value of the current instance, converted to a <see cref="T:System.UInt32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Int64> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToUInt32%28System.Int64%29?displayProperty=nameWithType> method.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt64 : IFormatProvider -&gt; uint64&#xA;override this.System.IConvertible.ToUInt64 : IFormatProvider -&gt; uint64" Usage="int64.System.IConvertible.ToUInt64 provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>The value of the current instance, converted to a <see cref="T:System.UInt64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Int64> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToUInt64%28System.Int64%29?displayProperty=nameWithType> method.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IAdditionOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_Addition">
      <MemberSignature Language="C#" Value="static long IAdditionOperators&lt;long,long,long&gt;.operator + (long left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig int64 System.Numerics.IAdditionOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_Addition(int64 left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IAdditionOperators&lt;System#Int64,System#Int64,System#Int64&gt;#op_Addition(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator + (left As Long, right As Long) As Long Implements IAdditionOperators(Of Long, Long, Long).op_Addition" />
      <MemberSignature Language="F#" Value="static member ( + ) : int64 * int64 -&gt; int64" Usage="left + right" />
      <MemberSignature Language="C++ CLI" Value=" static long System.Numerics.IAdditionOperators&lt;System.Int64,System.Int64,System.Int64&gt;.operator +(long left, long right) = System::Numerics::IAdditionOperators&lt;long, long, long&gt;::op_Addition;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IAdditionOperators`3.op_Addition(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Int64" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to which <paramref name="right" /> is added.</param>
        <param name="right">The value that's added to <paramref name="left" />.</param>
        <summary>Adds two values together to compute their sum.</summary>
        <returns>The sum of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IAdditionOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_CheckedAddition">
      <MemberSignature Language="C#" Value="static long IAdditionOperators&lt;long,long,long&gt;.op_CheckedAddition (long left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig int64 System.Numerics.IAdditionOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_CheckedAddition(int64 left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IAdditionOperators&lt;System#Int64,System#Int64,System#Int64&gt;#op_CheckedAddition(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_CheckedAddition (left As Long, right As Long) As Long Implements IAdditionOperators(Of Long, Long, Long).op_CheckedAddition" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IAdditionOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_CheckedAddition : int64 * int64 -&gt; int64" Usage="System.int64.System.Numerics.IAdditionOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_CheckedAddition (left, right)" />
      <MemberSignature Language="C++ CLI" Value=" static long System.Numerics.IAdditionOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_CheckedAddition(long left, long right) = System::Numerics::IAdditionOperators&lt;long, long, long&gt;::op_CheckedAddition;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IAdditionOperators`3.op_CheckedAddition(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Int64" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to which <paramref name="right" /> is added.</param>
        <param name="right">The value that's added to <paramref name="left" />.</param>
        <summary>Adds two values together to compute their sum.</summary>
        <returns>The sum of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IAdditiveIdentity&lt;System.Int64,System.Int64&gt;.AdditiveIdentity">
      <MemberSignature Language="C#" Value="static long System.Numerics.IAdditiveIdentity&lt;System.Int64,System.Int64&gt;.AdditiveIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 System.Numerics.IAdditiveIdentity&lt;System.Int64,System.Int64&gt;.AdditiveIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Int64.System#Numerics#IAdditiveIdentity&lt;System#Int64,System#Int64&gt;#AdditiveIdentity" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property AdditiveIdentity As Long Implements IAdditiveIdentity(Of Long, Long).AdditiveIdentity" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IAdditiveIdentity&lt;System.Int64,System.Int64&gt;.AdditiveIdentity : int64" Usage="System.Numerics.IAdditiveIdentity&lt;System.Int64,System.Int64&gt;.AdditiveIdentity" />
      <MemberSignature Language="C++ CLI" Value="static property long System::Numerics::IAdditiveIdentity&lt;System::Int64,System::Int64&gt;::AdditiveIdentity { long get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IAdditiveIdentity`2.AdditiveIdentity</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the additive identity of the current type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.Int64&gt;.GetByteCount">
      <MemberSignature Language="C#" Value="int IBinaryInteger&lt;long&gt;.GetByteCount ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Numerics.IBinaryInteger&lt;System.Int64&gt;.GetByteCount() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IBinaryInteger&lt;System#Int64&gt;#GetByteCount" />
      <MemberSignature Language="VB.NET" Value="Function GetByteCount () As Integer Implements IBinaryInteger(Of Long).GetByteCount" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.IBinaryInteger&lt;System.Int64&gt;.GetByteCount : unit -&gt; int&#xA;override this.System.Numerics.IBinaryInteger&lt;System.Int64&gt;.GetByteCount : unit -&gt; int" Usage="int64.System.Numerics.IBinaryInteger&lt;System.Int64&gt;.GetByteCount " />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Numerics.IBinaryInteger&lt;System.Int64&gt;.GetByteCount() = System::Numerics::IBinaryInteger&lt;long&gt;::GetByteCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.GetByteCount</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the number of bytes that will be written as part of <see cref="M:System.Numerics.IBinaryInteger`1.TryWriteLittleEndian(System.Span{System.Byte},System.Int32@)" />.</summary>
        <returns>The number of bytes that will be written as part of <see cref="M:System.Numerics.IBinaryInteger`1.TryWriteLittleEndian(System.Span{System.Byte},System.Int32@)" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.GetByteCount" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.Int64&gt;.GetShortestBitLength">
      <MemberSignature Language="C#" Value="int IBinaryInteger&lt;long&gt;.GetShortestBitLength ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Numerics.IBinaryInteger&lt;System.Int64&gt;.GetShortestBitLength() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IBinaryInteger&lt;System#Int64&gt;#GetShortestBitLength" />
      <MemberSignature Language="VB.NET" Value="Function GetShortestBitLength () As Integer Implements IBinaryInteger(Of Long).GetShortestBitLength" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.IBinaryInteger&lt;System.Int64&gt;.GetShortestBitLength : unit -&gt; int&#xA;override this.System.Numerics.IBinaryInteger&lt;System.Int64&gt;.GetShortestBitLength : unit -&gt; int" Usage="int64.System.Numerics.IBinaryInteger&lt;System.Int64&gt;.GetShortestBitLength " />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Numerics.IBinaryInteger&lt;System.Int64&gt;.GetShortestBitLength() = System::Numerics::IBinaryInteger&lt;long&gt;::GetShortestBitLength;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.GetShortestBitLength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the length, in bits, of the shortest two's complement representation of the current value.</summary>
        <returns>The length, in bits, of the shortest two's complement representation of the current value.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.GetShortestBitLength" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.Int64&gt;.TryReadBigEndian">
      <MemberSignature Language="C#" Value="static bool IBinaryInteger&lt;long&gt;.TryReadBigEndian (ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out long value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IBinaryInteger&lt;System.Int64&gt;.TryReadBigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, bool isUnsigned, [out] int64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IBinaryInteger&lt;System#Int64&gt;#TryReadBigEndian(System.ReadOnlySpan{System.Byte},System.Boolean,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryReadBigEndian (source As ReadOnlySpan(Of Byte), isUnsigned As Boolean, ByRef value As Long) As Boolean Implements IBinaryInteger(Of Long).TryReadBigEndian" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IBinaryInteger&lt;System.Int64&gt;.TryReadBigEndian : ReadOnlySpan&lt;byte&gt; * bool * int64 -&gt; bool" Usage="System.int64.System.Numerics.IBinaryInteger&lt;System.Int64&gt;.TryReadBigEndian (source, isUnsigned, value)" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IBinaryInteger&lt;System.Int64&gt;.TryReadBigEndian(ReadOnlySpan&lt;System::Byte&gt; source, bool isUnsigned, [Runtime::InteropServices::Out] long % value) = System::Numerics::IBinaryInteger&lt;long&gt;::TryReadBigEndian;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="value" Type="System.Int64" RefType="out" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.Int64&gt;.TryReadLittleEndian">
      <MemberSignature Language="C#" Value="static bool IBinaryInteger&lt;long&gt;.TryReadLittleEndian (ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out long value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IBinaryInteger&lt;System.Int64&gt;.TryReadLittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, bool isUnsigned, [out] int64&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IBinaryInteger&lt;System#Int64&gt;#TryReadLittleEndian(System.ReadOnlySpan{System.Byte},System.Boolean,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryReadLittleEndian (source As ReadOnlySpan(Of Byte), isUnsigned As Boolean, ByRef value As Long) As Boolean Implements IBinaryInteger(Of Long).TryReadLittleEndian" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IBinaryInteger&lt;System.Int64&gt;.TryReadLittleEndian : ReadOnlySpan&lt;byte&gt; * bool * int64 -&gt; bool" Usage="System.int64.System.Numerics.IBinaryInteger&lt;System.Int64&gt;.TryReadLittleEndian (source, isUnsigned, value)" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IBinaryInteger&lt;System.Int64&gt;.TryReadLittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, bool isUnsigned, [Runtime::InteropServices::Out] long % value) = System::Numerics::IBinaryInteger&lt;long&gt;::TryReadLittleEndian;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="value" Type="System.Int64" RefType="out" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.Int64&gt;.TryWriteBigEndian">
      <MemberSignature Language="C#" Value="bool IBinaryInteger&lt;long&gt;.TryWriteBigEndian (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Numerics.IBinaryInteger&lt;System.Int64&gt;.TryWriteBigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IBinaryInteger&lt;System#Int64&gt;#TryWriteBigEndian(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Function TryWriteBigEndian (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean Implements IBinaryInteger(Of Long).TryWriteBigEndian" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.IBinaryInteger&lt;System.Int64&gt;.TryWriteBigEndian : Span&lt;byte&gt; * int -&gt; bool&#xA;override this.System.Numerics.IBinaryInteger&lt;System.Int64&gt;.TryWriteBigEndian : Span&lt;byte&gt; * int -&gt; bool" Usage="int64.System.Numerics.IBinaryInteger&lt;System.Int64&gt;.TryWriteBigEndian (destination, bytesWritten)" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Numerics.IBinaryInteger&lt;System.Int64&gt;.TryWriteBigEndian(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten) = System::Numerics::IBinaryInteger&lt;long&gt;::TryWriteBigEndian;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.TryWriteBigEndian(System.Span{System.Byte},System.Int32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="destination">The span to which the current value should be written.</param>
        <param name="bytesWritten">When this method returns, contains the number of bytes written to <paramref name="destination" />.</param>
        <summary>Tries to write the current value, in big-endian format, to a given span.</summary>
        <returns>
          <see langword="true" /> if the value was succesfully written to <paramref name="destination" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.TryWriteBigEndian(System.Span{System.Byte},System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.Int64&gt;.TryWriteLittleEndian">
      <MemberSignature Language="C#" Value="bool IBinaryInteger&lt;long&gt;.TryWriteLittleEndian (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Numerics.IBinaryInteger&lt;System.Int64&gt;.TryWriteLittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IBinaryInteger&lt;System#Int64&gt;#TryWriteLittleEndian(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Function TryWriteLittleEndian (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean Implements IBinaryInteger(Of Long).TryWriteLittleEndian" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.IBinaryInteger&lt;System.Int64&gt;.TryWriteLittleEndian : Span&lt;byte&gt; * int -&gt; bool&#xA;override this.System.Numerics.IBinaryInteger&lt;System.Int64&gt;.TryWriteLittleEndian : Span&lt;byte&gt; * int -&gt; bool" Usage="int64.System.Numerics.IBinaryInteger&lt;System.Int64&gt;.TryWriteLittleEndian (destination, bytesWritten)" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Numerics.IBinaryInteger&lt;System.Int64&gt;.TryWriteLittleEndian(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten) = System::Numerics::IBinaryInteger&lt;long&gt;::TryWriteLittleEndian;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.TryWriteLittleEndian(System.Span{System.Byte},System.Int32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="destination">The span to which the current value should be written.</param>
        <param name="bytesWritten">When this method returns, contains the number of bytes written to <paramref name="destination" />.</param>
        <summary>Tries to write the current value, in little-endian format, to a given span.</summary>
        <returns>
          <see langword="true" /> if the value was succesfully written to <paramref name="destination" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.TryWriteLittleEndian(System.Span{System.Byte},System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryNumber&lt;System.Int64&gt;.AllBitsSet">
      <MemberSignature Language="C#" Value="static long System.Numerics.IBinaryNumber&lt;System.Int64&gt;.AllBitsSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 System.Numerics.IBinaryNumber&lt;System.Int64&gt;.AllBitsSet" />
      <MemberSignature Language="DocId" Value="P:System.Int64.System#Numerics#IBinaryNumber&lt;System#Int64&gt;#AllBitsSet" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property AllBitsSet As Long Implements IBinaryNumber(Of Long).AllBitsSet" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IBinaryNumber&lt;System.Int64&gt;.AllBitsSet : int64" Usage="System.Numerics.IBinaryNumber&lt;System.Int64&gt;.AllBitsSet" />
      <MemberSignature Language="C++ CLI" Value="static property long System::Numerics::IBinaryNumber&lt;System::Int64&gt;::AllBitsSet { long get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IBinaryNumber`1.AllBitsSet</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an instance of the binary type in which all bits are set.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBitwiseOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_BitwiseAnd">
      <MemberSignature Language="C#" Value="static long IBitwiseOperators&lt;long,long,long&gt;.operator &amp; (long left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig int64 System.Numerics.IBitwiseOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_BitwiseAnd(int64 left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IBitwiseOperators&lt;System#Int64,System#Int64,System#Int64&gt;#op_BitwiseAnd(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator And (left As Long, right As Long) As Long Implements IBitwiseOperators(Of Long, Long, Long).op_BitwiseAnd" />
      <MemberSignature Language="F#" Value="static member ( &amp;&amp;&amp; ) : int64 * int64 -&gt; int64" Usage="left &amp;&amp;&amp; right" />
      <MemberSignature Language="C++ CLI" Value=" static long System.Numerics.IBitwiseOperators&lt;System.Int64,System.Int64,System.Int64&gt;.operator &amp;(long left, long right) = System::Numerics::IBitwiseOperators&lt;long, long, long&gt;::op_BitwiseAnd;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBitwiseOperators`3.op_BitwiseAnd(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Int64" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to <see langword="and" /> with <paramref name="right" />.</param>
        <param name="right">The value to <see langword="and" /> with <paramref name="left" />.</param>
        <summary>Computes the bitwise-and of two values.</summary>
        <returns>The bitwise-and of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBitwiseOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_BitwiseOr">
      <MemberSignature Language="C#" Value="static long IBitwiseOperators&lt;long,long,long&gt;.operator | (long left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig int64 System.Numerics.IBitwiseOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_BitwiseOr(int64 left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IBitwiseOperators&lt;System#Int64,System#Int64,System#Int64&gt;#op_BitwiseOr(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator Or (left As Long, right As Long) As Long Implements IBitwiseOperators(Of Long, Long, Long).op_BitwiseOr" />
      <MemberSignature Language="F#" Value="static member ( ||| ) : int64 * int64 -&gt; int64" Usage="left ||| right" />
      <MemberSignature Language="C++ CLI" Value=" static long System.Numerics.IBitwiseOperators&lt;System.Int64,System.Int64,System.Int64&gt;.operator |(long left, long right) = System::Numerics::IBitwiseOperators&lt;long, long, long&gt;::op_BitwiseOr;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBitwiseOperators`3.op_BitwiseOr(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Int64" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to <see langword="or" /> with <paramref name="right" />.</param>
        <param name="right">The value to <see langword="or" /> with <paramref name="left" />.</param>
        <summary>Computes the bitwise-or of two values.</summary>
        <returns>The bitwise-or of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBitwiseOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_ExclusiveOr">
      <MemberSignature Language="C#" Value="static long IBitwiseOperators&lt;long,long,long&gt;.operator ^ (long left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig int64 System.Numerics.IBitwiseOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_ExclusiveOr(int64 left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IBitwiseOperators&lt;System#Int64,System#Int64,System#Int64&gt;#op_ExclusiveOr(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator Xor (left As Long, right As Long) As Long Implements IBitwiseOperators(Of Long, Long, Long).op_ExclusiveOr" />
      <MemberSignature Language="F#" Value="static member ( ^^^ ) : int64 * int64 -&gt; int64" Usage="left ^^^ right" />
      <MemberSignature Language="C++ CLI" Value=" static long System.Numerics.IBitwiseOperators&lt;System.Int64,System.Int64,System.Int64&gt;.operator ^(long left, long right) = System::Numerics::IBitwiseOperators&lt;long, long, long&gt;::op_ExclusiveOr;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBitwiseOperators`3.op_ExclusiveOr(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Int64" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to xor with <paramref name="right" />.</param>
        <param name="right">The value to xor with <paramref name="left" />.</param>
        <summary>Computes the exclusive-or of two values.</summary>
        <returns>The exclusive-or of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBitwiseOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_OnesComplement">
      <MemberSignature Language="C#" Value="static long IBitwiseOperators&lt;long,long,long&gt;.operator ~ (long value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig int64 System.Numerics.IBitwiseOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_OnesComplement(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IBitwiseOperators&lt;System#Int64,System#Int64,System#Int64&gt;#op_OnesComplement(System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator Not (value As Long) As Long Implements IBitwiseOperators(Of Long, Long, Long).op_OnesComplement" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IBitwiseOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_OnesComplement : int64 -&gt; int64" Usage="System.int64.System.Numerics.IBitwiseOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_OnesComplement value" />
      <MemberSignature Language="C++ CLI" Value=" static long System.Numerics.IBitwiseOperators&lt;System.Int64,System.Int64,System.Int64&gt;.operator ~(long value) = System::Numerics::IBitwiseOperators&lt;long, long, long&gt;::op_OnesComplement;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBitwiseOperators`3.op_OnesComplement(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value for which to compute the ones-complement.</param>
        <summary>Computes the ones-complement representation of a given value.</summary>
        <returns>The ones-complement of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IComparisonOperators&lt;System.Int64,System.Int64,System.Boolean&gt;.op_GreaterThan">
      <MemberSignature Language="C#" Value="static bool IComparisonOperators&lt;long,long,bool&gt;.operator &gt; (long left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IComparisonOperators&lt;System.Int64,System.Int64,System.Boolean&gt;.op_GreaterThan(int64 left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IComparisonOperators&lt;System#Int64,System#Int64,System#Boolean&gt;#op_GreaterThan(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator &gt; (left As Long, right As Long) As Boolean Implements IComparisonOperators(Of Long, Long, Boolean).op_GreaterThan" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : int64 * int64 -&gt; bool" Usage="left &gt; right" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IComparisonOperators&lt;System.Int64,System.Int64,System.Boolean&gt;.operator &gt;(long left, long right) = System::Numerics::IComparisonOperators&lt;long, long, bool&gt;::op_GreaterThan;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IComparisonOperators`3.op_GreaterThan(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Int64" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to compare with <paramref name="right" />.</param>
        <param name="right">The value to compare with <paramref name="left" />.</param>
        <summary>Compares two values to determine which is greater.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IComparisonOperators&lt;System.Int64,System.Int64,System.Boolean&gt;.op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="static bool IComparisonOperators&lt;long,long,bool&gt;.operator &gt;= (long left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IComparisonOperators&lt;System.Int64,System.Int64,System.Boolean&gt;.op_GreaterThanOrEqual(int64 left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IComparisonOperators&lt;System#Int64,System#Int64,System#Boolean&gt;#op_GreaterThanOrEqual(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator &gt;= (left As Long, right As Long) As Boolean Implements IComparisonOperators(Of Long, Long, Boolean).op_GreaterThanOrEqual" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : int64 * int64 -&gt; bool" Usage="left &gt;= right" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IComparisonOperators&lt;System.Int64,System.Int64,System.Boolean&gt;.operator &gt;=(long left, long right) = System::Numerics::IComparisonOperators&lt;long, long, bool&gt;::op_GreaterThanOrEqual;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IComparisonOperators`3.op_GreaterThanOrEqual(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Int64" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to compare with <paramref name="right" />.</param>
        <param name="right">The value to compare with <paramref name="left" />.</param>
        <summary>Compares two values to determine which is greater or equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is greater than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IComparisonOperators&lt;System.Int64,System.Int64,System.Boolean&gt;.op_LessThan">
      <MemberSignature Language="C#" Value="static bool IComparisonOperators&lt;long,long,bool&gt;.operator &lt; (long left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IComparisonOperators&lt;System.Int64,System.Int64,System.Boolean&gt;.op_LessThan(int64 left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IComparisonOperators&lt;System#Int64,System#Int64,System#Boolean&gt;#op_LessThan(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator &lt; (left As Long, right As Long) As Boolean Implements IComparisonOperators(Of Long, Long, Boolean).op_LessThan" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : int64 * int64 -&gt; bool" Usage="left &lt; right" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IComparisonOperators&lt;System.Int64,System.Int64,System.Boolean&gt;.operator &lt;(long left, long right) = System::Numerics::IComparisonOperators&lt;long, long, bool&gt;::op_LessThan;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IComparisonOperators`3.op_LessThan(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Int64" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to compare with <paramref name="right" />.</param>
        <param name="right">The value to compare with <paramref name="left" />.</param>
        <summary>Compares two values to determine which is less.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IComparisonOperators&lt;System.Int64,System.Int64,System.Boolean&gt;.op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="static bool IComparisonOperators&lt;long,long,bool&gt;.operator &lt;= (long left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IComparisonOperators&lt;System.Int64,System.Int64,System.Boolean&gt;.op_LessThanOrEqual(int64 left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IComparisonOperators&lt;System#Int64,System#Int64,System#Boolean&gt;#op_LessThanOrEqual(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator &lt;= (left As Long, right As Long) As Boolean Implements IComparisonOperators(Of Long, Long, Boolean).op_LessThanOrEqual" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : int64 * int64 -&gt; bool" Usage="left &lt;= right" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IComparisonOperators&lt;System.Int64,System.Int64,System.Boolean&gt;.operator &lt;=(long left, long right) = System::Numerics::IComparisonOperators&lt;long, long, bool&gt;::op_LessThanOrEqual;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IComparisonOperators`3.op_LessThanOrEqual(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Int64" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to compare with <paramref name="right" />.</param>
        <param name="right">The value to compare with <paramref name="left" />.</param>
        <summary>Compares two values to determine which is less or equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IDecrementOperators&lt;System.Int64&gt;.op_CheckedDecrement">
      <MemberSignature Language="C#" Value="static long IDecrementOperators&lt;long&gt;.op_CheckedDecrement (long value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig int64 System.Numerics.IDecrementOperators&lt;System.Int64&gt;.op_CheckedDecrement(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IDecrementOperators&lt;System#Int64&gt;#op_CheckedDecrement(System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_CheckedDecrement (value As Long) As Long Implements IDecrementOperators(Of Long).op_CheckedDecrement" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IDecrementOperators&lt;System.Int64&gt;.op_CheckedDecrement : int64 -&gt; int64" Usage="System.int64.System.Numerics.IDecrementOperators&lt;System.Int64&gt;.op_CheckedDecrement value" />
      <MemberSignature Language="C++ CLI" Value=" static long System.Numerics.IDecrementOperators&lt;System.Int64&gt;.op_CheckedDecrement(long value) = System::Numerics::IDecrementOperators&lt;long&gt;::op_CheckedDecrement;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IDecrementOperators`1.op_CheckedDecrement(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to decrement.</param>
        <summary>Decrements a value.</summary>
        <returns>The result of decrementing <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IDecrementOperators&lt;System.Int64&gt;.op_Decrement">
      <MemberSignature Language="C#" Value="static long IDecrementOperators&lt;long&gt;.operator -- (long value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig int64 System.Numerics.IDecrementOperators&lt;System.Int64&gt;.op_Decrement(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IDecrementOperators&lt;System#Int64&gt;#op_Decrement(System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_Decrement (value As Long) As Long Implements IDecrementOperators(Of Long).op_Decrement" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IDecrementOperators&lt;System.Int64&gt;.op_Decrement : int64 -&gt; int64" Usage="System.int64.System.Numerics.IDecrementOperators&lt;System.Int64&gt;.op_Decrement value" />
      <MemberSignature Language="C++ CLI" Value=" static long System.Numerics.IDecrementOperators&lt;System.Int64&gt;.operator --(long value) = System::Numerics::IDecrementOperators&lt;long&gt;::op_Decrement;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IDecrementOperators`1.op_Decrement(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to decrement.</param>
        <summary>Decrements a value.</summary>
        <returns>The result of decrementing <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IDivisionOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_Division">
      <MemberSignature Language="C#" Value="static long IDivisionOperators&lt;long,long,long&gt;.operator / (long left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig int64 System.Numerics.IDivisionOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_Division(int64 left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IDivisionOperators&lt;System#Int64,System#Int64,System#Int64&gt;#op_Division(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator / (left As Long, right As Long) As Long Implements IDivisionOperators(Of Long, Long, Long).op_Division" />
      <MemberSignature Language="F#" Value="static member ( / ) : int64 * int64 -&gt; int64" Usage="left / right" />
      <MemberSignature Language="C++ CLI" Value=" static long System.Numerics.IDivisionOperators&lt;System.Int64,System.Int64,System.Int64&gt;.operator /(long left, long right) = System::Numerics::IDivisionOperators&lt;long, long, long&gt;::op_Division;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IDivisionOperators`3.op_Division(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Int64" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value that <paramref name="right" /> divides.</param>
        <param name="right">The value that divides <paramref name="left" />.</param>
        <summary>Divides one value by another to compute their quotient.</summary>
        <returns>The quotient of <paramref name="left" /> divided by <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IEqualityOperators&lt;System.Int64,System.Int64,System.Boolean&gt;.op_Equality">
      <MemberSignature Language="C#" Value="static bool IEqualityOperators&lt;long,long,bool&gt;.operator == (long left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IEqualityOperators&lt;System.Int64,System.Int64,System.Boolean&gt;.op_Equality(int64 left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IEqualityOperators&lt;System#Int64,System#Int64,System#Boolean&gt;#op_Equality(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator == (left As Long, right As Long) As Boolean Implements IEqualityOperators(Of Long, Long, Boolean).op_Equality" />
      <MemberSignature Language="F#" Value="static member ( = ) : int64 * int64 -&gt; bool" Usage="left = right" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IEqualityOperators&lt;System.Int64,System.Int64,System.Boolean&gt;.operator ==(long left, long right) = System::Numerics::IEqualityOperators&lt;long, long, bool&gt;::op_Equality;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Int64" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to compare with <paramref name="right" />.</param>
        <param name="right">The value to compare with <paramref name="left" />.</param>
        <summary>Compares two values to determine equality.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IEqualityOperators&lt;System.Int64,System.Int64,System.Boolean&gt;.op_Inequality">
      <MemberSignature Language="C#" Value="static bool IEqualityOperators&lt;long,long,bool&gt;.operator != (long left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IEqualityOperators&lt;System.Int64,System.Int64,System.Boolean&gt;.op_Inequality(int64 left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IEqualityOperators&lt;System#Int64,System#Int64,System#Boolean&gt;#op_Inequality(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator != (left As Long, right As Long) As Boolean Implements IEqualityOperators(Of Long, Long, Boolean).op_Inequality" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IEqualityOperators&lt;System.Int64,System.Int64,System.Boolean&gt;.op_Inequality : int64 * int64 -&gt; bool" Usage="System.int64.System.Numerics.IEqualityOperators&lt;System.Int64,System.Int64,System.Boolean&gt;.op_Inequality (left, right)" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IEqualityOperators&lt;System.Int64,System.Int64,System.Boolean&gt;.operator !=(long left, long right) = System::Numerics::IEqualityOperators&lt;long, long, bool&gt;::op_Inequality;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Int64" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to compare with <paramref name="right" />.</param>
        <param name="right">The value to compare with <paramref name="left" />.</param>
        <summary>Compares two values to determine inequality.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IIncrementOperators&lt;System.Int64&gt;.op_CheckedIncrement">
      <MemberSignature Language="C#" Value="static long IIncrementOperators&lt;long&gt;.op_CheckedIncrement (long value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig int64 System.Numerics.IIncrementOperators&lt;System.Int64&gt;.op_CheckedIncrement(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IIncrementOperators&lt;System#Int64&gt;#op_CheckedIncrement(System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_CheckedIncrement (value As Long) As Long Implements IIncrementOperators(Of Long).op_CheckedIncrement" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IIncrementOperators&lt;System.Int64&gt;.op_CheckedIncrement : int64 -&gt; int64" Usage="System.int64.System.Numerics.IIncrementOperators&lt;System.Int64&gt;.op_CheckedIncrement value" />
      <MemberSignature Language="C++ CLI" Value=" static long System.Numerics.IIncrementOperators&lt;System.Int64&gt;.op_CheckedIncrement(long value) = System::Numerics::IIncrementOperators&lt;long&gt;::op_CheckedIncrement;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IIncrementOperators`1.op_CheckedIncrement(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to increment.</param>
        <summary>Increments a value.</summary>
        <returns>The result of incrementing <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IIncrementOperators&lt;System.Int64&gt;.op_Increment">
      <MemberSignature Language="C#" Value="static long IIncrementOperators&lt;long&gt;.operator ++ (long value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig int64 System.Numerics.IIncrementOperators&lt;System.Int64&gt;.op_Increment(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IIncrementOperators&lt;System#Int64&gt;#op_Increment(System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_Increment (value As Long) As Long Implements IIncrementOperators(Of Long).op_Increment" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IIncrementOperators&lt;System.Int64&gt;.op_Increment : int64 -&gt; int64" Usage="System.int64.System.Numerics.IIncrementOperators&lt;System.Int64&gt;.op_Increment value" />
      <MemberSignature Language="C++ CLI" Value=" static long System.Numerics.IIncrementOperators&lt;System.Int64&gt;.operator ++(long value) = System::Numerics::IIncrementOperators&lt;long&gt;::op_Increment;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IIncrementOperators`1.op_Increment(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to increment.</param>
        <summary>Increments a value.</summary>
        <returns>The result of incrementing <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IMinMaxValue&lt;System.Int64&gt;.MaxValue">
      <MemberSignature Language="C#" Value="static long System.Numerics.IMinMaxValue&lt;System.Int64&gt;.MaxValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 System.Numerics.IMinMaxValue&lt;System.Int64&gt;.MaxValue" />
      <MemberSignature Language="DocId" Value="P:System.Int64.System#Numerics#IMinMaxValue&lt;System#Int64&gt;#MaxValue" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property MaxValue As Long Implements IMinMaxValue(Of Long).MaxValue" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IMinMaxValue&lt;System.Int64&gt;.MaxValue : int64" Usage="System.Numerics.IMinMaxValue&lt;System.Int64&gt;.MaxValue" />
      <MemberSignature Language="C++ CLI" Value="static property long System::Numerics::IMinMaxValue&lt;System::Int64&gt;::MaxValue { long get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IMinMaxValue`1.MaxValue</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum value of the current type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IMinMaxValue&lt;System.Int64&gt;.MinValue">
      <MemberSignature Language="C#" Value="static long System.Numerics.IMinMaxValue&lt;System.Int64&gt;.MinValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 System.Numerics.IMinMaxValue&lt;System.Int64&gt;.MinValue" />
      <MemberSignature Language="DocId" Value="P:System.Int64.System#Numerics#IMinMaxValue&lt;System#Int64&gt;#MinValue" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property MinValue As Long Implements IMinMaxValue(Of Long).MinValue" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IMinMaxValue&lt;System.Int64&gt;.MinValue : int64" Usage="System.Numerics.IMinMaxValue&lt;System.Int64&gt;.MinValue" />
      <MemberSignature Language="C++ CLI" Value="static property long System::Numerics::IMinMaxValue&lt;System::Int64&gt;::MinValue { long get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IMinMaxValue`1.MinValue</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the minimum value of the current type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IModulusOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_Modulus">
      <MemberSignature Language="C#" Value="static long IModulusOperators&lt;long,long,long&gt;.operator % (long left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig int64 System.Numerics.IModulusOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_Modulus(int64 left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IModulusOperators&lt;System#Int64,System#Int64,System#Int64&gt;#op_Modulus(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator Mod (left As Long, right As Long) As Long Implements IModulusOperators(Of Long, Long, Long).op_Modulus" />
      <MemberSignature Language="F#" Value="static member ( % ) : int64 * int64 -&gt; int64" Usage="left % right" />
      <MemberSignature Language="C++ CLI" Value=" static long System.Numerics.IModulusOperators&lt;System.Int64,System.Int64,System.Int64&gt;.operator %(long left, long right) = System::Numerics::IModulusOperators&lt;long, long, long&gt;::op_Modulus;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IModulusOperators`3.op_Modulus(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Int64" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value that <paramref name="right" /> divides.</param>
        <param name="right">The value that divides <paramref name="left" />.</param>
        <summary>Divides two values together to compute their modulus or remainder.</summary>
        <returns>The modulus or remainder of <paramref name="left" /> divided by <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IMultiplicativeIdentity&lt;System.Int64,System.Int64&gt;.MultiplicativeIdentity">
      <MemberSignature Language="C#" Value="static long System.Numerics.IMultiplicativeIdentity&lt;System.Int64,System.Int64&gt;.MultiplicativeIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 System.Numerics.IMultiplicativeIdentity&lt;System.Int64,System.Int64&gt;.MultiplicativeIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Int64.System#Numerics#IMultiplicativeIdentity&lt;System#Int64,System#Int64&gt;#MultiplicativeIdentity" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property MultiplicativeIdentity As Long Implements IMultiplicativeIdentity(Of Long, Long).MultiplicativeIdentity" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IMultiplicativeIdentity&lt;System.Int64,System.Int64&gt;.MultiplicativeIdentity : int64" Usage="System.Numerics.IMultiplicativeIdentity&lt;System.Int64,System.Int64&gt;.MultiplicativeIdentity" />
      <MemberSignature Language="C++ CLI" Value="static property long System::Numerics::IMultiplicativeIdentity&lt;System::Int64,System::Int64&gt;::MultiplicativeIdentity { long get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IMultiplicativeIdentity`2.MultiplicativeIdentity</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the multiplicative identity of the current type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IMultiplyOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_CheckedMultiply">
      <MemberSignature Language="C#" Value="static long IMultiplyOperators&lt;long,long,long&gt;.op_CheckedMultiply (long left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig int64 System.Numerics.IMultiplyOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_CheckedMultiply(int64 left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IMultiplyOperators&lt;System#Int64,System#Int64,System#Int64&gt;#op_CheckedMultiply(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_CheckedMultiply (left As Long, right As Long) As Long Implements IMultiplyOperators(Of Long, Long, Long).op_CheckedMultiply" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IMultiplyOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_CheckedMultiply : int64 * int64 -&gt; int64" Usage="System.int64.System.Numerics.IMultiplyOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_CheckedMultiply (left, right)" />
      <MemberSignature Language="C++ CLI" Value=" static long System.Numerics.IMultiplyOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_CheckedMultiply(long left, long right) = System::Numerics::IMultiplyOperators&lt;long, long, long&gt;::op_CheckedMultiply;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IMultiplyOperators`3.op_CheckedMultiply(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Int64" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value that <paramref name="right" /> multiplies.</param>
        <param name="right">The value that multiplies <paramref name="left" />.</param>
        <summary>Multiplies two values together to compute their product.</summary>
        <returns>The product of <paramref name="left" /> multiplied by <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IMultiplyOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_Multiply">
      <MemberSignature Language="C#" Value="static long IMultiplyOperators&lt;long,long,long&gt;.operator * (long left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig int64 System.Numerics.IMultiplyOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_Multiply(int64 left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IMultiplyOperators&lt;System#Int64,System#Int64,System#Int64&gt;#op_Multiply(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator * (left As Long, right As Long) As Long Implements IMultiplyOperators(Of Long, Long, Long).op_Multiply" />
      <MemberSignature Language="F#" Value="static member ( * ) : int64 * int64 -&gt; int64" Usage="left * right" />
      <MemberSignature Language="C++ CLI" Value=" static long System.Numerics.IMultiplyOperators&lt;System.Int64,System.Int64,System.Int64&gt;.operator *(long left, long right) = System::Numerics::IMultiplyOperators&lt;long, long, long&gt;::op_Multiply;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IMultiplyOperators`3.op_Multiply(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Int64" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value that <paramref name="right" /> multiplies.</param>
        <param name="right">The value that multiplies <paramref name="left" />.</param>
        <summary>Multiplies two values together to compute their product.</summary>
        <returns>The product of <paramref name="left" /> multiplied by <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumber&lt;System.Int64&gt;.MaxNumber">
      <MemberSignature Language="C#" Value="static long INumber&lt;long&gt;.MaxNumber (long x, long y);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig int64 System.Numerics.INumber&lt;System.Int64&gt;.MaxNumber(int64 x, int64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#INumber&lt;System#Int64&gt;#MaxNumber(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function MaxNumber (x As Long, y As Long) As Long Implements INumber(Of Long).MaxNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumber&lt;System.Int64&gt;.MaxNumber : int64 * int64 -&gt; int64" Usage="System.int64.System.Numerics.INumber&lt;System.Int64&gt;.MaxNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value=" static long System.Numerics.INumber&lt;System.Int64&gt;.MaxNumber(long x, long y) = System::Numerics::INumber&lt;long&gt;::MaxNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.MaxNumber(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.Int64" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is greater and returning the other value if an input is <c>NaN</c>.</summary>
        <returns>
          <paramref name="x" /> if it is greater than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumber&lt;System.Int64&gt;.MinNumber">
      <MemberSignature Language="C#" Value="static long INumber&lt;long&gt;.MinNumber (long x, long y);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig int64 System.Numerics.INumber&lt;System.Int64&gt;.MinNumber(int64 x, int64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#INumber&lt;System#Int64&gt;#MinNumber(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function MinNumber (x As Long, y As Long) As Long Implements INumber(Of Long).MinNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumber&lt;System.Int64&gt;.MinNumber : int64 * int64 -&gt; int64" Usage="System.int64.System.Numerics.INumber&lt;System.Int64&gt;.MinNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value=" static long System.Numerics.INumber&lt;System.Int64&gt;.MinNumber(long x, long y) = System::Numerics::INumber&lt;long&gt;::MinNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.MinNumber(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.Int64" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is lesser and returning the other value if an input is <c>NaN</c>.</summary>
        <returns>
          <paramref name="x" /> if it is less than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Int64&gt;.IsCanonical">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;long&gt;.IsCanonical (long value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Int64&gt;.IsCanonical(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#INumberBase&lt;System#Int64&gt;#IsCanonical(System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsCanonical (value As Long) As Boolean Implements INumberBase(Of Long).IsCanonical" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Int64&gt;.IsCanonical : int64 -&gt; bool" Usage="System.int64.System.Numerics.INumberBase&lt;System.Int64&gt;.IsCanonical value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Int64&gt;.IsCanonical(long value) = System::Numerics::INumberBase&lt;long&gt;::IsCanonical;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsCanonical(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is in its canonical representation.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is in its canonical representation; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Int64&gt;.IsComplexNumber">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;long&gt;.IsComplexNumber (long value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Int64&gt;.IsComplexNumber(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#INumberBase&lt;System#Int64&gt;#IsComplexNumber(System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsComplexNumber (value As Long) As Boolean Implements INumberBase(Of Long).IsComplexNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Int64&gt;.IsComplexNumber : int64 -&gt; bool" Usage="System.int64.System.Numerics.INumberBase&lt;System.Int64&gt;.IsComplexNumber value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Int64&gt;.IsComplexNumber(long value) = System::Numerics::INumberBase&lt;long&gt;::IsComplexNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsComplexNumber(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents a complex number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is a complex number; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Int64&gt;.IsFinite">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;long&gt;.IsFinite (long value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Int64&gt;.IsFinite(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#INumberBase&lt;System#Int64&gt;#IsFinite(System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsFinite (value As Long) As Boolean Implements INumberBase(Of Long).IsFinite" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Int64&gt;.IsFinite : int64 -&gt; bool" Usage="System.int64.System.Numerics.INumberBase&lt;System.Int64&gt;.IsFinite value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Int64&gt;.IsFinite(long value) = System::Numerics::INumberBase&lt;long&gt;::IsFinite;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsFinite(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is finite.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is finite; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Int64&gt;.IsImaginaryNumber">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;long&gt;.IsImaginaryNumber (long value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Int64&gt;.IsImaginaryNumber(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#INumberBase&lt;System#Int64&gt;#IsImaginaryNumber(System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsImaginaryNumber (value As Long) As Boolean Implements INumberBase(Of Long).IsImaginaryNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Int64&gt;.IsImaginaryNumber : int64 -&gt; bool" Usage="System.int64.System.Numerics.INumberBase&lt;System.Int64&gt;.IsImaginaryNumber value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Int64&gt;.IsImaginaryNumber(long value) = System::Numerics::INumberBase&lt;long&gt;::IsImaginaryNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsImaginaryNumber(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents a pure imaginary number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is a pure imaginary number; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Int64&gt;.IsInfinity">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;long&gt;.IsInfinity (long value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Int64&gt;.IsInfinity(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#INumberBase&lt;System#Int64&gt;#IsInfinity(System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsInfinity (value As Long) As Boolean Implements INumberBase(Of Long).IsInfinity" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Int64&gt;.IsInfinity : int64 -&gt; bool" Usage="System.int64.System.Numerics.INumberBase&lt;System.Int64&gt;.IsInfinity value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Int64&gt;.IsInfinity(long value) = System::Numerics::INumberBase&lt;long&gt;::IsInfinity;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsInfinity(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is infinite.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is infinite; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Int64&gt;.IsInteger">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;long&gt;.IsInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Int64&gt;.IsInteger(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#INumberBase&lt;System#Int64&gt;#IsInteger(System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsInteger (value As Long) As Boolean Implements INumberBase(Of Long).IsInteger" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Int64&gt;.IsInteger : int64 -&gt; bool" Usage="System.int64.System.Numerics.INumberBase&lt;System.Int64&gt;.IsInteger value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Int64&gt;.IsInteger(long value) = System::Numerics::INumberBase&lt;long&gt;::IsInteger;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsInteger(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents an integral number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an integer; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Int64&gt;.IsNaN">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;long&gt;.IsNaN (long value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Int64&gt;.IsNaN(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#INumberBase&lt;System#Int64&gt;#IsNaN(System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsNaN (value As Long) As Boolean Implements INumberBase(Of Long).IsNaN" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Int64&gt;.IsNaN : int64 -&gt; bool" Usage="System.int64.System.Numerics.INumberBase&lt;System.Int64&gt;.IsNaN value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Int64&gt;.IsNaN(long value) = System::Numerics::INumberBase&lt;long&gt;::IsNaN;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsNaN(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is NaN.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is NaN; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Int64&gt;.IsNegativeInfinity">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;long&gt;.IsNegativeInfinity (long value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Int64&gt;.IsNegativeInfinity(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#INumberBase&lt;System#Int64&gt;#IsNegativeInfinity(System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsNegativeInfinity (value As Long) As Boolean Implements INumberBase(Of Long).IsNegativeInfinity" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Int64&gt;.IsNegativeInfinity : int64 -&gt; bool" Usage="System.int64.System.Numerics.INumberBase&lt;System.Int64&gt;.IsNegativeInfinity value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Int64&gt;.IsNegativeInfinity(long value) = System::Numerics::INumberBase&lt;long&gt;::IsNegativeInfinity;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsNegativeInfinity(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is negative infinity.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is negative infinity; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Int64&gt;.IsNormal">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;long&gt;.IsNormal (long value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Int64&gt;.IsNormal(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#INumberBase&lt;System#Int64&gt;#IsNormal(System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsNormal (value As Long) As Boolean Implements INumberBase(Of Long).IsNormal" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Int64&gt;.IsNormal : int64 -&gt; bool" Usage="System.int64.System.Numerics.INumberBase&lt;System.Int64&gt;.IsNormal value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Int64&gt;.IsNormal(long value) = System::Numerics::INumberBase&lt;long&gt;::IsNormal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsNormal(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is normal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is normal; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Int64&gt;.IsPositiveInfinity">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;long&gt;.IsPositiveInfinity (long value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Int64&gt;.IsPositiveInfinity(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#INumberBase&lt;System#Int64&gt;#IsPositiveInfinity(System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsPositiveInfinity (value As Long) As Boolean Implements INumberBase(Of Long).IsPositiveInfinity" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Int64&gt;.IsPositiveInfinity : int64 -&gt; bool" Usage="System.int64.System.Numerics.INumberBase&lt;System.Int64&gt;.IsPositiveInfinity value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Int64&gt;.IsPositiveInfinity(long value) = System::Numerics::INumberBase&lt;long&gt;::IsPositiveInfinity;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsPositiveInfinity(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is positive infinity.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is positive infinity; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Int64&gt;.IsRealNumber">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;long&gt;.IsRealNumber (long value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Int64&gt;.IsRealNumber(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#INumberBase&lt;System#Int64&gt;#IsRealNumber(System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsRealNumber (value As Long) As Boolean Implements INumberBase(Of Long).IsRealNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Int64&gt;.IsRealNumber : int64 -&gt; bool" Usage="System.int64.System.Numerics.INumberBase&lt;System.Int64&gt;.IsRealNumber value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Int64&gt;.IsRealNumber(long value) = System::Numerics::INumberBase&lt;long&gt;::IsRealNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsRealNumber(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents a real number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is a real number; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Int64&gt;.IsSubnormal">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;long&gt;.IsSubnormal (long value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Int64&gt;.IsSubnormal(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#INumberBase&lt;System#Int64&gt;#IsSubnormal(System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsSubnormal (value As Long) As Boolean Implements INumberBase(Of Long).IsSubnormal" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Int64&gt;.IsSubnormal : int64 -&gt; bool" Usage="System.int64.System.Numerics.INumberBase&lt;System.Int64&gt;.IsSubnormal value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Int64&gt;.IsSubnormal(long value) = System::Numerics::INumberBase&lt;long&gt;::IsSubnormal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsSubnormal(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is subnormal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is subnormal; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Int64&gt;.IsZero">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;long&gt;.IsZero (long value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Int64&gt;.IsZero(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#INumberBase&lt;System#Int64&gt;#IsZero(System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsZero (value As Long) As Boolean Implements INumberBase(Of Long).IsZero" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Int64&gt;.IsZero : int64 -&gt; bool" Usage="System.int64.System.Numerics.INumberBase&lt;System.Int64&gt;.IsZero value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Int64&gt;.IsZero(long value) = System::Numerics::INumberBase&lt;long&gt;::IsZero;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsZero(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is zero.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is zero; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Int64&gt;.MaxMagnitudeNumber">
      <MemberSignature Language="C#" Value="static long INumberBase&lt;long&gt;.MaxMagnitudeNumber (long x, long y);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig int64 System.Numerics.INumberBase&lt;System.Int64&gt;.MaxMagnitudeNumber(int64 x, int64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#INumberBase&lt;System#Int64&gt;#MaxMagnitudeNumber(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function MaxMagnitudeNumber (x As Long, y As Long) As Long Implements INumberBase(Of Long).MaxMagnitudeNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Int64&gt;.MaxMagnitudeNumber : int64 * int64 -&gt; int64" Usage="System.int64.System.Numerics.INumberBase&lt;System.Int64&gt;.MaxMagnitudeNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value=" static long System.Numerics.INumberBase&lt;System.Int64&gt;.MaxMagnitudeNumber(long x, long y) = System::Numerics::INumberBase&lt;long&gt;::MaxMagnitudeNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.MaxMagnitudeNumber(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.Int64" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which has the greater magnitude and returning the other value if an input is <c>NaN</c>.</summary>
        <returns>
          <paramref name="x" /> if it is greater than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Int64&gt;.MinMagnitudeNumber">
      <MemberSignature Language="C#" Value="static long INumberBase&lt;long&gt;.MinMagnitudeNumber (long x, long y);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig int64 System.Numerics.INumberBase&lt;System.Int64&gt;.MinMagnitudeNumber(int64 x, int64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#INumberBase&lt;System#Int64&gt;#MinMagnitudeNumber(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function MinMagnitudeNumber (x As Long, y As Long) As Long Implements INumberBase(Of Long).MinMagnitudeNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Int64&gt;.MinMagnitudeNumber : int64 * int64 -&gt; int64" Usage="System.int64.System.Numerics.INumberBase&lt;System.Int64&gt;.MinMagnitudeNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value=" static long System.Numerics.INumberBase&lt;System.Int64&gt;.MinMagnitudeNumber(long x, long y) = System::Numerics::INumberBase&lt;long&gt;::MinMagnitudeNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.MinMagnitudeNumber(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.Int64" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which has the lesser magnitude and returning the other value if an input is <c>NaN</c>.</summary>
        <returns>
          <paramref name="x" /> if it is less than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Int64&gt;.One">
      <MemberSignature Language="C#" Value="static long System.Numerics.INumberBase&lt;System.Int64&gt;.One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 System.Numerics.INumberBase&lt;System.Int64&gt;.One" />
      <MemberSignature Language="DocId" Value="P:System.Int64.System#Numerics#INumberBase&lt;System#Int64&gt;#One" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property One As Long Implements INumberBase(Of Long).One" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Int64&gt;.One : int64" Usage="System.Numerics.INumberBase&lt;System.Int64&gt;.One" />
      <MemberSignature Language="C++ CLI" Value="static property long System::Numerics::INumberBase&lt;System::Int64&gt;::One { long get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.INumberBase`1.One</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value <c>1</c> for the type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Int64&gt;.Radix">
      <MemberSignature Language="C#" Value="static int System.Numerics.INumberBase&lt;System.Int64&gt;.Radix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 System.Numerics.INumberBase&lt;System.Int64&gt;.Radix" />
      <MemberSignature Language="DocId" Value="P:System.Int64.System#Numerics#INumberBase&lt;System#Int64&gt;#Radix" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property Radix As Integer Implements INumberBase(Of Long).Radix" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Int64&gt;.Radix : int" Usage="System.Numerics.INumberBase&lt;System.Int64&gt;.Radix" />
      <MemberSignature Language="C++ CLI" Value="static property int System::Numerics::INumberBase&lt;System::Int64&gt;::Radix { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.INumberBase`1.Radix</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the radix, or base, for the type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Int64&gt;.TryConvertToChecked&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;long&gt;.TryConvertToChecked&lt;TOther&gt; (long value, out TOther result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Int64&gt;.TryConvertToChecked&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(int64 value, [out] !!TOther&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#INumberBase&lt;System#Int64&gt;#TryConvertToChecked``1(System.Int64,``0@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertToChecked(Of TOther As INumberBase(Of TOther)) (value As Long, ByRef result As TOther) As Boolean Implements INumberBase(Of Long).TryConvertToChecked" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Int64&gt;.TryConvertToChecked : int64 * 'Other -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.int64.System.Numerics.INumberBase&lt;System.Int64&gt;.TryConvertToChecked (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;System.Int64&gt;.TryConvertToChecked(long value, [Runtime::InteropServices::Out] TOther % result) = System::Numerics::INumberBase&lt;long&gt;::TryConvertToChecked;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.TryConvertToChecked``1(`0,``0@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="TOther" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type to which <paramref name="value" /> should be converted.</typeparam>
        <param name="value">The value that's used to create the instance of <typeparamref name="TOther" />.</param>
        <param name="result">When this method returns, contains an instance of <typeparamref name="TOther" /> converted from <paramref name="value" />.</param>
        <summary>Tries to convert an instance of the the current type to another type, throwing an overflow exception for any values that fall outside the representable range of the current type.</summary>
        <returns>
          <see langword="false" /> if <typeparamref name="TOther" /> is not supported; otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Int64&gt;.TryConvertToSaturating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;long&gt;.TryConvertToSaturating&lt;TOther&gt; (long value, out TOther result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Int64&gt;.TryConvertToSaturating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(int64 value, [out] !!TOther&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#INumberBase&lt;System#Int64&gt;#TryConvertToSaturating``1(System.Int64,``0@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertToSaturating(Of TOther As INumberBase(Of TOther)) (value As Long, ByRef result As TOther) As Boolean Implements INumberBase(Of Long).TryConvertToSaturating" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Int64&gt;.TryConvertToSaturating : int64 * 'Other -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.int64.System.Numerics.INumberBase&lt;System.Int64&gt;.TryConvertToSaturating (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;System.Int64&gt;.TryConvertToSaturating(long value, [Runtime::InteropServices::Out] TOther % result) = System::Numerics::INumberBase&lt;long&gt;::TryConvertToSaturating;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.TryConvertToSaturating``1(`0,``0@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="TOther" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type to which <paramref name="value" /> should be converted.</typeparam>
        <param name="value">The value that's used to create the instance of <typeparamref name="TOther" />.</param>
        <param name="result">When this method returns, contains an instance of <typeparamref name="TOther" /> converted from <paramref name="value" />.</param>
        <summary>Tries to convert an instance of the the current type to another type, saturating any values that fall outside the representable range of the current type.</summary>
        <returns>
          <see langword="false" /> if <typeparamref name="TOther" /> is not supported; otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Int64&gt;.TryConvertToTruncating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;long&gt;.TryConvertToTruncating&lt;TOther&gt; (long value, out TOther result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Int64&gt;.TryConvertToTruncating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(int64 value, [out] !!TOther&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#INumberBase&lt;System#Int64&gt;#TryConvertToTruncating``1(System.Int64,``0@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertToTruncating(Of TOther As INumberBase(Of TOther)) (value As Long, ByRef result As TOther) As Boolean Implements INumberBase(Of Long).TryConvertToTruncating" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Int64&gt;.TryConvertToTruncating : int64 * 'Other -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.int64.System.Numerics.INumberBase&lt;System.Int64&gt;.TryConvertToTruncating (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;System.Int64&gt;.TryConvertToTruncating(long value, [Runtime::InteropServices::Out] TOther % result) = System::Numerics::INumberBase&lt;long&gt;::TryConvertToTruncating;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.TryConvertToTruncating``1(`0,``0@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="TOther" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type to which <paramref name="value" /> should be converted.</typeparam>
        <param name="value">The value that's used to create the instance of <typeparamref name="TOther" />.</param>
        <param name="result">When this method returns, contains an instance of <typeparamref name="TOther" /> converted from <paramref name="value" />.</param>
        <summary>Tries to convert an instance of the the current type to another type, truncating any values that fall outside the representable range of the current type.</summary>
        <returns>
          <see langword="false" /> if <typeparamref name="TOther" /> is not supported; otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Int64&gt;.TryConvertFromChecked&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;long&gt;.TryConvertFromChecked&lt;TOther&gt; (TOther value, out long result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Int64&gt;.TryConvertFromChecked&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value, [out] int64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#INumberBase&lt;System#Int64&gt;#TryConvertFromChecked``1(``0,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertFromChecked(Of TOther As INumberBase(Of TOther)) (value As TOther, ByRef result As Long) As Boolean Implements INumberBase(Of Long).TryConvertFromChecked" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Int64&gt;.TryConvertFromChecked : 'Other * int64 -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.int64.System.Numerics.INumberBase&lt;System.Int64&gt;.TryConvertFromChecked (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;System.Int64&gt;.TryConvertFromChecked(TOther value, [Runtime::InteropServices::Out] long % result) = System::Numerics::INumberBase&lt;long&gt;::TryConvertFromChecked;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.Int64" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">To be added.</typeparam>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Int64&gt;.TryConvertFromSaturating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;long&gt;.TryConvertFromSaturating&lt;TOther&gt; (TOther value, out long result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Int64&gt;.TryConvertFromSaturating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value, [out] int64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#INumberBase&lt;System#Int64&gt;#TryConvertFromSaturating``1(``0,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertFromSaturating(Of TOther As INumberBase(Of TOther)) (value As TOther, ByRef result As Long) As Boolean Implements INumberBase(Of Long).TryConvertFromSaturating" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Int64&gt;.TryConvertFromSaturating : 'Other * int64 -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.int64.System.Numerics.INumberBase&lt;System.Int64&gt;.TryConvertFromSaturating (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;System.Int64&gt;.TryConvertFromSaturating(TOther value, [Runtime::InteropServices::Out] long % result) = System::Numerics::INumberBase&lt;long&gt;::TryConvertFromSaturating;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.Int64" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">To be added.</typeparam>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Int64&gt;.TryConvertFromTruncating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;long&gt;.TryConvertFromTruncating&lt;TOther&gt; (TOther value, out long result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Int64&gt;.TryConvertFromTruncating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value, [out] int64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#INumberBase&lt;System#Int64&gt;#TryConvertFromTruncating``1(``0,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertFromTruncating(Of TOther As INumberBase(Of TOther)) (value As TOther, ByRef result As Long) As Boolean Implements INumberBase(Of Long).TryConvertFromTruncating" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Int64&gt;.TryConvertFromTruncating : 'Other * int64 -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.int64.System.Numerics.INumberBase&lt;System.Int64&gt;.TryConvertFromTruncating (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;System.Int64&gt;.TryConvertFromTruncating(TOther value, [Runtime::InteropServices::Out] long % result) = System::Numerics::INumberBase&lt;long&gt;::TryConvertFromTruncating;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.Int64" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">To be added.</typeparam>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Int64&gt;.Zero">
      <MemberSignature Language="C#" Value="static long System.Numerics.INumberBase&lt;System.Int64&gt;.Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 System.Numerics.INumberBase&lt;System.Int64&gt;.Zero" />
      <MemberSignature Language="DocId" Value="P:System.Int64.System#Numerics#INumberBase&lt;System#Int64&gt;#Zero" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property Zero As Long Implements INumberBase(Of Long).Zero" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Int64&gt;.Zero : int64" Usage="System.Numerics.INumberBase&lt;System.Int64&gt;.Zero" />
      <MemberSignature Language="C++ CLI" Value="static property long System::Numerics::INumberBase&lt;System::Int64&gt;::Zero { long get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.INumberBase`1.Zero</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value <c>0</c> for the type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IShiftOperators&lt;System.Int64,System.Int32,System.Int64&gt;.op_LeftShift">
      <MemberSignature Language="C#" Value="static long IShiftOperators&lt;long,int,long&gt;.operator &lt;&lt; (long value, int shiftAmount);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig int64 System.Numerics.IShiftOperators&lt;System.Int64,System.Int32,System.Int64&gt;.op_LeftShift(int64 value, int32 shiftAmount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IShiftOperators&lt;System#Int64,System#Int32,System#Int64&gt;#op_LeftShift(System.Int64,System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator &lt;&lt; (value As Long, shiftAmount As Integer) As Long Implements IShiftOperators(Of Long, Integer, Long).op_LeftShift" />
      <MemberSignature Language="F#" Value="static member ( &lt;&lt;&lt; ) : int64 * int -&gt; int64" Usage="value &lt;&lt;&lt; shiftAmount" />
      <MemberSignature Language="C++ CLI" Value=" static long System.Numerics.IShiftOperators&lt;System.Int64,System.Int32,System.Int64&gt;.operator &lt;&lt;(long value, int shiftAmount) = System::Numerics::IShiftOperators&lt;long, int, long&gt;::op_LeftShift;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IShiftOperators`3.op_LeftShift(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="shiftAmount" Type="System.Int32" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value that is shifted left by <paramref name="shiftAmount" />.</param>
        <param name="shiftAmount">The amount by which <paramref name="value" /> is shifted left.</param>
        <summary>Shifts a value left by a given amount.</summary>
        <returns>The result of shifting <paramref name="value" /> left by <paramref name="shiftAmount" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IShiftOperators&lt;System.Int64,System.Int32,System.Int64&gt;.op_RightShift">
      <MemberSignature Language="C#" Value="static long IShiftOperators&lt;long,int,long&gt;.operator &gt;&gt; (long value, int shiftAmount);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig int64 System.Numerics.IShiftOperators&lt;System.Int64,System.Int32,System.Int64&gt;.op_RightShift(int64 value, int32 shiftAmount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IShiftOperators&lt;System#Int64,System#Int32,System#Int64&gt;#op_RightShift(System.Int64,System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator &gt;&gt; (value As Long, shiftAmount As Integer) As Long Implements IShiftOperators(Of Long, Integer, Long).op_RightShift" />
      <MemberSignature Language="F#" Value="static member ( &gt;&gt;&gt; ) : int64 * int -&gt; int64" Usage="value &gt;&gt;&gt; shiftAmount" />
      <MemberSignature Language="C++ CLI" Value=" static long System.Numerics.IShiftOperators&lt;System.Int64,System.Int32,System.Int64&gt;.operator &gt;&gt;(long value, int shiftAmount) = System::Numerics::IShiftOperators&lt;long, int, long&gt;::op_RightShift;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IShiftOperators`3.op_RightShift(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="shiftAmount" Type="System.Int32" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value that is shifted right by <paramref name="shiftAmount" />.</param>
        <param name="shiftAmount">The amount by which <paramref name="value" /> is shifted right.</param>
        <summary>Shifts a value right by a given amount.</summary>
        <returns>The result of shifting <paramref name="value" /> right by <paramref name="shiftAmount" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IShiftOperators&lt;System.Int64,System.Int32,System.Int64&gt;.op_UnsignedRightShift">
      <MemberSignature Language="C#" Value="static long IShiftOperators&lt;long,int,long&gt;.op_UnsignedRightShift (long value, int shiftAmount);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig int64 System.Numerics.IShiftOperators&lt;System.Int64,System.Int32,System.Int64&gt;.op_UnsignedRightShift(int64 value, int32 shiftAmount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IShiftOperators&lt;System#Int64,System#Int32,System#Int64&gt;#op_UnsignedRightShift(System.Int64,System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_UnsignedRightShift (value As Long, shiftAmount As Integer) As Long Implements IShiftOperators(Of Long, Integer, Long).op_UnsignedRightShift" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IShiftOperators&lt;System.Int64,System.Int32,System.Int64&gt;.op_UnsignedRightShift : int64 * int -&gt; int64" Usage="System.int64.System.Numerics.IShiftOperators&lt;System.Int64,System.Int32,System.Int64&gt;.op_UnsignedRightShift (value, shiftAmount)" />
      <MemberSignature Language="C++ CLI" Value=" static long System.Numerics.IShiftOperators&lt;System.Int64,System.Int32,System.Int64&gt;.op_UnsignedRightShift(long value, int shiftAmount) = System::Numerics::IShiftOperators&lt;long, int, long&gt;::op_UnsignedRightShift;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IShiftOperators`3.op_UnsignedRightShift(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="shiftAmount" Type="System.Int32" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value that is shifted right by <paramref name="shiftAmount" />.</param>
        <param name="shiftAmount">The amount by which <paramref name="value" /> is shifted right.</param>
        <summary>Shifts a value right by a given amount.</summary>
        <returns>The result of shifting <paramref name="value" /> right by <paramref name="shiftAmount" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.ISignedNumber&lt;System.Int64&gt;.NegativeOne">
      <MemberSignature Language="C#" Value="static long System.Numerics.ISignedNumber&lt;System.Int64&gt;.NegativeOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 System.Numerics.ISignedNumber&lt;System.Int64&gt;.NegativeOne" />
      <MemberSignature Language="DocId" Value="P:System.Int64.System#Numerics#ISignedNumber&lt;System#Int64&gt;#NegativeOne" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property NegativeOne As Long Implements ISignedNumber(Of Long).NegativeOne" />
      <MemberSignature Language="F#" Value="static member System.Numerics.ISignedNumber&lt;System.Int64&gt;.NegativeOne : int64" Usage="System.Numerics.ISignedNumber&lt;System.Int64&gt;.NegativeOne" />
      <MemberSignature Language="C++ CLI" Value="static property long System::Numerics::ISignedNumber&lt;System::Int64&gt;::NegativeOne { long get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.ISignedNumber`1.NegativeOne</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value <c>-1</c> for the type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.ISubtractionOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_CheckedSubtraction">
      <MemberSignature Language="C#" Value="static long ISubtractionOperators&lt;long,long,long&gt;.op_CheckedSubtraction (long left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig int64 System.Numerics.ISubtractionOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_CheckedSubtraction(int64 left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#ISubtractionOperators&lt;System#Int64,System#Int64,System#Int64&gt;#op_CheckedSubtraction(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_CheckedSubtraction (left As Long, right As Long) As Long Implements ISubtractionOperators(Of Long, Long, Long).op_CheckedSubtraction" />
      <MemberSignature Language="F#" Value="static member System.Numerics.ISubtractionOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_CheckedSubtraction : int64 * int64 -&gt; int64" Usage="System.int64.System.Numerics.ISubtractionOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_CheckedSubtraction (left, right)" />
      <MemberSignature Language="C++ CLI" Value=" static long System.Numerics.ISubtractionOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_CheckedSubtraction(long left, long right) = System::Numerics::ISubtractionOperators&lt;long, long, long&gt;::op_CheckedSubtraction;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ISubtractionOperators`3.op_CheckedSubtraction(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Int64" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value from which <paramref name="right" /> is subtracted.</param>
        <param name="right">The value that's subtracted from <paramref name="left" />.</param>
        <summary>Subtracts two values to compute their difference.</summary>
        <returns>The value of <paramref name="right" /> subtracted from <paramref name="left" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.ISubtractionOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_Subtraction">
      <MemberSignature Language="C#" Value="static long ISubtractionOperators&lt;long,long,long&gt;.operator - (long left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig int64 System.Numerics.ISubtractionOperators&lt;System.Int64,System.Int64,System.Int64&gt;.op_Subtraction(int64 left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#ISubtractionOperators&lt;System#Int64,System#Int64,System#Int64&gt;#op_Subtraction(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator - (left As Long, right As Long) As Long Implements ISubtractionOperators(Of Long, Long, Long).op_Subtraction" />
      <MemberSignature Language="F#" Value="static member ( - ) : int64 * int64 -&gt; int64" Usage="left - right" />
      <MemberSignature Language="C++ CLI" Value=" static long System.Numerics.ISubtractionOperators&lt;System.Int64,System.Int64,System.Int64&gt;.operator -(long left, long right) = System::Numerics::ISubtractionOperators&lt;long, long, long&gt;::op_Subtraction;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ISubtractionOperators`3.op_Subtraction(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Int64" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value from which <paramref name="right" /> is subtracted.</param>
        <param name="right">The value that's subtracted from <paramref name="left" />.</param>
        <summary>Subtracts two values to compute their difference.</summary>
        <returns>The value of <paramref name="right" /> subtracted from <paramref name="left" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IUnaryNegationOperators&lt;System.Int64,System.Int64&gt;.op_CheckedUnaryNegation">
      <MemberSignature Language="C#" Value="static long IUnaryNegationOperators&lt;long,long&gt;.op_CheckedUnaryNegation (long value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig int64 System.Numerics.IUnaryNegationOperators&lt;System.Int64,System.Int64&gt;.op_CheckedUnaryNegation(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IUnaryNegationOperators&lt;System#Int64,System#Int64&gt;#op_CheckedUnaryNegation(System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_CheckedUnaryNegation (value As Long) As Long Implements IUnaryNegationOperators(Of Long, Long).op_CheckedUnaryNegation" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IUnaryNegationOperators&lt;System.Int64,System.Int64&gt;.op_CheckedUnaryNegation : int64 -&gt; int64" Usage="System.int64.System.Numerics.IUnaryNegationOperators&lt;System.Int64,System.Int64&gt;.op_CheckedUnaryNegation value" />
      <MemberSignature Language="C++ CLI" Value=" static long System.Numerics.IUnaryNegationOperators&lt;System.Int64,System.Int64&gt;.op_CheckedUnaryNegation(long value) = System::Numerics::IUnaryNegationOperators&lt;long, long&gt;::op_CheckedUnaryNegation;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IUnaryNegationOperators`2.op_CheckedUnaryNegation(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value for which to compute the unary negation.</param>
        <summary>Computes the checked unary negation of a value.</summary>
        <returns>The unary negation of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IUnaryNegationOperators&lt;System.Int64,System.Int64&gt;.op_UnaryNegation">
      <MemberSignature Language="C#" Value="static long IUnaryNegationOperators&lt;long,long&gt;.operator - (long value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig int64 System.Numerics.IUnaryNegationOperators&lt;System.Int64,System.Int64&gt;.op_UnaryNegation(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IUnaryNegationOperators&lt;System#Int64,System#Int64&gt;#op_UnaryNegation(System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator - (value As Long) As Long Implements IUnaryNegationOperators(Of Long, Long).op_UnaryNegation" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : int64 -&gt; int64" Usage="- value" />
      <MemberSignature Language="C++ CLI" Value=" static long System.Numerics.IUnaryNegationOperators&lt;System.Int64,System.Int64&gt;.operator -(long value) = System::Numerics::IUnaryNegationOperators&lt;long, long&gt;::op_UnaryNegation;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IUnaryNegationOperators`2.op_UnaryNegation(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value for which to compute the unary negation.</param>
        <summary>Computes the unary negation of a value.</summary>
        <returns>The unary negation of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IUnaryPlusOperators&lt;System.Int64,System.Int64&gt;.op_UnaryPlus">
      <MemberSignature Language="C#" Value="static long IUnaryPlusOperators&lt;long,long&gt;.operator + (long value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig int64 System.Numerics.IUnaryPlusOperators&lt;System.Int64,System.Int64&gt;.op_UnaryPlus(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.System#Numerics#IUnaryPlusOperators&lt;System#Int64,System#Int64&gt;#op_UnaryPlus(System.Int64)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator + (value As Long) As Long Implements IUnaryPlusOperators(Of Long, Long).op_UnaryPlus" />
      <MemberSignature Language="F#" Value="static member ( ~+ ) : int64 -&gt; int64" Usage="+ value" />
      <MemberSignature Language="C++ CLI" Value=" static long System.Numerics.IUnaryPlusOperators&lt;System.Int64,System.Int64&gt;.operator +(long value) = System::Numerics::IUnaryPlusOperators&lt;long, long&gt;::op_UnaryPlus;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IUnaryPlusOperators`2.op_UnaryPlus(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value for which to compute the unary plus.</param>
        <summary>Computes the unary plus of a value.</summary>
        <returns>The unary plus of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converts the numeric value of this instance to its equivalent string representation.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="int64.ToString " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converts the numeric value of this instance to its equivalent string representation.</summary>
        <returns>The string representation of the value of this instance, consisting of a minus sign if the value is negative, and a sequence of digits ranging from 0 to 9 with no leading zeroes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Int64.ToString> method formats an <xref:System.Int64> value in the default ("G", or general) format by using the <xref:System.Globalization.NumberFormatInfo> object of the current culture. If you want to specify a different format or culture, use the other overloads of the <xref:System.Int64.ToString%2A> method, as follows:

|To use format|For culture|Use the overload|
|-------------------|-----------------|----------------------|
|Default ("G") format|A specific culture|<xref:System.Int64.ToString%28System.IFormatProvider%29>|
|A specific format|Default (current) culture|<xref:System.Int64.ToString%28System.String%29>|
|A specific format|A specific culture|<xref:System.Int64.ToString%28System.String%2CSystem.IFormatProvider%29>|

.NET provides extensive formatting support, which is described in greater detail in the following formatting topics:

-   For more information about numeric format specifiers, see [Standard Numeric Format Strings](/dotnet/standard/base-types/standard-numeric-format-strings) and [Custom Numeric Format Strings](/dotnet/standard/base-types/custom-numeric-format-strings).

-   For more information about formatting, see [Formatting Types](/dotnet/standard/base-types/formatting-types).



## Examples
 The following example displays an <xref:System.Int64> value using the default <xref:System.Int64.ToString> method. It also displays the string representations of the <xref:System.Int64> value that results from using a number of standard format specifiers. The examples are displayed using the formatting conventions of the en-US culture.

 :::code language="csharp" source="~/snippets/csharp/System/Int64/ToString/ToString.cs" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Int64.ToString/fs/ToString.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Int64.ToString/vb/ToString.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.Int64.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">Formatting Types in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Int64.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="int64.ToString provider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider? provider);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1">M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">An <see cref="T:System.IFormatProvider" /> that supplies culture-specific formatting information.</param>
        <summary>Converts the numeric value of this instance to its equivalent string representation using the specified culture-specific format information.</summary>
        <returns>The string representation of the value of this instance as specified by <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Int64.ToString%28System.IFormatProvider%29> method formats an <xref:System.Int64> value in the default ("G", or general) format by using the <xref:System.Globalization.NumberFormatInfo> object of a specified culture. If you want to specify a different format or the current culture, use the other overloads of the <xref:System.Int64.ToString%2A> method, as follows:

|To use format|For culture|Use the overload|
|-------------------|-----------------|----------------------|
|Default ("G") format|Default (current) culture|<xref:System.Int64.ToString>|
|A specific format|Default (current) culture|<xref:System.Int64.ToString%28System.String%29>|
|A specific format|A specific culture|<xref:System.Int64.ToString%28System.String%2CSystem.IFormatProvider%29>|

 The `provider` parameter is an object that implements the <xref:System.IFormatProvider> interface. Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the string that is returned by this method. The object that implements <xref:System.IFormatProvider> can be any of the following:

-   A <xref:System.Globalization.CultureInfo> object that represents the culture whose formatting rules are to be used.

-   A <xref:System.Globalization.NumberFormatInfo> object that contains specific numeric formatting information for this value.

-   A custom object that implements <xref:System.IFormatProvider> and whose <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides formatting information.

 If `provider` is `null` or a <xref:System.Globalization.NumberFormatInfo> object cannot be obtained from `provider`, the return value is formatted with the <xref:System.Globalization.NumberFormatInfo> object for the current culture.

.NET provides extensive formatting support, which is described in greater detail in the following formatting topics:

-   For more information about numeric format specifiers, see [Standard Numeric Format Strings](/dotnet/standard/base-types/standard-numeric-format-strings) and [Custom Numeric Format Strings](/dotnet/standard/base-types/custom-numeric-format-strings).

-   For more information about formatting, see [Formatting Types](/dotnet/standard/base-types/formatting-types).



## Examples
 The following example displays the string representation of an <xref:System.Int64> value using <xref:System.Globalization.CultureInfo> objects that represent several different cultures.

 :::code language="csharp" source="~/snippets/csharp/System/Int64/ToString/ToString.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Int64.ToString/fs/ToString.fs" id="Snippet2":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Int64.ToString/vb/ToString.vb" id="Snippet2":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.Int64.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">Formatting Types in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="int64.ToString format" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="C#" Value="public string ToString (string? format);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String">
          <Attributes>
            <Attribute FrameworkAlternate="net-7.0;net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">A numeric format string.</param>
        <summary>Converts the numeric value of this instance to its equivalent string representation, using the specified format.</summary>
        <returns>The string representation of the value of this instance as specified by <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Int64.ToString%28System.String%29> method formats an <xref:System.Int64> value in a specified format by using a <xref:System.Globalization.NumberFormatInfo> object that represents the conventions of the current culture. If you want to use the default ("G", or general) format or specify a different culture, use the other overloads of the <xref:System.Int64.ToString%2A> method, as follows:

|To use format|For culture|Use the overload|
|-------------------|-----------------|----------------------|
|Default ("G") format|Default (current) culture|<xref:System.Int64.ToString>|
|Default ("G") format|A specific culture|<xref:System.Int64.ToString%28System.IFormatProvider%29>|
|A specific format|A specific culture|<xref:System.Int64.ToString%28System.String%2CSystem.IFormatProvider%29>|

 The `format` parameter can be any valid standard numeric format specifier except for "R", as well as any combination of custom numeric format specifiers. If `format` is `null` or an empty string (""), the return value of this instance is formatted with the general numeric format specifier ("G").

.NET provides extensive formatting support, which is described in greater detail in the following formatting topics:

-   For more information about numeric format specifiers, [Standard Numeric Format Strings](/dotnet/standard/base-types/standard-numeric-format-strings) and [Custom Numeric Format Strings](/dotnet/standard/base-types/custom-numeric-format-strings).

-   For more information about formatting, see [Formatting Types](/dotnet/standard/base-types/formatting-types).

 The return value of this instance is formatted with the <xref:System.Globalization.NumberFormatInfo> for the current culture.



## Examples
 The following example displays an <xref:System.Int64> value using each of the supported standard numeric format specifiers together with two custom numeric format strings. In converting the numeric values to strings, the example uses the formatting conventions of the en-US culture.

 :::code language="csharp" source="~/snippets/csharp/System/Int64/ToString/ToString.cs" id="Snippet3":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Int64.ToString/fs/ToString.fs" id="Snippet3":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Int64.ToString/vb/ToString.vb" id="Snippet3":::

 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> is invalid or not supported.</exception>
        <altmember cref="M:System.Int64.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">Formatting Types in .NET</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">Standard Numeric Format Strings</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">Custom Numeric Format Strings</related>
        <related type="Article" href="/dotnet/standard/base-types/how-to-pad-a-number-with-leading-zeros">How to: Pad a Number with Leading Zeros</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="int64.ToString (format, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="C#" Value="public string ToString (string? format, IFormatProvider? provider);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String">
          <Attributes>
            <Attribute FrameworkAlternate="net-7.0;net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">A numeric format string.</param>
        <param name="provider">An object that supplies culture-specific formatting information about this instance.</param>
        <summary>Converts the numeric value of this instance to its equivalent string representation using the specified format and culture-specific format information.</summary>
        <returns>The string representation of the value of this instance as specified by <paramref name="format" /> and <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Int64.ToString%28System.String%2CSystem.IFormatProvider%29> method formats an <xref:System.Int64> value in a specified format by using the <xref:System.Globalization.NumberFormatInfo> object of a specified culture. If you want to use default format or culture settings, use the other overloads of the <xref:System.Int64.ToString%2A> method, as follows:

|To use format|For culture|Use the overload|
|-------------------|-----------------|----------------------|
|Default ("G") format|Default (current) culture|<xref:System.Int64.ToString>|
|Default ("G") format|A specific culture|<xref:System.Int64.ToString%28System.IFormatProvider%29>|
|A specific format|Default (current) culture|<xref:System.Int64.ToString%28System.String%29>|

 The `format` parameter can be either a standard or a custom numeric format string. All standard numeric format strings other than "R" (or "r") are supported, as are all custom numeric format characters. If `format` is `null` or an empty string (""), the return value for this instance is formatted with the general numeric format specifier ("G").

 The `provider` parameter is an object that implements the <xref:System.IFormatProvider> interface. Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the string that is returned by this method. The object that implements <xref:System.IFormatProvider> can be any of the following:

-   A <xref:System.Globalization.CultureInfo> object that represents the culture whose formatting rules are to be used.

-   A <xref:System.Globalization.NumberFormatInfo> object that contains specific numeric formatting information for this value.

-   A custom object that implements <xref:System.IFormatProvider> and whose <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides formatting information.

 If `provider` is `null` or a <xref:System.Globalization.NumberFormatInfo> object cannot be obtained from `provider`, the return value for this instance is formatted with the <xref:System.Globalization.NumberFormatInfo> for the current culture.

.NET provides extensive formatting support, which is described in greater detail in the following formatting topics:

-   For more information about numeric format specifiers, see [Standard Numeric Format Strings](/dotnet/standard/base-types/standard-numeric-format-strings) and [Custom Numeric Format Strings](/dotnet/standard/base-types/custom-numeric-format-strings).

-   For more information about formatting, see [Formatting Types](/dotnet/standard/base-types/formatting-types).



## Examples
 The following example displays a positive and a negative value using each of the supported standard numeric format specifiers for three different cultures.

 :::code language="csharp" source="~/snippets/csharp/System/Int64/ToString/ToString.cs" interactive="try-dotnet-method" id="Snippet4":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Int64.ToString/fs/ToString.fs" id="Snippet4":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Int64.ToString/vb/ToString.vb" id="Snippet4":::

 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> is invalid or not supported.</exception>
        <altmember cref="M:System.Int64.Parse(System.String)" />
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">Formatting Types in .NET</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">Standard Numeric Format Strings</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">Custom Numeric Format Strings</related>
        <related type="Article" href="/dotnet/standard/base-types/how-to-pad-a-number-with-leading-zeros">How to: Pad a Number with Leading Zeros</related>
        <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/windowsforms-formatting-utility-cs/">Sample: .NET Core WinForms Formatting Utility (C#)</related>
        <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/windowsforms-formatting-utility-vb/">Sample: .NET Core WinForms Formatting Utility (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TrailingZeroCount">
      <MemberSignature Language="C#" Value="public static long TrailingZeroCount (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 TrailingZeroCount(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.TrailingZeroCount(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrailingZeroCount (value As Long) As Long" />
      <MemberSignature Language="F#" Value="static member TrailingZeroCount : int64 -&gt; int64" Usage="System.int64.TrailingZeroCount value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long TrailingZeroCount(long value) = System::Numerics::IBinaryInteger&lt;long&gt;::TrailingZeroCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.TrailingZeroCount(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value whose trailing zeroes are to be counted.</param>
        <summary>Computes the number of trailing zeros in a value.</summary>
        <returns>The number of trailing zeros in <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.TrailingZeroCount(`0)" />
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;byte&gt; utf8Destination, out int bytesWritten, ReadOnlySpan&lt;char&gt; format = default, IFormatProvider? provider = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryFormat(valuetype System.Span`1&lt;unsigned int8&gt; utf8Destination, [out] int32&amp; bytesWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.TryFormat(System.Span{System.Byte},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (utf8Destination As Span(Of Byte), ByRef bytesWritten As Integer, Optional format As ReadOnlySpan(Of Char) = Nothing, Optional provider As IFormatProvider = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member TryFormat : Span&lt;byte&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool&#xA;override this.TryFormat : Span&lt;byte&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="int64.TryFormat (utf8Destination, bytesWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.System#IUtf8SpanFormattable#TryFormat(System.Span{System.Byte},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)</InterfaceMember>
        <InterfaceMember FrameworkAlternate="net-9.0">M:System.IUtf8SpanFormattable.TryFormat(System.Span{System.Byte},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="utf8Destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.IUtf8SpanFormattable.TryFormat(System.Span{System.Byte},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default, IFormatProvider? provider = default);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Int64.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = Nothing, Optional provider As IFormatProvider = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="int64.TryFormat (destination, charsWritten, format, provider)" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0" />
      <MemberSignature Language="F#" Value="abstract member TryFormat : Span&lt;char&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool&#xA;override this.TryFormat : Span&lt;char&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="int64.TryFormat (destination, charsWritten, format, provider)" FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0" />
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default, IFormatProvider provider = default);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0">M:System.ISpanFormattable.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-7.0;net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="destination">The span in which to write this instance's value formatted as a span of characters.</param>
        <param name="charsWritten">When this method returns, contains the number of characters that were written in <paramref name="destination" />.</param>
        <param name="format">A span containing the characters that represent a standard or custom format string that defines the acceptable format for <paramref name="destination" />.</param>
        <param name="provider">An optional object that supplies culture-specific formatting information for <paramref name="destination" />.</param>
        <summary>Tries to format the value of the current long number instance into the provided span of characters.</summary>
        <returns>
          <see langword="true" /> if the formatting was successful; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
      <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">Standard numeric format strings</related>
      <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">Custom numeric format strings</related>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converts the string representation of a number to its 64-bit signed integer equivalent. A return value indicates whether the conversion succeeded or failed.</summary>
        <altmember cref="Overload:System.Int64.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;byte&gt; utf8Text, out long result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Text, [out] int64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.TryParse(System.ReadOnlySpan{System.Byte},System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (utf8Text As ReadOnlySpan(Of Byte), ByRef result As Long) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;byte&gt; * int64 -&gt; bool" Usage="System.int64.TryParse (utf8Text, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;System::Byte&gt; utf8Text, [Runtime::InteropServices::Out] long % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Text" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.Int64" RefType="out" Index="1" FrameworkAlternate="net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="utf8Text">A span containing the UTF-8 characters representing the number to convert.</param>
        <param name="result">When this method returns, contains the 64-bit signed integer value equivalent to the number contained in <paramref name="utf8Text" /> if the conversion succeeded, or zero if the conversion failed. This parameter is passed uninitialized; any value originally supplied in result will be overwritten.</param>
        <summary>Tries to convert a UTF-8 character span containing the string representation of a number to its 64-bit signed integer equivalent.</summary>
        <returns>
          <see langword="true" /> if <paramref name="utf8Text" /> was converted successfully; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out long result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] int64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.TryParse(System.ReadOnlySpan{System.Char},System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Long) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * int64 -&gt; bool" Usage="System.int64.TryParse (s, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] long % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.Int64" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="s">A span containing the characters representing the number to convert.</param>
        <param name="result">When this method returns, contains the 64-bit signed integer value equivalent of the number contained in <paramref name="s" />, if the conversion succeeded, or zero if the conversion failed. The conversion fails if the <paramref name="s" /> parameter is <see langword="null" /> or <see cref="F:System.String.Empty" />, is not of the correct format, or represents a number less than <see cref="F:System.Int64.MinValue">Int64.MinValue</see> or greater than <see cref="F:System.Int64.MaxValue">Int64.MaxValue</see>. This parameter is passed uninitialized; any value originally supplied in <paramref name="result" /> will be overwritten.</param>
        <summary>Converts the span representation of a number to its 64-bit signed integer equivalent. A return value indicates whether the conversion succeeded or failed.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was converted successfully; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out long result);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] int64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.TryParse(System.String,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Long) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : string * int64 -&gt; bool" Usage="System.int64.TryParse (s, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] long % result);" />
      <MemberSignature Language="C#" Value="public static bool TryParse (string? s, out long result);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="result" Type="System.Int64" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">A string containing a number to convert.</param>
        <param name="result">When this method returns, contains the 64-bit signed integer value equivalent of the number contained in <paramref name="s" />, if the conversion succeeded, or zero if the conversion failed. The conversion fails if the <paramref name="s" /> parameter is <see langword="null" /> or <see cref="F:System.String.Empty" />, is not of the correct format, or represents a number less than <see cref="F:System.Int64.MinValue">Int64.MinValue</see> or greater than <see cref="F:System.Int64.MaxValue">Int64.MaxValue</see>. This parameter is passed uninitialized; any value originally supplied in <paramref name="result" /> will be overwritten.</param>
        <summary>Converts the string representation of a number to its 64-bit signed integer equivalent. A return value indicates whether the conversion succeeded or failed.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was converted successfully; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Int64.TryParse%2A> method is like the <xref:System.Int64.Parse%2A> method, except the <xref:System.Int64.TryParse%2A> method does not throw an exception if the conversion fails. It eliminates the need to use exception handling to test for a <xref:System.FormatException> in the event that `s` is invalid and cannot be successfully parsed.

 The `s` parameter contains a number of the form:

 [ws][sign]digits[ws]

 Elements in square brackets ([ and ]) are optional. The following table describes each element.

|Element|Description|
|-------------|-----------------|
|*ws*|An optional white space.|
|*sign*|An optional sign.|
|*digits*|A sequence of digits ranging from 0 to 9.|

 The `s` parameter is interpreted using the <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> style. In addition to the decimal digits, only leading and trailing spaces together with a leading sign are allowed. To explicitly define the style elements together with the culture-specific formatting information that can be present in `s`, use the <xref:System.Int64.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Int64%40%29> method.

 The `s` parameter is parsed using the formatting information in a <xref:System.Globalization.NumberFormatInfo> object initialized for the current system culture. For more information, see <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>.

 This overload of the <xref:System.Int64.TryParse%2A> method interprets all digits in the `s` parameter as decimal digits. To parse the string representation of a hexadecimal number, call the <xref:System.Int64.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Int64%40%29> overload.



## Examples
 The following example calls the <xref:System.Int64.TryParse%28System.String%2CSystem.Int64%40%29?displayProperty=nameWithType> method with a number of different string values.

 :::code language="csharp" source="~/snippets/csharp/System/Int64/TryParse/TryParse1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Int64.TryParse/fs/TryParse1.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Int64.TryParse/vb/TryParse1.vb" id="Snippet1":::

 Some of the strings that the <xref:System.Int64.TryParse%28System.String%2CSystem.Int64%40%29> method is unable to convert in this example are:

-   "9432.0". The conversion fails because the string cannot contain a decimal separator; it must contain integral digits only.

-   "16,667". The conversion fails because the string cannot contain group separators; it must contain integral digits only.

-   "(100)". The conversion fails because the string cannot contain a negative sign other than the one defined by the current culture's <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> and <xref:System.Globalization.NumberFormatInfo.NumberNegativePattern%2A?displayProperty=nameWithType> properties.

-   "01FA". The conversion fails because the string cannot contain hexadecimal digits; it must contain decimal digits only.

 ]]></format>
        </remarks>
        <altmember cref="M:System.Int64.Parse(System.String)" />
        <altmember cref="M:System.Int64.ToString" />
        <related type="Article" href="/dotnet/standard/base-types/parsing-numeric">Parsing Numeric Strings in .NET</related>
        <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/windowsforms-formatting-utility-cs/">Sample: .NET Core WinForms Formatting Utility (C#)</related>
        <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/windowsforms-formatting-utility-vb/">Sample: .NET Core WinForms Formatting Utility (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;byte&gt; utf8Text, IFormatProvider? provider, out long result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Text, class System.IFormatProvider provider, [out] int64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.TryParse(System.ReadOnlySpan{System.Byte},System.IFormatProvider,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (utf8Text As ReadOnlySpan(Of Byte), provider As IFormatProvider, ByRef result As Long) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;byte&gt; * IFormatProvider * int64 -&gt; bool" Usage="System.int64.TryParse (utf8Text, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;System::Byte&gt; utf8Text, IFormatProvider ^ provider, [Runtime::InteropServices::Out] long % result) = IUtf8SpanParsable&lt;long&gt;::TryParse;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Text" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="result" Type="System.Int64" RefType="out" Index="2" FrameworkAlternate="net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="utf8Text">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.IUtf8SpanParsable`1.TryParse(System.ReadOnlySpan{System.Byte},System.IFormatProvider,`0@)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider, out long result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, class System.IFormatProvider provider, [out] int64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), provider As IFormatProvider, ByRef result As Long) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * IFormatProvider * int64 -&gt; bool" Usage="System.int64.TryParse (s, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider ^ provider, [Runtime::InteropServices::Out] long % result) = ISpanParsable&lt;long&gt;::TryParse;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="result" Type="System.Int64" RefType="out" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="s">The span of characters to parse.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <param name="result">When this method returns, contains the result of successfully parsing <paramref name="s" />, or an undefined value on failure.</param>
        <summary>Tries to parse a span of characters into a value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was successfully parsed; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.ISpanParsable`1.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,`0@)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string? s, IFormatProvider? provider, out long result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, class System.IFormatProvider provider, [out] int64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.TryParse(System.String,System.IFormatProvider,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, provider As IFormatProvider, ByRef result As Long) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : string * IFormatProvider * int64 -&gt; bool" Usage="System.int64.TryParse (s, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, IFormatProvider ^ provider, [Runtime::InteropServices::Out] long % result) = IParsable&lt;long&gt;::TryParse;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.Int64" RefType="out" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="s">The string to parse.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <param name="result">When this method returns, contains the result of successfully parsing <paramref name="s" /> or an undefined value on failure.</param>
        <summary>Tries to parse a string into a value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was successfully parsed; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.IParsable`1.TryParse(System.String,System.IFormatProvider,`0@)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;byte&gt; utf8Text, System.Globalization.NumberStyles style, IFormatProvider? provider, out long result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Text, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] int64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.TryParse(System.ReadOnlySpan{System.Byte},System.Globalization.NumberStyles,System.IFormatProvider,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (utf8Text As ReadOnlySpan(Of Byte), style As NumberStyles, provider As IFormatProvider, ByRef result As Long) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;byte&gt; * System.Globalization.NumberStyles * IFormatProvider * int64 -&gt; bool" Usage="System.int64.TryParse (utf8Text, style, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;System::Byte&gt; utf8Text, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] long % result) = System::Numerics::INumberBase&lt;long&gt;::TryParse;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Text" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="result" Type="System.Int64" RefType="out" Index="3" FrameworkAlternate="net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="utf8Text">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.TryParse(System.ReadOnlySpan{System.Byte},System.Globalization.NumberStyles,System.IFormatProvider,`0@)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider? provider, out long result);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] int64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Long) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider * int64 -&gt; bool" Usage="System.int64.TryParse (s, style, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] long % result);" FrameworkAlternate="net-5.0;net-6.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] long % result) = System::Numerics::INumberBase&lt;long&gt;::TryParse;" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out long result);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="result" Type="System.Int64" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="s">A span containing the characters representing the number to convert. The span is interpreted using the style specified by <paramref name="style" />.</param>
        <param name="style">A bitwise combination of enumeration values that indicates the style elements that can be present in <paramref name="s" />. A typical value to specify is <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <param name="provider">An object that supplies culture-specific formatting information about <paramref name="s" />.</param>
        <param name="result">When this method returns, contains the 64-bit signed integer value equivalent of the number contained in <paramref name="s" />, if the conversion succeeded, or zero if the conversion failed. The conversion fails if the <paramref name="s" /> parameter is <see langword="null" /> or <see cref="F:System.String.Empty" />, is not in a format compliant with <paramref name="style" />, or represents a number less than <see cref="F:System.Int64.MinValue">Int64.MinValue</see> or greater than <see cref="F:System.Int64.MaxValue">Int64.MaxValue</see>. This parameter is passed uninitialized; any value originally supplied in <paramref name="result" /> will be overwritten.</param>
        <summary>Converts the span representation of a number in a specified style and culture-specific format to its 64-bit signed integer equivalent. A return value indicates whether the conversion succeeded or failed.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was converted successfully; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out long result);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] int64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Int64.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Long) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider * int64 -&gt; bool" Usage="System.int64.TryParse (s, style, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] long % result);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public static bool TryParse (string? s, System.Globalization.NumberStyles style, IFormatProvider? provider, out long result);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] long % result) = System::Numerics::INumberBase&lt;long&gt;::TryParse;" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.Int64" RefType="out" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">A string containing a number to convert. The string is interpreted using the style specified by <paramref name="style" />.</param>
        <param name="style">A bitwise combination of enumeration values that indicates the style elements that can be present in <paramref name="s" />. A typical value to specify is <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <param name="provider">An object that supplies culture-specific formatting information about <paramref name="s" />.</param>
        <param name="result">When this method returns, contains the 64-bit signed integer value equivalent of the number contained in <paramref name="s" />, if the conversion succeeded, or zero if the conversion failed. The conversion fails if the <paramref name="s" /> parameter is <see langword="null" /> or <see cref="F:System.String.Empty" />, is not in a format compliant with <paramref name="style" />, or represents a number less than <see cref="F:System.Int64.MinValue">Int64.MinValue</see> or greater than <see cref="F:System.Int64.MaxValue">Int64.MaxValue</see>. This parameter is passed uninitialized; any value originally supplied in <paramref name="result" /> will be overwritten.</param>
        <summary>Converts the string representation of a number in a specified style and culture-specific format to its 64-bit signed integer equivalent. A return value indicates whether the conversion succeeded or failed.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was converted successfully; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Int64.TryParse%2A> method is like the <xref:System.Int64.Parse%2A> method, except the <xref:System.Int64.TryParse%2A> method does not throw an exception if the conversion fails. It eliminates the need to use exception handling to test for a <xref:System.FormatException> in the event that `s` is invalid and cannot be parsed successfully.

 The `style` parameter defines the style elements (such as white space or a positive or negative sign) that are allowed in the `s` parameter for the parse operation to succeed. It must be a combination of bit flags from the <xref:System.Globalization.NumberStyles> enumeration. Depending on the value of `style`,the `s` parameter may include the following elements:

 [ws][$][sign][digits,]digits[.fractional_digits][e[sign]exponential_digits][ws]

 Or, if the `style` parameter includes <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>:

 [ws]hexdigits[ws]

 Elements in square brackets ([ and ]) are optional. The following table describes each element.

|Element|Description|
|-------------|-----------------|
|*ws*|Optional white space. White space can appear at the beginning of `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flag, or at the end of `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flag.|
|*$*|A culture-specific currency symbol. Its position in the string is defined by the <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A> property of the <xref:System.Globalization.NumberFormatInfo> object returned by the <xref:System.IFormatProvider.GetFormat%2A> method of the `provider` parameter. The currency symbol can appear in `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flag.|
|*sign*|An optional sign. A sign symbol can appear in `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> or <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flags.|
|*digits*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|A sequence of digits from 0 through 9. For *fractional_digits*, only the digit 0 is valid.|
|*,*|A culture-specific thousands separator. The thousands separator of the culture specified by `provider` can appear in `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> flag.|
|*.*|A culture-specific decimal point symbol. The decimal point symbol of the culture specified by `provider` can appear in `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.|
|*e*|The 'e' or 'E' character, which indicates that the value is represented in exponential notation. The `s` parameter can represent a number in exponential notation if `style` includes the <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.|
|*hexdigits*|A sequence of hexadecimal digits from 0 through f, or 0 through F.|

> [!NOTE]
> Any terminating NUL (U+0000) characters in `s` are ignored by the parsing operation, regardless of the value of the `style` argument.

 A string with decimal digits only (which corresponds to the <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> flag) always parses successfully. Most of the remaining <xref:System.Globalization.NumberStyles> members control elements that may be but are not required to be present in this input string. The following table indicates how individual <xref:System.Globalization.NumberStyles> members affect the elements that may be present in `s`.

|Non-composite NumberStyles values|Elements permitted in s in addition to digits|
|----------------------------------------|---------------------------------------------------|
|<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>|Decimal digits only.|
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>|The decimal point ( *.* ) and *fractional_digits* elements. However, *fractional_digits* must consist of only one or more 0 digits or the method returns `false`.|
|<xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>|The `s` parameter can also use exponential notation. The `s` parameter must represent an integer within the range of the <xref:System.Int64> data type without a non-zero fractional component.|
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>|The *ws* element at the beginning of `s`.|
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>|The *ws* element at the end of `s`.|
|<xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>|A sign can appear before *digits*.|
|<xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>|A sign can appear after *digits*.|
|<xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>|The *sign* element in the form of parentheses enclosing the numeric value.|
|<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>|The thousands separator ( *,* ) element.|
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>|The *$* element.|
|<xref:System.Globalization.NumberStyles.Currency?displayProperty=nameWithType>|All elements. The `s` parameter cannot represent a hexadecimal number or a number in exponential notation.|
|<xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType>|The *ws* element at the beginning or end of `s`, *sign* at the beginning of `s`, and the decimal point ( *.* ) symbol. The `s` parameter can also use exponential notation.|
|<xref:System.Globalization.NumberStyles.Number?displayProperty=nameWithType>|The *ws*, *sign*, thousands separator (*,*), and decimal point (*.*) elements.|
|<xref:System.Globalization.NumberStyles.Any?displayProperty=nameWithType>|All styles, except `s` cannot represent a hexadecimal number.|

 If the <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> flag is used, `s` must be a hexadecimal value without a prefix. For example, "C9AF3" parses successfully, but "0xC9AF3" does not. The only other flags that can be present in `style` are <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> and <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (The <xref:System.Globalization.NumberStyles> enumeration has a composite style, <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>, that includes both white space flags.)

 The `provider` parameter is an <xref:System.IFormatProvider> implementation, such as a <xref:System.Globalization.CultureInfo> object or a <xref:System.Globalization.NumberFormatInfo> object, whose <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object. The <xref:System.Globalization.NumberFormatInfo> object provides culture-specific information about the format of `s`. If `provider` is `null`, the <xref:System.Globalization.NumberFormatInfo> object for the current culture is used.



## Examples
 The following example calls the <xref:System.Int64.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Int64%40%29> method with a number of different string and <xref:System.Globalization.NumberStyles> values.

 :::code language="csharp" source="~/snippets/csharp/System/Int64/TryParse/TryParse2.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Int64.TryParse/fs/TryParse2.fs" id="Snippet2":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Int64.TryParse/vb/TryParse2.vb" id="Snippet2":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> is not a <see cref="T:System.Globalization.NumberStyles" /> value.

 -or-

 <paramref name="style" /> is not a combination of <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="F:System.Globalization.NumberStyles.HexNumber" /> values.</exception>
        <altmember cref="M:System.Int64.Parse(System.String)" />
        <altmember cref="M:System.Int64.ToString" />
        <related type="Article" href="/dotnet/standard/base-types/parsing-numeric">Parsing Numeric Strings in .NET</related>
      </Docs>
    </Member>
  </Members>
</Type>
