<Type Name="Byte" FullName="System.Byte">
  <TypeSignature Language="C#" Value="public struct Byte : IComparable, IComparable&lt;byte&gt;, IConvertible, IEquatable&lt;byte&gt;, IFormattable" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit unsigned int8 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;unsigned int8&gt;, class System.IConvertible, class System.IEquatable`1&lt;unsigned int8&gt;, class System.IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Byte" />
  <TypeSignature Language="VB.NET" Value="Public Structure Byte&#xA;Implements IComparable, IComparable(Of Byte), IConvertible, IEquatable(Of Byte), IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="F#" Value="type byte = struct&#xA;    interface IConvertible&#xA;    interface IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="C++ CLI" Value="public value class System::Byte : IComparable, IComparable&lt;System::Byte&gt;, IConvertible, IEquatable&lt;System::Byte&gt;, IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="C#" Value="public readonly struct Byte : IComparable, IComparable&lt;byte&gt;, IConvertible, IEquatable&lt;byte&gt;, IFormattable" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1" />
  <TypeSignature Language="C#" Value="public readonly struct Byte : IComparable, IComparable&lt;byte&gt;, IConvertible, IEquatable&lt;byte&gt;, ISpanFormattable" FrameworkAlternate="net-6.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit unsigned int8 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;unsigned int8&gt;, class System.IConvertible, class System.IEquatable`1&lt;unsigned int8&gt;, class System.IFormattable, class System.ISpanFormattable" FrameworkAlternate="net-6.0" />
  <TypeSignature Language="VB.NET" Value="Public Structure Byte&#xA;Implements IComparable, IComparable(Of Byte), IConvertible, IEquatable(Of Byte), ISpanFormattable" FrameworkAlternate="net-6.0" />
  <TypeSignature Language="F#" Value="type byte = struct&#xA;    interface IConvertible&#xA;    interface ISpanFormattable&#xA;    interface IFormattable" FrameworkAlternate="net-6.0" />
  <TypeSignature Language="C++ CLI" Value="public value class System::Byte : IComparable, IComparable&lt;System::Byte&gt;, IConvertible, IEquatable&lt;System::Byte&gt;, ISpanFormattable" FrameworkAlternate="net-6.0" />
  <TypeSignature Language="C#" Value="public readonly struct Byte : IComparable&lt;byte&gt;, IConvertible, IEquatable&lt;byte&gt;, IParsable&lt;byte&gt;, ISpanParsable&lt;byte&gt;, System.Numerics.IAdditionOperators&lt;byte,byte,byte&gt;, System.Numerics.IAdditiveIdentity&lt;byte,byte&gt;, System.Numerics.IBinaryInteger&lt;byte&gt;, System.Numerics.IBinaryNumber&lt;byte&gt;, System.Numerics.IBitwiseOperators&lt;byte,byte,byte&gt;, System.Numerics.IComparisonOperators&lt;byte,byte,bool&gt;, System.Numerics.IDecrementOperators&lt;byte&gt;, System.Numerics.IDivisionOperators&lt;byte,byte,byte&gt;, System.Numerics.IEqualityOperators&lt;byte,byte,bool&gt;, System.Numerics.IIncrementOperators&lt;byte&gt;, System.Numerics.IMinMaxValue&lt;byte&gt;, System.Numerics.IModulusOperators&lt;byte,byte,byte&gt;, System.Numerics.IMultiplicativeIdentity&lt;byte,byte&gt;, System.Numerics.IMultiplyOperators&lt;byte,byte,byte&gt;, System.Numerics.INumber&lt;byte&gt;, System.Numerics.INumberBase&lt;byte&gt;, System.Numerics.IShiftOperators&lt;byte,int,byte&gt;, System.Numerics.ISubtractionOperators&lt;byte,byte,byte&gt;, System.Numerics.IUnaryNegationOperators&lt;byte,byte&gt;, System.Numerics.IUnaryPlusOperators&lt;byte,byte&gt;, System.Numerics.IUnsignedNumber&lt;byte&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit unsigned int8 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;unsigned int8&gt;, class System.IConvertible, class System.IEquatable`1&lt;unsigned int8&gt;, class System.IFormattable, class System.IParsable`1&lt;unsigned int8&gt;, class System.ISpanFormattable, class System.ISpanParsable`1&lt;unsigned int8&gt;, class System.Numerics.IAdditionOperators`3&lt;unsigned int8, unsigned int8, unsigned int8&gt;, class System.Numerics.IAdditiveIdentity`2&lt;unsigned int8, unsigned int8&gt;, class System.Numerics.IBinaryInteger`1&lt;unsigned int8&gt;, class System.Numerics.IBinaryNumber`1&lt;unsigned int8&gt;, class System.Numerics.IBitwiseOperators`3&lt;unsigned int8, unsigned int8, unsigned int8&gt;, class System.Numerics.IComparisonOperators`3&lt;unsigned int8, unsigned int8, bool&gt;, class System.Numerics.IDecrementOperators`1&lt;unsigned int8&gt;, class System.Numerics.IDivisionOperators`3&lt;unsigned int8, unsigned int8, unsigned int8&gt;, class System.Numerics.IEqualityOperators`3&lt;unsigned int8, unsigned int8, bool&gt;, class System.Numerics.IIncrementOperators`1&lt;unsigned int8&gt;, class System.Numerics.IMinMaxValue`1&lt;unsigned int8&gt;, class System.Numerics.IModulusOperators`3&lt;unsigned int8, unsigned int8, unsigned int8&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;unsigned int8, unsigned int8&gt;, class System.Numerics.IMultiplyOperators`3&lt;unsigned int8, unsigned int8, unsigned int8&gt;, class System.Numerics.INumber`1&lt;unsigned int8&gt;, class System.Numerics.INumberBase`1&lt;unsigned int8&gt;, class System.Numerics.IShiftOperators`3&lt;unsigned int8, int32, unsigned int8&gt;, class System.Numerics.ISubtractionOperators`3&lt;unsigned int8, unsigned int8, unsigned int8&gt;, class System.Numerics.IUnaryNegationOperators`2&lt;unsigned int8, unsigned int8&gt;, class System.Numerics.IUnaryPlusOperators`2&lt;unsigned int8, unsigned int8&gt;, class System.Numerics.IUnsignedNumber`1&lt;unsigned int8&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="VB.NET" Value="Public Structure Byte&#xA;Implements IAdditionOperators(Of Byte, Byte, Byte), IAdditiveIdentity(Of Byte, Byte), IBinaryInteger(Of Byte), IBinaryNumber(Of Byte), IBitwiseOperators(Of Byte, Byte, Byte), IComparable(Of Byte), IComparisonOperators(Of Byte, Byte, Boolean), IConvertible, IDecrementOperators(Of Byte), IDivisionOperators(Of Byte, Byte, Byte), IEqualityOperators(Of Byte, Byte, Boolean), IEquatable(Of Byte), IIncrementOperators(Of Byte), IMinMaxValue(Of Byte), IModulusOperators(Of Byte, Byte, Byte), IMultiplicativeIdentity(Of Byte, Byte), IMultiplyOperators(Of Byte, Byte, Byte), INumber(Of Byte), INumberBase(Of Byte), IParsable(Of Byte), IShiftOperators(Of Byte, Integer, Byte), ISpanParsable(Of Byte), ISubtractionOperators(Of Byte, Byte, Byte), IUnaryNegationOperators(Of Byte, Byte), IUnaryPlusOperators(Of Byte, Byte), IUnsignedNumber(Of Byte)" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="F#" Value="type byte = struct&#xA;    interface IConvertible&#xA;    interface IFormattable&#xA;    interface IParsable&lt;byte&gt;&#xA;    interface ISpanFormattable&#xA;    interface ISpanParsable&lt;byte&gt;&#xA;    interface IAdditionOperators&lt;byte, byte, byte&gt;&#xA;    interface IAdditiveIdentity&lt;byte, byte&gt;&#xA;    interface IBinaryInteger&lt;byte&gt;&#xA;    interface IBinaryNumber&lt;byte&gt;&#xA;    interface IBitwiseOperators&lt;byte, byte, byte&gt;&#xA;    interface IComparisonOperators&lt;byte, byte, bool&gt;&#xA;    interface IEqualityOperators&lt;byte, byte, bool&gt;&#xA;    interface IDecrementOperators&lt;byte&gt;&#xA;    interface IDivisionOperators&lt;byte, byte, byte&gt;&#xA;    interface IIncrementOperators&lt;byte&gt;&#xA;    interface IModulusOperators&lt;byte, byte, byte&gt;&#xA;    interface IMultiplicativeIdentity&lt;byte, byte&gt;&#xA;    interface IMultiplyOperators&lt;byte, byte, byte&gt;&#xA;    interface INumber&lt;byte&gt;&#xA;    interface INumberBase&lt;byte&gt;&#xA;    interface ISubtractionOperators&lt;byte, byte, byte&gt;&#xA;    interface IUnaryNegationOperators&lt;byte, byte&gt;&#xA;    interface IUnaryPlusOperators&lt;byte, byte&gt;&#xA;    interface IShiftOperators&lt;byte, int, byte&gt;&#xA;    interface IMinMaxValue&lt;byte&gt;&#xA;    interface IUnsignedNumber&lt;byte&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="C++ CLI" Value="public value class System::Byte : IComparable&lt;System::Byte&gt;, IConvertible, IEquatable&lt;System::Byte&gt;, IParsable&lt;System::Byte&gt;, ISpanParsable&lt;System::Byte&gt;, System::Numerics::IAdditionOperators&lt;System::Byte, System::Byte, System::Byte&gt;, System::Numerics::IAdditiveIdentity&lt;System::Byte, System::Byte&gt;, System::Numerics::IBinaryInteger&lt;System::Byte&gt;, System::Numerics::IBinaryNumber&lt;System::Byte&gt;, System::Numerics::IBitwiseOperators&lt;System::Byte, System::Byte, System::Byte&gt;, System::Numerics::IComparisonOperators&lt;System::Byte, System::Byte, bool&gt;, System::Numerics::IDecrementOperators&lt;System::Byte&gt;, System::Numerics::IDivisionOperators&lt;System::Byte, System::Byte, System::Byte&gt;, System::Numerics::IEqualityOperators&lt;System::Byte, System::Byte, bool&gt;, System::Numerics::IIncrementOperators&lt;System::Byte&gt;, System::Numerics::IMinMaxValue&lt;System::Byte&gt;, System::Numerics::IModulusOperators&lt;System::Byte, System::Byte, System::Byte&gt;, System::Numerics::IMultiplicativeIdentity&lt;System::Byte, System::Byte&gt;, System::Numerics::IMultiplyOperators&lt;System::Byte, System::Byte, System::Byte&gt;, System::Numerics::INumber&lt;System::Byte&gt;, System::Numerics::INumberBase&lt;System::Byte&gt;, System::Numerics::IShiftOperators&lt;System::Byte, int, System::Byte&gt;, System::Numerics::ISubtractionOperators&lt;System::Byte, System::Byte, System::Byte&gt;, System::Numerics::IUnaryNegationOperators&lt;System::Byte, System::Byte&gt;, System::Numerics::IUnaryPlusOperators&lt;System::Byte, System::Byte&gt;, System::Numerics::IUnsignedNumber&lt;System::Byte&gt;" FrameworkAlternate="net-7.0" />
  <TypeSignature Language="C#" Value="public readonly struct Byte : IComparable&lt;byte&gt;, IConvertible, IEquatable&lt;byte&gt;, IParsable&lt;byte&gt;, ISpanParsable&lt;byte&gt;, IUtf8SpanParsable&lt;byte&gt;, System.Numerics.IAdditionOperators&lt;byte,byte,byte&gt;, System.Numerics.IAdditiveIdentity&lt;byte,byte&gt;, System.Numerics.IBinaryInteger&lt;byte&gt;, System.Numerics.IBinaryNumber&lt;byte&gt;, System.Numerics.IBitwiseOperators&lt;byte,byte,byte&gt;, System.Numerics.IComparisonOperators&lt;byte,byte,bool&gt;, System.Numerics.IDecrementOperators&lt;byte&gt;, System.Numerics.IDivisionOperators&lt;byte,byte,byte&gt;, System.Numerics.IEqualityOperators&lt;byte,byte,bool&gt;, System.Numerics.IIncrementOperators&lt;byte&gt;, System.Numerics.IMinMaxValue&lt;byte&gt;, System.Numerics.IModulusOperators&lt;byte,byte,byte&gt;, System.Numerics.IMultiplicativeIdentity&lt;byte,byte&gt;, System.Numerics.IMultiplyOperators&lt;byte,byte,byte&gt;, System.Numerics.INumber&lt;byte&gt;, System.Numerics.INumberBase&lt;byte&gt;, System.Numerics.IShiftOperators&lt;byte,int,byte&gt;, System.Numerics.ISubtractionOperators&lt;byte,byte,byte&gt;, System.Numerics.IUnaryNegationOperators&lt;byte,byte&gt;, System.Numerics.IUnaryPlusOperators&lt;byte,byte&gt;, System.Numerics.IUnsignedNumber&lt;byte&gt;" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit unsigned int8 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;unsigned int8&gt;, class System.IConvertible, class System.IEquatable`1&lt;unsigned int8&gt;, class System.IFormattable, class System.IParsable`1&lt;unsigned int8&gt;, class System.ISpanFormattable, class System.ISpanParsable`1&lt;unsigned int8&gt;, class System.IUtf8SpanFormattable, class System.IUtf8SpanParsable`1&lt;unsigned int8&gt;, class System.Numerics.IAdditionOperators`3&lt;unsigned int8, unsigned int8, unsigned int8&gt;, class System.Numerics.IAdditiveIdentity`2&lt;unsigned int8, unsigned int8&gt;, class System.Numerics.IBinaryInteger`1&lt;unsigned int8&gt;, class System.Numerics.IBinaryNumber`1&lt;unsigned int8&gt;, class System.Numerics.IBitwiseOperators`3&lt;unsigned int8, unsigned int8, unsigned int8&gt;, class System.Numerics.IComparisonOperators`3&lt;unsigned int8, unsigned int8, bool&gt;, class System.Numerics.IDecrementOperators`1&lt;unsigned int8&gt;, class System.Numerics.IDivisionOperators`3&lt;unsigned int8, unsigned int8, unsigned int8&gt;, class System.Numerics.IEqualityOperators`3&lt;unsigned int8, unsigned int8, bool&gt;, class System.Numerics.IIncrementOperators`1&lt;unsigned int8&gt;, class System.Numerics.IMinMaxValue`1&lt;unsigned int8&gt;, class System.Numerics.IModulusOperators`3&lt;unsigned int8, unsigned int8, unsigned int8&gt;, class System.Numerics.IMultiplicativeIdentity`2&lt;unsigned int8, unsigned int8&gt;, class System.Numerics.IMultiplyOperators`3&lt;unsigned int8, unsigned int8, unsigned int8&gt;, class System.Numerics.INumber`1&lt;unsigned int8&gt;, class System.Numerics.INumberBase`1&lt;unsigned int8&gt;, class System.Numerics.IShiftOperators`3&lt;unsigned int8, int32, unsigned int8&gt;, class System.Numerics.ISubtractionOperators`3&lt;unsigned int8, unsigned int8, unsigned int8&gt;, class System.Numerics.IUnaryNegationOperators`2&lt;unsigned int8, unsigned int8&gt;, class System.Numerics.IUnaryPlusOperators`2&lt;unsigned int8, unsigned int8&gt;, class System.Numerics.IUnsignedNumber`1&lt;unsigned int8&gt;" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="VB.NET" Value="Public Structure Byte&#xA;Implements IAdditionOperators(Of Byte, Byte, Byte), IAdditiveIdentity(Of Byte, Byte), IBinaryInteger(Of Byte), IBinaryNumber(Of Byte), IBitwiseOperators(Of Byte, Byte, Byte), IComparable(Of Byte), IComparisonOperators(Of Byte, Byte, Boolean), IConvertible, IDecrementOperators(Of Byte), IDivisionOperators(Of Byte, Byte, Byte), IEqualityOperators(Of Byte, Byte, Boolean), IEquatable(Of Byte), IIncrementOperators(Of Byte), IMinMaxValue(Of Byte), IModulusOperators(Of Byte, Byte, Byte), IMultiplicativeIdentity(Of Byte, Byte), IMultiplyOperators(Of Byte, Byte, Byte), INumber(Of Byte), INumberBase(Of Byte), IParsable(Of Byte), IShiftOperators(Of Byte, Integer, Byte), ISpanParsable(Of Byte), ISubtractionOperators(Of Byte, Byte, Byte), IUnaryNegationOperators(Of Byte, Byte), IUnaryPlusOperators(Of Byte, Byte), IUnsignedNumber(Of Byte), IUtf8SpanParsable(Of Byte)" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="F#" Value="type byte = struct&#xA;    interface IConvertible&#xA;    interface IFormattable&#xA;    interface IParsable&lt;byte&gt;&#xA;    interface ISpanFormattable&#xA;    interface ISpanParsable&lt;byte&gt;&#xA;    interface IAdditionOperators&lt;byte, byte, byte&gt;&#xA;    interface IAdditiveIdentity&lt;byte, byte&gt;&#xA;    interface IBinaryInteger&lt;byte&gt;&#xA;    interface IBinaryNumber&lt;byte&gt;&#xA;    interface IBitwiseOperators&lt;byte, byte, byte&gt;&#xA;    interface IComparisonOperators&lt;byte, byte, bool&gt;&#xA;    interface IEqualityOperators&lt;byte, byte, bool&gt;&#xA;    interface IDecrementOperators&lt;byte&gt;&#xA;    interface IDivisionOperators&lt;byte, byte, byte&gt;&#xA;    interface IIncrementOperators&lt;byte&gt;&#xA;    interface IModulusOperators&lt;byte, byte, byte&gt;&#xA;    interface IMultiplicativeIdentity&lt;byte, byte&gt;&#xA;    interface IMultiplyOperators&lt;byte, byte, byte&gt;&#xA;    interface INumber&lt;byte&gt;&#xA;    interface INumberBase&lt;byte&gt;&#xA;    interface ISubtractionOperators&lt;byte, byte, byte&gt;&#xA;    interface IUnaryNegationOperators&lt;byte, byte&gt;&#xA;    interface IUnaryPlusOperators&lt;byte, byte&gt;&#xA;    interface IUtf8SpanFormattable&#xA;    interface IUtf8SpanParsable&lt;byte&gt;&#xA;    interface IShiftOperators&lt;byte, int, byte&gt;&#xA;    interface IMinMaxValue&lt;byte&gt;&#xA;    interface IUnsignedNumber&lt;byte&gt;" FrameworkAlternate="net-8.0" />
  <TypeSignature Language="C++ CLI" Value="public value class System::Byte : IComparable&lt;System::Byte&gt;, IConvertible, IEquatable&lt;System::Byte&gt;, IParsable&lt;System::Byte&gt;, ISpanParsable&lt;System::Byte&gt;, IUtf8SpanParsable&lt;System::Byte&gt;, System::Numerics::IAdditionOperators&lt;System::Byte, System::Byte, System::Byte&gt;, System::Numerics::IAdditiveIdentity&lt;System::Byte, System::Byte&gt;, System::Numerics::IBinaryInteger&lt;System::Byte&gt;, System::Numerics::IBinaryNumber&lt;System::Byte&gt;, System::Numerics::IBitwiseOperators&lt;System::Byte, System::Byte, System::Byte&gt;, System::Numerics::IComparisonOperators&lt;System::Byte, System::Byte, bool&gt;, System::Numerics::IDecrementOperators&lt;System::Byte&gt;, System::Numerics::IDivisionOperators&lt;System::Byte, System::Byte, System::Byte&gt;, System::Numerics::IEqualityOperators&lt;System::Byte, System::Byte, bool&gt;, System::Numerics::IIncrementOperators&lt;System::Byte&gt;, System::Numerics::IMinMaxValue&lt;System::Byte&gt;, System::Numerics::IModulusOperators&lt;System::Byte, System::Byte, System::Byte&gt;, System::Numerics::IMultiplicativeIdentity&lt;System::Byte, System::Byte&gt;, System::Numerics::IMultiplyOperators&lt;System::Byte, System::Byte, System::Byte&gt;, System::Numerics::INumber&lt;System::Byte&gt;, System::Numerics::INumberBase&lt;System::Byte&gt;, System::Numerics::IShiftOperators&lt;System::Byte, int, System::Byte&gt;, System::Numerics::ISubtractionOperators&lt;System::Byte, System::Byte, System::Byte&gt;, System::Numerics::IUnaryNegationOperators&lt;System::Byte, System::Byte&gt;, System::Numerics::IUnaryPlusOperators&lt;System::Byte, System::Byte&gt;, System::Numerics::IUnsignedNumber&lt;System::Byte&gt;" FrameworkAlternate="net-8.0;net-9.0" />
  <TypeSignature Language="F#" Value="type byte = struct&#xA;    interface IConvertible&#xA;    interface IFormattable&#xA;    interface IParsable&lt;byte&gt;&#xA;    interface ISpanFormattable&#xA;    interface ISpanParsable&lt;byte&gt;&#xA;    interface IUtf8SpanFormattable&#xA;    interface IUtf8SpanParsable&lt;byte&gt;&#xA;    interface IAdditionOperators&lt;byte, byte, byte&gt;&#xA;    interface IAdditiveIdentity&lt;byte, byte&gt;&#xA;    interface IBinaryInteger&lt;byte&gt;&#xA;    interface IBinaryNumber&lt;byte&gt;&#xA;    interface IBitwiseOperators&lt;byte, byte, byte&gt;&#xA;    interface IComparisonOperators&lt;byte, byte, bool&gt;&#xA;    interface IEqualityOperators&lt;byte, byte, bool&gt;&#xA;    interface IDecrementOperators&lt;byte&gt;&#xA;    interface IDivisionOperators&lt;byte, byte, byte&gt;&#xA;    interface IIncrementOperators&lt;byte&gt;&#xA;    interface IModulusOperators&lt;byte, byte, byte&gt;&#xA;    interface IMultiplicativeIdentity&lt;byte, byte&gt;&#xA;    interface IMultiplyOperators&lt;byte, byte, byte&gt;&#xA;    interface INumber&lt;byte&gt;&#xA;    interface INumberBase&lt;byte&gt;&#xA;    interface ISubtractionOperators&lt;byte, byte, byte&gt;&#xA;    interface IUnaryNegationOperators&lt;byte, byte&gt;&#xA;    interface IUnaryPlusOperators&lt;byte, byte&gt;&#xA;    interface IShiftOperators&lt;byte, int, byte&gt;&#xA;    interface IMinMaxValue&lt;byte&gt;&#xA;    interface IUnsignedNumber&lt;byte&gt;" FrameworkAlternate="net-9.0" />
  <TypeSignature Language="C#" Value="public struct Byte : IComparable, IConvertible, IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit unsigned int8 extends System.ValueType implements class System.IComparable, class System.IConvertible, class System.IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="VB.NET" Value="Public Structure Byte&#xA;Implements IComparable, IConvertible, IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="F#" Value="type byte = struct&#xA;    interface IFormattable&#xA;    interface IConvertible" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1" />
  <TypeSignature Language="C++ CLI" Value="public value class System::Byte : IComparable, IConvertible, IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit unsigned int8 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;unsigned int8&gt;, class System.IConvertible, class System.IEquatable`1&lt;unsigned int8&gt;, class System.IFormattable" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1" />
  <TypeSignature Language="C#" Value="public struct Byte : IComparable, IComparable&lt;byte&gt;, IEquatable&lt;byte&gt;, IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit unsigned int8 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;unsigned int8&gt;, class System.IEquatable`1&lt;unsigned int8&gt;, class System.IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="VB.NET" Value="Public Structure Byte&#xA;Implements IComparable, IComparable(Of Byte), IEquatable(Of Byte), IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="F#" Value="type byte = struct&#xA;    interface IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="C++ CLI" Value="public value class System::Byte : IComparable, IComparable&lt;System::Byte&gt;, IEquatable&lt;System::Byte&gt;, IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
    <AssemblyVersion>6.0.0.0</AssemblyVersion>
    <AssemblyVersion>7.0.0.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>9.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="6.0.0.0" FrameworkAlternate="net-6.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="7.0.0.0" FrameworkAlternate="net-7.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="8.0.0.0" FrameworkAlternate="net-8.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="9.0.0.0" FrameworkAlternate="net-9.0" />
    <TypeForwarding From="System.Runtime" FromVersion="4.1.1.1" To="mscorlib" ToVersion="4.0.0.0" FrameworkAlternate="netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1">
      <InterfaceName>System.IComparable&lt;System.Byte&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1">
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1">
      <InterfaceName>System.IEquatable&lt;System.Byte&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.ISpanFormattable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.IComparable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.IEquatable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.IParsable&lt;System.Byte&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.IParsable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.ISpanParsable&lt;System.Byte&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.ISpanParsable&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IAdditionOperators&lt;System.Byte,System.Byte,System.Byte&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IAdditionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IAdditiveIdentity&lt;System.Byte,System.Byte&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IAdditiveIdentity&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IBinaryInteger&lt;System.Byte&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IBinaryNumber&lt;System.Byte&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IBinaryNumber&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IBitwiseOperators&lt;System.Byte,System.Byte,System.Byte&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IBitwiseOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IComparisonOperators&lt;System.Byte,System.Byte,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IComparisonOperators&lt;TSelf,TSelf,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IDecrementOperators&lt;System.Byte&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IDecrementOperators&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IDivisionOperators&lt;System.Byte,System.Byte,System.Byte&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IDivisionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IEqualityOperators&lt;System.Byte,System.Byte,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IEqualityOperators&lt;TSelf,TOther,TResult&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IEqualityOperators&lt;TSelf,TSelf,System.Boolean&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IIncrementOperators&lt;System.Byte&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IIncrementOperators&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IMinMaxValue&lt;System.Byte&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IModulusOperators&lt;System.Byte,System.Byte,System.Byte&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IModulusOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;System.Byte,System.Byte&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IMultiplicativeIdentity&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IMultiplyOperators&lt;System.Byte,System.Byte,System.Byte&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IMultiplyOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.INumber&lt;System.Byte&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.INumber&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.INumberBase&lt;System.Byte&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.INumberBase&lt;TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IShiftOperators&lt;System.Byte,System.Int32,System.Byte&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IShiftOperators&lt;TSelf,System.Int32,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.ISubtractionOperators&lt;System.Byte,System.Byte,System.Byte&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.ISubtractionOperators&lt;TSelf,TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IUnaryNegationOperators&lt;System.Byte,System.Byte&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IUnaryNegationOperators&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IUnaryPlusOperators&lt;System.Byte,System.Byte&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IUnaryPlusOperators&lt;TSelf,TSelf&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-7.0;net-8.0;net-9.0">
      <InterfaceName>System.Numerics.IUnsignedNumber&lt;System.Byte&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-8.0;net-9.0">
      <InterfaceName>System.IUtf8SpanFormattable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-8.0;net-9.0">
      <InterfaceName>System.IUtf8SpanParsable&lt;System.Byte&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="net-8.0;net-9.0">
      <InterfaceName>System.IUtf8SpanParsable&lt;TSelf&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1;netstandard-2.1">
      <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents an 8-bit unsigned integer.</summary>
    <remarks>For more information about this API, see <see href="/dotnet/fundamentals/runtime-libraries/system-byte">Supplemental API remarks for Byte</see>.</remarks>
    <threadsafe>All members of this type are thread safe. Members that appear to modify instance state actually return a new instance initialized with the new value. As with any other type, reading and writing to a shared variable that contains an instance of this type must be protected by a lock to guarantee thread safety.</threadsafe>
    <altmember cref="T:System.SByte" />
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.IFormattable" />
    <altmember cref="T:System.IConvertible" />
    <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/windowsforms-formatting-utility-cs/">Sample: .NET Core WinForms Formatting Utility (C#)</related>
    <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/windowsforms-formatting-utility-vb/">Sample: .NET Core WinForms Formatting Utility (Visual Basic)</related>
  </Docs>
  <Members>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static byte Clamp (byte value, byte min, byte max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Clamp(unsigned int8 value, unsigned int8 min, unsigned int8 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.Clamp(System.Byte,System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Byte, min As Byte, max As Byte) As Byte" />
      <MemberSignature Language="F#" Value="static member Clamp : byte * byte * byte -&gt; byte" Usage="System.byte.Clamp (value, min, max)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Clamp(System::Byte value, System::Byte min, System::Byte max) = System::Numerics::INumber&lt;System::Byte&gt;::Clamp;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.Clamp(`0,`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="min" Type="System.Byte" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="max" Type="System.Byte" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to clamp.</param>
        <param name="min">The inclusive minimum to which <paramref name="value" /> should clamp.</param>
        <param name="max">The inclusive maximum to which <paramref name="value" /> should clamp.</param>
        <summary>Clamps a value to an inclusive minimum and maximum value.</summary>
        <returns>The result of clamping <paramref name="value" /> to the inclusive range of <paramref name="min" /> and <paramref name="max" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumber`1.Clamp(`0,`0,`0)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compares this instance to a specified object or <see cref="T:System.Byte" /> and returns an indication of their relative values.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.CompareTo(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Byte) As Integer" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : byte -&gt; int&#xA;override this.CompareTo : byte -&gt; int" Usage="byte.CompareTo value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Byte value);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">An 8-bit unsigned integer to compare.</param>
        <summary>Compares this instance to a specified 8-bit unsigned integer and returns an indication of their relative values.</summary>
        <returns>A signed integer that indicates the relative order of this instance and <paramref name="value" />.

 <list type="table"><listheader><term> Return Value

 </term><description> Description

 </description></listheader><item><term> Less than zero

 </term><description> This instance is less than <paramref name="value" />.

 </description></item><item><term> Zero

 </term><description> This instance is equal to <paramref name="value" />.

 </description></item><item><term> Greater than zero

 </term><description> This instance is greater than <paramref name="value" />.

 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This method implements the <xref:System.IComparable%601?displayProperty=nameWithType> interface and performs slightly better than the <xref:System.Byte.CompareTo%28System.Object%29?displayProperty=nameWithType> method because it does not have to convert the `value` parameter to an object.

 Depending on your programming language, it might be possible to code a <xref:System.Byte.CompareTo%2A> method where the parameter type has fewer bits (is narrower) than the instance type. This is possible because some programming languages perform an implicit widening conversion that represents the parameter as a type with as many bits as the instance.

 For example, suppose the instance type is <xref:System.Int32> and the parameter type is <xref:System.Byte>. The Microsoft C# compiler generates instructions to represent the value of the parameter as an <xref:System.Int32>, then generates a <xref:System.Int32.CompareTo%2A?displayProperty=nameWithType> method that compares the values of the <xref:System.Int32> instance and the <xref:System.Int32> parameter representation.

 Consult your programming language's documentation to determine whether its compiler performs implicit widening conversions on numeric types.



## Examples
 The following code example demonstrates generic and non-generic versions of the `CompareTo` method for several value and reference types.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp" id="Snippet1":::
 :::code language="csharp" source="~/snippets/csharp/System/Boolean/CompareTo/cat.cs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="T:System.IComparable" />
        <altmember cref="M:System.Byte.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object? value);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="byte.CompareTo value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-2.0;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;netframework-4.8.1;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">An object to compare, or <see langword="null" />.</param>
        <summary>Compares this instance to a specified object and returns an indication of their relative values.</summary>
        <returns>A signed integer that indicates the relative order of this instance and <paramref name="value" />.

 <list type="table"><listheader><term> Return Value

 </term><description> Description

 </description></listheader><item><term> Less than zero

 </term><description> This instance is less than <paramref name="value" />.

 </description></item><item><term> Zero

 </term><description> This instance is equal to <paramref name="value" />.

 </description></item><item><term> Greater than zero

 </term><description> This instance is greater than <paramref name="value" />, or <paramref name="value" /> is <see langword="null" />.</description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 `value` must be `null` or an instance of <xref:System.Byte>; otherwise, an exception is thrown.

 Any instance of <xref:System.Byte>, regardless of its value, is considered greater than `null`.

 This method is implemented to support the <xref:System.IComparable> interface.



## Examples
 The following code example demonstrates the <xref:System.Byte.CompareTo%2A> method.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Byte Examples/CPP/systembyte.cpp" id="Snippet3":::
 :::code language="csharp" source="~/snippets/csharp/System/Byte/CompareTo/systembyte.cs" id="Snippet3":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Byte Examples/FS/systembyte.fs" id="Snippet3":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Byte Examples/VB/systembyte.vb" id="Snippet3":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> is not a <see cref="T:System.Byte" />.</exception>
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="M:System.Byte.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CreateChecked&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="public static byte CreateChecked&lt;TOther&gt; (TOther value) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 CreateChecked&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.CreateChecked``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateChecked(Of TOther As INumberBase(Of TOther)) (value As TOther) As Byte" />
      <MemberSignature Language="F#" Value="static member CreateChecked : 'Other -&gt; byte (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.byte.CreateChecked value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static System::Byte CreateChecked(TOther value) = System::Numerics::INumberBase&lt;System::Byte&gt;::CreateChecked;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.CreateChecked``1(``0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type of <paramref name="value" />.</typeparam>
        <param name="value">The value that's used to create the instance of <typeparamref name="TSelf" />.</param>
        <summary>Creates an instance of the current type from a value, throwing an overflow exception for any values that fall outside the representable range of the current type.</summary>
        <returns>An instance of <typeparamref name="TSelf" /> created from <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.CreateChecked``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="CreateSaturating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="public static byte CreateSaturating&lt;TOther&gt; (TOther value) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 CreateSaturating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.CreateSaturating``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSaturating(Of TOther As INumberBase(Of TOther)) (value As TOther) As Byte" />
      <MemberSignature Language="F#" Value="static member CreateSaturating : 'Other -&gt; byte (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.byte.CreateSaturating value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static System::Byte CreateSaturating(TOther value) = System::Numerics::INumberBase&lt;System::Byte&gt;::CreateSaturating;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.CreateSaturating``1(``0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type of <paramref name="value" />.</typeparam>
        <param name="value">The value that's used to create the instance of <typeparamref name="TSelf" />.</param>
        <summary>Creates an instance of the current type from a value, saturating any values that fall outside the representable range of the current type.</summary>
        <returns>An instance of <typeparamref name="TSelf" /> created from <paramref name="value" />, saturating if <paramref name="value" /> falls outside the representable range of <typeparamref name="TSelf" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.CreateSaturating``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="CreateTruncating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="public static byte CreateTruncating&lt;TOther&gt; (TOther value) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 CreateTruncating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.CreateTruncating``1(``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateTruncating(Of TOther As INumberBase(Of TOther)) (value As TOther) As Byte" />
      <MemberSignature Language="F#" Value="static member CreateTruncating : 'Other -&gt; byte (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.byte.CreateTruncating value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static System::Byte CreateTruncating(TOther value) = System::Numerics::INumberBase&lt;System::Byte&gt;::CreateTruncating;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.CreateTruncating``1(``0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(0)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(0)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type of <paramref name="value" />.</typeparam>
        <param name="value">The value that's used to create the instance of <typeparamref name="TSelf" />.</param>
        <summary>Creates an instance of the current type from a value, truncating any values that fall outside the representable range of the current type.</summary>
        <returns>An instance of <typeparamref name="TSelf" /> created from <paramref name="value" />, truncating if <paramref name="value" /> falls outside the representable range of <typeparamref name="TSelf" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.CreateTruncating``1(``0)" />
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static (byte Quotient, byte Remainder) DivRem (byte left, byte right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ValueTuple`2&lt;unsigned int8, unsigned int8&gt; DivRem(unsigned int8 left, unsigned int8 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.DivRem(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (left As Byte, right As Byte) As ValueTuple(Of Byte, Byte)" />
      <MemberSignature Language="F#" Value="static member DivRem : byte * byte -&gt; ValueTuple&lt;byte, byte&gt;" Usage="System.byte.DivRem (left, right)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ValueTuple&lt;System::Byte, System::Byte&gt; DivRem(System::Byte left, System::Byte right) = System::Numerics::IBinaryInteger&lt;System::Byte&gt;::DivRem;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.DivRem(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ValueTuple&lt;System.Byte,System.Byte&gt;</ReturnType>
        <Attributes>
          <Attribute FrameworkAlternate="net-7.0">
            <AttributeName Language="C#">[System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Quotient", "Remainder" })]</AttributeName>
            <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.TupleElementNames(new System.String[] { "Quotient", "Remainder" })&gt;]</AttributeName>
          </Attribute>
        </Attributes>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Byte" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value which <paramref name="right" /> divides.</param>
        <param name="right">The value which divides <paramref name="left" />.</param>
        <summary>Computes the quotient and remainder of two values.</summary>
        <returns>The quotient and remainder of <paramref name="left" /> divided-by <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.DivRem(`0,`0)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns a value indicating whether two instances of <see cref="T:System.Byte" /> represent the same value.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Examples
 The following code example determines whether the first <xref:System.Byte> value is equal to the second <xref:System.Byte> value, and whether the first <xref:System.Byte> value is equal to the boxed version of the second <xref:System.Byte> value.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.byte.equals/cpp/eq.cpp" id="Snippet1":::
 :::code language="csharp" source="~/snippets/csharp/System/Byte/Equals/eq.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.byte.equals/fs/eq.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.byte.equals/vb/eq.vb" id="Snippet1":::

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (byte obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(unsigned int8 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.Equals(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Byte) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Equals : byte -&gt; bool" Usage="byte.Equals obj" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Byte obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Byte" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj">An object to compare to this instance.</param>
        <summary>Returns a value indicating whether this instance and a specified <see cref="T:System.Byte" /> object represent the same value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="obj" /> is equal to this instance; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This method implements the <xref:System.IEquatable%601?displayProperty=nameWithType> interface, and performs slightly better than <xref:System.Byte.Equals%28System.Object%29> because it does not have to convert the `obj` parameter to an object.

 ]]></format>
        </remarks>
        <altmember cref="M:System.Byte.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="byte.Equals obj" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="C#" Value="public override bool Equals (object? obj);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object">
          <Attributes>
            <Attribute FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="obj">An object to compare with this instance, or <see langword="null" />.</param>
        <summary>Returns a value indicating whether this instance is equal to a specified object.</summary>
        <returns>
          <see langword="true" /> if <paramref name="obj" /> is an instance of <see cref="T:System.Byte" /> and equals the value of this instance; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

 ]]></format>
        </remarks>
        <altmember cref="M:System.Byte.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="byte.GetHashCode " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the hash code for this instance.</summary>
        <returns>A hash code for the current <see cref="T:System.Byte" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="byte.GetTypeCode " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the <see cref="T:System.TypeCode" /> for value type <see cref="T:System.Byte" />.</summary>
        <returns>The enumerated constant, <see cref="F:System.TypeCode.Byte" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEvenInteger">
      <MemberSignature Language="C#" Value="public static bool IsEvenInteger (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEvenInteger(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.IsEvenInteger(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEvenInteger (value As Byte) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsEvenInteger : byte -&gt; bool" Usage="System.byte.IsEvenInteger value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEvenInteger(System::Byte value) = System::Numerics::INumberBase&lt;System::Byte&gt;::IsEvenInteger;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsEvenInteger(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents an even integral number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an even integer; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This method correctly handles floating-point values and so `2.0` will return `true` while `2.2` will return `false`.

A return value of `false` does not imply that <xref:System.Numerics.INumberBase%601.IsOddInteger(%600)> will return `true`. A number with a fractional portion, for example, `3.3`, is not even or odd.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.IsEvenInteger(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IsOddInteger">
      <MemberSignature Language="C#" Value="public static bool IsOddInteger (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsOddInteger(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.IsOddInteger(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsOddInteger (value As Byte) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsOddInteger : byte -&gt; bool" Usage="System.byte.IsOddInteger value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsOddInteger(System::Byte value) = System::Numerics::INumberBase&lt;System::Byte&gt;::IsOddInteger;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsOddInteger(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents an odd integral number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an odd integer; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This method correctly handles floating-point values and so `3.0` will return `true` while `3.3` will return `false`.

A return value of `false` does not imply that <xref:System.Numerics.INumberBase%601.IsEvenInteger(%600)> will return `true`. A number with a fractional portion, for example, `3.3`, is not even or odd.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.IsOddInteger(`0)" />
      </Docs>
    </Member>
    <Member MemberName="IsPow2">
      <MemberSignature Language="C#" Value="public static bool IsPow2 (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPow2(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.IsPow2(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPow2 (value As Byte) As Boolean" />
      <MemberSignature Language="F#" Value="static member IsPow2 : byte -&gt; bool" Usage="System.byte.IsPow2 value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPow2(System::Byte value) = System::Numerics::IBinaryNumber&lt;System::Byte&gt;::IsPow2;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryNumber`1.IsPow2(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is a power of two.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is a power of two; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryNumber`1.IsPow2(`0)" />
      </Docs>
    </Member>
    <Member MemberName="LeadingZeroCount">
      <MemberSignature Language="C#" Value="public static byte LeadingZeroCount (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 LeadingZeroCount(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.LeadingZeroCount(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LeadingZeroCount (value As Byte) As Byte" />
      <MemberSignature Language="F#" Value="static member LeadingZeroCount : byte -&gt; byte" Usage="System.byte.LeadingZeroCount value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte LeadingZeroCount(System::Byte value) = System::Numerics::IBinaryInteger&lt;System::Byte&gt;::LeadingZeroCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.LeadingZeroCount(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value whose leading zeroes are to be counted.</param>
        <summary>Computes the number of leading zeros in a value.</summary>
        <returns>The number of leading zeros in <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.LeadingZeroCount(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Log2">
      <MemberSignature Language="C#" Value="public static byte Log2 (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Log2(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.Log2(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log2 (value As Byte) As Byte" />
      <MemberSignature Language="F#" Value="static member Log2 : byte -&gt; byte" Usage="System.byte.Log2 value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Log2(System::Byte value) = System::Numerics::IBinaryNumber&lt;System::Byte&gt;::Log2;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryNumber`1.Log2(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value whose log2 is to be computed.</param>
        <summary>Computes the log2 of a value.</summary>
        <returns>The log2 of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryNumber`1.Log2(`0)" />
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static byte Max (byte x, byte y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Max(unsigned int8 x, unsigned int8 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.Max(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (x As Byte, y As Byte) As Byte" />
      <MemberSignature Language="F#" Value="static member Max : byte * byte -&gt; byte" Usage="System.byte.Max (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Max(System::Byte x, System::Byte y) = System::Numerics::INumber&lt;System::Byte&gt;::Max;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.Max(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.Byte" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is greater.</summary>
        <returns>
          <paramref name="x" /> if it is greater than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For <xref:System.Numerics.IFloatingPoint%601>, this method matches the IEEE 754:2019 `maximum` function. This requires NaN inputs to be propagated back to the caller and for `-0.0` to be treated as less than `+0.0`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumber`1.Max(`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const byte MaxValue = 255;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal unsigned int8 MaxValue = unsigned int8(255)" />
      <MemberSignature Language="DocId" Value="F:System.Byte.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Byte  = 255" />
      <MemberSignature Language="F#" Value="val mutable MaxValue : byte" Usage="System.byte.MaxValue" />
      <MemberSignature Language="C++ CLI" Value="public: System::Byte MaxValue = 255;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <MemberValue>255</MemberValue>
      <Docs>
        <summary>Represents the largest possible value of a <see cref="T:System.Byte" />. This field is constant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The value of this constant is 255 (hexadecimal 0xFF).



## Examples
 The following example demonstrates how to use the <xref:System.Byte.MaxValue> field to screen variable inputs for values that are outside the range of possible byte values.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Byte Examples/CPP/systembyte.cpp" id="Snippet1":::
 :::code language="csharp" source="~/snippets/csharp/System/Byte/CompareTo/systembyte.cs" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Byte Examples/FS/systembyte.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Byte Examples/VB/systembyte.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="F:System.Byte.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static byte Min (byte x, byte y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Min(unsigned int8 x, unsigned int8 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.Min(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (x As Byte, y As Byte) As Byte" />
      <MemberSignature Language="F#" Value="static member Min : byte * byte -&gt; byte" Usage="System.byte.Min (x, y)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Min(System::Byte x, System::Byte y) = System::Numerics::INumber&lt;System::Byte&gt;::Min;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.Min(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.Byte" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is lesser.</summary>
        <returns>
          <paramref name="x" /> if it is less than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

For <xref:System.Numerics.IFloatingPoint%601>, this method matches the IEEE 754:2019 `minimum` function. This requires NaN inputs to be propagated back to the caller and for `-0.0` to be treated as less than `+0.0`.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumber`1.Min(`0,`0)" />
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const byte MinValue = 0;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal unsigned int8 MinValue = unsigned int8(0)" />
      <MemberSignature Language="DocId" Value="F:System.Byte.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Byte  = 0" />
      <MemberSignature Language="F#" Value="val mutable MinValue : byte" Usage="System.byte.MinValue" />
      <MemberSignature Language="C++ CLI" Value="public: System::Byte MinValue = 0;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>Represents the smallest possible value of a <see cref="T:System.Byte" />. This field is constant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The value of this constant is 0.



## Examples
 The following example demonstrates how to use the <xref:System.Byte.MinValue> field to screen variable inputs for values that are outside the range of possible byte values.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Byte Examples/CPP/systembyte.cpp" id="Snippet1":::
 :::code language="csharp" source="~/snippets/csharp/System/Byte/CompareTo/systembyte.cs" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Byte Examples/FS/systembyte.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Byte Examples/VB/systembyte.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <altmember cref="F:System.Byte.MaxValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converts the string representation of a number to its <see cref="T:System.Byte" /> equivalent.</summary>
        <altmember cref="Overload:System.Byte.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static byte Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Byte" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; byte" Usage="System.byte.Parse s" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Parse(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">A string that contains a number to convert. The string is interpreted using the <see cref="F:System.Globalization.NumberStyles.Integer" /> style.</param>
        <summary>Converts the string representation of a number to its <see cref="T:System.Byte" /> equivalent.</summary>
        <returns>A byte value that is equivalent to the number contained in <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The `s` parameter contains a number of the form:

 [ws][sign]digits[ws]

 Elements in square brackets ([ and ]) are optional. The following table describes each element.

|Element|Description|
|-------------|-----------------|
|*ws*|Optional white space.|
|*sign*|An optional positive or negative sign.|
|*digits*|A sequence of digits ranging from 0 to 9.|

 The `s` parameter is interpreted using the <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> style. In addition to the byte value's decimal digits, only leading and trailing spaces together with a leading sign are allowed. (If the sign is present, it must be a positive sign or the method throws an <xref:System.OverflowException>.) To explicitly define the style elements that can be present in `s`, use either the <xref:System.Byte.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> or the <xref:System.Byte.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.

 The `s` parameter is parsed using the formatting information in a <xref:System.Globalization.NumberFormatInfo> object that is initialized for the current system culture. For more information, see <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. To parse a string using the formatting information of some other culture, use the <xref:System.Byte.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.



## Examples
 The following example demonstrates how to convert a string value into a byte value using the <xref:System.Byte.Parse%28System.String%29?displayProperty=nameWithType> method. The resulting byte value is then displayed to the console.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Byte.Parse/cpp/parse.cpp" id="Snippet1":::
 :::code language="csharp" source="~/snippets/csharp/System/Byte/Parse/parse.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Byte.Parse/FS/parse.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Byte.Parse/VB/parse.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> is not of the correct format.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> represents a number less than <see cref="F:System.Byte.MinValue">Byte.MinValue</see> or greater than <see cref="F:System.Byte.MaxValue">Byte.MaxValue</see>.</exception>
        <altmember cref="M:System.Byte.ToString" />
        <altmember cref="F:System.Byte.MaxValue" />
        <altmember cref="F:System.Byte.MinValue" />
        <altmember cref="T:System.Globalization.NumberStyles" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <related type="Article" href="/dotnet/standard/base-types/parsing-numeric">Parsing Numeric Strings in .NET</related>
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">Formatting Types in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static byte Parse (ReadOnlySpan&lt;byte&gt; utf8Text, IFormatProvider? provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Parse(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Text, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.Parse(System.ReadOnlySpan{System.Byte},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (utf8Text As ReadOnlySpan(Of Byte), provider As IFormatProvider) As Byte" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;byte&gt; * IFormatProvider -&gt; byte" Usage="System.byte.Parse (utf8Text, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Parse(ReadOnlySpan&lt;System::Byte&gt; utf8Text, IFormatProvider ^ provider) = IUtf8SpanParsable&lt;System::Byte&gt;::Parse;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IUtf8SpanParsable`1.Parse(System.ReadOnlySpan{System.Byte},System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Text" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="utf8Text">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.IUtf8SpanParsable`1.Parse(System.ReadOnlySpan{System.Byte},System.IFormatProvider)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static byte Parse (ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), provider As IFormatProvider) As Byte" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; byte" Usage="System.byte.Parse (s, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Parse(ReadOnlySpan&lt;char&gt; s, IFormatProvider ^ provider) = ISpanParsable&lt;System::Byte&gt;::Parse;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ISpanParsable`1.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="s">The span of characters to parse.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <summary>Parses a span of characters into a value.</summary>
        <returns>The result of parsing <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.ISpanParsable`1.Parse(System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static byte Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Byte" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; byte" Usage="System.byte.Parse (s, style)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">A string that contains a number to convert. The string is interpreted using the style specified by <paramref name="style" />.</param>
        <param name="style">A bitwise combination of enumeration values that indicates the style elements that can be present in <paramref name="s" />. A typical value to specify is <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <summary>Converts the string representation of a number in a specified style to its <see cref="T:System.Byte" /> equivalent.</summary>
        <returns>A byte value that is equivalent to the number contained in <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The `style` parameter defines the style elements (such as white space or the positive sign) that are allowed in the `s` parameter for the parse operation to succeed. It must be a combination of bit flags from the <xref:System.Globalization.NumberStyles> enumeration. Depending on the value of `style`, the `s` parameter may include the following elements:

 [ws][$][sign]digits[.fractional_digits][e[sign]digits][ws]

 Or, if `style` includes <xref:System.Globalization.NumberStyles.AllowHexSpecifier>:

 [ws]hexdigits[ws]

 Elements in square brackets ([ and ]) are optional. The following table describes each element.

|Element|Description|
|-------------|-----------------|
|*ws*|Optional white space. White space can appear at the beginning of `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flag, or at the end of s if style includes the <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flag.|
|*$*|A culture-specific currency symbol. Its position in the string is defined by the <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> property of the current culture. The current culture's currency symbol can appear in `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flag.|
|*sign*|An optional positive sign. (The method throws an <xref:System.OverflowException> if a negative sign is present in `s`.) The sign can appear at the beginning of `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flag, or at the end of `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flag.|
|*digits*|A sequence of digits from 0 through 9.|
|*.*|A culture-specific decimal point symbol. The current culture's decimal point symbol can appear in `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.|
|*fractional_digits*|One or more occurrences of the digit 0. Fractional digits can appear in `s` only if `style` includes the <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.|
|*e*|The e or E character, which indicates that the value is represented in exponential notation. The `s` parameter can represent a number in exponential notation if `style` includes the <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.|
|*hexdigits*|A sequence of hexadecimal digits from 0 through f, or 0 through F.|

> [!NOTE]
> Any terminating NUL (U+0000) characters in `s` are ignored by the parsing operation, regardless of the value of the `style` argument.

 A string with decimal digits only (which corresponds to the <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> style) always parses successfully. Most of the remaining <xref:System.Globalization.NumberStyles> members control elements that may be but are not required to be present in this input string. The following table indicates how individual <xref:System.Globalization.NumberStyles> members affect the elements that may be present in `s`.

|Non-composite NumberStyles values|Elements permitted in s in addition to digits|
|----------------------------------------|---------------------------------------------------|
|<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>|Decimal digits only.|
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>|The *.* and *fractional_digits* elements. However, *fractional_digits* must consist of only one or more 0 digits or an <xref:System.OverflowException> is thrown.|
|<xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>|The `s` parameter can also use exponential notation.|
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>|The *ws* element at the beginning of `s`.|
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>|The *ws* element at the end of `s`.|
|<xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>|A positive sign can appear before *digits*.|
|<xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>|A positive sign can appear after *digits*.|
|<xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>|Although this flag is supported, the use of parentheses in `s` results in an <xref:System.OverflowException>.|
|<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>|Although the group separator symbol can appear in `s`, it can be preceded by only one or more 0 digits.|
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>|The *$* element.|

 If the <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> flag is used, `s` must be a hexadecimal value without a prefix. For example, "F3" parses successfully, but "0xF3" does not. The only other flags that can be combined with it are <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> and <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (The <xref:System.Globalization.NumberStyles> enumeration includes a composite number style, <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>, that includes both white space flags.)

 The `s` parameter is parsed using the formatting information in a <xref:System.Globalization.NumberFormatInfo> object that is initialized for the current system culture. To use the formatting information of some other culture, call the <xref:System.Byte.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> overload.



## Examples
 The following example parses string representations of `Byte` values with the <xref:System.Byte.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> method. The current culture for the example is en-US.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Byte.Parse/cpp/parse.cpp" id="Snippet3":::
 :::code language="csharp" source="~/snippets/csharp/System/Byte/Parse/parse.cs" interactive="try-dotnet-method" id="Snippet3":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Byte.Parse/FS/parse.fs" id="Snippet3":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Byte.Parse/VB/parse.vb" id="Snippet3":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> is not of the correct format.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> represents a number less than <see cref="F:System.Byte.MinValue">Byte.MinValue</see> or greater than <see cref="F:System.Byte.MaxValue">Byte.MaxValue</see>.

 -or-

 <paramref name="s" /> includes non-zero, fractional digits.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> is not a <see cref="T:System.Globalization.NumberStyles" /> value.

 -or-

 <paramref name="style" /> is not a combination of <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="F:System.Globalization.NumberStyles.HexNumber" /> values.</exception>
        <altmember cref="M:System.Byte.ToString" />
        <altmember cref="Overload:System.Byte.TryParse" />
        <altmember cref="F:System.Byte.MaxValue" />
        <altmember cref="F:System.Byte.MinValue" />
        <altmember cref="T:System.Globalization.NumberStyles" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <altmember cref="T:System.IFormatProvider" />
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">Formatting Types in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static byte Parse (string s, IFormatProvider provider);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Byte" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; byte" Usage="System.byte.Parse (s, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Parse(System::String ^ s, IFormatProvider ^ provider);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public static byte Parse (string s, IFormatProvider? provider);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Parse(System::String ^ s, IFormatProvider ^ provider) = IParsable&lt;System::Byte&gt;::Parse;" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0;net-8.0;net-9.0">M:System.IParsable`1.Parse(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="s">A string that contains a number to convert. The string is interpreted using the <see cref="F:System.Globalization.NumberStyles.Integer" /> style.</param>
        <param name="provider">An object that supplies culture-specific parsing information about <paramref name="s" />. If <paramref name="provider" /> is <see langword="null" />, the thread current culture is used.</param>
        <summary>Converts the string representation of a number in a specified culture-specific format to its <see cref="T:System.Byte" /> equivalent.</summary>
        <returns>A byte value that is equivalent to the number contained in <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The `s` parameter contains a number of the form:

 [ws][sign]digits[ws]

 Elements in square brackets ([ and ]) are optional. The following table describes each element.

|Element|Description|
|-------------|-----------------|
|*ws*|Optional white space.|
|*sign*|An optional positive sign.|
|*digits*|A sequence of digits ranging from 0 to 9.|

 The `s` parameter is interpreted using the <xref:System.Globalization.NumberStyles.Integer> style. In addition to the byte value's decimal digits, only leading and trailing spaces together with a leading sign are allowed. (If the sign is present, it must be a positive sign or the method throws an <xref:System.OverflowException>.) To explicitly define the style elements together with the culture-specific formatting information that can be present in `s`, use the <xref:System.Byte.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.

 The `s` parameter is parsed using the formatting information in a <xref:System.Globalization.NumberFormatInfo> object supplied by `provider`. The `provider` parameter is an <xref:System.IFormatProvider> implementation such as a <xref:System.Globalization.NumberFormatInfo> or <xref:System.Globalization.CultureInfo> object. The `provider` parameter supplies culture-specific information used in parsing. If `provider` is `null`, the thread current culture is used.



## Examples
 The following example parses string representations of `Byte` values with the <xref:System.Byte.Parse%2A> method.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Byte.Parse/cpp/parse.cpp" id="Snippet2":::
 :::code language="csharp" source="~/snippets/csharp/System/Byte/Parse/parse.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Byte.Parse/FS/parse.fs" id="Snippet2":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Byte.Parse/VB/parse.vb" id="Snippet2":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> is not of the correct format.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> represents a number less than <see cref="F:System.Byte.MinValue">Byte.MinValue</see> or greater than <see cref="F:System.Byte.MaxValue">Byte.MaxValue</see>.</exception>
        <altmember cref="M:System.Byte.ToString" />
        <altmember cref="Overload:System.Byte.TryParse" />
        <altmember cref="F:System.Byte.MaxValue" />
        <altmember cref="F:System.Byte.MinValue" />
        <altmember cref="T:System.Globalization.NumberStyles" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <altmember cref="T:System.IFormatProvider" />
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">Formatting Types in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static byte Parse (ReadOnlySpan&lt;byte&gt; utf8Text, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider? provider = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Parse(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Text, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.Parse(System.ReadOnlySpan{System.Byte},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (utf8Text As ReadOnlySpan(Of Byte), Optional style As NumberStyles = System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = Nothing) As Byte" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;byte&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; byte" Usage="System.byte.Parse (utf8Text, style, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.Parse(System.ReadOnlySpan{System.Byte},System.Globalization.NumberStyles,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Text" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="utf8Text">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.Parse(System.ReadOnlySpan{System.Byte},System.Globalization.NumberStyles,System.IFormatProvider)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static byte Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider? provider = default);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = Nothing) As Byte" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; byte" Usage="System.byte.Parse (s, style, provider)" />
      <MemberSignature Language="C#" Value="public static byte Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider provider = default);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0;net-8.0;net-9.0">M:System.Numerics.INumberBase`1.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="s">A span containing the characters representing the value to convert.</param>
        <param name="style">A bitwise combination of enumeration values that indicates the style elements that can be present in <paramref name="s" />. A typical value to specify is <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <param name="provider">An object that supplies culture-specific information about the format of <paramref name="s" />. If <paramref name="provider" /> is <see langword="null" />, the thread current culture is used.</param>
        <summary>Converts the span representation of a number in a specified style and culture-specific format to its <see cref="T:System.Byte" /> equivalent.</summary>
        <returns>A byte value that is equivalent to the number contained in <paramref name="s" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static byte Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Byte" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; byte" Usage="System.byte.Parse (s, style, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public static byte Parse (string s, System.Globalization.NumberStyles style, IFormatProvider? provider);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider) = System::Numerics::INumberBase&lt;System::Byte&gt;::Parse;" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-7.0;net-8.0;net-9.0">M:System.Numerics.INumberBase`1.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="s">A string that contains a number to convert. The string is interpreted using the style specified by <paramref name="style" />.</param>
        <param name="style">A bitwise combination of enumeration values that indicates the style elements that can be present in <paramref name="s" />. A typical value to specify is <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <param name="provider">An object that supplies culture-specific information about the format of <paramref name="s" />. If <paramref name="provider" /> is <see langword="null" />, the thread current culture is used.</param>
        <summary>Converts the string representation of a number in a specified style and culture-specific format to its <see cref="T:System.Byte" /> equivalent.</summary>
        <returns>A byte value that is equivalent to the number contained in <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The `style` parameter defines the style elements (such as white space or the positive sign) that are allowed in the `s` parameter for the parse operation to succeed. It must be a combination of bit flags from the <xref:System.Globalization.NumberStyles> enumeration. Depending on the value of `style`, the `s` parameter may include the following elements:

 [ws][$][sign]digits[.fractional_digits][e[sign]digits][ws]

 Or, if the `style` parameter includes <xref:System.Globalization.NumberStyles.AllowHexSpecifier>:

 [ws]hexdigits[ws]

 Elements in square brackets ([ and ]) are optional. The following table describes each element.

|Element|Description|
|-------------|-----------------|
|*ws*|Optional white space. White space can appear at the beginning of `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flag, or at the end of `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flag.|
|*$*|A culture-specific currency symbol. Its position in the string is defined by the <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> property of the <xref:System.Globalization.NumberFormatInfo> object returned by the <xref:System.IFormatProvider.GetFormat%2A> method of the `provider` parameter. The currency symbol can appear in `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flag.|
|*sign*|An optional positive sign. (The method throws an <xref:System.OverflowException> if a negative sign is present in `s`.) The sign can appear at the beginning of `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flag, or at the end of `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flag.|
|*digits*|A sequence of digits from 0 through 9.|
|*.*|A culture-specific decimal point symbol. The decimal point symbol of the culture specified by `provider` can appear in `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.|
|*fractional_digits*|One or more occurrences of the digit 0. Fractional digits can appear in `s` only if `style` includes the <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.|
|*e*|The e or E character, which indicates that the value is represented in exponential notation. The s parameter can represent a number in exponential notation if `style` includes the <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.|
|*hexdigits*|A sequence of hexadecimal digits from 0 through f, or 0 through F.|

> [!NOTE]
> Any terminating NUL (U+0000) characters in `s` are ignored by the parsing operation, regardless of the value of the `style` argument.

 A string with decimal digits only (which corresponds to the <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> style) always parses successfully. Most of the remaining <xref:System.Globalization.NumberStyles> members control elements that may be but are not required to be present in this input string. The following table indicates how individual <xref:System.Globalization.NumberStyles> members affect the elements that may be present in `s`.

|Non-composite NumberStyles values|Elements permitted in s in addition to digits|
|----------------------------------------|---------------------------------------------------|
|<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>|Decimal digits only.|
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>|The *.* and *fractional_digits* elements. However, *fractional_digits* must consist of only one or more 0 digits or an <xref:System.OverflowException> is thrown.|
|<xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>|The `s` parameter can also use exponential notation.|
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>|The *ws* element at the beginning of `s`.|
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>|The *ws* element at the end of `s`.|
|<xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>|A positive sign can appear before *digits*.|
|<xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>|A positive sign can appear after *digits*.|
|<xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>|Although this flag is supported, the use of parentheses in `s` results in an <xref:System.OverflowException>.|
|<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>|Although the group separator symbol can appear in `s`, it can be preceded by only one or more 0 digits.|
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>|The *$* element.|

 If the <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> flag is used, `s` must be a hexadecimal value without a prefix. For example, "F3" parses successfully, but "0xF3" does not. The only other flags that can be present in `style` are <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> and <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (The <xref:System.Globalization.NumberStyles> enumeration has a composite number style, <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>, that includes both white space flags.)

 The `provider` parameter is an <xref:System.IFormatProvider> implementation, such as a <xref:System.Globalization.NumberFormatInfo> or <xref:System.Globalization.CultureInfo> object. The `provider` parameter supplies culture-specific information used in parsing. If `provider` is `null`, the thread current culture is used.



## Examples
 The following code example parses string representations of `Byte` values with this overload of the <xref:System.Byte.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Byte.Parse/cpp/parse.cpp" id="Snippet4":::
 :::code language="csharp" source="~/snippets/csharp/System/Byte/Parse/parse.cs" interactive="try-dotnet-method" id="Snippet4":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Byte.Parse/FS/parse.fs" id="Snippet4":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Byte.Parse/VB/parse.vb" id="Snippet4":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> is <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> is not of the correct format.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> represents a number less than <see cref="F:System.Byte.MinValue">Byte.MinValue</see> or greater than <see cref="F:System.Byte.MaxValue">Byte.MaxValue</see>.

 -or-

 <paramref name="s" /> includes non-zero, fractional digits.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> is not a <see cref="T:System.Globalization.NumberStyles" /> value.

 -or-

 <paramref name="style" /> is not a combination of <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="F:System.Globalization.NumberStyles.HexNumber" /> values.</exception>
        <altmember cref="M:System.Byte.ToString" />
        <altmember cref="F:System.Byte.MaxValue" />
        <altmember cref="F:System.Byte.MinValue" />
        <altmember cref="T:System.Globalization.NumberStyles" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <altmember cref="T:System.IFormatProvider" />
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">Formatting Types in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="PopCount">
      <MemberSignature Language="C#" Value="public static byte PopCount (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 PopCount(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.PopCount(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function PopCount (value As Byte) As Byte" />
      <MemberSignature Language="F#" Value="static member PopCount : byte -&gt; byte" Usage="System.byte.PopCount value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte PopCount(System::Byte value) = System::Numerics::IBinaryInteger&lt;System::Byte&gt;::PopCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.PopCount(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value whose set bits are to be counted.</param>
        <summary>Computes the number of bits that are set in a value.</summary>
        <returns>The number of set bits in <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.PopCount(`0)" />
      </Docs>
    </Member>
    <Member MemberName="RotateLeft">
      <MemberSignature Language="C#" Value="public static byte RotateLeft (byte value, int rotateAmount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 RotateLeft(unsigned int8 value, int32 rotateAmount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.RotateLeft(System.Byte,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RotateLeft (value As Byte, rotateAmount As Integer) As Byte" />
      <MemberSignature Language="F#" Value="static member RotateLeft : byte * int -&gt; byte" Usage="System.byte.RotateLeft (value, rotateAmount)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte RotateLeft(System::Byte value, int rotateAmount) = System::Numerics::IBinaryInteger&lt;System::Byte&gt;::RotateLeft;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.RotateLeft(`0,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="rotateAmount" Type="System.Int32" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value which is rotated left by <paramref name="rotateAmount" />.</param>
        <param name="rotateAmount">The amount by which <paramref name="value" /> is rotated left.</param>
        <summary>Rotates a value left by a given amount.</summary>
        <returns>The result of rotating <paramref name="value" /> left by <paramref name="rotateAmount" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.RotateLeft(`0,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RotateRight">
      <MemberSignature Language="C#" Value="public static byte RotateRight (byte value, int rotateAmount);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 RotateRight(unsigned int8 value, int32 rotateAmount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.RotateRight(System.Byte,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RotateRight (value As Byte, rotateAmount As Integer) As Byte" />
      <MemberSignature Language="F#" Value="static member RotateRight : byte * int -&gt; byte" Usage="System.byte.RotateRight (value, rotateAmount)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte RotateRight(System::Byte value, int rotateAmount) = System::Numerics::IBinaryInteger&lt;System::Byte&gt;::RotateRight;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.RotateRight(`0,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="rotateAmount" Type="System.Int32" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value which is rotated right by <paramref name="rotateAmount" />.</param>
        <param name="rotateAmount">The amount by which <paramref name="value" /> is rotated right.</param>
        <summary>Rotates a value right by a given amount.</summary>
        <returns>The result of rotating <paramref name="value" /> right by <paramref name="rotateAmount" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.RotateRight(`0,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.Sign(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Byte) As Integer" />
      <MemberSignature Language="F#" Value="static member Sign : byte -&gt; int" Usage="System.byte.Sign value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(System::Byte value) = System::Numerics::INumber&lt;System::Byte&gt;::Sign;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.Sign(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value whose sign is to be computed.</param>
        <summary>Computes the sign of a value.</summary>
        <returns>A positive value if <paramref name="value" /> is positive, <see cref="P:System.Numerics.INumberBase`1.Zero" /> if <paramref name="value" /> is zero, and a negative value if <paramref name="value" /> is negative.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

It is recommended that a function return `1`, `0`, and `-1`, respectively.

          ]]></format>
        </remarks>
        <inheritdoc cref="M:System.Numerics.INumber`1.Sign(`0)" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="F#" Value="abstract member System.IComparable.CompareTo : obj -&gt; int&#xA;override this.System.IComparable.CompareTo : obj -&gt; int" Usage="byte.System.IComparable.CompareTo value" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value">The object to compare.</param>
        <summary>Compares the current instance with another object of the same type and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object.</summary>
        <returns>A value that indicates the relative order of the objects being compared.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This member is an explicit interface member implementation. It can be used only when the <xref:System.Byte> instance is cast to an <xref:System.IComparable> interface.

The return value has these meanings:

| Value             | Meaning                                                                 |
|-------------------|-------------------------------------------------------------------------|
| Less than zero    | This instance precedes `value` in the sort order.                       |
| Zero              | This instance occurs in the same position in the sort order as `value`. |
| Greater than zero | This instance follows `value` in the sort order.                        |

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.GetTypeCode : unit -&gt; TypeCode&#xA;override this.System.IConvertible.GetTypeCode : unit -&gt; TypeCode" Usage="byte.System.IConvertible.GetTypeCode " />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the <see cref="T:System.TypeCode" /> for this instance.</summary>
        <returns>The enumerated constant that is the <see cref="T:System.TypeCode" /> of the class or value type that implements this interface.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

This member is an explicit interface member implementation. It can be used only when the <xref:System.Boolean> instance is cast to an <xref:System.IConvertible> interface.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToBoolean : IFormatProvider -&gt; bool&#xA;override this.System.IConvertible.ToBoolean : IFormatProvider -&gt; bool" Usage="byte.System.IConvertible.ToBoolean provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns>
          <see langword="true" /> if the value of the current instance is not zero; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Byte> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToBoolean%28System.Byte%29?displayProperty=nameWithType> method.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToByte : IFormatProvider -&gt; byte&#xA;override this.System.IConvertible.ToByte : IFormatProvider -&gt; byte" Usage="byte.System.IConvertible.ToByte provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>The value of the current instance, unchanged.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Byte> instance is cast to an <xref:System.IConvertible> interface.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToChar : IFormatProvider -&gt; char&#xA;override this.System.IConvertible.ToChar : IFormatProvider -&gt; char" Usage="byte.System.IConvertible.ToChar provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</summary>
        <returns>The value of the current instance, converted to a <see cref="T:System.Char" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Byte> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToChar%28System.Byte%29?displayProperty=nameWithType> method.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDateTime : IFormatProvider -&gt; DateTime&#xA;override this.System.IConvertible.ToDateTime : IFormatProvider -&gt; DateTime" Usage="byte.System.IConvertible.ToDateTime provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>This conversion is not supported. Attempting to use this method throws an <see cref="T:System.InvalidCastException" />.</summary>
        <returns>This conversion is not supported. No value is returned.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">In all cases.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDecimal : IFormatProvider -&gt; decimal&#xA;override this.System.IConvertible.ToDecimal : IFormatProvider -&gt; decimal" Usage="byte.System.IConvertible.ToDecimal provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>The value of the current instance, converted to a <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Byte> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToDecimal%28System.Byte%29?displayProperty=nameWithType> method.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDouble : IFormatProvider -&gt; double&#xA;override this.System.IConvertible.ToDouble : IFormatProvider -&gt; double" Usage="byte.System.IConvertible.ToDouble provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>The value of the current instance, converted to a <see cref="T:System.Double" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Byte> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToDouble%28System.Byte%29?displayProperty=nameWithType> method.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt16 : IFormatProvider -&gt; int16&#xA;override this.System.IConvertible.ToInt16 : IFormatProvider -&gt; int16" Usage="byte.System.IConvertible.ToInt16 provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>The value of the current instance, converted to an <see cref="T:System.Int16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Byte> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToInt16%28System.Byte%29?displayProperty=nameWithType> method.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt32 : IFormatProvider -&gt; int&#xA;override this.System.IConvertible.ToInt32 : IFormatProvider -&gt; int" Usage="byte.System.IConvertible.ToInt32 provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>The value of the current instance, converted to an <see cref="T:System.Int32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Byte> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToInt32%28System.Byte%29?displayProperty=nameWithType> method.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt64 : IFormatProvider -&gt; int64&#xA;override this.System.IConvertible.ToInt64 : IFormatProvider -&gt; int64" Usage="byte.System.IConvertible.ToInt64 provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>The value of the current instance, converted to an <see cref="T:System.Int64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Byte> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToInt64%28System.Byte%29?displayProperty=nameWithType> method.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToSByte : IFormatProvider -&gt; sbyte&#xA;override this.System.IConvertible.ToSByte : IFormatProvider -&gt; sbyte" Usage="byte.System.IConvertible.ToSByte provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>The value of the current instance, converted to an <see cref="T:System.SByte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Byte> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToSByte%28System.Byte%29?displayProperty=nameWithType> method.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToSingle : IFormatProvider -&gt; single&#xA;override this.System.IConvertible.ToSingle : IFormatProvider -&gt; single" Usage="byte.System.IConvertible.ToSingle provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>The value of the current instance, converted to a <see cref="T:System.Single" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Byte> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToSingle%28System.Byte%29?displayProperty=nameWithType> method.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToType (type As Type, provider As IFormatProvider) As Object Implements IConvertible.ToType" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToType : Type * IFormatProvider -&gt; obj&#xA;override this.System.IConvertible.ToType : Type * IFormatProvider -&gt; obj" Usage="byte.System.IConvertible.ToType (type, provider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="type">The type to which to convert this <see cref="T:System.Byte" /> value.</param>
        <param name="provider">An <see cref="T:System.IFormatProvider" /> implementation that supplies information about the format of the returned value.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>The value of the current instance, converted to <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Byte> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the `static` (`Shared` in Visual Basic) <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> method instead.

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">The requested type conversion is not supported.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt16 : IFormatProvider -&gt; uint16&#xA;override this.System.IConvertible.ToUInt16 : IFormatProvider -&gt; uint16" Usage="byte.System.IConvertible.ToUInt16 provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>The value of the current instance, converted to a <see cref="T:System.UInt16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Byte> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToUInt16%28System.Byte%29?displayProperty=nameWithType> method.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt32 : IFormatProvider -&gt; uint32&#xA;override this.System.IConvertible.ToUInt32 : IFormatProvider -&gt; uint32" Usage="byte.System.IConvertible.ToUInt32 provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>The value of the current instance, converted to a <see cref="T:System.UInt32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Byte> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToUInt32%28System.Byte%29?displayProperty=nameWithType> method.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt64 : IFormatProvider -&gt; uint64&#xA;override this.System.IConvertible.ToUInt64 : IFormatProvider -&gt; uint64" Usage="byte.System.IConvertible.ToUInt64 provider" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="provider">This parameter is ignored.</param>
        <summary>For a description of this member, see <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>The value of the current instance, converted to a <see cref="T:System.UInt64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 This member is an explicit interface member implementation. It can be used only when the <xref:System.Byte> instance is cast to an <xref:System.IConvertible> interface. The recommended alternative is to call the <xref:System.Convert.ToUInt64%28System.Byte%29?displayProperty=nameWithType> method.

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IAdditionOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_Addition">
      <MemberSignature Language="C#" Value="static byte IAdditionOperators&lt;byte,byte,byte&gt;.operator + (byte left, byte right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig unsigned int8 System.Numerics.IAdditionOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_Addition(unsigned int8 left, unsigned int8 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IAdditionOperators&lt;System#Byte,System#Byte,System#Byte&gt;#op_Addition(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator + (left As Byte, right As Byte) As Byte Implements IAdditionOperators(Of Byte, Byte, Byte).op_Addition" />
      <MemberSignature Language="F#" Value="static member ( + ) : byte * byte -&gt; byte" Usage="left + right" />
      <MemberSignature Language="C++ CLI" Value=" static System::Byte System.Numerics.IAdditionOperators&lt;System.Byte,System.Byte,System.Byte&gt;.operator +(System::Byte left, System::Byte right) = System::Numerics::IAdditionOperators&lt;System::Byte, System::Byte, System::Byte&gt;::op_Addition;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IAdditionOperators`3.op_Addition(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Byte" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to which <paramref name="right" /> is added.</param>
        <param name="right">The value that's added to <paramref name="left" />.</param>
        <summary>Adds two values together to compute their sum.</summary>
        <returns>The sum of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IAdditionOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_CheckedAddition">
      <MemberSignature Language="C#" Value="static byte IAdditionOperators&lt;byte,byte,byte&gt;.op_CheckedAddition (byte left, byte right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig unsigned int8 System.Numerics.IAdditionOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_CheckedAddition(unsigned int8 left, unsigned int8 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IAdditionOperators&lt;System#Byte,System#Byte,System#Byte&gt;#op_CheckedAddition(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_CheckedAddition (left As Byte, right As Byte) As Byte Implements IAdditionOperators(Of Byte, Byte, Byte).op_CheckedAddition" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IAdditionOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_CheckedAddition : byte * byte -&gt; byte" Usage="System.byte.System.Numerics.IAdditionOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_CheckedAddition (left, right)" />
      <MemberSignature Language="C++ CLI" Value=" static System::Byte System.Numerics.IAdditionOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_CheckedAddition(System::Byte left, System::Byte right) = System::Numerics::IAdditionOperators&lt;System::Byte, System::Byte, System::Byte&gt;::op_CheckedAddition;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IAdditionOperators`3.op_CheckedAddition(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Byte" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to which <paramref name="right" /> is added.</param>
        <param name="right">The value that's added to <paramref name="left" />.</param>
        <summary>Adds two values together to compute their sum.</summary>
        <returns>The sum of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IAdditiveIdentity&lt;System.Byte,System.Byte&gt;.AdditiveIdentity">
      <MemberSignature Language="C#" Value="static byte System.Numerics.IAdditiveIdentity&lt;System.Byte,System.Byte&gt;.AdditiveIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property unsigned int8 System.Numerics.IAdditiveIdentity&lt;System.Byte,System.Byte&gt;.AdditiveIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Byte.System#Numerics#IAdditiveIdentity&lt;System#Byte,System#Byte&gt;#AdditiveIdentity" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property AdditiveIdentity As Byte Implements IAdditiveIdentity(Of Byte, Byte).AdditiveIdentity" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IAdditiveIdentity&lt;System.Byte,System.Byte&gt;.AdditiveIdentity : byte" Usage="System.Numerics.IAdditiveIdentity&lt;System.Byte,System.Byte&gt;.AdditiveIdentity" />
      <MemberSignature Language="C++ CLI" Value="static property System::Byte System::Numerics::IAdditiveIdentity&lt;System::Byte,System::Byte&gt;::AdditiveIdentity { System::Byte get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IAdditiveIdentity`2.AdditiveIdentity</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the additive identity of the current type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.Byte&gt;.GetByteCount">
      <MemberSignature Language="C#" Value="int IBinaryInteger&lt;byte&gt;.GetByteCount ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Numerics.IBinaryInteger&lt;System.Byte&gt;.GetByteCount() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IBinaryInteger&lt;System#Byte&gt;#GetByteCount" />
      <MemberSignature Language="VB.NET" Value="Function GetByteCount () As Integer Implements IBinaryInteger(Of Byte).GetByteCount" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.IBinaryInteger&lt;System.Byte&gt;.GetByteCount : unit -&gt; int&#xA;override this.System.Numerics.IBinaryInteger&lt;System.Byte&gt;.GetByteCount : unit -&gt; int" Usage="byte.System.Numerics.IBinaryInteger&lt;System.Byte&gt;.GetByteCount " />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Numerics.IBinaryInteger&lt;System.Byte&gt;.GetByteCount() = System::Numerics::IBinaryInteger&lt;System::Byte&gt;::GetByteCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.GetByteCount</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the number of bytes that will be written as part of <see cref="M:System.Numerics.IBinaryInteger`1.TryWriteLittleEndian(System.Span{System.Byte},System.Int32@)" />.</summary>
        <returns>The number of bytes that will be written as part of <see cref="M:System.Numerics.IBinaryInteger`1.TryWriteLittleEndian(System.Span{System.Byte},System.Int32@)" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.GetByteCount" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.Byte&gt;.GetShortestBitLength">
      <MemberSignature Language="C#" Value="int IBinaryInteger&lt;byte&gt;.GetShortestBitLength ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Numerics.IBinaryInteger&lt;System.Byte&gt;.GetShortestBitLength() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IBinaryInteger&lt;System#Byte&gt;#GetShortestBitLength" />
      <MemberSignature Language="VB.NET" Value="Function GetShortestBitLength () As Integer Implements IBinaryInteger(Of Byte).GetShortestBitLength" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.IBinaryInteger&lt;System.Byte&gt;.GetShortestBitLength : unit -&gt; int&#xA;override this.System.Numerics.IBinaryInteger&lt;System.Byte&gt;.GetShortestBitLength : unit -&gt; int" Usage="byte.System.Numerics.IBinaryInteger&lt;System.Byte&gt;.GetShortestBitLength " />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Numerics.IBinaryInteger&lt;System.Byte&gt;.GetShortestBitLength() = System::Numerics::IBinaryInteger&lt;System::Byte&gt;::GetShortestBitLength;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.GetShortestBitLength</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the length, in bits, of the shortest two's complement representation of the current value.</summary>
        <returns>The length, in bits, of the shortest two's complement representation of the current value.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.GetShortestBitLength" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.Byte&gt;.TryReadBigEndian">
      <MemberSignature Language="C#" Value="static bool IBinaryInteger&lt;byte&gt;.TryReadBigEndian (ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out byte value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IBinaryInteger&lt;System.Byte&gt;.TryReadBigEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, bool isUnsigned, [out] unsigned int8&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IBinaryInteger&lt;System#Byte&gt;#TryReadBigEndian(System.ReadOnlySpan{System.Byte},System.Boolean,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryReadBigEndian (source As ReadOnlySpan(Of Byte), isUnsigned As Boolean, ByRef value As Byte) As Boolean Implements IBinaryInteger(Of Byte).TryReadBigEndian" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IBinaryInteger&lt;System.Byte&gt;.TryReadBigEndian : ReadOnlySpan&lt;byte&gt; * bool * byte -&gt; bool" Usage="System.byte.System.Numerics.IBinaryInteger&lt;System.Byte&gt;.TryReadBigEndian (source, isUnsigned, value)" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IBinaryInteger&lt;System.Byte&gt;.TryReadBigEndian(ReadOnlySpan&lt;System::Byte&gt; source, bool isUnsigned, [Runtime::InteropServices::Out] System::Byte % value) = System::Numerics::IBinaryInteger&lt;System::Byte&gt;::TryReadBigEndian;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="value" Type="System.Byte" RefType="out" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.Byte&gt;.TryReadLittleEndian">
      <MemberSignature Language="C#" Value="static bool IBinaryInteger&lt;byte&gt;.TryReadLittleEndian (ReadOnlySpan&lt;byte&gt; source, bool isUnsigned, out byte value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IBinaryInteger&lt;System.Byte&gt;.TryReadLittleEndian(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; source, bool isUnsigned, [out] unsigned int8&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IBinaryInteger&lt;System#Byte&gt;#TryReadLittleEndian(System.ReadOnlySpan{System.Byte},System.Boolean,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryReadLittleEndian (source As ReadOnlySpan(Of Byte), isUnsigned As Boolean, ByRef value As Byte) As Boolean Implements IBinaryInteger(Of Byte).TryReadLittleEndian" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IBinaryInteger&lt;System.Byte&gt;.TryReadLittleEndian : ReadOnlySpan&lt;byte&gt; * bool * byte -&gt; bool" Usage="System.byte.System.Numerics.IBinaryInteger&lt;System.Byte&gt;.TryReadLittleEndian (source, isUnsigned, value)" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IBinaryInteger&lt;System.Byte&gt;.TryReadLittleEndian(ReadOnlySpan&lt;System::Byte&gt; source, bool isUnsigned, [Runtime::InteropServices::Out] System::Byte % value) = System::Numerics::IBinaryInteger&lt;System::Byte&gt;::TryReadLittleEndian;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="value" Type="System.Byte" RefType="out" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="source">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.Byte&gt;.TryWriteBigEndian">
      <MemberSignature Language="C#" Value="bool IBinaryInteger&lt;byte&gt;.TryWriteBigEndian (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Numerics.IBinaryInteger&lt;System.Byte&gt;.TryWriteBigEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IBinaryInteger&lt;System#Byte&gt;#TryWriteBigEndian(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Function TryWriteBigEndian (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean Implements IBinaryInteger(Of Byte).TryWriteBigEndian" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.IBinaryInteger&lt;System.Byte&gt;.TryWriteBigEndian : Span&lt;byte&gt; * int -&gt; bool&#xA;override this.System.Numerics.IBinaryInteger&lt;System.Byte&gt;.TryWriteBigEndian : Span&lt;byte&gt; * int -&gt; bool" Usage="byte.System.Numerics.IBinaryInteger&lt;System.Byte&gt;.TryWriteBigEndian (destination, bytesWritten)" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Numerics.IBinaryInteger&lt;System.Byte&gt;.TryWriteBigEndian(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten) = System::Numerics::IBinaryInteger&lt;System::Byte&gt;::TryWriteBigEndian;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.TryWriteBigEndian(System.Span{System.Byte},System.Int32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="destination">The span to which the current value should be written.</param>
        <param name="bytesWritten">When this method returns, contains the number of bytes written to <paramref name="destination" />.</param>
        <summary>Tries to write the current value, in big-endian format, to a given span.</summary>
        <returns>
          <see langword="true" /> if the value was succesfully written to <paramref name="destination" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.TryWriteBigEndian(System.Span{System.Byte},System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryInteger&lt;System.Byte&gt;.TryWriteLittleEndian">
      <MemberSignature Language="C#" Value="bool IBinaryInteger&lt;byte&gt;.TryWriteLittleEndian (Span&lt;byte&gt; destination, out int bytesWritten);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Numerics.IBinaryInteger&lt;System.Byte&gt;.TryWriteLittleEndian(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IBinaryInteger&lt;System#Byte&gt;#TryWriteLittleEndian(System.Span{System.Byte},System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Function TryWriteLittleEndian (destination As Span(Of Byte), ByRef bytesWritten As Integer) As Boolean Implements IBinaryInteger(Of Byte).TryWriteLittleEndian" />
      <MemberSignature Language="F#" Value="abstract member System.Numerics.IBinaryInteger&lt;System.Byte&gt;.TryWriteLittleEndian : Span&lt;byte&gt; * int -&gt; bool&#xA;override this.System.Numerics.IBinaryInteger&lt;System.Byte&gt;.TryWriteLittleEndian : Span&lt;byte&gt; * int -&gt; bool" Usage="byte.System.Numerics.IBinaryInteger&lt;System.Byte&gt;.TryWriteLittleEndian (destination, bytesWritten)" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Numerics.IBinaryInteger&lt;System.Byte&gt;.TryWriteLittleEndian(Span&lt;System::Byte&gt; destination, [Runtime::InteropServices::Out] int % bytesWritten) = System::Numerics::IBinaryInteger&lt;System::Byte&gt;::TryWriteLittleEndian;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.TryWriteLittleEndian(System.Span{System.Byte},System.Int32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="destination">The span to which the current value should be written.</param>
        <param name="bytesWritten">When this method returns, contains the number of bytes written to <paramref name="destination" />.</param>
        <summary>Tries to write the current value, in little-endian format, to a given span.</summary>
        <returns>
          <see langword="true" /> if the value was succesfully written to <paramref name="destination" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.TryWriteLittleEndian(System.Span{System.Byte},System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBinaryNumber&lt;System.Byte&gt;.AllBitsSet">
      <MemberSignature Language="C#" Value="static byte System.Numerics.IBinaryNumber&lt;System.Byte&gt;.AllBitsSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property unsigned int8 System.Numerics.IBinaryNumber&lt;System.Byte&gt;.AllBitsSet" />
      <MemberSignature Language="DocId" Value="P:System.Byte.System#Numerics#IBinaryNumber&lt;System#Byte&gt;#AllBitsSet" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property AllBitsSet As Byte Implements IBinaryNumber(Of Byte).AllBitsSet" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IBinaryNumber&lt;System.Byte&gt;.AllBitsSet : byte" Usage="System.Numerics.IBinaryNumber&lt;System.Byte&gt;.AllBitsSet" />
      <MemberSignature Language="C++ CLI" Value="static property System::Byte System::Numerics::IBinaryNumber&lt;System::Byte&gt;::AllBitsSet { System::Byte get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IBinaryNumber`1.AllBitsSet</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an instance of the binary type in which all bits are set.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBitwiseOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_BitwiseAnd">
      <MemberSignature Language="C#" Value="static byte IBitwiseOperators&lt;byte,byte,byte&gt;.operator &amp; (byte left, byte right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig unsigned int8 System.Numerics.IBitwiseOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_BitwiseAnd(unsigned int8 left, unsigned int8 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IBitwiseOperators&lt;System#Byte,System#Byte,System#Byte&gt;#op_BitwiseAnd(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator And (left As Byte, right As Byte) As Byte Implements IBitwiseOperators(Of Byte, Byte, Byte).op_BitwiseAnd" />
      <MemberSignature Language="F#" Value="static member ( &amp;&amp;&amp; ) : byte * byte -&gt; byte" Usage="left &amp;&amp;&amp; right" />
      <MemberSignature Language="C++ CLI" Value=" static System::Byte System.Numerics.IBitwiseOperators&lt;System.Byte,System.Byte,System.Byte&gt;.operator &amp;(System::Byte left, System::Byte right) = System::Numerics::IBitwiseOperators&lt;System::Byte, System::Byte, System::Byte&gt;::op_BitwiseAnd;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBitwiseOperators`3.op_BitwiseAnd(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Byte" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to <see langword="and" /> with <paramref name="right" />.</param>
        <param name="right">The value to <see langword="and" /> with <paramref name="left" />.</param>
        <summary>Computes the bitwise-and of two values.</summary>
        <returns>The bitwise-and of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBitwiseOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_BitwiseOr">
      <MemberSignature Language="C#" Value="static byte IBitwiseOperators&lt;byte,byte,byte&gt;.operator | (byte left, byte right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig unsigned int8 System.Numerics.IBitwiseOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_BitwiseOr(unsigned int8 left, unsigned int8 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IBitwiseOperators&lt;System#Byte,System#Byte,System#Byte&gt;#op_BitwiseOr(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator Or (left As Byte, right As Byte) As Byte Implements IBitwiseOperators(Of Byte, Byte, Byte).op_BitwiseOr" />
      <MemberSignature Language="F#" Value="static member ( ||| ) : byte * byte -&gt; byte" Usage="left ||| right" />
      <MemberSignature Language="C++ CLI" Value=" static System::Byte System.Numerics.IBitwiseOperators&lt;System.Byte,System.Byte,System.Byte&gt;.operator |(System::Byte left, System::Byte right) = System::Numerics::IBitwiseOperators&lt;System::Byte, System::Byte, System::Byte&gt;::op_BitwiseOr;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBitwiseOperators`3.op_BitwiseOr(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Byte" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to <see langword="or" /> with <paramref name="right" />.</param>
        <param name="right">The value to <see langword="or" /> with <paramref name="left" />.</param>
        <summary>Computes the bitwise-or of two values.</summary>
        <returns>The bitwise-or of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBitwiseOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_ExclusiveOr">
      <MemberSignature Language="C#" Value="static byte IBitwiseOperators&lt;byte,byte,byte&gt;.operator ^ (byte left, byte right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig unsigned int8 System.Numerics.IBitwiseOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_ExclusiveOr(unsigned int8 left, unsigned int8 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IBitwiseOperators&lt;System#Byte,System#Byte,System#Byte&gt;#op_ExclusiveOr(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator Xor (left As Byte, right As Byte) As Byte Implements IBitwiseOperators(Of Byte, Byte, Byte).op_ExclusiveOr" />
      <MemberSignature Language="F#" Value="static member ( ^^^ ) : byte * byte -&gt; byte" Usage="left ^^^ right" />
      <MemberSignature Language="C++ CLI" Value=" static System::Byte System.Numerics.IBitwiseOperators&lt;System.Byte,System.Byte,System.Byte&gt;.operator ^(System::Byte left, System::Byte right) = System::Numerics::IBitwiseOperators&lt;System::Byte, System::Byte, System::Byte&gt;::op_ExclusiveOr;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBitwiseOperators`3.op_ExclusiveOr(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Byte" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to xor with <paramref name="right" />.</param>
        <param name="right">The value to xor with <paramref name="left" />.</param>
        <summary>Computes the exclusive-or of two values.</summary>
        <returns>The exclusive-or of <paramref name="left" /> and <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IBitwiseOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_OnesComplement">
      <MemberSignature Language="C#" Value="static byte IBitwiseOperators&lt;byte,byte,byte&gt;.operator ~ (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig unsigned int8 System.Numerics.IBitwiseOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_OnesComplement(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IBitwiseOperators&lt;System#Byte,System#Byte,System#Byte&gt;#op_OnesComplement(System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator Not (value As Byte) As Byte Implements IBitwiseOperators(Of Byte, Byte, Byte).op_OnesComplement" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IBitwiseOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_OnesComplement : byte -&gt; byte" Usage="System.byte.System.Numerics.IBitwiseOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_OnesComplement value" />
      <MemberSignature Language="C++ CLI" Value=" static System::Byte System.Numerics.IBitwiseOperators&lt;System.Byte,System.Byte,System.Byte&gt;.operator ~(System::Byte value) = System::Numerics::IBitwiseOperators&lt;System::Byte, System::Byte, System::Byte&gt;::op_OnesComplement;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBitwiseOperators`3.op_OnesComplement(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value for which to compute the ones-complement.</param>
        <summary>Computes the ones-complement representation of a given value.</summary>
        <returns>The ones-complement of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IComparisonOperators&lt;System.Byte,System.Byte,System.Boolean&gt;.op_GreaterThan">
      <MemberSignature Language="C#" Value="static bool IComparisonOperators&lt;byte,byte,bool&gt;.operator &gt; (byte left, byte right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IComparisonOperators&lt;System.Byte,System.Byte,System.Boolean&gt;.op_GreaterThan(unsigned int8 left, unsigned int8 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IComparisonOperators&lt;System#Byte,System#Byte,System#Boolean&gt;#op_GreaterThan(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator &gt; (left As Byte, right As Byte) As Boolean Implements IComparisonOperators(Of Byte, Byte, Boolean).op_GreaterThan" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : byte * byte -&gt; bool" Usage="left &gt; right" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IComparisonOperators&lt;System.Byte,System.Byte,System.Boolean&gt;.operator &gt;(System::Byte left, System::Byte right) = System::Numerics::IComparisonOperators&lt;System::Byte, System::Byte, bool&gt;::op_GreaterThan;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IComparisonOperators`3.op_GreaterThan(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Byte" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to compare with <paramref name="right" />.</param>
        <param name="right">The value to compare with <paramref name="left" />.</param>
        <summary>Compares two values to determine which is greater.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is greater than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IComparisonOperators&lt;System.Byte,System.Byte,System.Boolean&gt;.op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="static bool IComparisonOperators&lt;byte,byte,bool&gt;.operator &gt;= (byte left, byte right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IComparisonOperators&lt;System.Byte,System.Byte,System.Boolean&gt;.op_GreaterThanOrEqual(unsigned int8 left, unsigned int8 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IComparisonOperators&lt;System#Byte,System#Byte,System#Boolean&gt;#op_GreaterThanOrEqual(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator &gt;= (left As Byte, right As Byte) As Boolean Implements IComparisonOperators(Of Byte, Byte, Boolean).op_GreaterThanOrEqual" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : byte * byte -&gt; bool" Usage="left &gt;= right" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IComparisonOperators&lt;System.Byte,System.Byte,System.Boolean&gt;.operator &gt;=(System::Byte left, System::Byte right) = System::Numerics::IComparisonOperators&lt;System::Byte, System::Byte, bool&gt;::op_GreaterThanOrEqual;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IComparisonOperators`3.op_GreaterThanOrEqual(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Byte" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to compare with <paramref name="right" />.</param>
        <param name="right">The value to compare with <paramref name="left" />.</param>
        <summary>Compares two values to determine which is greater or equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is greater than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IComparisonOperators&lt;System.Byte,System.Byte,System.Boolean&gt;.op_LessThan">
      <MemberSignature Language="C#" Value="static bool IComparisonOperators&lt;byte,byte,bool&gt;.operator &lt; (byte left, byte right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IComparisonOperators&lt;System.Byte,System.Byte,System.Boolean&gt;.op_LessThan(unsigned int8 left, unsigned int8 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IComparisonOperators&lt;System#Byte,System#Byte,System#Boolean&gt;#op_LessThan(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator &lt; (left As Byte, right As Byte) As Boolean Implements IComparisonOperators(Of Byte, Byte, Boolean).op_LessThan" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : byte * byte -&gt; bool" Usage="left &lt; right" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IComparisonOperators&lt;System.Byte,System.Byte,System.Boolean&gt;.operator &lt;(System::Byte left, System::Byte right) = System::Numerics::IComparisonOperators&lt;System::Byte, System::Byte, bool&gt;::op_LessThan;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IComparisonOperators`3.op_LessThan(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Byte" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to compare with <paramref name="right" />.</param>
        <param name="right">The value to compare with <paramref name="left" />.</param>
        <summary>Compares two values to determine which is less.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is less than <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IComparisonOperators&lt;System.Byte,System.Byte,System.Boolean&gt;.op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="static bool IComparisonOperators&lt;byte,byte,bool&gt;.operator &lt;= (byte left, byte right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IComparisonOperators&lt;System.Byte,System.Byte,System.Boolean&gt;.op_LessThanOrEqual(unsigned int8 left, unsigned int8 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IComparisonOperators&lt;System#Byte,System#Byte,System#Boolean&gt;#op_LessThanOrEqual(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator &lt;= (left As Byte, right As Byte) As Boolean Implements IComparisonOperators(Of Byte, Byte, Boolean).op_LessThanOrEqual" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : byte * byte -&gt; bool" Usage="left &lt;= right" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IComparisonOperators&lt;System.Byte,System.Byte,System.Boolean&gt;.operator &lt;=(System::Byte left, System::Byte right) = System::Numerics::IComparisonOperators&lt;System::Byte, System::Byte, bool&gt;::op_LessThanOrEqual;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IComparisonOperators`3.op_LessThanOrEqual(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Byte" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to compare with <paramref name="right" />.</param>
        <param name="right">The value to compare with <paramref name="left" />.</param>
        <summary>Compares two values to determine which is less or equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is less than or equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IDecrementOperators&lt;System.Byte&gt;.op_CheckedDecrement">
      <MemberSignature Language="C#" Value="static byte IDecrementOperators&lt;byte&gt;.op_CheckedDecrement (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig unsigned int8 System.Numerics.IDecrementOperators&lt;System.Byte&gt;.op_CheckedDecrement(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IDecrementOperators&lt;System#Byte&gt;#op_CheckedDecrement(System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_CheckedDecrement (value As Byte) As Byte Implements IDecrementOperators(Of Byte).op_CheckedDecrement" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IDecrementOperators&lt;System.Byte&gt;.op_CheckedDecrement : byte -&gt; byte" Usage="System.byte.System.Numerics.IDecrementOperators&lt;System.Byte&gt;.op_CheckedDecrement value" />
      <MemberSignature Language="C++ CLI" Value=" static System::Byte System.Numerics.IDecrementOperators&lt;System.Byte&gt;.op_CheckedDecrement(System::Byte value) = System::Numerics::IDecrementOperators&lt;System::Byte&gt;::op_CheckedDecrement;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IDecrementOperators`1.op_CheckedDecrement(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to decrement.</param>
        <summary>Decrements a value.</summary>
        <returns>The result of decrementing <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IDecrementOperators&lt;System.Byte&gt;.op_Decrement">
      <MemberSignature Language="C#" Value="static byte IDecrementOperators&lt;byte&gt;.operator -- (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig unsigned int8 System.Numerics.IDecrementOperators&lt;System.Byte&gt;.op_Decrement(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IDecrementOperators&lt;System#Byte&gt;#op_Decrement(System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_Decrement (value As Byte) As Byte Implements IDecrementOperators(Of Byte).op_Decrement" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IDecrementOperators&lt;System.Byte&gt;.op_Decrement : byte -&gt; byte" Usage="System.byte.System.Numerics.IDecrementOperators&lt;System.Byte&gt;.op_Decrement value" />
      <MemberSignature Language="C++ CLI" Value=" static System::Byte System.Numerics.IDecrementOperators&lt;System.Byte&gt;.operator --(System::Byte value) = System::Numerics::IDecrementOperators&lt;System::Byte&gt;::op_Decrement;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IDecrementOperators`1.op_Decrement(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to decrement.</param>
        <summary>Decrements a value.</summary>
        <returns>The result of decrementing <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IDivisionOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_Division">
      <MemberSignature Language="C#" Value="static byte IDivisionOperators&lt;byte,byte,byte&gt;.operator / (byte left, byte right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig unsigned int8 System.Numerics.IDivisionOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_Division(unsigned int8 left, unsigned int8 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IDivisionOperators&lt;System#Byte,System#Byte,System#Byte&gt;#op_Division(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator / (left As Byte, right As Byte) As Byte Implements IDivisionOperators(Of Byte, Byte, Byte).op_Division" />
      <MemberSignature Language="F#" Value="static member ( / ) : byte * byte -&gt; byte" Usage="left / right" />
      <MemberSignature Language="C++ CLI" Value=" static System::Byte System.Numerics.IDivisionOperators&lt;System.Byte,System.Byte,System.Byte&gt;.operator /(System::Byte left, System::Byte right) = System::Numerics::IDivisionOperators&lt;System::Byte, System::Byte, System::Byte&gt;::op_Division;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IDivisionOperators`3.op_Division(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Byte" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value that <paramref name="right" /> divides.</param>
        <param name="right">The value that divides <paramref name="left" />.</param>
        <summary>Divides one value by another to compute their quotient.</summary>
        <returns>The quotient of <paramref name="left" /> divided by <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IEqualityOperators&lt;System.Byte,System.Byte,System.Boolean&gt;.op_Equality">
      <MemberSignature Language="C#" Value="static bool IEqualityOperators&lt;byte,byte,bool&gt;.operator == (byte left, byte right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IEqualityOperators&lt;System.Byte,System.Byte,System.Boolean&gt;.op_Equality(unsigned int8 left, unsigned int8 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IEqualityOperators&lt;System#Byte,System#Byte,System#Boolean&gt;#op_Equality(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator == (left As Byte, right As Byte) As Boolean Implements IEqualityOperators(Of Byte, Byte, Boolean).op_Equality" />
      <MemberSignature Language="F#" Value="static member ( = ) : byte * byte -&gt; bool" Usage="left = right" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IEqualityOperators&lt;System.Byte,System.Byte,System.Boolean&gt;.operator ==(System::Byte left, System::Byte right) = System::Numerics::IEqualityOperators&lt;System::Byte, System::Byte, bool&gt;::op_Equality;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IEqualityOperators`3.op_Equality(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Byte" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to compare with <paramref name="right" />.</param>
        <param name="right">The value to compare with <paramref name="left" />.</param>
        <summary>Compares two values to determine equality.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IEqualityOperators&lt;System.Byte,System.Byte,System.Boolean&gt;.op_Inequality">
      <MemberSignature Language="C#" Value="static bool IEqualityOperators&lt;byte,byte,bool&gt;.operator != (byte left, byte right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.IEqualityOperators&lt;System.Byte,System.Byte,System.Boolean&gt;.op_Inequality(unsigned int8 left, unsigned int8 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IEqualityOperators&lt;System#Byte,System#Byte,System#Boolean&gt;#op_Inequality(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator != (left As Byte, right As Byte) As Boolean Implements IEqualityOperators(Of Byte, Byte, Boolean).op_Inequality" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IEqualityOperators&lt;System.Byte,System.Byte,System.Boolean&gt;.op_Inequality : byte * byte -&gt; bool" Usage="System.byte.System.Numerics.IEqualityOperators&lt;System.Byte,System.Byte,System.Boolean&gt;.op_Inequality (left, right)" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.IEqualityOperators&lt;System.Byte,System.Byte,System.Boolean&gt;.operator !=(System::Byte left, System::Byte right) = System::Numerics::IEqualityOperators&lt;System::Byte, System::Byte, bool&gt;::op_Inequality;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IEqualityOperators`3.op_Inequality(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Byte" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value to compare with <paramref name="right" />.</param>
        <param name="right">The value to compare with <paramref name="left" />.</param>
        <summary>Compares two values to determine inequality.</summary>
        <returns>
          <see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IIncrementOperators&lt;System.Byte&gt;.op_CheckedIncrement">
      <MemberSignature Language="C#" Value="static byte IIncrementOperators&lt;byte&gt;.op_CheckedIncrement (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig unsigned int8 System.Numerics.IIncrementOperators&lt;System.Byte&gt;.op_CheckedIncrement(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IIncrementOperators&lt;System#Byte&gt;#op_CheckedIncrement(System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_CheckedIncrement (value As Byte) As Byte Implements IIncrementOperators(Of Byte).op_CheckedIncrement" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IIncrementOperators&lt;System.Byte&gt;.op_CheckedIncrement : byte -&gt; byte" Usage="System.byte.System.Numerics.IIncrementOperators&lt;System.Byte&gt;.op_CheckedIncrement value" />
      <MemberSignature Language="C++ CLI" Value=" static System::Byte System.Numerics.IIncrementOperators&lt;System.Byte&gt;.op_CheckedIncrement(System::Byte value) = System::Numerics::IIncrementOperators&lt;System::Byte&gt;::op_CheckedIncrement;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IIncrementOperators`1.op_CheckedIncrement(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to increment.</param>
        <summary>Increments a value.</summary>
        <returns>The result of incrementing <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IIncrementOperators&lt;System.Byte&gt;.op_Increment">
      <MemberSignature Language="C#" Value="static byte IIncrementOperators&lt;byte&gt;.operator ++ (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig unsigned int8 System.Numerics.IIncrementOperators&lt;System.Byte&gt;.op_Increment(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IIncrementOperators&lt;System#Byte&gt;#op_Increment(System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_Increment (value As Byte) As Byte Implements IIncrementOperators(Of Byte).op_Increment" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IIncrementOperators&lt;System.Byte&gt;.op_Increment : byte -&gt; byte" Usage="System.byte.System.Numerics.IIncrementOperators&lt;System.Byte&gt;.op_Increment value" />
      <MemberSignature Language="C++ CLI" Value=" static System::Byte System.Numerics.IIncrementOperators&lt;System.Byte&gt;.operator ++(System::Byte value) = System::Numerics::IIncrementOperators&lt;System::Byte&gt;::op_Increment;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IIncrementOperators`1.op_Increment(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to increment.</param>
        <summary>Increments a value.</summary>
        <returns>The result of incrementing <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IMinMaxValue&lt;System.Byte&gt;.MaxValue">
      <MemberSignature Language="C#" Value="static byte System.Numerics.IMinMaxValue&lt;System.Byte&gt;.MaxValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property unsigned int8 System.Numerics.IMinMaxValue&lt;System.Byte&gt;.MaxValue" />
      <MemberSignature Language="DocId" Value="P:System.Byte.System#Numerics#IMinMaxValue&lt;System#Byte&gt;#MaxValue" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property MaxValue As Byte Implements IMinMaxValue(Of Byte).MaxValue" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IMinMaxValue&lt;System.Byte&gt;.MaxValue : byte" Usage="System.Numerics.IMinMaxValue&lt;System.Byte&gt;.MaxValue" />
      <MemberSignature Language="C++ CLI" Value="static property System::Byte System::Numerics::IMinMaxValue&lt;System::Byte&gt;::MaxValue { System::Byte get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IMinMaxValue`1.MaxValue</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the maximum value of the current type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IMinMaxValue&lt;System.Byte&gt;.MinValue">
      <MemberSignature Language="C#" Value="static byte System.Numerics.IMinMaxValue&lt;System.Byte&gt;.MinValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property unsigned int8 System.Numerics.IMinMaxValue&lt;System.Byte&gt;.MinValue" />
      <MemberSignature Language="DocId" Value="P:System.Byte.System#Numerics#IMinMaxValue&lt;System#Byte&gt;#MinValue" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property MinValue As Byte Implements IMinMaxValue(Of Byte).MinValue" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IMinMaxValue&lt;System.Byte&gt;.MinValue : byte" Usage="System.Numerics.IMinMaxValue&lt;System.Byte&gt;.MinValue" />
      <MemberSignature Language="C++ CLI" Value="static property System::Byte System::Numerics::IMinMaxValue&lt;System::Byte&gt;::MinValue { System::Byte get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IMinMaxValue`1.MinValue</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the minimum value of the current type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IModulusOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_Modulus">
      <MemberSignature Language="C#" Value="static byte IModulusOperators&lt;byte,byte,byte&gt;.operator % (byte left, byte right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig unsigned int8 System.Numerics.IModulusOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_Modulus(unsigned int8 left, unsigned int8 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IModulusOperators&lt;System#Byte,System#Byte,System#Byte&gt;#op_Modulus(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator Mod (left As Byte, right As Byte) As Byte Implements IModulusOperators(Of Byte, Byte, Byte).op_Modulus" />
      <MemberSignature Language="F#" Value="static member ( % ) : byte * byte -&gt; byte" Usage="left % right" />
      <MemberSignature Language="C++ CLI" Value=" static System::Byte System.Numerics.IModulusOperators&lt;System.Byte,System.Byte,System.Byte&gt;.operator %(System::Byte left, System::Byte right) = System::Numerics::IModulusOperators&lt;System::Byte, System::Byte, System::Byte&gt;::op_Modulus;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IModulusOperators`3.op_Modulus(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Byte" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value that <paramref name="right" /> divides.</param>
        <param name="right">The value that divides <paramref name="left" />.</param>
        <summary>Divides two values together to compute their modulus or remainder.</summary>
        <returns>The modulus or remainder of <paramref name="left" /> divided by <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IMultiplicativeIdentity&lt;System.Byte,System.Byte&gt;.MultiplicativeIdentity">
      <MemberSignature Language="C#" Value="static byte System.Numerics.IMultiplicativeIdentity&lt;System.Byte,System.Byte&gt;.MultiplicativeIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property unsigned int8 System.Numerics.IMultiplicativeIdentity&lt;System.Byte,System.Byte&gt;.MultiplicativeIdentity" />
      <MemberSignature Language="DocId" Value="P:System.Byte.System#Numerics#IMultiplicativeIdentity&lt;System#Byte,System#Byte&gt;#MultiplicativeIdentity" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property MultiplicativeIdentity As Byte Implements IMultiplicativeIdentity(Of Byte, Byte).MultiplicativeIdentity" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IMultiplicativeIdentity&lt;System.Byte,System.Byte&gt;.MultiplicativeIdentity : byte" Usage="System.Numerics.IMultiplicativeIdentity&lt;System.Byte,System.Byte&gt;.MultiplicativeIdentity" />
      <MemberSignature Language="C++ CLI" Value="static property System::Byte System::Numerics::IMultiplicativeIdentity&lt;System::Byte,System::Byte&gt;::MultiplicativeIdentity { System::Byte get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.IMultiplicativeIdentity`2.MultiplicativeIdentity</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the multiplicative identity of the current type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IMultiplyOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_CheckedMultiply">
      <MemberSignature Language="C#" Value="static byte IMultiplyOperators&lt;byte,byte,byte&gt;.op_CheckedMultiply (byte left, byte right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig unsigned int8 System.Numerics.IMultiplyOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_CheckedMultiply(unsigned int8 left, unsigned int8 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IMultiplyOperators&lt;System#Byte,System#Byte,System#Byte&gt;#op_CheckedMultiply(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_CheckedMultiply (left As Byte, right As Byte) As Byte Implements IMultiplyOperators(Of Byte, Byte, Byte).op_CheckedMultiply" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IMultiplyOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_CheckedMultiply : byte * byte -&gt; byte" Usage="System.byte.System.Numerics.IMultiplyOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_CheckedMultiply (left, right)" />
      <MemberSignature Language="C++ CLI" Value=" static System::Byte System.Numerics.IMultiplyOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_CheckedMultiply(System::Byte left, System::Byte right) = System::Numerics::IMultiplyOperators&lt;System::Byte, System::Byte, System::Byte&gt;::op_CheckedMultiply;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IMultiplyOperators`3.op_CheckedMultiply(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Byte" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value that <paramref name="right" /> multiplies.</param>
        <param name="right">The value that multiplies <paramref name="left" />.</param>
        <summary>Multiplies two values together to compute their product.</summary>
        <returns>The product of <paramref name="left" /> multiplied by <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IMultiplyOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_Multiply">
      <MemberSignature Language="C#" Value="static byte IMultiplyOperators&lt;byte,byte,byte&gt;.operator * (byte left, byte right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig unsigned int8 System.Numerics.IMultiplyOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_Multiply(unsigned int8 left, unsigned int8 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IMultiplyOperators&lt;System#Byte,System#Byte,System#Byte&gt;#op_Multiply(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator * (left As Byte, right As Byte) As Byte Implements IMultiplyOperators(Of Byte, Byte, Byte).op_Multiply" />
      <MemberSignature Language="F#" Value="static member ( * ) : byte * byte -&gt; byte" Usage="left * right" />
      <MemberSignature Language="C++ CLI" Value=" static System::Byte System.Numerics.IMultiplyOperators&lt;System.Byte,System.Byte,System.Byte&gt;.operator *(System::Byte left, System::Byte right) = System::Numerics::IMultiplyOperators&lt;System::Byte, System::Byte, System::Byte&gt;::op_Multiply;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IMultiplyOperators`3.op_Multiply(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Byte" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value that <paramref name="right" /> multiplies.</param>
        <param name="right">The value that multiplies <paramref name="left" />.</param>
        <summary>Multiplies two values together to compute their product.</summary>
        <returns>The product of <paramref name="left" /> multiplied by <paramref name="right" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumber&lt;System.Byte&gt;.CopySign">
      <MemberSignature Language="C#" Value="static byte INumber&lt;byte&gt;.CopySign (byte value, byte sign);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig unsigned int8 System.Numerics.INumber&lt;System.Byte&gt;.CopySign(unsigned int8 value, unsigned int8 sign) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#INumber&lt;System#Byte&gt;#CopySign(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function CopySign (value As Byte, sign As Byte) As Byte Implements INumber(Of Byte).CopySign" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumber&lt;System.Byte&gt;.CopySign : byte * byte -&gt; byte" Usage="System.byte.System.Numerics.INumber&lt;System.Byte&gt;.CopySign (value, sign)" />
      <MemberSignature Language="C++ CLI" Value=" static System::Byte System.Numerics.INumber&lt;System.Byte&gt;.CopySign(System::Byte value, System::Byte sign) = System::Numerics::INumber&lt;System::Byte&gt;::CopySign;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.CopySign(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="sign" Type="System.Byte" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value whose magnitude is used in the result.</param>
        <param name="sign">The value whose sign is used in the result.</param>
        <summary>Copies the sign of a value to the sign of another value.</summary>
        <returns>A value with the magnitude of <paramref name="value" /> and the sign of <paramref name="sign" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumber&lt;System.Byte&gt;.MaxNumber">
      <MemberSignature Language="C#" Value="static byte INumber&lt;byte&gt;.MaxNumber (byte x, byte y);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig unsigned int8 System.Numerics.INumber&lt;System.Byte&gt;.MaxNumber(unsigned int8 x, unsigned int8 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#INumber&lt;System#Byte&gt;#MaxNumber(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function MaxNumber (x As Byte, y As Byte) As Byte Implements INumber(Of Byte).MaxNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumber&lt;System.Byte&gt;.MaxNumber : byte * byte -&gt; byte" Usage="System.byte.System.Numerics.INumber&lt;System.Byte&gt;.MaxNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value=" static System::Byte System.Numerics.INumber&lt;System.Byte&gt;.MaxNumber(System::Byte x, System::Byte y) = System::Numerics::INumber&lt;System::Byte&gt;::MaxNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.MaxNumber(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.Byte" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is greater and returning the other value if an input is <c>NaN</c>.</summary>
        <returns>
          <paramref name="x" /> if it is greater than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumber&lt;System.Byte&gt;.MinNumber">
      <MemberSignature Language="C#" Value="static byte INumber&lt;byte&gt;.MinNumber (byte x, byte y);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig unsigned int8 System.Numerics.INumber&lt;System.Byte&gt;.MinNumber(unsigned int8 x, unsigned int8 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#INumber&lt;System#Byte&gt;#MinNumber(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function MinNumber (x As Byte, y As Byte) As Byte Implements INumber(Of Byte).MinNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumber&lt;System.Byte&gt;.MinNumber : byte * byte -&gt; byte" Usage="System.byte.System.Numerics.INumber&lt;System.Byte&gt;.MinNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value=" static System::Byte System.Numerics.INumber&lt;System.Byte&gt;.MinNumber(System::Byte x, System::Byte y) = System::Numerics::INumber&lt;System::Byte&gt;::MinNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumber`1.MinNumber(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.Byte" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is lesser and returning the other value if an input is <c>NaN</c>.</summary>
        <returns>
          <paramref name="x" /> if it is less than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Byte&gt;.Abs">
      <MemberSignature Language="C#" Value="static byte INumberBase&lt;byte&gt;.Abs (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig unsigned int8 System.Numerics.INumberBase&lt;System.Byte&gt;.Abs(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#INumberBase&lt;System#Byte&gt;#Abs(System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function Abs (value As Byte) As Byte Implements INumberBase(Of Byte).Abs" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Byte&gt;.Abs : byte -&gt; byte" Usage="System.byte.System.Numerics.INumberBase&lt;System.Byte&gt;.Abs value" />
      <MemberSignature Language="C++ CLI" Value=" static System::Byte System.Numerics.INumberBase&lt;System.Byte&gt;.Abs(System::Byte value) = System::Numerics::INumberBase&lt;System::Byte&gt;::Abs;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.Abs(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value for which to get its absolute.</param>
        <summary>Computes the absolute of a value.</summary>
        <returns>The absolute of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Byte&gt;.IsCanonical">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;byte&gt;.IsCanonical (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Byte&gt;.IsCanonical(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#INumberBase&lt;System#Byte&gt;#IsCanonical(System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsCanonical (value As Byte) As Boolean Implements INumberBase(Of Byte).IsCanonical" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Byte&gt;.IsCanonical : byte -&gt; bool" Usage="System.byte.System.Numerics.INumberBase&lt;System.Byte&gt;.IsCanonical value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Byte&gt;.IsCanonical(System::Byte value) = System::Numerics::INumberBase&lt;System::Byte&gt;::IsCanonical;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsCanonical(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is in its canonical representation.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is in its canonical representation; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Byte&gt;.IsComplexNumber">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;byte&gt;.IsComplexNumber (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Byte&gt;.IsComplexNumber(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#INumberBase&lt;System#Byte&gt;#IsComplexNumber(System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsComplexNumber (value As Byte) As Boolean Implements INumberBase(Of Byte).IsComplexNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Byte&gt;.IsComplexNumber : byte -&gt; bool" Usage="System.byte.System.Numerics.INumberBase&lt;System.Byte&gt;.IsComplexNumber value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Byte&gt;.IsComplexNumber(System::Byte value) = System::Numerics::INumberBase&lt;System::Byte&gt;::IsComplexNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsComplexNumber(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents a complex number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is a complex number; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Byte&gt;.IsFinite">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;byte&gt;.IsFinite (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Byte&gt;.IsFinite(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#INumberBase&lt;System#Byte&gt;#IsFinite(System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsFinite (value As Byte) As Boolean Implements INumberBase(Of Byte).IsFinite" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Byte&gt;.IsFinite : byte -&gt; bool" Usage="System.byte.System.Numerics.INumberBase&lt;System.Byte&gt;.IsFinite value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Byte&gt;.IsFinite(System::Byte value) = System::Numerics::INumberBase&lt;System::Byte&gt;::IsFinite;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsFinite(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is finite.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is finite; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Byte&gt;.IsImaginaryNumber">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;byte&gt;.IsImaginaryNumber (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Byte&gt;.IsImaginaryNumber(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#INumberBase&lt;System#Byte&gt;#IsImaginaryNumber(System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsImaginaryNumber (value As Byte) As Boolean Implements INumberBase(Of Byte).IsImaginaryNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Byte&gt;.IsImaginaryNumber : byte -&gt; bool" Usage="System.byte.System.Numerics.INumberBase&lt;System.Byte&gt;.IsImaginaryNumber value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Byte&gt;.IsImaginaryNumber(System::Byte value) = System::Numerics::INumberBase&lt;System::Byte&gt;::IsImaginaryNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsImaginaryNumber(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents a pure imaginary number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is a pure imaginary number; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Byte&gt;.IsInfinity">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;byte&gt;.IsInfinity (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Byte&gt;.IsInfinity(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#INumberBase&lt;System#Byte&gt;#IsInfinity(System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsInfinity (value As Byte) As Boolean Implements INumberBase(Of Byte).IsInfinity" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Byte&gt;.IsInfinity : byte -&gt; bool" Usage="System.byte.System.Numerics.INumberBase&lt;System.Byte&gt;.IsInfinity value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Byte&gt;.IsInfinity(System::Byte value) = System::Numerics::INumberBase&lt;System::Byte&gt;::IsInfinity;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsInfinity(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is infinite.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is infinite; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Byte&gt;.IsInteger">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;byte&gt;.IsInteger (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Byte&gt;.IsInteger(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#INumberBase&lt;System#Byte&gt;#IsInteger(System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsInteger (value As Byte) As Boolean Implements INumberBase(Of Byte).IsInteger" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Byte&gt;.IsInteger : byte -&gt; bool" Usage="System.byte.System.Numerics.INumberBase&lt;System.Byte&gt;.IsInteger value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Byte&gt;.IsInteger(System::Byte value) = System::Numerics::INumberBase&lt;System::Byte&gt;::IsInteger;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsInteger(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents an integral number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is an integer; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Byte&gt;.IsNaN">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;byte&gt;.IsNaN (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Byte&gt;.IsNaN(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#INumberBase&lt;System#Byte&gt;#IsNaN(System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsNaN (value As Byte) As Boolean Implements INumberBase(Of Byte).IsNaN" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Byte&gt;.IsNaN : byte -&gt; bool" Usage="System.byte.System.Numerics.INumberBase&lt;System.Byte&gt;.IsNaN value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Byte&gt;.IsNaN(System::Byte value) = System::Numerics::INumberBase&lt;System::Byte&gt;::IsNaN;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsNaN(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is NaN.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is NaN; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Byte&gt;.IsNegative">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;byte&gt;.IsNegative (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Byte&gt;.IsNegative(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#INumberBase&lt;System#Byte&gt;#IsNegative(System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsNegative (value As Byte) As Boolean Implements INumberBase(Of Byte).IsNegative" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Byte&gt;.IsNegative : byte -&gt; bool" Usage="System.byte.System.Numerics.INumberBase&lt;System.Byte&gt;.IsNegative value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Byte&gt;.IsNegative(System::Byte value) = System::Numerics::INumberBase&lt;System::Byte&gt;::IsNegative;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsNegative(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is negative.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is negative; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Byte&gt;.IsNegativeInfinity">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;byte&gt;.IsNegativeInfinity (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Byte&gt;.IsNegativeInfinity(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#INumberBase&lt;System#Byte&gt;#IsNegativeInfinity(System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsNegativeInfinity (value As Byte) As Boolean Implements INumberBase(Of Byte).IsNegativeInfinity" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Byte&gt;.IsNegativeInfinity : byte -&gt; bool" Usage="System.byte.System.Numerics.INumberBase&lt;System.Byte&gt;.IsNegativeInfinity value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Byte&gt;.IsNegativeInfinity(System::Byte value) = System::Numerics::INumberBase&lt;System::Byte&gt;::IsNegativeInfinity;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsNegativeInfinity(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is negative infinity.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is negative infinity; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Byte&gt;.IsNormal">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;byte&gt;.IsNormal (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Byte&gt;.IsNormal(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#INumberBase&lt;System#Byte&gt;#IsNormal(System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsNormal (value As Byte) As Boolean Implements INumberBase(Of Byte).IsNormal" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Byte&gt;.IsNormal : byte -&gt; bool" Usage="System.byte.System.Numerics.INumberBase&lt;System.Byte&gt;.IsNormal value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Byte&gt;.IsNormal(System::Byte value) = System::Numerics::INumberBase&lt;System::Byte&gt;::IsNormal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsNormal(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is normal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is normal; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Byte&gt;.IsPositive">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;byte&gt;.IsPositive (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Byte&gt;.IsPositive(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#INumberBase&lt;System#Byte&gt;#IsPositive(System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsPositive (value As Byte) As Boolean Implements INumberBase(Of Byte).IsPositive" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Byte&gt;.IsPositive : byte -&gt; bool" Usage="System.byte.System.Numerics.INumberBase&lt;System.Byte&gt;.IsPositive value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Byte&gt;.IsPositive(System::Byte value) = System::Numerics::INumberBase&lt;System::Byte&gt;::IsPositive;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsPositive(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is positive.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is positive; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Byte&gt;.IsPositiveInfinity">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;byte&gt;.IsPositiveInfinity (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Byte&gt;.IsPositiveInfinity(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#INumberBase&lt;System#Byte&gt;#IsPositiveInfinity(System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsPositiveInfinity (value As Byte) As Boolean Implements INumberBase(Of Byte).IsPositiveInfinity" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Byte&gt;.IsPositiveInfinity : byte -&gt; bool" Usage="System.byte.System.Numerics.INumberBase&lt;System.Byte&gt;.IsPositiveInfinity value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Byte&gt;.IsPositiveInfinity(System::Byte value) = System::Numerics::INumberBase&lt;System::Byte&gt;::IsPositiveInfinity;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsPositiveInfinity(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is positive infinity.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is positive infinity; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Byte&gt;.IsRealNumber">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;byte&gt;.IsRealNumber (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Byte&gt;.IsRealNumber(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#INumberBase&lt;System#Byte&gt;#IsRealNumber(System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsRealNumber (value As Byte) As Boolean Implements INumberBase(Of Byte).IsRealNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Byte&gt;.IsRealNumber : byte -&gt; bool" Usage="System.byte.System.Numerics.INumberBase&lt;System.Byte&gt;.IsRealNumber value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Byte&gt;.IsRealNumber(System::Byte value) = System::Numerics::INumberBase&lt;System::Byte&gt;::IsRealNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsRealNumber(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value represents a real number.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is a real number; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Byte&gt;.IsSubnormal">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;byte&gt;.IsSubnormal (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Byte&gt;.IsSubnormal(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#INumberBase&lt;System#Byte&gt;#IsSubnormal(System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsSubnormal (value As Byte) As Boolean Implements INumberBase(Of Byte).IsSubnormal" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Byte&gt;.IsSubnormal : byte -&gt; bool" Usage="System.byte.System.Numerics.INumberBase&lt;System.Byte&gt;.IsSubnormal value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Byte&gt;.IsSubnormal(System::Byte value) = System::Numerics::INumberBase&lt;System::Byte&gt;::IsSubnormal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsSubnormal(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is subnormal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is subnormal; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Byte&gt;.IsZero">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;byte&gt;.IsZero (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Byte&gt;.IsZero(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#INumberBase&lt;System#Byte&gt;#IsZero(System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function IsZero (value As Byte) As Boolean Implements INumberBase(Of Byte).IsZero" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Byte&gt;.IsZero : byte -&gt; bool" Usage="System.byte.System.Numerics.INumberBase&lt;System.Byte&gt;.IsZero value" />
      <MemberSignature Language="C++ CLI" Value=" static bool System.Numerics.INumberBase&lt;System.Byte&gt;.IsZero(System::Byte value) = System::Numerics::INumberBase&lt;System::Byte&gt;::IsZero;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.IsZero(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value to be checked.</param>
        <summary>Determines if a value is zero.</summary>
        <returns>
          <see langword="true" /> if <paramref name="value" /> is zero; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Byte&gt;.MaxMagnitude">
      <MemberSignature Language="C#" Value="static byte INumberBase&lt;byte&gt;.MaxMagnitude (byte x, byte y);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig unsigned int8 System.Numerics.INumberBase&lt;System.Byte&gt;.MaxMagnitude(unsigned int8 x, unsigned int8 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#INumberBase&lt;System#Byte&gt;#MaxMagnitude(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function MaxMagnitude (x As Byte, y As Byte) As Byte Implements INumberBase(Of Byte).MaxMagnitude" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Byte&gt;.MaxMagnitude : byte * byte -&gt; byte" Usage="System.byte.System.Numerics.INumberBase&lt;System.Byte&gt;.MaxMagnitude (x, y)" />
      <MemberSignature Language="C++ CLI" Value=" static System::Byte System.Numerics.INumberBase&lt;System.Byte&gt;.MaxMagnitude(System::Byte x, System::Byte y) = System::Numerics::INumberBase&lt;System::Byte&gt;::MaxMagnitude;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.MaxMagnitude(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.Byte" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is greater.</summary>
        <returns>
          <paramref name="x" /> if it is greater than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Byte&gt;.MaxMagnitudeNumber">
      <MemberSignature Language="C#" Value="static byte INumberBase&lt;byte&gt;.MaxMagnitudeNumber (byte x, byte y);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig unsigned int8 System.Numerics.INumberBase&lt;System.Byte&gt;.MaxMagnitudeNumber(unsigned int8 x, unsigned int8 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#INumberBase&lt;System#Byte&gt;#MaxMagnitudeNumber(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function MaxMagnitudeNumber (x As Byte, y As Byte) As Byte Implements INumberBase(Of Byte).MaxMagnitudeNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Byte&gt;.MaxMagnitudeNumber : byte * byte -&gt; byte" Usage="System.byte.System.Numerics.INumberBase&lt;System.Byte&gt;.MaxMagnitudeNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value=" static System::Byte System.Numerics.INumberBase&lt;System.Byte&gt;.MaxMagnitudeNumber(System::Byte x, System::Byte y) = System::Numerics::INumberBase&lt;System::Byte&gt;::MaxMagnitudeNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.MaxMagnitudeNumber(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.Byte" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which has the greater magnitude and returning the other value if an input is <c>NaN</c>.</summary>
        <returns>
          <paramref name="x" /> if it is greater than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Byte&gt;.MinMagnitude">
      <MemberSignature Language="C#" Value="static byte INumberBase&lt;byte&gt;.MinMagnitude (byte x, byte y);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig unsigned int8 System.Numerics.INumberBase&lt;System.Byte&gt;.MinMagnitude(unsigned int8 x, unsigned int8 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#INumberBase&lt;System#Byte&gt;#MinMagnitude(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function MinMagnitude (x As Byte, y As Byte) As Byte Implements INumberBase(Of Byte).MinMagnitude" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Byte&gt;.MinMagnitude : byte * byte -&gt; byte" Usage="System.byte.System.Numerics.INumberBase&lt;System.Byte&gt;.MinMagnitude (x, y)" />
      <MemberSignature Language="C++ CLI" Value=" static System::Byte System.Numerics.INumberBase&lt;System.Byte&gt;.MinMagnitude(System::Byte x, System::Byte y) = System::Numerics::INumberBase&lt;System::Byte&gt;::MinMagnitude;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.MinMagnitude(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.Byte" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which is lesser.</summary>
        <returns>
          <paramref name="x" /> if it is less than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Byte&gt;.MinMagnitudeNumber">
      <MemberSignature Language="C#" Value="static byte INumberBase&lt;byte&gt;.MinMagnitudeNumber (byte x, byte y);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig unsigned int8 System.Numerics.INumberBase&lt;System.Byte&gt;.MinMagnitudeNumber(unsigned int8 x, unsigned int8 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#INumberBase&lt;System#Byte&gt;#MinMagnitudeNumber(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function MinMagnitudeNumber (x As Byte, y As Byte) As Byte Implements INumberBase(Of Byte).MinMagnitudeNumber" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Byte&gt;.MinMagnitudeNumber : byte * byte -&gt; byte" Usage="System.byte.System.Numerics.INumberBase&lt;System.Byte&gt;.MinMagnitudeNumber (x, y)" />
      <MemberSignature Language="C++ CLI" Value=" static System::Byte System.Numerics.INumberBase&lt;System.Byte&gt;.MinMagnitudeNumber(System::Byte x, System::Byte y) = System::Numerics::INumberBase&lt;System::Byte&gt;::MinMagnitudeNumber;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.MinMagnitudeNumber(`0,`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="y" Type="System.Byte" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="x">The value to compare with <paramref name="y" />.</param>
        <param name="y">The value to compare with <paramref name="x" />.</param>
        <summary>Compares two values to compute which has the lesser magnitude and returning the other value if an input is <c>NaN</c>.</summary>
        <returns>
          <paramref name="x" /> if it is less than <paramref name="y" />; otherwise, <paramref name="y" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Byte&gt;.One">
      <MemberSignature Language="C#" Value="static byte System.Numerics.INumberBase&lt;System.Byte&gt;.One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property unsigned int8 System.Numerics.INumberBase&lt;System.Byte&gt;.One" />
      <MemberSignature Language="DocId" Value="P:System.Byte.System#Numerics#INumberBase&lt;System#Byte&gt;#One" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property One As Byte Implements INumberBase(Of Byte).One" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Byte&gt;.One : byte" Usage="System.Numerics.INumberBase&lt;System.Byte&gt;.One" />
      <MemberSignature Language="C++ CLI" Value="static property System::Byte System::Numerics::INumberBase&lt;System::Byte&gt;::One { System::Byte get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.INumberBase`1.One</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value <c>1</c> for the type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Byte&gt;.Radix">
      <MemberSignature Language="C#" Value="static int System.Numerics.INumberBase&lt;System.Byte&gt;.Radix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 System.Numerics.INumberBase&lt;System.Byte&gt;.Radix" />
      <MemberSignature Language="DocId" Value="P:System.Byte.System#Numerics#INumberBase&lt;System#Byte&gt;#Radix" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property Radix As Integer Implements INumberBase(Of Byte).Radix" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Byte&gt;.Radix : int" Usage="System.Numerics.INumberBase&lt;System.Byte&gt;.Radix" />
      <MemberSignature Language="C++ CLI" Value="static property int System::Numerics::INumberBase&lt;System::Byte&gt;::Radix { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.INumberBase`1.Radix</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the radix, or base, for the type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Byte&gt;.TryConvertToChecked&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;byte&gt;.TryConvertToChecked&lt;TOther&gt; (byte value, out TOther result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Byte&gt;.TryConvertToChecked&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(unsigned int8 value, [out] !!TOther&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#INumberBase&lt;System#Byte&gt;#TryConvertToChecked``1(System.Byte,``0@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertToChecked(Of TOther As INumberBase(Of TOther)) (value As Byte, ByRef result As TOther) As Boolean Implements INumberBase(Of Byte).TryConvertToChecked" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Byte&gt;.TryConvertToChecked : byte * 'Other -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.byte.System.Numerics.INumberBase&lt;System.Byte&gt;.TryConvertToChecked (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;System.Byte&gt;.TryConvertToChecked(System::Byte value, [Runtime::InteropServices::Out] TOther % result) = System::Numerics::INumberBase&lt;System::Byte&gt;::TryConvertToChecked;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.TryConvertToChecked``1(`0,``0@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="TOther" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type to which <paramref name="value" /> should be converted.</typeparam>
        <param name="value">The value that's used to create the instance of <typeparamref name="TOther" />.</param>
        <param name="result">When this method returns, contains an instance of <typeparamref name="TOther" /> converted from <paramref name="value" />.</param>
        <summary>Tries to convert an instance of the the current type to another type, throwing an overflow exception for any values that fall outside the representable range of the current type.</summary>
        <returns>
          <see langword="false" /> if <typeparamref name="TOther" /> is not supported; otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Byte&gt;.TryConvertToSaturating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;byte&gt;.TryConvertToSaturating&lt;TOther&gt; (byte value, out TOther result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Byte&gt;.TryConvertToSaturating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(unsigned int8 value, [out] !!TOther&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#INumberBase&lt;System#Byte&gt;#TryConvertToSaturating``1(System.Byte,``0@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertToSaturating(Of TOther As INumberBase(Of TOther)) (value As Byte, ByRef result As TOther) As Boolean Implements INumberBase(Of Byte).TryConvertToSaturating" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Byte&gt;.TryConvertToSaturating : byte * 'Other -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.byte.System.Numerics.INumberBase&lt;System.Byte&gt;.TryConvertToSaturating (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;System.Byte&gt;.TryConvertToSaturating(System::Byte value, [Runtime::InteropServices::Out] TOther % result) = System::Numerics::INumberBase&lt;System::Byte&gt;::TryConvertToSaturating;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.TryConvertToSaturating``1(`0,``0@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="TOther" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type to which <paramref name="value" /> should be converted.</typeparam>
        <param name="value">The value that's used to create the instance of <typeparamref name="TOther" />.</param>
        <param name="result">When this method returns, contains an instance of <typeparamref name="TOther" /> converted from <paramref name="value" />.</param>
        <summary>Tries to convert an instance of the the current type to another type, saturating any values that fall outside the representable range of the current type.</summary>
        <returns>
          <see langword="false" /> if <typeparamref name="TOther" /> is not supported; otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Byte&gt;.TryConvertToTruncating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;byte&gt;.TryConvertToTruncating&lt;TOther&gt; (byte value, out TOther result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Byte&gt;.TryConvertToTruncating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(unsigned int8 value, [out] !!TOther&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#INumberBase&lt;System#Byte&gt;#TryConvertToTruncating``1(System.Byte,``0@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertToTruncating(Of TOther As INumberBase(Of TOther)) (value As Byte, ByRef result As TOther) As Boolean Implements INumberBase(Of Byte).TryConvertToTruncating" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Byte&gt;.TryConvertToTruncating : byte * 'Other -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.byte.System.Numerics.INumberBase&lt;System.Byte&gt;.TryConvertToTruncating (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;System.Byte&gt;.TryConvertToTruncating(System::Byte value, [Runtime::InteropServices::Out] TOther % result) = System::Numerics::INumberBase&lt;System::Byte&gt;::TryConvertToTruncating;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.TryConvertToTruncating``1(`0,``0@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="TOther" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <typeparam name="TOther">The type to which <paramref name="value" /> should be converted.</typeparam>
        <param name="value">The value that's used to create the instance of <typeparamref name="TOther" />.</param>
        <param name="result">When this method returns, contains an instance of <typeparamref name="TOther" /> converted from <paramref name="value" />.</param>
        <summary>Tries to convert an instance of the the current type to another type, truncating any values that fall outside the representable range of the current type.</summary>
        <returns>
          <see langword="false" /> if <typeparamref name="TOther" /> is not supported; otherwise, <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Byte&gt;.TryConvertFromChecked&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;byte&gt;.TryConvertFromChecked&lt;TOther&gt; (TOther value, out byte result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Byte&gt;.TryConvertFromChecked&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value, [out] unsigned int8&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#INumberBase&lt;System#Byte&gt;#TryConvertFromChecked``1(``0,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertFromChecked(Of TOther As INumberBase(Of TOther)) (value As TOther, ByRef result As Byte) As Boolean Implements INumberBase(Of Byte).TryConvertFromChecked" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Byte&gt;.TryConvertFromChecked : 'Other * byte -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.byte.System.Numerics.INumberBase&lt;System.Byte&gt;.TryConvertFromChecked (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;System.Byte&gt;.TryConvertFromChecked(TOther value, [Runtime::InteropServices::Out] System::Byte % result) = System::Numerics::INumberBase&lt;System::Byte&gt;::TryConvertFromChecked;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.Byte" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">To be added.</typeparam>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Byte&gt;.TryConvertFromSaturating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;byte&gt;.TryConvertFromSaturating&lt;TOther&gt; (TOther value, out byte result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Byte&gt;.TryConvertFromSaturating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value, [out] unsigned int8&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#INumberBase&lt;System#Byte&gt;#TryConvertFromSaturating``1(``0,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertFromSaturating(Of TOther As INumberBase(Of TOther)) (value As TOther, ByRef result As Byte) As Boolean Implements INumberBase(Of Byte).TryConvertFromSaturating" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Byte&gt;.TryConvertFromSaturating : 'Other * byte -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.byte.System.Numerics.INumberBase&lt;System.Byte&gt;.TryConvertFromSaturating (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;System.Byte&gt;.TryConvertFromSaturating(TOther value, [Runtime::InteropServices::Out] System::Byte % result) = System::Numerics::INumberBase&lt;System::Byte&gt;::TryConvertFromSaturating;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.Byte" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">To be added.</typeparam>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Byte&gt;.TryConvertFromTruncating&lt;TOther&gt;">
      <MemberSignature Language="C#" Value="static bool INumberBase&lt;byte&gt;.TryConvertFromTruncating&lt;TOther&gt; (TOther value, out byte result) where TOther : System.Numerics.INumberBase&lt;TOther&gt;;" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig bool System.Numerics.INumberBase&lt;System.Byte&gt;.TryConvertFromTruncating&lt;(class System.Numerics.INumberBase`1&lt;!!TOther&gt;) TOther&gt;(!!TOther value, [out] unsigned int8&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#INumberBase&lt;System#Byte&gt;#TryConvertFromTruncating``1(``0,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value=" Shared Function TryConvertFromTruncating(Of TOther As INumberBase(Of TOther)) (value As TOther, ByRef result As Byte) As Boolean Implements INumberBase(Of Byte).TryConvertFromTruncating" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Byte&gt;.TryConvertFromTruncating : 'Other * byte -&gt; bool (requires 'Other :&gt; System.Numerics.INumberBase&lt;'Other&gt;)" Usage="System.byte.System.Numerics.INumberBase&lt;System.Byte&gt;.TryConvertFromTruncating (value, result)" />
      <MemberSignature Language="C++ CLI" Value="generic &lt;typename TOther&gt;&#xA; where TOther : System::Numerics::INumberBase&lt;TOther&gt; static bool System.Numerics.INumberBase&lt;System.Byte&gt;.TryConvertFromTruncating(TOther value, [Runtime::InteropServices::Out] System::Byte % result) = System::Numerics::INumberBase&lt;System::Byte&gt;::TryConvertFromTruncating;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOther">
          <Constraints>
            <InterfaceName>System.Numerics.INumberBase&lt;TOther&gt;</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="TOther" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.Byte" RefType="out" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <typeparam name="TOther">To be added.</typeparam>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.INumberBase&lt;System.Byte&gt;.Zero">
      <MemberSignature Language="C#" Value="static byte System.Numerics.INumberBase&lt;System.Byte&gt;.Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property unsigned int8 System.Numerics.INumberBase&lt;System.Byte&gt;.Zero" />
      <MemberSignature Language="DocId" Value="P:System.Byte.System#Numerics#INumberBase&lt;System#Byte&gt;#Zero" />
      <MemberSignature Language="VB.NET" Value=" Shared ReadOnly Property Zero As Byte Implements INumberBase(Of Byte).Zero" />
      <MemberSignature Language="F#" Value="static member System.Numerics.INumberBase&lt;System.Byte&gt;.Zero : byte" Usage="System.Numerics.INumberBase&lt;System.Byte&gt;.Zero" />
      <MemberSignature Language="C++ CLI" Value="static property System::Byte System::Numerics::INumberBase&lt;System::Byte&gt;::Zero { System::Byte get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Numerics.INumberBase`1.Zero</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value <c>0</c> for the type.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IShiftOperators&lt;System.Byte,System.Int32,System.Byte&gt;.op_LeftShift">
      <MemberSignature Language="C#" Value="static byte IShiftOperators&lt;byte,int,byte&gt;.operator &lt;&lt; (byte value, int shiftAmount);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig unsigned int8 System.Numerics.IShiftOperators&lt;System.Byte,System.Int32,System.Byte&gt;.op_LeftShift(unsigned int8 value, int32 shiftAmount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IShiftOperators&lt;System#Byte,System#Int32,System#Byte&gt;#op_LeftShift(System.Byte,System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator &lt;&lt; (value As Byte, shiftAmount As Integer) As Byte Implements IShiftOperators(Of Byte, Integer, Byte).op_LeftShift" />
      <MemberSignature Language="F#" Value="static member ( &lt;&lt;&lt; ) : byte * int -&gt; byte" Usage="value &lt;&lt;&lt; shiftAmount" />
      <MemberSignature Language="C++ CLI" Value=" static System::Byte System.Numerics.IShiftOperators&lt;System.Byte,System.Int32,System.Byte&gt;.operator &lt;&lt;(System::Byte value, int shiftAmount) = System::Numerics::IShiftOperators&lt;System::Byte, int, System::Byte&gt;::op_LeftShift;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IShiftOperators`3.op_LeftShift(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="shiftAmount" Type="System.Int32" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value that is shifted left by <paramref name="shiftAmount" />.</param>
        <param name="shiftAmount">The amount by which <paramref name="value" /> is shifted left.</param>
        <summary>Shifts a value left by a given amount.</summary>
        <returns>The result of shifting <paramref name="value" /> left by <paramref name="shiftAmount" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IShiftOperators&lt;System.Byte,System.Int32,System.Byte&gt;.op_RightShift">
      <MemberSignature Language="C#" Value="static byte IShiftOperators&lt;byte,int,byte&gt;.operator &gt;&gt; (byte value, int shiftAmount);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig unsigned int8 System.Numerics.IShiftOperators&lt;System.Byte,System.Int32,System.Byte&gt;.op_RightShift(unsigned int8 value, int32 shiftAmount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IShiftOperators&lt;System#Byte,System#Int32,System#Byte&gt;#op_RightShift(System.Byte,System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator &gt;&gt; (value As Byte, shiftAmount As Integer) As Byte Implements IShiftOperators(Of Byte, Integer, Byte).op_RightShift" />
      <MemberSignature Language="F#" Value="static member ( &gt;&gt;&gt; ) : byte * int -&gt; byte" Usage="value &gt;&gt;&gt; shiftAmount" />
      <MemberSignature Language="C++ CLI" Value=" static System::Byte System.Numerics.IShiftOperators&lt;System.Byte,System.Int32,System.Byte&gt;.operator &gt;&gt;(System::Byte value, int shiftAmount) = System::Numerics::IShiftOperators&lt;System::Byte, int, System::Byte&gt;::op_RightShift;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IShiftOperators`3.op_RightShift(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="shiftAmount" Type="System.Int32" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value that is shifted right by <paramref name="shiftAmount" />.</param>
        <param name="shiftAmount">The amount by which <paramref name="value" /> is shifted right.</param>
        <summary>Shifts a value right by a given amount.</summary>
        <returns>The result of shifting <paramref name="value" /> right by <paramref name="shiftAmount" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IShiftOperators&lt;System.Byte,System.Int32,System.Byte&gt;.op_UnsignedRightShift">
      <MemberSignature Language="C#" Value="static byte IShiftOperators&lt;byte,int,byte&gt;.op_UnsignedRightShift (byte value, int shiftAmount);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig unsigned int8 System.Numerics.IShiftOperators&lt;System.Byte,System.Int32,System.Byte&gt;.op_UnsignedRightShift(unsigned int8 value, int32 shiftAmount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IShiftOperators&lt;System#Byte,System#Int32,System#Byte&gt;#op_UnsignedRightShift(System.Byte,System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_UnsignedRightShift (value As Byte, shiftAmount As Integer) As Byte Implements IShiftOperators(Of Byte, Integer, Byte).op_UnsignedRightShift" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IShiftOperators&lt;System.Byte,System.Int32,System.Byte&gt;.op_UnsignedRightShift : byte * int -&gt; byte" Usage="System.byte.System.Numerics.IShiftOperators&lt;System.Byte,System.Int32,System.Byte&gt;.op_UnsignedRightShift (value, shiftAmount)" />
      <MemberSignature Language="C++ CLI" Value=" static System::Byte System.Numerics.IShiftOperators&lt;System.Byte,System.Int32,System.Byte&gt;.op_UnsignedRightShift(System::Byte value, int shiftAmount) = System::Numerics::IShiftOperators&lt;System::Byte, int, System::Byte&gt;::op_UnsignedRightShift;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IShiftOperators`3.op_UnsignedRightShift(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="shiftAmount" Type="System.Int32" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value that is shifted right by <paramref name="shiftAmount" />.</param>
        <param name="shiftAmount">The amount by which <paramref name="value" /> is shifted right.</param>
        <summary>Shifts a value right by a given amount.</summary>
        <returns>The result of shifting <paramref name="value" /> right by <paramref name="shiftAmount" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.ISubtractionOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_CheckedSubtraction">
      <MemberSignature Language="C#" Value="static byte ISubtractionOperators&lt;byte,byte,byte&gt;.op_CheckedSubtraction (byte left, byte right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig unsigned int8 System.Numerics.ISubtractionOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_CheckedSubtraction(unsigned int8 left, unsigned int8 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#ISubtractionOperators&lt;System#Byte,System#Byte,System#Byte&gt;#op_CheckedSubtraction(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_CheckedSubtraction (left As Byte, right As Byte) As Byte Implements ISubtractionOperators(Of Byte, Byte, Byte).op_CheckedSubtraction" />
      <MemberSignature Language="F#" Value="static member System.Numerics.ISubtractionOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_CheckedSubtraction : byte * byte -&gt; byte" Usage="System.byte.System.Numerics.ISubtractionOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_CheckedSubtraction (left, right)" />
      <MemberSignature Language="C++ CLI" Value=" static System::Byte System.Numerics.ISubtractionOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_CheckedSubtraction(System::Byte left, System::Byte right) = System::Numerics::ISubtractionOperators&lt;System::Byte, System::Byte, System::Byte&gt;::op_CheckedSubtraction;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ISubtractionOperators`3.op_CheckedSubtraction(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Byte" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value from which <paramref name="right" /> is subtracted.</param>
        <param name="right">The value that's subtracted from <paramref name="left" />.</param>
        <summary>Subtracts two values to compute their difference.</summary>
        <returns>The value of <paramref name="right" /> subtracted from <paramref name="left" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.ISubtractionOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_Subtraction">
      <MemberSignature Language="C#" Value="static byte ISubtractionOperators&lt;byte,byte,byte&gt;.operator - (byte left, byte right);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig unsigned int8 System.Numerics.ISubtractionOperators&lt;System.Byte,System.Byte,System.Byte&gt;.op_Subtraction(unsigned int8 left, unsigned int8 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#ISubtractionOperators&lt;System#Byte,System#Byte,System#Byte&gt;#op_Subtraction(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator - (left As Byte, right As Byte) As Byte Implements ISubtractionOperators(Of Byte, Byte, Byte).op_Subtraction" />
      <MemberSignature Language="F#" Value="static member ( - ) : byte * byte -&gt; byte" Usage="left - right" />
      <MemberSignature Language="C++ CLI" Value=" static System::Byte System.Numerics.ISubtractionOperators&lt;System.Byte,System.Byte,System.Byte&gt;.operator -(System::Byte left, System::Byte right) = System::Numerics::ISubtractionOperators&lt;System::Byte, System::Byte, System::Byte&gt;::op_Subtraction;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.ISubtractionOperators`3.op_Subtraction(`0,`1)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="right" Type="System.Byte" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="left">The value from which <paramref name="right" /> is subtracted.</param>
        <param name="right">The value that's subtracted from <paramref name="left" />.</param>
        <summary>Subtracts two values to compute their difference.</summary>
        <returns>The value of <paramref name="right" /> subtracted from <paramref name="left" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IUnaryNegationOperators&lt;System.Byte,System.Byte&gt;.op_CheckedUnaryNegation">
      <MemberSignature Language="C#" Value="static byte IUnaryNegationOperators&lt;byte,byte&gt;.op_CheckedUnaryNegation (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig unsigned int8 System.Numerics.IUnaryNegationOperators&lt;System.Byte,System.Byte&gt;.op_CheckedUnaryNegation(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IUnaryNegationOperators&lt;System#Byte,System#Byte&gt;#op_CheckedUnaryNegation(System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared op_CheckedUnaryNegation (value As Byte) As Byte Implements IUnaryNegationOperators(Of Byte, Byte).op_CheckedUnaryNegation" />
      <MemberSignature Language="F#" Value="static member System.Numerics.IUnaryNegationOperators&lt;System.Byte,System.Byte&gt;.op_CheckedUnaryNegation : byte -&gt; byte" Usage="System.byte.System.Numerics.IUnaryNegationOperators&lt;System.Byte,System.Byte&gt;.op_CheckedUnaryNegation value" />
      <MemberSignature Language="C++ CLI" Value=" static System::Byte System.Numerics.IUnaryNegationOperators&lt;System.Byte,System.Byte&gt;.op_CheckedUnaryNegation(System::Byte value) = System::Numerics::IUnaryNegationOperators&lt;System::Byte, System::Byte&gt;::op_CheckedUnaryNegation;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IUnaryNegationOperators`2.op_CheckedUnaryNegation(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value for which to compute the unary negation.</param>
        <summary>Computes the checked unary negation of a value.</summary>
        <returns>The unary negation of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IUnaryNegationOperators&lt;System.Byte,System.Byte&gt;.op_UnaryNegation">
      <MemberSignature Language="C#" Value="static byte IUnaryNegationOperators&lt;byte,byte&gt;.operator - (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig unsigned int8 System.Numerics.IUnaryNegationOperators&lt;System.Byte,System.Byte&gt;.op_UnaryNegation(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IUnaryNegationOperators&lt;System#Byte,System#Byte&gt;#op_UnaryNegation(System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator - (value As Byte) As Byte Implements IUnaryNegationOperators(Of Byte, Byte).op_UnaryNegation" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : byte -&gt; byte" Usage="- value" />
      <MemberSignature Language="C++ CLI" Value=" static System::Byte System.Numerics.IUnaryNegationOperators&lt;System.Byte,System.Byte&gt;.operator -(System::Byte value) = System::Numerics::IUnaryNegationOperators&lt;System::Byte, System::Byte&gt;::op_UnaryNegation;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IUnaryNegationOperators`2.op_UnaryNegation(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value for which to compute the unary negation.</param>
        <summary>Computes the unary negation of a value.</summary>
        <returns>The unary negation of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Numerics.IUnaryPlusOperators&lt;System.Byte,System.Byte&gt;.op_UnaryPlus">
      <MemberSignature Language="C#" Value="static byte IUnaryPlusOperators&lt;byte,byte&gt;.operator + (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method static hidebysig unsigned int8 System.Numerics.IUnaryPlusOperators&lt;System.Byte,System.Byte&gt;.op_UnaryPlus(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.System#Numerics#IUnaryPlusOperators&lt;System#Byte,System#Byte&gt;#op_UnaryPlus(System.Byte)" />
      <MemberSignature Language="VB.NET" Value=" Shared Operator + (value As Byte) As Byte Implements IUnaryPlusOperators(Of Byte, Byte).op_UnaryPlus" />
      <MemberSignature Language="F#" Value="static member ( ~+ ) : byte -&gt; byte" Usage="+ value" />
      <MemberSignature Language="C++ CLI" Value=" static System::Byte System.Numerics.IUnaryPlusOperators&lt;System.Byte,System.Byte&gt;.operator +(System::Byte value) = System::Numerics::IUnaryPlusOperators&lt;System::Byte, System::Byte&gt;::op_UnaryPlus;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IUnaryPlusOperators`2.op_UnaryPlus(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value for which to compute the unary plus.</param>
        <summary>Computes the unary plus of a value.</summary>
        <returns>The unary plus of <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converts the value of the current <see cref="T:System.Byte" /> object to its equivalent string representation.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="byte.ToString " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converts the value of the current <see cref="T:System.Byte" /> object to its equivalent string representation.</summary>
        <returns>The string representation of the value of this object, which consists of a sequence of digits that range from 0 to 9 with no leading zeroes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The return value is formatted with the general numeric format specifier ("G") and the <xref:System.Globalization.NumberFormatInfo> object for the thread current culture. To define the formatting of the <xref:System.Byte> value's string representation, call the <xref:System.Byte.ToString%2A> method. To define both the format specifiers and culture used to create the string representation of a <xref:System.Byte> value, call the <xref:System.Byte.ToString%2A> method.

.NET provides extensive formatting support, which is described in greater detail in the following formatting topics:

-   For more information about numeric format specifiers, see [Standard Numeric Format Strings](/dotnet/standard/base-types/standard-numeric-format-strings) and [Custom Numeric Format Strings](/dotnet/standard/base-types/custom-numeric-format-strings).

-   For more information about formatting, see [Formatting Types](/dotnet/standard/base-types/formatting-types).

 For information about the thread current culture, see <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType>.



## Examples
 The following example displays an array of byte values. Note that the <xref:System.Byte.ToString> method is not called explicitly in the example. Instead, it is called implicitly, because of the use of the [composite formatting](/dotnet/standard/base-types/composite-formatting) feature, the F# example uses [string interpolation](/dotnet/fsharp/language-reference/interpolated-strings).

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Byte.ToString/CPP/newbytemembers2.cpp" id="Snippet2":::
 :::code language="csharp" source="~/snippets/csharp/System/Byte/ToString/NewByteMembers.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Byte.ToString/FS/NewByteMembers.fs" id="Snippet2":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Byte.ToString/VB/NewByteMembers.vb" id="Snippet2":::

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Byte.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="byte.ToString provider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider? provider);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1">M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">An object that supplies culture-specific formatting information.</param>
        <summary>Converts the numeric value of the current <see cref="T:System.Byte" /> object to its equivalent string representation using the specified culture-specific formatting information.</summary>
        <returns>The string representation of the value of this object in the format specified by the <paramref name="provider" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The return value is formatted with the general numeric format specifier ("G").

 The `provider` parameter is an object that implements the <xref:System.IFormatProvider> interface. Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the string that is returned by this method. The object that implements <xref:System.IFormatProvider> can be any of the following:

-   A <xref:System.Globalization.CultureInfo> object that represents the culture whose formatting rules are to be used.

-   A <xref:System.Globalization.NumberFormatInfo> object that contains specific numeric formatting information for this value.

-   A custom object that implements <xref:System.IFormatProvider>.

 If `provider` is `null` or a <xref:System.Globalization.NumberFormatInfo> object cannot be obtained from `provider`, the return value is formatted using the <xref:System.Globalization.NumberFormatInfo> object for the thread current culture. For information about the thread current culture, see <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType>.

.NET provides extensive formatting support, which is described in greater detail in the following formatting topics:

-   For more information about numeric format specifiers, see [Standard Numeric Format Strings](/dotnet/standard/base-types/standard-numeric-format-strings) and [Custom Numeric Format Strings](/dotnet/standard/base-types/custom-numeric-format-strings).

-   For more information about formatting, see [Formatting Types](/dotnet/standard/base-types/formatting-types).



## Examples
 The following example iterates an array of byte values and displays each of them to the console by calling the <xref:System.Byte.ToString%28System.IFormatProvider%29> method with different format providers.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Byte.ToString/CPP/newbytemembers.cpp" id="Snippet3":::
 :::code language="csharp" source="~/snippets/csharp/System/Byte/ToString/NewByteMembers.cs" interactive="try-dotnet-method" id="Snippet3":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Byte.ToString/FS/NewByteMembers.fs" id="Snippet3":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Byte.ToString/VB/NewByteMembers.vb" id="Snippet3":::

 ]]></format>
        </remarks>
        <altmember cref="M:System.Byte.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">Formatting Types in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="byte.ToString format" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="C#" Value="public string ToString (string? format);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(1)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(1)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String">
          <Attributes>
            <Attribute FrameworkAlternate="net-7.0;net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")&gt;]</AttributeName>
            </Attribute>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">A numeric format string.</param>
        <summary>Converts the value of the current <see cref="T:System.Byte" /> object to its equivalent string representation using the specified format.</summary>
        <returns>The string representation of the current <see cref="T:System.Byte" /> object, formatted as specified by the <paramref name="format" /> parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The `format` parameter can be either a standard or a custom numeric format string. All standard numeric format strings other than "R" (or "r") are supported, as are all custom numeric format characters. If `format` is `null` or an empty string (""), the return value is formatted with the general numeric format specifier ("G").

 The return value of this function is formatted using the <xref:System.Globalization.NumberFormatInfo> object for the thread current culture. For information about the thread current culture, see <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType>. To provide formatting information for cultures other than the current culture, call the <xref:System.Byte.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.

.NET provides extensive formatting support, which is described in greater detail in the following formatting topics:

-   For more information about numeric format specifiers, see [Standard Numeric Format Strings](/dotnet/standard/base-types/standard-numeric-format-strings) and [Custom Numeric Format Strings](/dotnet/standard/base-types/custom-numeric-format-strings).

-   For more information about formatting, see [Formatting Types](/dotnet/standard/base-types/formatting-types).



## Examples
 The following example initializes a <xref:System.Byte> value and displays it to the console using each of the supported standard format strings and a custom format string. The example is run with en-US as the current culture.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Byte.ToString/CPP/newbytemembers2.cpp" id="Snippet4":::
 :::code language="csharp" source="~/snippets/csharp/System/Byte/ToString/NewByteMembers.cs" id="Snippet4":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Byte.ToString/FS/NewByteMembers.fs" id="Snippet4":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Byte.ToString/VB/NewByteMembers.vb" id="Snippet4":::

 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> includes an unsupported specifier. Supported format specifiers are listed in the Remarks section.</exception>
        <related type="Article" href="/dotnet/standard/base-types/how-to-pad-a-number-with-leading-zeros">How to: Pad a Number with Leading Zeros</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="byte.ToString (format, provider)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="C#" Value="public string ToString (string? format, IFormatProvider? provider);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String">
          <Attributes>
            <Attribute FrameworkAlternate="net-7.0;net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">A standard or custom numeric format string.</param>
        <param name="provider">An object that supplies culture-specific formatting information.</param>
        <summary>Converts the value of the current <see cref="T:System.Byte" /> object to its equivalent string representation using the specified format and culture-specific formatting information.</summary>
        <returns>The string representation of the current <see cref="T:System.Byte" /> object, formatted as specified by the <paramref name="format" /> and <paramref name="provider" /> parameters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Byte.ToString%28System.String%2CSystem.IFormatProvider%29> method formats a <xref:System.Byte> value in a specified format of a specified culture. To format a number by using the default ("G") format of the current culture, call the <xref:System.Byte.ToString> method. To format a number by using a specified format of the current culture, call the <xref:System.Byte.ToString%28System.String%29> method.

 The `format` parameter can be either a standard or a custom numeric format string. All standard numeric format strings other than "R" (or "r") are supported, as are all custom numeric format characters. If `format` is `null` or an empty string (""), the return value of this method is formatted with the general numeric format specifier ("G").

 The `provider` parameter is an object that implements the <xref:System.IFormatProvider> interface. Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the string that is returned by this method. The object that implements <xref:System.IFormatProvider> can be any of the following:

-   A <xref:System.Globalization.CultureInfo> object that represents the culture whose formatting rules are to be used.

-   A <xref:System.Globalization.NumberFormatInfo> object that contains specific numeric formatting information for this value.

-   A custom object that implements <xref:System.IFormatProvider>.

 If `provider` is `null` or a <xref:System.Globalization.NumberFormatInfo> object cannot be obtained from `provider`, the return value is formatted using the <xref:System.Globalization.NumberFormatInfo> object for the thread current culture. For information about the thread current culture, see <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType>.

.NET provides extensive formatting support, which is described in greater detail in the following formatting topics:

-   For more information about numeric format specifiers, see [Standard Numeric Format Strings](/dotnet/standard/base-types/standard-numeric-format-strings) and [Custom Numeric Format Strings](/dotnet/standard/base-types/custom-numeric-format-strings).

-   For more information about formatting, see [Formatting Types](/dotnet/standard/base-types/formatting-types).



## Examples
 The following example uses the standard "N" format string and four different <xref:System.Globalization.CultureInfo> objects to display the string representation of a byte value to the console.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Byte.ToString/CPP/newbytemembers2.cpp" id="Snippet5":::
 :::code language="csharp" source="~/snippets/csharp/System/Byte/ToString/NewByteMembers.cs" interactive="try-dotnet-method" id="Snippet5":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Byte.ToString/FS/NewByteMembers.fs" id="Snippet5":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Byte.ToString/VB/NewByteMembers.vb" id="Snippet5":::

 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> includes an unsupported specifier. Supported format specifiers are listed in the Remarks section.</exception>
        <altmember cref="M:System.Byte.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <altmember cref="T:System.IFormattable" />
        <altmember cref="T:System.IFormatProvider" />
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">Formatting Types in .NET</related>
        <related type="Article" href="/dotnet/standard/base-types/how-to-pad-a-number-with-leading-zeros">How to: Pad a Number with Leading Zeros</related>
        <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/windowsforms-formatting-utility-cs/">Sample: .NET Core WinForms Formatting Utility (C#)</related>
        <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/windowsforms-formatting-utility-vb/">Sample: .NET Core WinForms Formatting Utility (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TrailingZeroCount">
      <MemberSignature Language="C#" Value="public static byte TrailingZeroCount (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 TrailingZeroCount(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.TrailingZeroCount(System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrailingZeroCount (value As Byte) As Byte" />
      <MemberSignature Language="F#" Value="static member TrailingZeroCount : byte -&gt; byte" Usage="System.byte.TrailingZeroCount value" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte TrailingZeroCount(System::Byte value) = System::Numerics::IBinaryInteger&lt;System::Byte&gt;::TrailingZeroCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.IBinaryInteger`1.TrailingZeroCount(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="value">The value whose trailing zeroes are to be counted.</param>
        <summary>Computes the number of trailing zeros in a value.</summary>
        <returns>The number of trailing zeros in <paramref name="value" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.IBinaryInteger`1.TrailingZeroCount(`0)" />
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;byte&gt; utf8Destination, out int bytesWritten, ReadOnlySpan&lt;char&gt; format = default, IFormatProvider? provider = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryFormat(valuetype System.Span`1&lt;unsigned int8&gt; utf8Destination, [out] int32&amp; bytesWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.TryFormat(System.Span{System.Byte},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (utf8Destination As Span(Of Byte), ByRef bytesWritten As Integer, Optional format As ReadOnlySpan(Of Char) = Nothing, Optional provider As IFormatProvider = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member TryFormat : Span&lt;byte&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool&#xA;override this.TryFormat : Span&lt;byte&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="byte.TryFormat (utf8Destination, bytesWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Numerics.INumberBase`1.System#IUtf8SpanFormattable#TryFormat(System.Span{System.Byte},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)</InterfaceMember>
        <InterfaceMember FrameworkAlternate="net-9.0">M:System.IUtf8SpanFormattable.TryFormat(System.Span{System.Byte},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="utf8Destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.IUtf8SpanFormattable.TryFormat(System.Span{System.Byte},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default, IFormatProvider? provider = default);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Byte.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = Nothing, Optional provider As IFormatProvider = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="byte.TryFormat (destination, charsWritten, format, provider)" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0" />
      <MemberSignature Language="F#" Value="abstract member TryFormat : Span&lt;char&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool&#xA;override this.TryFormat : Span&lt;char&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="byte.TryFormat (destination, charsWritten, format, provider)" FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0" />
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default, IFormatProvider provider = default);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="net-6.0;net-7.0;net-8.0;net-9.0">M:System.ISpanFormattable.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-7.0;net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.StringSyntax("NumericFormat")&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="destination">The span in which to write this instance's value formatted as a span of characters.</param>
        <param name="charsWritten">When this method returns, the number of characters that were written in <paramref name="destination" />.</param>
        <param name="format">A span containing the charactes that represent a standard or custom format string that defines the acceptable format for <paramref name="destination" />.</param>
        <param name="provider">An optional object that supplies culture-specific formatting information for <paramref name="destination" />.</param>
        <summary>Tries to format the value of the current 8-bit unsigned integer instance into the provided span of characters.</summary>
        <returns>
          <see langword="true" /> if the formatting was successful; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">Standard numeric format strings</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">Custom numeric format strings</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Tries to convert the string representation of a number to its <see cref="T:System.Byte" /> equivalent, and returns a value that indicates whether the conversion succeeded.</summary>
        <altmember cref="Overload:System.Byte.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;byte&gt; utf8Text, out byte result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Text, [out] unsigned int8&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.TryParse(System.ReadOnlySpan{System.Byte},System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (utf8Text As ReadOnlySpan(Of Byte), ByRef result As Byte) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;byte&gt; * byte -&gt; bool" Usage="System.byte.TryParse (utf8Text, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;System::Byte&gt; utf8Text, [Runtime::InteropServices::Out] System::Byte % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Text" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.Byte" RefType="out" Index="1" FrameworkAlternate="net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="utf8Text">A span containing the UTF-8 characters representing the number to convert.</param>
        <param name="result">When this method returns, contains the 8-bit unsigned integer value equivalent to the number contained in <paramref name="utf8Text" /> if the conversion succeeded, or zero if the conversion failed. This parameter is passed uninitialized; any value originally supplied in result will be overwritten.</param>
        <summary>Tries to convert a UTF-8 character span containing the string representation of a number to its 8-bit unsigned integer equivalent.</summary>
        <returns>
          <see langword="true" /> if <paramref name="utf8Text" /> was converted successfully; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out byte result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] unsigned int8&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.TryParse(System.ReadOnlySpan{System.Char},System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Byte) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * byte -&gt; bool" Usage="System.byte.TryParse (s, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] System::Byte % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.Byte" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="s">A span containing the characters representing the number to convert.</param>
        <param name="result">When this method returns, contains the <see cref="T:System.Byte" /> value equivalent to the number contained in <paramref name="s" /> if the conversion succeeded, or zero if the conversion failed. This parameter is passed uninitialized; any value originally supplied in <paramref name="result" /> will be overwritten.</param>
        <summary>Tries to convert the span representation of a number to its <see cref="T:System.Byte" /> equivalent, and returns a value that indicates whether the conversion succeeded.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was converted successfully; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out byte result);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] unsigned int8&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.TryParse(System.String,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Byte) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : string * byte -&gt; bool" Usage="System.byte.TryParse (s, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] System::Byte % result);" />
      <MemberSignature Language="C#" Value="public static bool TryParse (string? s, out byte result);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="result" Type="System.Byte" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">A string that contains a number to convert.</param>
        <param name="result">When this method returns, contains the <see cref="T:System.Byte" /> value equivalent to the number contained in <paramref name="s" /> if the conversion succeeded, or zero if the conversion failed. This parameter is passed uninitialized; any value originally supplied in <paramref name="result" /> will be overwritten.</param>
        <summary>Tries to convert the string representation of a number to its <see cref="T:System.Byte" /> equivalent, and returns a value that indicates whether the conversion succeeded.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was converted successfully; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The conversion fails and the method returns `false` if the `s` parameter is not in the correct format, if it is `null` or <xref:System.String.Empty?displayProperty=nameWithType>, or if it represents a number less than <xref:System.Byte.MinValue> or greater than <xref:System.Byte.MaxValue>.

 The <xref:System.Byte.TryParse%28System.String%2CSystem.Byte%40%29?displayProperty=nameWithType> method is similar to the <xref:System.Byte.Parse%28System.String%29?displayProperty=nameWithType> method, except that <xref:System.Byte.TryParse%28System.String%2CSystem.Byte%40%29> does not throw an exception if the conversion fails.

 The `s` parameter should be the string representation of a number in the following form:

```
[ws][sign]digits[ws]
```

 Elements in square brackets ([ and ]) are optional. The following table describes each element.

|Element|Description|
|-------------|-----------------|
|*ws*|Optional white space.|
|*sign*|An optional positive sign, as specified by the <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> property of the current culture.|
|*digits*|A sequence of decimal digits that range from 0 to 9.|

 The `s` parameter is interpreted using the <xref:System.Globalization.NumberStyles.Integer> style. In addition to the byte value's decimal digits, only leading and trailing spaces together with a leading sign are allowed. (If the sign is present, it must be a positive sign or the method throws an <xref:System.OverflowException>.) To explicitly define the style elements together with the culture-specific formatting information that can be present in `s`, use the <xref:System.Byte.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.

 The `s` parameter is parsed using the formatting information in a <xref:System.Globalization.NumberFormatInfo> object for the current culture. For more information, see <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>.

 This overload of the <xref:System.Byte.TryParse%28System.String%2CSystem.Byte%40%29?displayProperty=nameWithType> method interprets all digits in the `s` parameter as decimal digits. To parse the string representation of a hexadecimal number, call the <xref:System.Byte.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Byte%40%29?displayProperty=nameWithType> overload.



## Examples
 The following example calls the <xref:System.Byte.TryParse%28System.String%2CSystem.Byte%40%29> method with a number of different string values.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Byte.TryParse/cpp/tryparse.cpp" id="Snippet1":::
 :::code language="csharp" source="~/snippets/csharp/System/Byte/TryParse/TryParse.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Byte.TryParse/fs/TryParse.fs" id="Snippet1":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Byte.TryParse/vb/TryParse.vb" id="Snippet1":::

 ]]></format>
        </remarks>
        <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/windowsforms-formatting-utility-cs/">Sample: .NET Core WinForms Formatting Utility (C#)</related>
        <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/windowsforms-formatting-utility-vb/">Sample: .NET Core WinForms Formatting Utility (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;byte&gt; utf8Text, IFormatProvider? provider, out byte result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Text, class System.IFormatProvider provider, [out] unsigned int8&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.TryParse(System.ReadOnlySpan{System.Byte},System.IFormatProvider,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (utf8Text As ReadOnlySpan(Of Byte), provider As IFormatProvider, ByRef result As Byte) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;byte&gt; * IFormatProvider * byte -&gt; bool" Usage="System.byte.TryParse (utf8Text, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;System::Byte&gt; utf8Text, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Byte % result) = IUtf8SpanParsable&lt;System::Byte&gt;::TryParse;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Text" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="result" Type="System.Byte" RefType="out" Index="2" FrameworkAlternate="net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="utf8Text">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.IUtf8SpanParsable`1.TryParse(System.ReadOnlySpan{System.Byte},System.IFormatProvider,`0@)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, IFormatProvider? provider, out byte result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, class System.IFormatProvider provider, [out] unsigned int8&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), provider As IFormatProvider, ByRef result As Byte) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * IFormatProvider * byte -&gt; bool" Usage="System.byte.TryParse (s, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Byte % result) = ISpanParsable&lt;System::Byte&gt;::TryParse;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="result" Type="System.Byte" RefType="out" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="s">The span of characters to parse.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <param name="result">When this method returns, contains the result of successfully parsing <paramref name="s" />, or an undefined value on failure.</param>
        <summary>Tries to parse a span of characters into a value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was successfully parsed; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.ISpanParsable`1.TryParse(System.ReadOnlySpan{System.Char},System.IFormatProvider,`0@)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string? s, IFormatProvider? provider, out byte result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, class System.IFormatProvider provider, [out] unsigned int8&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.TryParse(System.String,System.IFormatProvider,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, provider As IFormatProvider, ByRef result As Byte) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : string * IFormatProvider * byte -&gt; bool" Usage="System.byte.TryParse (s, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Byte % result) = IParsable&lt;System::Byte&gt;::TryParse;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
        <Parameter Name="result" Type="System.Byte" RefType="out" Index="2" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="s">The string to parse.</param>
        <param name="provider">An object that provides culture-specific formatting information about <paramref name="s" />.</param>
        <param name="result">When this method returns, contains the result of successfully parsing <paramref name="s" /> or an undefined value on failure.</param>
        <summary>Tries to parse a string into a value.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was successfully parsed; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.IParsable`1.TryParse(System.String,System.IFormatProvider,`0@)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;byte&gt; utf8Text, System.Globalization.NumberStyles style, IFormatProvider? provider, out byte result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; utf8Text, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] unsigned int8&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.TryParse(System.ReadOnlySpan{System.Byte},System.Globalization.NumberStyles,System.IFormatProvider,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (utf8Text As ReadOnlySpan(Of Byte), style As NumberStyles, provider As IFormatProvider, ByRef result As Byte) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;byte&gt; * System.Globalization.NumberStyles * IFormatProvider * byte -&gt; bool" Usage="System.byte.TryParse (utf8Text, style, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;System::Byte&gt; utf8Text, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Byte % result) = System::Numerics::INumberBase&lt;System::Byte&gt;::TryParse;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="utf8Text" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="net-8.0;net-9.0">
          <Attributes>
            <Attribute>
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="result" Type="System.Byte" RefType="out" Index="3" FrameworkAlternate="net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="utf8Text">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <inheritdoc cref="M:System.Numerics.INumberBase`1.TryParse(System.ReadOnlySpan{System.Byte},System.Globalization.NumberStyles,System.IFormatProvider,`0@)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider? provider, out byte result);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] unsigned int8&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Byte) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider * byte -&gt; bool" Usage="System.byte.TryParse (s, style, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Byte % result);" FrameworkAlternate="net-5.0;net-6.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Byte % result) = System::Numerics::INumberBase&lt;System::Byte&gt;::TryParse;" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out byte result);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0">
          <Attributes>
            <Attribute FrameworkAlternate="net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Runtime.CompilerServices.Nullable(2)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.Nullable(2)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="result" Type="System.Byte" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0" />
      </Parameters>
      <Docs>
        <param name="s">A span containing the characters representing the number to convert. The span is interpreted using the <see cref="F:System.Globalization.NumberStyles.Integer" /> style.</param>
        <param name="style">A bitwise combination of enumeration values that indicates the style elements that can be present in <paramref name="s" />. A typical value to specify is <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <param name="provider">An object that supplies culture-specific formatting information about <paramref name="s" />. If <paramref name="provider" /> is <see langword="null" />, the thread current culture is used.</param>
        <param name="result">When this method returns, contains the 8-bit unsigned integer value equivalent to the number contained in <paramref name="s" /> if the conversion succeeded, or zero if the conversion failed. The conversion fails if the <paramref name="s" /> parameter is <see langword="null" /> or <see cref="F:System.String.Empty" />, is not of the correct format, or represents a number less than <see cref="F:System.Byte.MinValue">Byte.MinValue</see> or greater than <see cref="F:System.Byte.MaxValue">Byte.MaxValue</see>. This parameter is passed uninitialized; any value originally supplied in <paramref name="result" /> will be overwritten.</param>
        <summary>Converts the span representation of a number in a specified style and culture-specific format to its <see cref="T:System.Byte" /> equivalent. A return value indicates whether the conversion succeeded or failed.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was converted successfully; otherwise, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out byte result);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] unsigned int8&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Byte.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Byte) As Boolean" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider * byte -&gt; bool" Usage="System.byte.TryParse (s, style, provider, result)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Byte % result);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public static bool TryParse (string? s, System.Globalization.NumberStyles style, IFormatProvider? provider, out byte result);" FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Byte % result) = System::Numerics::INumberBase&lt;System::Byte&gt;::TryParse;" FrameworkAlternate="net-7.0;net-8.0;net-9.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
        <AssemblyVersion>6.0.0.0</AssemblyVersion>
        <AssemblyVersion>7.0.0.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>9.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="net-8.0;net-9.0">
          <AttributeName Language="C#">[System.Runtime.CompilerServices.NullableContext(2)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.NullableContext(2)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1">
          <Attributes>
            <Attribute FrameworkAlternate="net-5.0;net-6.0;net-7.0;net-8.0;net-9.0">
              <AttributeName Language="C#">[System.Diagnostics.CodeAnalysis.NotNullWhen(true)]</AttributeName>
              <AttributeName Language="F#">[&lt;System.Diagnostics.CodeAnalysis.NotNullWhen(true)&gt;]</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.Byte" RefType="out" Index="3" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;net-6.0;net-7.0;net-8.0;net-9.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netframework-4.8.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="s">A string containing a number to convert. The string is interpreted using the style specified by <paramref name="style" />.</param>
        <param name="style">A bitwise combination of enumeration values that indicates the style elements that can be present in <paramref name="s" />. A typical value to specify is <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <param name="provider">An object that supplies culture-specific formatting information about <paramref name="s" />. If <paramref name="provider" /> is <see langword="null" />, the thread current culture is used.</param>
        <param name="result">When this method returns, contains the 8-bit unsigned integer value equivalent to the number contained in <paramref name="s" /> if the conversion succeeded, or zero if the conversion failed. The conversion fails if the <paramref name="s" /> parameter is <see langword="null" /> or <see cref="F:System.String.Empty" />, is not of the correct format, or represents a number less than <see cref="F:System.Byte.MinValue">Byte.MinValue</see> or greater than <see cref="F:System.Byte.MaxValue">Byte.MaxValue</see>. This parameter is passed uninitialized; any value originally supplied in <paramref name="result" /> will be overwritten.</param>
        <summary>Converts the string representation of a number in a specified style and culture-specific format to its <see cref="T:System.Byte" /> equivalent. A return value indicates whether the conversion succeeded or failed.</summary>
        <returns>
          <see langword="true" /> if <paramref name="s" /> was converted successfully; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 The <xref:System.Byte.TryParse%2A> method is like the <xref:System.Byte.Parse%2A> method, except the <xref:System.Byte.TryParse%2A> method does not throw an exception if the conversion fails.

 The `s` parameter is parsed using the formatting information in a <xref:System.Globalization.NumberFormatInfo> object supplied by the `provider` parameter.

 The style parameter defines the style elements (such as white space or the positive sign) that are allowed in the `s` parameter for the parse operation to succeed. It must be a combination of bit flags from the <xref:System.Globalization.NumberStyles> enumeration. Depending on the value of `style`, the `s` parameter may include the following elements:

 [ws][$][sign]digits[.fractional_digits][e[sign]digits][ws]

 Or, if the `style` parameter includes <xref:System.Globalization.NumberStyles.AllowHexSpecifier>:

 [ws]hexdigits[ws]

 Elements in square brackets ( [ and ] ) are optional. The following table describes each element.

|Element|Description|
|-------------|-----------------|
|*ws*|Optional white space. White space can appear at the beginning of `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> flag, or at the end of s if style includes the <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> flag.|
|*$*|A culture-specific currency symbol. Its position in the string is defined by the <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> property of the <xref:System.Globalization.NumberFormatInfo> object returned by the <xref:System.IFormatProvider.GetFormat%2A> method of the `provider` parameter. The currency symbol can appear in `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> flag.|
|*sign*|An optional positive sign. (The parse operation fails if a negative sign is present in `s`.) The sign can appear at the beginning of `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> flag, or at the end of `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> flag.|
|*digits*|A sequence of digits from 0 through 9.|
|*.*|A culture-specific decimal point symbol. The decimal point symbol of the culture specified by `provider` can appear in `s` if `style` includes the <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.|
|*fractional_digits*|One or more occurrences of the digit 0. Fractional digits can appear in `s` only if `style` includes the <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> flag.|
|*e*|The e or E character, which indicates that the value is represented in exponential notation. The `s` parameter can represent a number in exponential notation if `style` includes the <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> flag.|
|*hexdigits*|A sequence of hexadecimal digits from 0 through f, or 0 through F.|

> [!NOTE]
> Any terminating NUL (U+0000) characters in `s` are ignored by the parsing operation, regardless of the value of the `style` argument.

 A string with decimal digits only (which corresponds to the <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> style) always parses successfully. Most of the remaining <xref:System.Globalization.NumberStyles> members control elements that may be but are not required to be present in this input string. The following table indicates how individual <xref:System.Globalization.NumberStyles> members affect the elements that may be present in `s`.

|Non-composite NumberStyles values|Elements permitted in s in addition to digits|
|----------------------------------------|---------------------------------------------------|
|<xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>|Decimal digits only.|
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>|The *.* and *fractional_digits* elements. However, *fractional_digits* must consist of only one or more 0 digits or the method returns `false`.|
|<xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>|The `s` parameter can also use exponential notation. If `s` represents a number in exponential notation, it must represent an integer within the range of the <xref:System.Byte> data type without a non-zero, fractional component.|
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>|The *ws* element at the beginning of `s`.|
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>|The *ws* element at the end of `s`.|
|<xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>|A positive sign can appear before *digits*.|
|<xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>|A positive sign can appear after *digits*.|
|<xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>|Although this flag is supported, the method returns `false` if parentheses are present in `s`.|
|<xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>|Although the group separator symbol can appear in `s`, it can be preceded by only one or more 0 digits.|
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>|The *$* element.|

 If the <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> flag is used, `s` must be a hexadecimal value without a prefix. For example, "F3" parses successfully, but "0xF3" does not. The only other flags that can be present in `style` are <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> and <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (The <xref:System.Globalization.NumberStyles> enumeration has a composite number style, <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>, that includes both white space flags.)

 The `provider` parameter is an <xref:System.IFormatProvider> implementation, such as a <xref:System.Globalization.CultureInfo> object or a <xref:System.Globalization.NumberFormatInfo> object, whose <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object. The <xref:System.Globalization.NumberFormatInfo> object provides culture-specific information about the format of `s`.



## Examples
 The following example calls the <xref:System.Byte.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Byte%40%29> method with a number of different string values.

 :::code language="cpp" source="~/snippets/cpp/VS_Snippets_CLR_System/system.Byte.TryParse/cpp/tryparse2.cpp" id="Snippet2":::
 :::code language="csharp" source="~/snippets/csharp/System/Byte/TryParse/TryParse2.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="fsharp" source="~/snippets/fsharp/VS_Snippets_CLR_System/system.Byte.TryParse/fs/TryParse2.fs" id="Snippet2":::
 :::code language="vb" source="~/snippets/visualbasic/VS_Snippets_CLR_System/system.Byte.TryParse/vb/TryParse2.vb" id="Snippet2":::

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> is not a <see cref="T:System.Globalization.NumberStyles" /> value.

 -or-

 <paramref name="style" /> is not a combination of <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" /> and <see cref="F:System.Globalization.NumberStyles.HexNumber" /> values.</exception>
        <altmember cref="M:System.Byte.ToString" />
        <altmember cref="F:System.Byte.MaxValue" />
        <altmember cref="F:System.Byte.MinValue" />
        <altmember cref="T:System.Globalization.NumberStyles" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <altmember cref="T:System.IFormatProvider" />
        <related type="Article" href="/dotnet/standard/base-types/parsing-numeric">Parsing Numeric Strings in .NET</related>
      </Docs>
    </Member>
  </Members>
</Type>
